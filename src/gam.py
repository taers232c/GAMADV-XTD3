#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# GAMADV-XTD3
#
# Copyright 2017, All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
u"""GAMADV-XTD3 is a command line tool which allows Administrators to control their G Suite domain and accounts.

For more information, see https://github.com/taers232c/GAMADV-XTD
"""

__author__ = u'Ross Scroggs <ross.scroggs@gmail.com>'
__version__ = u'4.57.22'
__license__ = u'Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)'

import sys
import os
import string
import time
import base64
import codecs
import collections
import csv
import datetime
import json
import logging
import mimetypes
import multiprocessing
import platform
import random
import re
import signal
import socket
import uuid

import configparser
from html.entities import name2codepoint
from html.parser import HTMLParser
import http.client as http_client
import io

from gamlib import glaction
from gamlib import glcfg as GC
from gamlib import glapi as API
from gamlib import glclargs
from gamlib import glentity
from gamlib import glgapi as GAPI
from gamlib import glgcp as GCP
from gamlib import glgdata as GDATA
from gamlib import glglobals as GM
from gamlib import glindent
from gamlib import glmsgs as Msg
from gamlib import glskus as SKU

import googleapiclient
import googleapiclient.discovery
import googleapiclient.errors
import googleapiclient.http
import httplib2
from iso8601 import iso8601
import google.oauth2.service_account
import google_auth_httplib2
import oauth2client.client
import oauth2client.file
from oauth2client.contrib.multiprocess_file_storage import MultiprocessFileStorage
import oauth2client.tools

# Python 3
string_types = (str,)
simple_types = (bool, float, int)
non_compound_types = (str, bool, float, int)
char_type = chr
text_type = str

def iteritems(d, **kw):
  return iter(d.items(**kw))

def ISOformatTimeStamp(timestamp):
  return timestamp.isoformat('T', 'seconds')

Act = glaction.GamAction()
Cmd = glclargs.GamCLArgs()
Ent = glentity.GamEntity()
Ind = glindent.GamIndent()

GM.Globals[GM.GAM_PATH] = os.path.dirname(os.path.realpath(__file__)) if not getattr(sys, u'frozen', False) else os.path.dirname(sys.executable)

# Override some oauth2client.tools strings saving us a few GAM-specific mods to oauth2client
oauth2client.tools._FAILED_START_MESSAGE = """
Failed to start a local webserver listening on either port 8080
or port 8090. Please check your firewall settings and locally
running programs that may be blocking or using those ports.

Falling back to nobrowser.txt  and continuing with
authorization.
"""

oauth2client.tools._BROWSER_OPENED_MESSAGE = """
Your browser has been opened to visit:

    {address}

If your browser is on a different machine then press CTRL+C,
set no_browser = true in gam.cfg and re-run this command.
"""

oauth2client.tools._GO_TO_LINK_MESSAGE = """
Go to the following link in your browser:

    {address}
"""

GIT_USER = u'taers232c'
GAM = u'GAMADV-XTD3'
GAM_URL = u'https://github.com/{0}/{1}'.format(GIT_USER, GAM)
GAM_INFO = u'GAM {0} - {1} / {2} / Python {3}.{4}.{5} {6} / {7} {8} /'.format(__version__, GAM_URL,
                                                                              __author__,
                                                                              sys.version_info[0], sys.version_info[1], sys.version_info[2],
                                                                              sys.version_info[3],
                                                                              platform.platform(), platform.machine())
GAM_RELEASES = u'https://github.com/{0}/{1}/releases'.format(GIT_USER, GAM)
GAM_WIKI = u'https://github.com/{0}/{1}/wiki'.format(GIT_USER, u'GAMADV-XTD')
GAM_ALL_RELEASES = u'https://api.github.com/repos/{0}/{1}/releases'.format(GIT_USER, GAM)
GAM_LATEST_RELEASE = GAM_ALL_RELEASES+u'/latest'
GAM_LATEST_SOURCE = u'https://raw.githubusercontent.com/{0}/{1}/master/src'.format(GIT_USER, GAM)
GAM_PROJECT_APIS = GAM_LATEST_SOURCE+u'/project-apis.txt'

TRUE = u'true'
FALSE = u'false'
TRUE_VALUES = [TRUE, u'on', u'yes', u'enabled', u'1']
FALSE_VALUES = [FALSE, u'off', u'no', u'disabled', u'0']
TRUE_FALSE = [TRUE, FALSE]
ERROR = u'ERROR'
ERROR_PREFIX = ERROR+u': '
WARNING = u'WARNING'
WARNING_PREFIX = WARNING+u': '
ONE_KILO_BYTES = 1000
ONE_MEGA_BYTES = 1000000
ONE_GIGA_BYTES = 1000000000
SECONDS_PER_MINUTE = 60
SECONDS_PER_HOUR = 3600
SECONDS_PER_DAY = 86400
SECONDS_PER_WEEK = 604800
UTF8 = u'utf-8'
FN_GAM_CFG = u'gam.cfg'
FN_LAST_UPDATE_CHECK_TXT = u'lastupdatecheck.txt'
FN_GAMCOMMANDS_TXT = u'GamCommands.txt'
TEAM_DRIVE = u'Team Drive'

# Python 3.6 values
DEFAULT_CSV_READ_MODE = u'r'
DEFAULT_FILE_APPEND_MODE = u'a'
DEFAULT_FILE_WRITE_MODE = u'w'

# Google API constants
APPLICATION_VND_GOOGLE_APPS = u'application/vnd.google-apps.'
MIMETYPE_GA_DOCUMENT = APPLICATION_VND_GOOGLE_APPS+u'document'
MIMETYPE_GA_DRAWING = APPLICATION_VND_GOOGLE_APPS+u'drawing'
MIMETYPE_GA_FOLDER = APPLICATION_VND_GOOGLE_APPS+u'folder'
MIMETYPE_GA_FORM = APPLICATION_VND_GOOGLE_APPS+u'form'
MIMETYPE_GA_FUSIONTABLE = APPLICATION_VND_GOOGLE_APPS+u'fusiontable'
MIMETYPE_GA_MAP = APPLICATION_VND_GOOGLE_APPS+u'map'
MIMETYPE_GA_PRESENTATION = APPLICATION_VND_GOOGLE_APPS+u'presentation'
MIMETYPE_GA_SCRIPT = APPLICATION_VND_GOOGLE_APPS+u'script'
MIMETYPE_GA_SITE = APPLICATION_VND_GOOGLE_APPS+u'site'
MIMETYPE_GA_SPREADSHEET = APPLICATION_VND_GOOGLE_APPS+u'spreadsheet'

GOOGLE_NAMESERVERS = [u'8.8.8.8', u'8.8.4.4']
NEVER_TIME = u'1970-01-01T00:00:00.000Z'
NEVER_START_DATE = u'1970-01-01'
NEVER_END_DATE = u'1969-12-31'
PROJECTION_CHOICE_MAP = {u'basic': u'BASIC', u'full': u'FULL',}
SORTORDER_CHOICE_MAP = {u'ascending': u'ASCENDING', u'descending': u'DESCENDING',}
ME_IN_OWNERS = u"'me' in owners"
ME_IN_OWNERS_AND = ME_IN_OWNERS+u" and "
AND_ME_IN_OWNERS = u" and "+ME_IN_OWNERS
NOT_ME_IN_OWNERS = u"not "+ME_IN_OWNERS
NOT_ME_IN_OWNERS_AND = NOT_ME_IN_OWNERS+u" and "
AND_NOT_ME_IN_OWNERS = u" and "+NOT_ME_IN_OWNERS
REPLACE_GROUP_PATTERN = re.compile(r'\\(\d+)')
# Drive v3
# Fields
V2_FILENAME = u'title'
V3_FILENAME = u'name'
VX_FILENAME = V3_FILENAME
VX_CREATED_TIME = u'createdTime'
VX_EXPIRATION_TIME = u'expirationTime'
VX_MODIFIED_BY_ME_TIME = u'modifiedByMeTime'
VX_MODIFIED_TIME = u'modifiedTime'
VX_SHARED_WITH_ME_TIME = u'sharedWithMeTime'
VX_VIEWED_BY_ME_TIME = u'viewedByMeTime'
VX_SIZE = u'size'
VX_WEB_VIEW_LINK = u'webViewLink'
# Queries
ANY_FOLDERS = u"mimeType = '{0}'".format(MIMETYPE_GA_FOLDER)
MY_FOLDERS = ME_IN_OWNERS_AND+ANY_FOLDERS
NON_TRASHED = u"trashed = false"
WITH_PARENTS = u"'{0}' in parents"
VX_ANY_NON_TRASHED_WITH_PARENTS = u"trashed = false and '{0}' in parents"
VX_ANY_NON_TRASHED_FOLDER_NAME = u"mimeType = '{0}' and {1} = '{{0}}' and trashed = false".format(MIMETYPE_GA_FOLDER, VX_FILENAME)
VX_ANY_NON_TRASHED_FOLDER_NAME_WITH_PARENTS = u"mimeType = '{0}' and {1} = '{{0}}' and trashed = false and '{{1}}' in parents".format(MIMETYPE_GA_FOLDER, VX_FILENAME)
VX_ANY_NON_TRASHED_MIMETYPE_NAME_PREFIX_WITH_PARENTS = u"mimeType = '{{0}}' and {0} contains '{{1}}' and trashed = false and '{{2}}' in parents".format(VX_FILENAME)
VX_ANY_NON_TRASHED_MIMETYPE_NAME_WITH_PARENTS = u"mimeType = '{{0}}' and {0} = '{{1}}' and trashed = false and '{{2}}' in parents".format(VX_FILENAME)
VX_MY_NON_TRASHED_FOLDER_NAME = ME_IN_OWNERS_AND+VX_ANY_NON_TRASHED_FOLDER_NAME
VX_MY_NON_TRASHED_FOLDER_NAME_WITH_PARENTS = ME_IN_OWNERS_AND+VX_ANY_NON_TRASHED_FOLDER_NAME_WITH_PARENTS
VX_WITH_ANY_FILE_NAME = u"{0} = '{{0}}'".format(VX_FILENAME)
VX_WITH_MY_FILE_NAME = ME_IN_OWNERS_AND+VX_WITH_ANY_FILE_NAME
# orderBy
VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME = 'folder desc,{0},{1} desc'.format(VX_FILENAME, VX_MODIFIED_TIME)
# Fields lists
VX_PAGES_FILES = u'files'
VX_PAGES_PERMISSIONS = u'permissions'
VX_PAGES_REVISIONS = u'revisions'

VX_PARENTS_ID = u'parents'
VX_TRASHED = u'trashed'

VX_COPY_FOLDER_FIELDS = u'{0},appProperties,contentHints,description,folderColorRgb,mimeType,modifiedTime,properties,starred,teamDriveId,viewedByMeTime,viewersCanCopyContent,writersCanShare'.format(VX_PARENTS_ID)
VX_DOWNLOAD_FIELDS = u'{0},fileExtension,mimeType,{1}'.format(VX_FILENAME, VX_SIZE)
VX_FILENAME_MIMETYPE_TEAMDRIVEID = u'{0},mimeType,teamDriveId'.format(VX_FILENAME)
VX_FILENAME_PARENTS = u'{0},{1}'.format(VX_FILENAME, VX_PARENTS_ID)
VX_FILENAME_PARENTS_COPY_FILE_FIELDS = u'id,{0},{1},appProperties,contentHints,capabilities,description,mimeType,modifiedTime,properties,starred,teamDriveId,viewedByMeTime,viewersCanCopyContent,writersCanShare'.format(VX_FILENAME, VX_PARENTS_ID)
VX_FILENAME_PARENTS_MIMETYPE = u'{0},{1},mimeType'.format(VX_FILENAME, VX_PARENTS_ID)
VX_FILENAME_PARENTS_MIMETYPE_TEAMDRIVEID = u'{0},{1},mimeType,teamDriveId'.format(VX_FILENAME, VX_PARENTS_ID)
VX_FILES_ID_FILENAME = u'{0}(id,{1})'.format(VX_PAGES_FILES, VX_FILENAME)
VX_ID_FILENAME = u'id,{0}'.format(VX_FILENAME)
VX_ID_FILENAME_MIMETYPE = u'id,{0},mimeType'.format(VX_FILENAME)
VX_ID_FILENAME_MIMETYPE_OWNEDBYME = u'id,{0},mimeType,ownedByMe'.format(VX_FILENAME)
VX_ID_FILENAME_PARENTS_MIMETYPE = u'id,{0},{1},mimeType'.format(VX_FILENAME, VX_PARENTS_ID)
VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME = u'id,{0},{1},mimeType,ownedByMe'.format(VX_FILENAME, VX_PARENTS_ID)
VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED = u'id,{0},{1},mimeType,ownedByMe,{2}'.format(VX_FILENAME, VX_PARENTS_ID, VX_TRASHED)
VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS = u'id,{0},{1},mimeType,ownedByMe,{2},owners(emailAddress,permissionId)'.format(VX_FILENAME, VX_PARENTS_ID, VX_TRASHED)
VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS_PERMISSIONS = u'id,{0},{1},mimeType,ownedByMe,{2},owners(emailAddress,permissionId),permissions(id,role)'.format(VX_FILENAME, VX_PARENTS_ID, VX_TRASHED)
VX_ID_FILENAME_PARENTS_MIMETYPE_OWNERS = u'id,{0},{1},mimeType,owners(emailAddress)'.format(VX_FILENAME, VX_PARENTS_ID)
VX_ID_MIMETYPE_CANEDIT = u'id,mimeType,capabilities(canEdit)'
VX_NPT_FILES_FIELDLIST = u'nextPageToken,{0}({{0}})'.format(VX_PAGES_FILES)
VX_NPT_FILES_ID = u'nextPageToken,{0}(id)'.format(VX_PAGES_FILES)
VX_NPT_FILES_ID_FILENAME = u'nextPageToken,{0}(id,{1})'.format(VX_PAGES_FILES, VX_FILENAME)
VX_NPT_FILES_ID_FILENAME_CAPABILITIES_MIMETYPE_MODIFIEDTIME = u'nextPageToken,{0}({1},id,capabilities,mimeType,{2})'.format(VX_PAGES_FILES, VX_FILENAME, VX_MODIFIED_TIME)
VX_NPT_FILES_ID_FILENAME_OWNEDBYME = u'nextPageToken,{0}(id,{1},ownedByMe)'.format(VX_PAGES_FILES, VX_FILENAME)
VX_NPT_FILES_ID_FILENAME_PARENTS_COPY_FIELDS = u'nextPageToken,{0}(id,{1},{2},appProperties,contentHints,capabilities,description,folderColorRgb,mimeType,modifiedTime,properties,starred,teamDriveId,viewedByMeTime,viewersCanCopyContent,writersCanShare)'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE = u'nextPageToken,{0}(id,{1},{2},mimeType)'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME = u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe)'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_OWNERS = u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,owners(emailAddress,permissionId))'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_OWNERS_PERMISSIONS = u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,owners(emailAddress,permissionId),permissions(id,role))'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED = u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,{3})'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID, VX_TRASHED)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS = u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,{3},owners(emailAddress,permissionId))'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID, VX_TRASHED)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS_PERMISSIONS = u'nextPageToken,{0}(id,{1},{2},mimeType,ownedByMe,{3},owners(emailAddress,permissionId),permissions(id,role))'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID, VX_TRASHED)
VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNERS = u'nextPageToken,{0}(id,{1},{2},mimeType,owners(emailAddress))'.format(VX_PAGES_FILES, VX_FILENAME, VX_PARENTS_ID)
VX_NPT_FILES_ID_MIMETYPE_CANEDIT = u'nextPageToken,{0}(id,mimeType,capabilities(canEdit))'.format(VX_PAGES_FILES)
VX_NPT_PERMISSIONS = u'nextPageToken,{0}'.format(VX_PAGES_PERMISSIONS)
VX_NPT_PERMISSIONS_FIELDLIST = u'nextPageToken,{0}({{0}})'.format(VX_PAGES_PERMISSIONS)
VX_NPT_REVISIONS_FIELDLIST = u'nextPageToken,{0}({{0}})'.format(VX_PAGES_REVISIONS)
VX_NPT_REVISIONS_ID_MODIFIEDTIME = u'nextPageToken,{0}(id,{1})'.format(VX_PAGES_REVISIONS, VX_MODIFIED_TIME)
VX_NPT_TEAMDRIVES_FIELDLIST = u'nextPageToken,teamDrives({0})'

# Cloudprint
CLOUDPRINT_ACCESS_URL = u'https://www.google.com/cloudprint/addpublicprinter.html?printerid={0}&key={1}'
# Valid language codes
LANGUAGE_CODES_MAP = {
  u'ach': u'ach', u'af': u'af', u'ag': u'ga', u'ak': u'ak', u'am': u'am', u'ar': u'ar', u'az': u'az', #Luo, Afrikaans, Irish, Akan, Amharic, Arabica, Azerbaijani
  u'be': u'be', u'bem': u'bem', u'bg': u'bg', u'bn': u'bn', u'br': u'br', u'bs': u'bs', u'ca': u'ca', #Belarusian, Bemba, Bulgarian, Bengali, Breton, Bosnian, Catalan
  u'chr': u'chr', u'ckb': u'ckb', u'co': u'co', u'crs': u'crs', u'cs': u'cs', u'cy': u'cy', u'da': u'da', #Cherokee, Kurdish (Sorani), Corsican, Seychellois Creole, Czech, Welsh, Danish
  u'de': u'de', u'ee': u'ee', u'el': u'el', u'en': u'en', u'en-gb': u'en-GB', u'en-us': u'en-US', u'eo': u'eo', #German, Ewe, Greek, English, English (UK), English (US), Esperanto
  u'es': u'es', u'es-419': u'es-419', u'et': u'et', u'eu': u'eu', u'fa': u'fa', u'fi': u'fi', u'fo': u'fo', #Spanish, Spanish (Latin American), Estonian, Basque, Persian, Finnish, Faroese
  u'fr': u'fr', u'fr-ca': u'fr-ca', u'fy': u'fy', u'ga': u'ga', u'gaa': u'gaa', u'gd': u'gd', u'gl': u'gl', #French, French (Canada), Frisian, Irish, Ga, Scots Gaelic, Galician
  u'gn': u'gn', u'gu': u'gu', u'ha': u'ha', u'haw': u'haw', u'he': u'he', u'hi': u'hi', u'hr': u'hr', #Guarani, Gujarati, Hausa, Hawaiian, Hebrew, Hindi, Croatian
  u'ht': u'ht', u'hu': u'hu', u'hy': u'hy', u'ia': u'ia', u'id': u'id', u'ig': u'ig', u'in': u'in', #Haitian Creole, Hungarian, Armenian, Interlingua, Indonesian, Igbo, in
  u'is': u'is', u'it': u'it', u'iw': u'iw', u'ja': u'ja', u'jw': u'jw', u'ka': u'ka', u'kg': u'kg', #Icelandic, Italian, Hebrew, Japanese, Javanese, Georgian, Kongo
  u'kk': u'kk', u'km': u'km', u'kn': u'kn', u'ko': u'ko', u'kri': u'kri', u'ku': u'ku', u'ky': u'ky', #Kazakh, Khmer, Kannada, Korean, Krio (Sierra Leone), Kurdish, Kyrgyz
  u'la': u'la', u'lg': u'lg', u'ln': u'ln', u'lo': u'lo', u'loz': u'loz', u'lt': u'lt', u'lua': u'lua', #Latin, Luganda, Lingala, Laothian, Lozi, Lithuanian, Tshiluba
  u'lv': u'lv', u'mfe': u'mfe', u'mg': u'mg', u'mi': u'mi', u'mk': u'mk', u'ml': u'ml', u'mn': u'mn', #Latvian, Mauritian Creole, Malagasy, Maori, Macedonian, Malayalam, Mongolian
  u'mo': u'mo', u'mr': u'mr', u'ms': u'ms', u'mt': u'mt', u'my': u'my', u'ne': u'ne', u'nl': u'nl', #Moldavian, Marathi, Malay, Maltese, Burmese, Nepali, Dutch
  u'nn': u'nn', u'no': u'no', u'nso': u'nso', u'ny': u'ny', u'nyn': u'nyn', u'oc': u'oc', u'om': u'om', #Norwegian (Nynorsk), Norwegian, Northern Sotho, Chichewa, Runyakitara, Occitan, Oromo
  u'or': u'or', u'pa': u'pa', u'pcm': u'pcm', u'pl': u'pl', u'ps': u'ps', u'pt-br': u'pt-BR', u'pt-pt': u'pt-PT', #Oriya, Punjabi, Nigerian Pidgin, Polish, Pashto, Portuguese (Brazil), Portuguese (Portugal)
  u'qu': u'qu', u'rm': u'rm', u'rn': u'rn', u'ro': u'ro', u'ru': u'ru', u'rw': u'rw', u'sd': u'sd', #Quechua, Romansh, Kirundi, Romanian, Russian, Kinyarwanda, Sindhi
  u'sh': u'sh', u'si': u'si', u'sk': u'sk', u'sl': u'sl', u'sn': u'sn', u'so': u'so', u'sq': u'sq', #Serbo-Croatian, Sinhalese, Slovak, Slovenian, Shona, Somali, Albanian
  u'sr': u'sr', u'sr-me': u'sr-ME', u'st': u'st', u'su': u'su', u'sv': u'sv', u'sw': u'sw', u'ta': u'ta', #Serbian, Montenegrin, Sesotho, Sundanese, Swedish, Swahili, Tamil
  u'te': u'te', u'tg': u'tg', u'th': u'th', u'ti': u'ti', u'tk': u'tk', u'tl': u'tl', u'tn': u'tn', #Telugu, Tajik, Thai, Tigrinya, Turkmen, Tagalog, Setswana
  u'to': u'to', u'tr': u'tr', u'tt': u'tt', u'tum': u'tum', u'tw': u'tw', u'ug': u'ug', u'uk': u'uk', #Tonga, Turkish, Tatar, Tumbuka, Twi, Uighur, Ukrainian
  u'ur': u'ur', u'uz': u'uz', u'vi': u'vi', u'wo': u'wo', u'xh': u'xh', u'yi': u'yi', u'yo': u'yo', #Urdu, Uzbek, Vietnamese, Wolof, Xhosa, Yiddish, Yoruba
  u'zh-cn': u'zh-CN', u'zh-hk': u'zh-HK', u'zh-tw': u'zh-TW', u'zu': u'zu', #Chinese (Simplified), Chinese (Hong Kong/Traditional), Chinese (Taiwan/Traditional), Zulu
  }
#
DFA_IGNORE_DEFAULT_VISIBILITY = u'ignoreDefaultVisibility'
DFA_KEEP_REVISION_FOREVER = u'keepRevisionForever'
DFA_LOCALFILEPATH = u'localFilepath'
DFA_LOCALFILENAME = u'localFilename'
DFA_LOCALMIMETYPE = u'localMimeType'
DFA_OCRLANGUAGE = u'ocrLanguage'
DFA_PARENTID = u'parentId'
DFA_PARENTQUERY = u'parentQuery'
DFA_ADD_PARENT_IDS = u'addParentIds'
DFA_REMOVE_PARENT_IDS = u'removeParentIds'
DFA_ADD_PARENTS = u'addParents'
DFA_REMOVE_PARENTS = u'removeParents'
DFA_ADD_PARENT_NAMES = u'addParentNames'
DFA_REMOVE_PARENT_NAMES = u'removeParentNames'
DFA_TEAMDRIVE_PARENT = u'teamDriveParent'
DFA_TEAMDRIVE_PARENTID = u'teamDriveParentId'
DFA_TEAMDRIVE_PARENTQUERY = u'teamDriveParentQuery'
DFA_KWARGS = u'kwargs'
DFA_SEARCHARGS = u'searchargs'
DFA_USE_CONTENT_AS_INDEXABLE_TEXT = u'useContentAsIndexableText'
# Program return codes
UNKNOWN_ERROR_RC = 1
USAGE_ERROR_RC = 2
SOCKET_ERROR_RC = 3
GOOGLE_API_ERROR_RC = 4
NETWORK_ERROR_RC = 5
FILE_ERROR_RC = 6
MEMORY_ERROR_RC = 7
KEYBOARD_INTERRUPT_RC = 8
HTTP_ERROR_RC = 9
SCOPES_NOT_AUTHORIZED = 10
API_ACCESS_DENIED_RC = 12
CONFIG_ERROR_RC = 13
CERTIFICATE_VALIDATION_UNSUPPORTED_RC = 14
NO_SCOPES_FOR_API_RC = 15
CLIENT_SECRETS_JSON_REQUIRED_RC = 16
OAUTH2SERVICE_JSON_REQUIRED_RC = 16
OAUTH2_TXT_REQUIRED_RC = 16
INVALID_JSON_RC = 17
AUTHENTICATION_TOKEN_REFRESH_ERROR_RC = 18
HARD_ERROR_RC = 19
# Information
ENTITY_IS_A_USER_RC = 20
ENTITY_IS_A_USER_ALIAS_RC = 21
ENTITY_IS_A_GROUP_RC = 22
ENTITY_IS_A_GROUP_ALIAS_RC = 23
ORPHANS_COLLECTED_RC = 30
# Warnings/Errors
AC_FAILED_RC = 50
AC_NOT_PERFORMED_RC = 51
BAD_REQUEST_RC = 53
ENTITY_IS_NOT_UNIQUE_RC = 54
DATA_NOT_AVALIABLE_RC = 55
ENTITY_DOES_NOT_EXIST_RC = 56
ENTITY_DUPLICATE_RC = 57
ENTITY_IS_NOT_AN_ALIAS_RC = 58
ENTITY_IS_UKNOWN_RC = 59
NO_ENTITIES_FOUND = 60
INVALID_DOMAIN_RC = 61
INVALID_DOMAIN_VALUE_RC = 62
INVALID_TOKEN_RC = 63
JSON_LOADS_ERROR_RC = 64
MULTIPLE_DELETED_USERS_FOUND_RC = 65
INSUFFICIENT_PERMISSIONS_RC = 67
REQUEST_COMPLETED_NO_RESULTS_RC = 71
REQUEST_NOT_COMPLETED_RC = 72
SERVICE_NOT_APPLICABLE_RC = 73
TARGET_DRIVE_SPACE_ERROR_RC = 74
USER_REQUIRED_TO_CHANGE_PASSWORD_ERROR_RC = 75
USER_SUSPENDED_ERROR_RC = 76
#
def convertUTF8(data):
  return data

def escapeCRsNLs(value):
  return value.replace(u'\r', u'\\r').replace(u'\n', u'\\n')

def unescapeCRsNLs(value):
  return value.replace(u'\\r', u'\r').replace(u'\\n', u'\n')

def executeBatch(dbatch):
  dbatch.execute()
  if GC.Values[GC.INTER_BATCH_WAIT] > 0:
    time.sleep(GC.Values[GC.INTER_BATCH_WAIT])

def StringIOobject(initbuff=None):
  if initbuff is None:
    return io.StringIO()
  return io.StringIO(initbuff)

def readStdin(prompt=None):
  return input(prompt)

def writeStdout(data):
  try:
    GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout).write(data)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def flushStdout():
  try:
    GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout).flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def writeStderr(data):
  flushStdout()
  try:
    GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr).write(data)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def flushStderr():
  try:
    GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr).flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

class _DeHTMLParser(HTMLParser):
  def __init__(self):
    HTMLParser.__init__(self)
    self.__text = []

  def handle_data(self, data):
    self.__text.append(data)

  def handle_charref(self, name):
    self.__text.append(char_type(int(name[1:], 16)) if name.startswith('x') else char_type(int(name)))

  def handle_entityref(self, name):
    cp = name2codepoint.get(name)
    if cp:
      self.__text.append(char_type(cp))
    else:
      self.__text.append(u'&'+name)

  def handle_starttag(self, tag, attrs):
    if tag == 'p':
      self.__text.append('\n\n')
    elif tag == 'br':
      self.__text.append('\n')
    elif tag == 'a':
      for attr in attrs:
        if attr[0] == 'href':
          self.__text.append('({0}) '.format(attr[1]))
          break
    elif tag == 'div':
      if not attrs:
        self.__text.append('\n')
    elif tag in ['http:', 'https']:
      self.__text.append(' ({0}//{1}) '.format(tag, attrs[0][0]))

  def handle_startendtag(self, tag, attrs):
    if tag == 'br':
      self.__text.append('\n\n')

  def text(self):
    return re.sub(r'\n{2}\n+', '\n\n', re.sub(r'\n +', '\n', ''.join(self.__text))).strip()

def dehtml(text):
  parser = _DeHTMLParser()
  parser.feed(str(text))
  parser.close()
  return parser.text()

# Format a key value list
#   key, value	-> "key: value" + ", " if not last item
#   key, ''	-> "key:" + ", " if not last item
#   key, None	-> "key" + " " if not last item
def formatKeyValueList(prefixStr, kvList, suffixStr):
  msg = prefixStr
  i = 0
  l = len(kvList)
  while i < l:
    if isinstance(kvList[i], simple_types):
      msg += str(kvList[i])
    else:
      msg += kvList[i]
    i += 1
    if i < l:
      val = kvList[i]
      if (val is not None) or (i == l-1):
        msg += u':'
        if (val is not None) and (not isinstance(val, string_types) or len(val) > 0):
          msg += u' '
          if isinstance(val, simple_types):
            msg += str(val)
          else:
            msg += val
        i += 1
        if i < l:
          msg += u', '
      else:
        i += 1
        if i < l:
          msg += u' '
  msg += suffixStr
  return msg

# Error exits
def setSysExitRC(sysRC):
  GM.Globals[GM.SYSEXITRC] = sysRC

def printErrorMessage(sysRC, message):
  setSysExitRC(sysRC)
  writeStderr(formatKeyValueList(Ind.Spaces(), [ERROR, message], u'\n'))

def stderrErrorMsg(message):
  writeStderr(convertUTF8(u'\n{0}{1}\n'.format(ERROR_PREFIX, message)))

def stderrWarningMsg(message):
  writeStderr(convertUTF8(u'\n{0}{1}\n'.format(WARNING_PREFIX, message)))

def systemErrorExit(sysRC, message):
  if message:
    stderrErrorMsg(message)
  sys.exit(sysRC)

# Something's wrong with CustomerID
def accessErrorMessage(cd):
  try:
    callGAPI(cd.customers(), u'get',
             throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerKey=GC.Values[GC.CUSTOMER_ID], fields=u'id')
  except GAPI.badRequest:
    return formatKeyValueList(u'',
                              [Ent.Singular(Ent.CUSTOMER_ID), GC.Values[GC.CUSTOMER_ID],
                               Msg.INVALID],
                              u'')
  except GAPI.resourceNotFound:
    return formatKeyValueList(u'',
                              [Ent.Singular(Ent.CUSTOMER_ID), GC.Values[GC.CUSTOMER_ID],
                               Msg.DOES_NOT_EXIST],
                              u'')
  except GAPI.forbidden:
    return formatKeyValueList(u'',
                              Ent.FormatEntityValueList([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID],
                                                         Ent.DOMAIN, GC.Values[GC.DOMAIN],
                                                         Ent.USER, GM.Globals[GM.ADMIN]])+[Msg.ACCESS_FORBIDDEN],
                              u'')
  return None

def accessErrorExit(cd):
  systemErrorExit(INVALID_DOMAIN_RC, accessErrorMessage(cd or buildGAPIObject(API.DIRECTORY)))

def APIAccessDeniedExit():
  stderrErrorMsg(Msg.API_ACCESS_DENIED)
  if GM.Globals[GM.CURRENT_CLIENT_API]:
    missingScopes = API.getClientScopesSet(GM.Globals[GM.CURRENT_CLIENT_API])-GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]
    if missingScopes:
      writeStderr(Msg.API_CHECK_CLIENT_AUTHORIZATION.format(GM.Globals[GM.OAUTH2_CLIENT_ID],
                                                            u','.join(sorted(missingScopes))))
  if GM.Globals[GM.CURRENT_SVCACCT_API]:
    writeStderr(Msg.API_CHECK_SVCACCT_AUTHORIZATION.format(GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID],
                                                           u','.join(sorted(API.getSvcAcctScopesSet(GM.Globals[GM.CURRENT_SVCACCT_API]))),
                                                           GM.Globals[GM.CURRENT_SVCACCT_USER]))
  systemErrorExit(API_ACCESS_DENIED_RC, None)

def checkEntityDNEorAccessErrorExit(cd, entityType, entityName, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityDoesNotExistWarning(entityType, entityName, i, count)

def checkEntityAFDNEorAccessErrorExit(cd, entityType, entityName, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityActionFailedWarning([entityType, entityName], Msg.DOES_NOT_EXIST, i, count)

def checkEntityItemValueAFDNEorAccessErrorExit(cd, entityType, entityName, itemType, itemValue, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityActionFailedWarning([entityType, entityName, itemType, itemValue], Msg.DOES_NOT_EXIST, i, count)

def invalidClientSecretsJsonExit():
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.CLIENT_SECRETS_JSON_FILE), GC.Values[GC.CLIENT_SECRETS_JSON]))
  writeStderr(Msg.INSTRUCTIONS_CLIENT_SECRETS_JSON)
  systemErrorExit(CLIENT_SECRETS_JSON_REQUIRED_RC, None)

def invalidOauth2serviceJsonExit():
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.OAUTH2SERVICE_JSON_FILE), GC.Values[GC.OAUTH2SERVICE_JSON]))
  writeStderr(Msg.INSTRUCTIONS_OAUTH2SERVICE_JSON)
  systemErrorExit(OAUTH2SERVICE_JSON_REQUIRED_RC, None)

def invalidOauth2TxtExit():
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.OAUTH2_TXT_FILE), GC.Values[GC.OAUTH2_TXT]))
  writeStderr(Msg.EXECUTE_GAM_OAUTH_CREATE)
  systemErrorExit(OAUTH2_TXT_REQUIRED_RC, None)

def invalidOauth2TxtImportExit(importFile):
  stderrErrorMsg(Msg.HAS_INVALID_FORMAT.format(Ent.Singular(Ent.OAUTH2_TXT_FILE), importFile))
  systemErrorExit(OAUTH2_TXT_REQUIRED_RC, None)

def invalidClassroomOauth2TxtExit(filename, noExit=False):
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.CLASSROOM_OAUTH2_TXT_FILE), filename))
  if noExit:
    setSysExitRC(OAUTH2_TXT_REQUIRED_RC)
    return
  systemErrorExit(OAUTH2_TXT_REQUIRED_RC, None)

def invalidDiscoveryJsonExit(fileName):
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.DISCOVERY_JSON_FILE), fileName))
  systemErrorExit(INVALID_JSON_RC, None)

def noPythonSSLExit():
  systemErrorExit(CERTIFICATE_VALIDATION_UNSUPPORTED_RC, Msg.NO_PYTHON_SSL)

def entityDoesNotExistExit(entityType, entityName, i=0, count=0, errMsg=None):
  Cmd.Backup()
  writeStderr(convertUTF8(Cmd.CommandLineWithBadArgumentMarked(False)))
  systemErrorExit(ENTITY_DOES_NOT_EXIST_RC, formatKeyValueList(Ind.Spaces(),
                                                               [Ent.Singular(entityType), entityName, errMsg or Msg.DOES_NOT_EXIST],
                                                               currentCountNL(i, count)))

def entityDoesNotHaveItemExit(entityValueList, i=0, count=0):
  Cmd.Backup()
  writeStderr(convertUTF8(Cmd.CommandLineWithBadArgumentMarked(False)))
  systemErrorExit(ENTITY_DOES_NOT_EXIST_RC, formatKeyValueList(Ind.Spaces(),
                                                               Ent.FormatEntityValueList(entityValueList)+[Msg.DOES_NOT_EXIST],
                                                               currentCountNL(i, count)))

def entityIsNotUniqueExit(entityType, entityName, valueType, valueList, i=0, count=0):
  Cmd.Backup()
  writeStderr(convertUTF8(Cmd.CommandLineWithBadArgumentMarked(False)))
  systemErrorExit(ENTITY_IS_NOT_UNIQUE_RC, formatKeyValueList(Ind.Spaces(),
                                                              [Ent.Singular(entityType), entityName, Msg.IS_NOT_UNIQUE.format(Ent.Plural(valueType), u','.join(valueList))],
                                                              currentCountNL(i, count)))

def usageErrorExit(message, extraneous=False):
  writeStderr(convertUTF8(Cmd.CommandLineWithBadArgumentMarked(extraneous)))
  stderrErrorMsg(message)
  writeStderr(Msg.HELP_SYNTAX.format(os.path.join(GM.Globals[GM.GAM_PATH], FN_GAMCOMMANDS_TXT)))
  writeStderr(Msg.HELP_WIKI.format(GAM_WIKI))
  sys.exit(USAGE_ERROR_RC)

def badEntitiesExit(entityType, count, phraseList, backupArg=False):
  if backupArg:
    Cmd.Backup()
  usageErrorExit(u'{0} {1} {2}'.format(count, Ent.Choose(entityType, count), phraseList[count == 1]))

def csvFieldErrorExit(fieldName, fieldNames, backupArg=False, checkForCharset=False):
  if backupArg:
    Cmd.Backup()
    if checkForCharset and Cmd.Previous() == u'charset':
      Cmd.Backup()
      Cmd.Backup()
  usageErrorExit(Msg.HEADER_NOT_FOUND_IN_CSV_HEADERS.format(fieldName, u','.join(fieldNames)))

def csvDataAlreadySavedErrorExit():
  Cmd.Backup()
  usageErrorExit(Msg.CSV_DATA_ALREADY_SAVED)

# The last thing shown is unknown
def unknownArgumentExit():
  Cmd.Backup()
  usageErrorExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1])

# Argument describes what's expected
def expectedArgumentExit(problem, argument):
  usageErrorExit(u'{0}: {1} <{2}>'.format(problem, Msg.EXPECTED, argument))

def blankArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_BLANK][1], u'{0} {1}'.format(Msg.NON_BLANK, argument))

def emptyArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_EMPTY][1], u'{0} {1}'.format(Msg.NON_EMPTY, argument))

def invalidArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1], argument)

def missingArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_MISSING][1], argument)

def deprecatedArgument(argument):
  Cmd.Backup()
  writeStderr(convertUTF8(Cmd.CommandLineWithBadArgumentMarked(False)))
  Cmd.Advance()
  stderrWarningMsg(u'{0}: {1} <{2}>'.format(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_DEPRECATED][1], Msg.IGNORED, argument))

# Choices is the valid set of choices that was expected
def formatChoiceList(choices):
  choiceList = list(choices)
  if len(choiceList) <= 5:
    return u'|'.join(choiceList)
  else:
    return u'|'.join(sorted(choiceList))

def invalidChoiceExit(choices, backupArg):
  if backupArg:
    Cmd.Backup()
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1], formatChoiceList(choices))

def missingChoiceExit(choices):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_MISSING][1], formatChoiceList(choices))

# Check if argument present
def checkArgumentPresent(choices, required=False):
  choiceList = choices if isinstance(choices, list) else [choices]
  if Cmd.ArgumentsRemaining():
    choice = Cmd.Current().strip().lower().replace(u'_', u'')
    if choice:
      if choice in choiceList:
        Cmd.Advance()
        return True
    if not required:
      return False
    invalidChoiceExit(choiceList, False)
  elif not required:
    return False
  missingChoiceExit(choiceList)

# Peek to see if argument present, do not advance
def peekArgumentPresent(choices):
  if Cmd.ArgumentsRemaining():
    choiceList = choices if isinstance(choices, list) else [choices]
    choice = Cmd.Current().strip().lower().replace(u'_', u'')
    if choice and choice in choiceList:
      return True
  return False

# Check that there are no extraneous arguments at the end of the command line
def checkForExtraneousArguments():
  if Cmd.ArgumentsRemaining():
    usageErrorExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_EXTRANEOUS][[1, 0][Cmd.MultipleArgumentsRemaining()]], extraneous=True)

# Get an argument, downshift, delete underscores
def getArgument():
  if Cmd.ArgumentsRemaining():
    argument = Cmd.Current().lower()
    if argument:
      Cmd.Advance()
      return argument.replace(u'_', u'')
  missingArgumentExit(Cmd.OB_ARGUMENT)

def getBoolean(defaultValue=True):
  if Cmd.ArgumentsRemaining():
    boolean = Cmd.Current().strip().lower()
    if boolean in TRUE_VALUES:
      Cmd.Advance()
      return True
    if boolean in FALSE_VALUES:
      Cmd.Advance()
      return False
    if defaultValue is not None:
      return defaultValue
    invalidChoiceExit(TRUE_FALSE, False)
  if defaultValue is not None:
    return defaultValue
  missingChoiceExit(TRUE_FALSE)

DEFAULT_CHOICE = u'defaultChoice'
CHOICE_ALIASES = u'choiceAliases'
MAP_CHOICE = u'mapChoice'
NO_DEFAULT = u'NoDefault'

def getChoice(choices, **opts):
  if Cmd.ArgumentsRemaining():
    choice = Cmd.Current().strip().lower()
    if choice:
      if choice in opts.get(CHOICE_ALIASES, []):
        choice = opts[CHOICE_ALIASES][choice]
      if choice not in choices:
        choice = choice.replace(u'_', u'').replace(u'-', u'')
        if choice in opts.get(CHOICE_ALIASES, []):
          choice = opts[CHOICE_ALIASES][choice]
      if choice in choices:
        Cmd.Advance()
        return choice if not opts.get(MAP_CHOICE, False) else choices[choice]
    if opts.get(DEFAULT_CHOICE, NO_DEFAULT) != NO_DEFAULT:
      return opts[DEFAULT_CHOICE]
    invalidChoiceExit(choices, False)
  elif opts.get(DEFAULT_CHOICE, NO_DEFAULT) != NO_DEFAULT:
    return opts[DEFAULT_CHOICE]
  missingChoiceExit(choices)

def getChoiceAndValue(item, choices, delimiter):
  if not Cmd.ArgumentsRemaining() or Cmd.Current().find(delimiter) == -1:
    return (None, None)
  choice, value = Cmd.Current().strip().split(delimiter, 1)
  choice = choice.strip().lower()
  value = value.strip()
  if choice in choices:
    if value:
      Cmd.Advance()
      return (choice, value)
    missingArgumentExit(item)
  invalidChoiceExit(choices, False)

WEBCOLOR_MAP = {
  u'aliceblue': u'#f0f8ff',
  u'antiquewhite': u'#faebd7',
  u'aqua': u'#00ffff',
  u'aquamarine': u'#7fffd4',
  u'azure': u'#f0ffff',
  u'beige': u'#f5f5dc',
  u'bisque': u'#ffe4c4',
  u'black': u'#000000',
  u'blanchedalmond': u'#ffebcd',
  u'blue': u'#0000ff',
  u'blueviolet': u'#8a2be2',
  u'brown': u'#a52a2a',
  u'burlywood': u'#deb887',
  u'cadetblue': u'#5f9ea0',
  u'chartreuse': u'#7fff00',
  u'chocolate': u'#d2691e',
  u'coral': u'#ff7f50',
  u'cornflowerblue': u'#6495ed',
  u'cornsilk': u'#fff8dc',
  u'crimson': u'#dc143c',
  u'cyan': u'#00ffff',
  u'darkblue': u'#00008b',
  u'darkcyan': u'#008b8b',
  u'darkgoldenrod': u'#b8860b',
  u'darkgray': u'#a9a9a9',
  u'darkgrey': u'#a9a9a9',
  u'darkgreen': u'#006400',
  u'darkkhaki': u'#bdb76b',
  u'darkmagenta': u'#8b008b',
  u'darkolivegreen': u'#556b2f',
  u'darkorange': u'#ff8c00',
  u'darkorchid': u'#9932cc',
  u'darkred': u'#8b0000',
  u'darksalmon': u'#e9967a',
  u'darkseagreen': u'#8fbc8f',
  u'darkslateblue': u'#483d8b',
  u'darkslategray': u'#2f4f4f',
  u'darkslategrey': u'#2f4f4f',
  u'darkturquoise': u'#00ced1',
  u'darkviolet': u'#9400d3',
  u'deeppink': u'#ff1493',
  u'deepskyblue': u'#00bfff',
  u'dimgray': u'#696969',
  u'dimgrey': u'#696969',
  u'dodgerblue': u'#1e90ff',
  u'firebrick': u'#b22222',
  u'floralwhite': u'#fffaf0',
  u'forestgreen': u'#228b22',
  u'fuchsia': u'#ff00ff',
  u'gainsboro': u'#dcdcdc',
  u'ghostwhite': u'#f8f8ff',
  u'gold': u'#ffd700',
  u'goldenrod': u'#daa520',
  u'gray': u'#808080',
  u'grey': u'#808080',
  u'green': u'#008000',
  u'greenyellow': u'#adff2f',
  u'honeydew': u'#f0fff0',
  u'hotpink': u'#ff69b4',
  u'indianred': u'#cd5c5c',
  u'indigo': u'#4b0082',
  u'ivory': u'#fffff0',
  u'khaki': u'#f0e68c',
  u'lavender': u'#e6e6fa',
  u'lavenderblush': u'#fff0f5',
  u'lawngreen': u'#7cfc00',
  u'lemonchiffon': u'#fffacd',
  u'lightblue': u'#add8e6',
  u'lightcoral': u'#f08080',
  u'lightcyan': u'#e0ffff',
  u'lightgoldenrodyellow': u'#fafad2',
  u'lightgray': u'#d3d3d3',
  u'lightgrey': u'#d3d3d3',
  u'lightgreen': u'#90ee90',
  u'lightpink': u'#ffb6c1',
  u'lightsalmon': u'#ffa07a',
  u'lightseagreen': u'#20b2aa',
  u'lightskyblue': u'#87cefa',
  u'lightslategray': u'#778899',
  u'lightslategrey': u'#778899',
  u'lightsteelblue': u'#b0c4de',
  u'lightyellow': u'#ffffe0',
  u'lime': u'#00ff00',
  u'limegreen': u'#32cd32',
  u'linen': u'#faf0e6',
  u'magenta': u'#ff00ff',
  u'maroon': u'#800000',
  u'mediumaquamarine': u'#66cdaa',
  u'mediumblue': u'#0000cd',
  u'mediumorchid': u'#ba55d3',
  u'mediumpurple': u'#9370db',
  u'mediumseagreen': u'#3cb371',
  u'mediumslateblue': u'#7b68ee',
  u'mediumspringgreen': u'#00fa9a',
  u'mediumturquoise': u'#48d1cc',
  u'mediumvioletred': u'#c71585',
  u'midnightblue': u'#191970',
  u'mintcream': u'#f5fffa',
  u'mistyrose': u'#ffe4e1',
  u'moccasin': u'#ffe4b5',
  u'navajowhite': u'#ffdead',
  u'navy': u'#000080',
  u'oldlace': u'#fdf5e6',
  u'olive': u'#808000',
  u'olivedrab': u'#6b8e23',
  u'orange': u'#ffa500',
  u'orangered': u'#ff4500',
  u'orchid': u'#da70d6',
  u'palegoldenrod': u'#eee8aa',
  u'palegreen': u'#98fb98',
  u'paleturquoise': u'#afeeee',
  u'palevioletred': u'#db7093',
  u'papayawhip': u'#ffefd5',
  u'peachpuff': u'#ffdab9',
  u'peru': u'#cd853f',
  u'pink': u'#ffc0cb',
  u'plum': u'#dda0dd',
  u'powderblue': u'#b0e0e6',
  u'purple': u'#800080',
  u'red': u'#ff0000',
  u'rosybrown': u'#bc8f8f',
  u'royalblue': u'#4169e1',
  u'saddlebrown': u'#8b4513',
  u'salmon': u'#fa8072',
  u'sandybrown': u'#f4a460',
  u'seagreen': u'#2e8b57',
  u'seashell': u'#fff5ee',
  u'sienna': u'#a0522d',
  u'silver': u'#c0c0c0',
  u'skyblue': u'#87ceeb',
  u'slateblue': u'#6a5acd',
  u'slategray': u'#708090',
  u'slategrey': u'#708090',
  u'snow': u'#fffafa',
  u'springgreen': u'#00ff7f',
  u'steelblue': u'#4682b4',
  u'tan': u'#d2b48c',
  u'teal': u'#008080',
  u'thistle': u'#d8bfd8',
  u'tomato': u'#ff6347',
  u'turquoise': u'#40e0d0',
  u'violet': u'#ee82ee',
  u'wheat': u'#f5deb3',
  u'white': u'#ffffff',
  u'whitesmoke': u'#f5f5f5',
  u'yellow': u'#ffff00',
  u'yellowgreen': u'#9acd32',
  }

COLORHEX_PATTERN = re.compile(r'^#[0-9a-fA-F]{6}$')
COLORHEX_FORMAT_REQUIRED = u'ColorName|ColorHex'

def getColor():
  if Cmd.ArgumentsRemaining():
    color = Cmd.Current().strip().lower()
    if color in WEBCOLOR_MAP:
      Cmd.Advance()
      return WEBCOLOR_MAP[color]
    tg = COLORHEX_PATTERN.match(color)
    if tg:
      Cmd.Advance()
      return tg.group(0)
    invalidArgumentExit(COLORHEX_FORMAT_REQUIRED)
  missingArgumentExit(COLORHEX_FORMAT_REQUIRED)

LABEL_COLORS = [
  u'#000000', u'#076239', u'#0b804b', u'#149e60', u'#16a766', u'#1a764d', u'#1c4587', u'#285bac',
  u'#2a9c68', u'#3c78d8', u'#3dc789', u'#41236d', u'#434343', u'#43d692', u'#44b984', u'#4a86e8',
  u'#653e9b', u'#666666', u'#68dfa9', u'#6d9eeb', u'#822111', u'#83334c', u'#89d3b2', u'#8e63ce',
  u'#999999', u'#a0eac9', u'#a46a21', u'#a479e2', u'#a4c2f4', u'#aa8831', u'#ac2b16', u'#b65775',
  u'#b694e8', u'#b9e4d0', u'#c6f3de', u'#c9daf8', u'#cc3a21', u'#cccccc', u'#cf8933', u'#d0bcf1',
  u'#d5ae49', u'#e07798', u'#e4d7f5', u'#e66550', u'#eaa041', u'#efa093', u'#efefef', u'#f2c960',
  u'#f3f3f3', u'#f691b3', u'#f6c5be', u'#f7a7c0', u'#fad165', u'#fb4c2f', u'#fbc8d9', u'#fcda83',
  u'#fcdee8', u'#fce8b3', u'#fef1d1', u'#ffad47', u'#ffbc6b', u'#ffd6a2', u'#ffe6c7', u'#ffffff',
  ]

def getLabelColor():
  if Cmd.ArgumentsRemaining():
    color = Cmd.Current().strip().lower()
    tg = COLORHEX_PATTERN.match(color)
    if tg:
      color = tg.group(0)
      if color in LABEL_COLORS:
        Cmd.Advance()
        return color
    invalidArgumentExit(u'|'.join(LABEL_COLORS))
  missingArgumentExit(Cmd.OB_LABEL_COLOR_HEX)

def removeCourseIdScope(courseId):
  if courseId.startswith(u'd:'):
    return courseId[2:]
  return courseId

def addCourseIdScope(courseId):
  if not courseId.isdigit() and courseId[:2] != u'd:':
    return u'd:{0}'.format(courseId)
  return courseId

def getCourseAlias():
  if Cmd.ArgumentsRemaining():
    courseAlias = Cmd.Current()
    if courseAlias:
      Cmd.Advance()
      if courseAlias[:2] != u'd:':
        return u'd:{0}'.format(courseAlias)
      return courseAlias
  missingArgumentExit(Cmd.OB_COURSE_ALIAS)

UID_PATTERN = re.compile(r'u?id: ?(.+)', re.IGNORECASE)

def validateEmailAddressOrUID(emailAddressOrUID):
  cg = UID_PATTERN.match(emailAddressOrUID)
  if cg:
    return cg.group(1)
  return emailAddressOrUID.find(u'@') != 0 and emailAddressOrUID.count(u'@') <= 1

# Normalize user/group email address/uid
# uid:12345abc -> 12345abc
# foo -> foo@domain
# foo@ -> foo@domain
# foo@bar.com -> foo@bar.com
# @domain -> domain
def normalizeEmailAddressOrUID(emailAddressOrUID, noUid=False, checkForCustomerId=False, noLower=False):
  if checkForCustomerId and (emailAddressOrUID == GC.Values[GC.CUSTOMER_ID]):
    return emailAddressOrUID
  if not noUid:
    cg = UID_PATTERN.match(emailAddressOrUID)
    if cg:
      return cg.group(1)
  atLoc = emailAddressOrUID.find(u'@')
  if atLoc == 0:
    return emailAddressOrUID[1:].lower() if not noLower else emailAddressOrUID[1:]
  if (atLoc == -1) or (atLoc == len(emailAddressOrUID)-1) and GC.Values[GC.DOMAIN]:
    if atLoc == -1:
      emailAddressOrUID = u'{0}@{1}'.format(emailAddressOrUID, GC.Values[GC.DOMAIN].lower())
    else:
      emailAddressOrUID = u'{0}{1}'.format(emailAddressOrUID, GC.Values[GC.DOMAIN].lower())
  return emailAddressOrUID.lower() if not noLower else emailAddressOrUID

# Normalize student/guardian email address/uid
# 12345678 -> 12345678
# - -> -
# Otherwise, same results as normalizeEmailAddressOrUID
def normalizeStudentGuardianEmailAddressOrUID(emailAddressOrUID):
  if emailAddressOrUID.isdigit() or emailAddressOrUID == u'-':
    return emailAddressOrUID
  return normalizeEmailAddressOrUID(emailAddressOrUID)

def getEmailAddress(noUid=False, minLen=1, optional=False):
  if Cmd.ArgumentsRemaining():
    emailAddress = Cmd.Current().strip().lower()
    if emailAddress:
      cg = UID_PATTERN.match(emailAddress)
      if cg:
        if not noUid:
          if cg.group(1):
            Cmd.Advance()
            return cg.group(1)
        else:
          invalidArgumentExit(u'name@domain')
      else:
        atLoc = emailAddress.find(u'@')
        if atLoc == -1:
          if GC.Values[GC.DOMAIN]:
            emailAddress = u'{0}@{1}'.format(emailAddress, GC.Values[GC.DOMAIN].lower())
          Cmd.Advance()
          return emailAddress
        if atLoc != 0:
          if (atLoc == len(emailAddress)-1) and GC.Values[GC.DOMAIN]:
            emailAddress = u'{0}{1}'.format(emailAddress, GC.Values[GC.DOMAIN].lower())
          Cmd.Advance()
          return emailAddress
        invalidArgumentExit(u'name@domain')
    if optional:
      Cmd.Advance()
      return None
    elif minLen == 0:
      Cmd.Advance()
      return u''
  elif optional:
    return None
  missingArgumentExit([Cmd.OB_EMAIL_ADDRESS_OR_UID, Cmd.OB_EMAIL_ADDRESS][noUid])

def getPermissionId():
  if Cmd.ArgumentsRemaining():
    emailAddress = Cmd.Current().strip().lower()
    if emailAddress:
      if emailAddress[:3] == u'id:':
        Cmd.Advance()
        return (False, Cmd.Previous().strip()[3:])
      atLoc = emailAddress.find(u'@')
      if atLoc == -1:
        if emailAddress == u'anyone':
          Cmd.Advance()
          return (False, emailAddress)
        if emailAddress == u'anyonewithlink':
          Cmd.Advance()
          return (False, u'anyoneWithLink')
        if GC.Values[GC.DOMAIN]:
          emailAddress = u'{0}@{1}'.format(emailAddress, GC.Values[GC.DOMAIN].lower())
        Cmd.Advance()
        return (True, emailAddress)
      if atLoc != 0:
        if (atLoc == len(emailAddress)-1) and GC.Values[GC.DOMAIN]:
          emailAddress = u'{0}{1}'.format(emailAddress, GC.Values[GC.DOMAIN].lower())
        Cmd.Advance()
        return (True, emailAddress)
      invalidArgumentExit(u'name@domain')
  missingArgumentExit(Cmd.OB_DRIVE_FILE_PERMISSION_ID)

def getGoogleProduct():
  if Cmd.ArgumentsRemaining():
    product = Cmd.Current().strip()
    if product:
      Cmd.Advance()
      return SKU.normalizeProductId(product)
  missingArgumentExit(Cmd.OB_PRODUCT_ID)

def getGoogleProductList():
  if Cmd.ArgumentsRemaining():
    productsList = []
    for product in Cmd.Current().split(u','):
      product = SKU.normalizeProductId(product)
      if product not in productsList:
        productsList.append(product)
    Cmd.Advance()
    return productsList
  missingArgumentExit(Cmd.OB_PRODUCT_ID_LIST)

def getGoogleSKU():
  if Cmd.ArgumentsRemaining():
    sku = Cmd.Current().strip()
    if sku:
      Cmd.Advance()
      return SKU.getProductAndSKU(sku)
  missingArgumentExit(Cmd.OB_SKU_ID)

def getGoogleSKUList():
  if Cmd.ArgumentsRemaining():
    skusList = []
    for sku in Cmd.Current().split(u','):
      _, sku = SKU.getProductAndSKU(sku)
      if sku not in skusList:
        skusList.append(sku)
    Cmd.Advance()
    return skusList
  missingArgumentExit(Cmd.OB_SKU_ID_LIST)

def floatLimits(minVal, maxVal, item=u'float'):
  if (minVal is not None) and (maxVal is not None):
    return u'{0} {1:5.3f}<=x<={2:5.3f}'.format(item, minVal, maxVal)
  if minVal is not None:
    return u'{0} x>={1:5.3f}'.format(item, minVal)
  if maxVal is not None:
    return u'{0} x<={1:5.3f}'.format(item, maxVal)
  return u'{0} x'.format(item)

def getFloat(minVal=None, maxVal=None):
  if Cmd.ArgumentsRemaining():
    try:
      number = float(Cmd.Current().strip())
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        Cmd.Advance()
        return number
    except ValueError:
      pass
    invalidArgumentExit(floatLimits(minVal, maxVal))
  missingArgumentExit(floatLimits(minVal, maxVal))

def integerLimits(minVal, maxVal, item=u'integer'):
  if (minVal is not None) and (maxVal is not None):
    return u'{0} {1}<=x<={2}'.format(item, minVal, maxVal)
  if minVal is not None:
    return u'{0} x>={1}'.format(item, minVal)
  if maxVal is not None:
    return u'{0} x<={1}'.format(item, maxVal)
  return u'{0} x'.format(item)

def getInteger(minVal=None, maxVal=None):
  if Cmd.ArgumentsRemaining():
    try:
      number = int(Cmd.Current().strip())
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        Cmd.Advance()
        return number
    except ValueError:
      pass
    invalidArgumentExit(integerLimits(minVal, maxVal))
  missingArgumentExit(integerLimits(minVal, maxVal))

def orgUnitPathQuery(path, checkSuspended):
  query = u"orgUnitPath='{0}'".format(path.replace(u"'", u"\\'")) if path != u'/' else None
  if checkSuspended is not None:
    query += u' isSuspended={0}'.format(checkSuspended)
  return query

def makeOrgUnitPathAbsolute(path):
  if path == u'/':
    return path
  if path.startswith(u'/'):
    return path.rstrip(u'/')
  if path.startswith(u'id:'):
    return path
  if path.startswith(u'uid:'):
    return path[1:]
  return u'/'+path.rstrip(u'/')

def makeOrgUnitPathRelative(path):
  if path == u'/':
    return path
  if path.startswith(u'/'):
    return path[1:].rstrip(u'/')
  if path.startswith(u'id:'):
    return path
  if path.startswith(u'uid:'):
    return path[1:]
  return path.rstrip(u'/')

def encodeOrgUnitPath(path):
  if path.find(u'+') == -1 and path.find(u'%') == -1:
    return path
  encpath = u''
  for c in path:
    if c == u'+':
      encpath += u'%2B'
    elif c == u'%':
      encpath += u'%25'
    else:
      encpath += c
  return encpath

def getOrgUnitItem(pathOnly=False, absolutePath=True):
  if Cmd.ArgumentsRemaining():
    path = Cmd.Current().strip()
    if path:
      if pathOnly and (path.startswith(u'id:') or path.startswith(u'uid:')):
        invalidArgumentExit(Cmd.OB_ORGUNIT_PATH)
      Cmd.Advance()
      if absolutePath:
        return makeOrgUnitPathAbsolute(path)
      return makeOrgUnitPathRelative(path)
  missingArgumentExit([Cmd.OB_ORGUNIT_ITEM, Cmd.OB_ORGUNIT_PATH][pathOnly])

def validateREPattern(patstr, flags=0):
  try:
    return re.compile(patstr, flags)
  except re.error as e:
    Cmd.Backup()
    usageErrorExit(u'{0} {1}: {2}'.format(Cmd.OB_RE_PATTERN, Msg.ERROR, e))

def getREPattern(flags=0):
  if Cmd.ArgumentsRemaining():
    patstr = Cmd.Current()
    if patstr:
      Cmd.Advance()
      return validateREPattern(patstr, flags)
  missingArgumentExit(Cmd.OB_RE_PATTERN)

SITENAME_PATTERN = re.compile(r'^[a-z0-9\-_]+$')
SITENAME_FORMAT_REQUIRED = u'[a-z,0-9,-_]+'

def validateSplitSiteName(fullSite):
  siteParts = fullSite.lower().split(u'/', 1)
  if (len(siteParts) == 1) or (len(siteParts[1]) == 0):
    domain = GC.Values[GC.DOMAIN]
    site = siteParts[0]
  elif len(siteParts[0]) == 0:
    domain = GC.Values[GC.DOMAIN]
    site = siteParts[1]
  else:
    domain = siteParts[0]
    site = siteParts[1]
  if SITENAME_PATTERN.match(site):
    return (domain, site, u'{0}/{1}'.format(domain, site))
  return (domain, site, None)

def getSiteName():
  if Cmd.ArgumentsRemaining():
    domain, site, domainSite = validateSplitSiteName(Cmd.Current())
    if domainSite:
      Cmd.Advance()
      return (domain, site, domainSite)
    invalidArgumentExit(SITENAME_FORMAT_REQUIRED)
  missingArgumentExit(SITENAME_FORMAT_REQUIRED)

def getString(item, checkBlank=False, optional=False, minLen=1, maxLen=None):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current()
    if argstr:
      if checkBlank:
        if argstr.isspace():
          blankArgumentExit(item)
      if (len(argstr) >= minLen) and ((maxLen is None) or (len(argstr) <= maxLen)):
        Cmd.Advance()
        return argstr
      invalidArgumentExit(u'{0} for {1}'.format(integerLimits(minLen, maxLen, Msg.STRING_LENGTH), item))
    if optional or (minLen == 0):
      Cmd.Advance()
      return u''
    emptyArgumentExit(item)
  elif optional:
    return u''
  missingArgumentExit(item)

def getStringWithCRsNLs():
  return unescapeCRsNLs(getString(Cmd.OB_STRING, minLen=0))

def getStringReturnInList(item):
  argstr = getString(item, minLen=0).strip()
  if argstr:
    return [argstr]
  return []

def todaysDate():
  return datetime.datetime(GM.Globals[GM.DATETIME_NOW].year, GM.Globals[GM.DATETIME_NOW].month, GM.Globals[GM.DATETIME_NOW].day,
                           tzinfo=GC.Values[GC.TIMEZONE])

def getDelta(argstr, pattern, formatRequired):
  if argstr == u'NOW':
    return todaysDate()+datetime.timedelta(hours=GM.Globals[GM.DATETIME_NOW].hour, minutes=GM.Globals[GM.DATETIME_NOW].minute)
  elif argstr == u'TODAY':
    return todaysDate()
  tg = pattern.match(argstr.lower())
  if tg is None:
    invalidArgumentExit(formatRequired)
  sign = tg.group(1)
  delta = int(tg.group(2))
  unit = tg.group(3)
  if unit == u'w':
    deltaTime = datetime.timedelta(weeks=delta)
  elif unit == u'd':
    deltaTime = datetime.timedelta(days=delta)
  elif unit == u'h':
    deltaTime = datetime.timedelta(hours=delta)
  elif unit == u'm':
    deltaTime = datetime.timedelta(minutes=delta)
  baseTime = todaysDate()
  if unit in [u'h', u'm']:
    baseTime = baseTime+datetime.timedelta(hours=GM.Globals[GM.DATETIME_NOW].hour, minutes=GM.Globals[GM.DATETIME_NOW].minute)
  if sign == u'-':
    return baseTime-deltaTime
  return baseTime+deltaTime

DELTA_DATE_PATTERN = re.compile(r'^([+-])(\d+)([dw])$')
DELTA_DATE_FORMAT_REQUIRED = u'(+|-)<Number>(d|w)'
def getDeltaDate(argstr):
  return getDelta(argstr, DELTA_DATE_PATTERN, DELTA_DATE_FORMAT_REQUIRED)

DELTA_TIME_PATTERN = re.compile(r'^([+-])(\d+)([mhdw])$')
DELTA_TIME_FORMAT_REQUIRED = u'(+|-)<Number>(m|h|d|w)'

def getDeltaTime(argstr):
  return getDelta(argstr, DELTA_TIME_PATTERN, DELTA_TIME_FORMAT_REQUIRED)

YYYYMMDD_FORMAT = u'%Y-%m-%d'
YYYYMMDD_FORMAT_REQUIRED = u'yyyy-mm-dd'

def getYYYYMMDD(minLen=1, returnTimeStamp=False, returnDateTime=False, alternateValue=None):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if alternateValue is not None and argstr == alternateValue.upper():
        Cmd.Advance()
        return None
      if argstr in [u'TODAY', u'NOW'] or argstr[0] in [u'+', u'-']:
        if argstr == u'NOW':
          argstr = u'TODAY'
        argstr = getDeltaDate(argstr).strftime(YYYYMMDD_FORMAT)
      try:
        dateTime = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
        Cmd.Advance()
        if returnTimeStamp:
          return time.mktime(dateTime.timetuple())*1000
        if returnDateTime:
          return dateTime
        return argstr
      except ValueError:
        invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
    elif minLen == 0:
      Cmd.Advance()
      return u''
  missingArgumentExit(YYYYMMDD_FORMAT_REQUIRED)

YYYYMMDD_HHMM_FORMAT = u'%Y-%m-%d %H:%M'
YYYYMMDD_HHMM_FORMAT_REQUIRED = u'yyyy-mm-dd hh:mm'
YYYYMMDD_HHMMSS_FORMAT = u'%Y-%m-%d %H:%M:%S'

def getYYYYMMDD_HHMM():
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if argstr in [u'TODAY', u'NOW'] or argstr[0] in [u'+', u'-']:
        argstr = getDeltaTime(argstr).strftime(YYYYMMDD_HHMM_FORMAT)
      argstr = argstr.replace(u'T', u' ')
      try:
        datetime.datetime.strptime(argstr, YYYYMMDD_HHMM_FORMAT)
        Cmd.Advance()
        return argstr
      except ValueError:
        invalidArgumentExit(YYYYMMDD_HHMM_FORMAT_REQUIRED)
  missingArgumentExit(YYYYMMDD_HHMM_FORMAT_REQUIRED)

YYYYMMDD_PATTERN = re.compile(r'^[0-9]{4}-[0-9]{2}-[0-9]{2}$')
YYYYMMDDTHHMMSS_FORMAT_REQUIRED = u'yyyy-mm-ddThh:mm:ss[.fff](Z|(+|-(hh:mm)))'
TIMEZONE_FORMAT_REQUIRED = u'Z|(+|-(hh:mm))'

def getTimeOrDeltaFromNow(returnDateTime=False):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if argstr in [u'TODAY', u'NOW'] or argstr[0] in [u'+', u'-']:
        argstr = ISOformatTimeStamp(getDeltaTime(argstr))
      elif YYYYMMDD_PATTERN.match(argstr):
        try:
          dateTime = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
        except ValueError:
          invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
        argstr = ISOformatTimeStamp(dateTime.replace(tzinfo=GC.Values[GC.TIMEZONE]))
      try:
        fullDateTime, tz = iso8601.parse_date(argstr)
        Cmd.Advance()
        if not returnDateTime:
          return argstr.replace(u' ', u'T')
        return (fullDateTime, tz, argstr.replace(u' ', u'T'))
      except iso8601.ParseError:
        pass
      invalidArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)
  missingArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)

EVENTID_PATTERN = re.compile(r'^[a-v0-9]{5,1024}$')
EVENTID_FORMAT_REQUIRED = u'[a-v0-9]{5,1024}'

def getEventID():
  if Cmd.ArgumentsRemaining():
    tg = EVENTID_PATTERN.match(Cmd.Current().strip())
    if tg:
      Cmd.Advance()
      return tg.group(0)
    invalidArgumentExit(EVENTID_FORMAT_REQUIRED)
  missingArgumentExit(EVENTID_FORMAT_REQUIRED)

EVENT_TIME_FORMAT_REQUIRED = u'allday yyyy-mm-dd | '+YYYYMMDDTHHMMSS_FORMAT_REQUIRED

def getEventTime():
  if Cmd.ArgumentsRemaining():
    if Cmd.Current().strip().lower() == u'allday':
      Cmd.Advance()
      return {u'date': getYYYYMMDD()}
    return {u'dateTime': getTimeOrDeltaFromNow()}
  missingArgumentExit(EVENT_TIME_FORMAT_REQUIRED)

AGE_TIME_PATTERN = re.compile(r'^(\d+)([mhdw])$')
AGE_TIME_FORMAT_REQUIRED = u'<Number>(m|h|d|w)'

def getAgeTime():
  if Cmd.ArgumentsRemaining():
    tg = AGE_TIME_PATTERN.match(Cmd.Current().strip().lower())
    if tg:
      age = int(tg.group(1))
      age_unit = tg.group(2)
      now = int(time.time())
      if age_unit == u'm':
        age = now-(age*SECONDS_PER_MINUTE)
      elif age_unit == u'h':
        age = now-(age*SECONDS_PER_HOUR)
      elif age_unit == u'd':
        age = now-(age*SECONDS_PER_DAY)
      else: # age_unit == u'w':
        age = now-(age*SECONDS_PER_WEEK)
      Cmd.Advance()
      return age*1000
    invalidArgumentExit(AGE_TIME_FORMAT_REQUIRED)
  missingArgumentExit(AGE_TIME_FORMAT_REQUIRED)

CALENDAR_REMINDER_METHODS = [u'email', u'sms', u'popup',]

def getCalendarReminder(allowClearNone=False):
  methods = CALENDAR_REMINDER_METHODS[:]
  if allowClearNone:
    methods += Cmd.CLEAR_NONE_ARGUMENT
  if Cmd.ArgumentsRemaining():
    method = Cmd.Current().strip()
    if not method.isdigit():
      method = getChoice(methods)
      minutes = getInteger(minVal=0, maxVal=40320)
    else:
      minutes = getInteger(minVal=0, maxVal=40320)
      method = getChoice(methods)
    return {u'method': method, u'minutes': minutes}
  missingChoiceExit(methods)

def getCharSet():
  if checkArgumentPresent(u'charset'):
    return getString(Cmd.OB_CHAR_SET)
  return GC.Values[GC.CHARSET]

def getCharacter():
  if Cmd.ArgumentsRemaining():
    argstr = codecs.escape_decode(bytes(Cmd.Current(), UTF8))[0].decode(UTF8)
    if argstr:
      if len(argstr) == 1:
        Cmd.Advance()
        return argstr
      invalidArgumentExit(u'{0} for {1}'.format(integerLimits(1, 1, Msg.STRING_LENGTH), Cmd.OB_CHARACTER))
    emptyArgumentExit(Cmd.OB_CHARACTER)
  missingArgumentExit(Cmd.OB_CHARACTER)

def getDelimiter():
  if not checkArgumentPresent(u'delimiter'):
    return None
  return getCharacter()

def getJSON(deleteFields):
  encoding = getCharSet()
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current()
    try:
      jsonData = json.loads(argstr, encoding=encoding)
      for field in deleteFields:
        jsonData.pop(field, None)
      Cmd.Advance()
      return jsonData
    except (TypeError, ValueError) as e:
      usageErrorExit(str(e))
  missingArgumentExit(Cmd.OB_JSON_DATA)

def getMatchFields(fieldNames):
  matchFields = {}
  while checkArgumentPresent(u'matchfield'):
    matchField = getString(Cmd.OB_FIELD_NAME).strip(u'~')
    if (not matchField) or (matchField not in fieldNames):
      csvFieldErrorExit(matchField, fieldNames, backupArg=True)
    matchFields[matchField] = getREPattern()
  return matchFields

def checkMatchFields(row, matchFields):
  for matchField, matchPattern in iteritems(matchFields):
    if (matchField not in row) or not matchPattern.search(row[matchField]):
      return False
  return True

def checkSubkeyField():
  if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.NO_CSV_FILE_SUBKEYS_SAVED)
  chkSubkeyField = getString(Cmd.OB_FIELD_NAME, checkBlank=True)
  if chkSubkeyField != GM.Globals[GM.CSV_SUBKEY_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.SUBKEY_FIELD_MISMATCH.format(chkSubkeyField, GM.Globals[GM.CSV_SUBKEY_FIELD]))

def checkDataField():
  if not GM.Globals[GM.CSV_DATA_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.NO_CSV_FILE_DATA_SAVED)
  chkDataField = getString(Cmd.OB_FIELD_NAME, checkBlank=True)
  if chkDataField != GM.Globals[GM.CSV_DATA_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.DATA_FIELD_MISMATCH.format(chkDataField, GM.Globals[GM.CSV_DATA_FIELD]))

MAX_MESSAGE_BYTES_PATTERN = re.compile(r'^(\d+)([mkb]?)$')
MAX_MESSAGE_BYTES_FORMAT_REQUIRED = u'<Number>[m|k|b]'

def getMaxMessageBytes():
  if Cmd.ArgumentsRemaining():
    tg = MAX_MESSAGE_BYTES_PATTERN.match(Cmd.Current().strip().lower())
    if tg:
      mmb = int(tg.group(1))
      mmb_unit = tg.group(2)
      if mmb_unit == u'm':
        mmb *= ONE_MEGA_BYTES
      elif mmb_unit == u'k':
        mmb *= ONE_KILO_BYTES
      Cmd.Advance()
      return mmb
    invalidArgumentExit(MAX_MESSAGE_BYTES_FORMAT_REQUIRED)
  missingArgumentExit(MAX_MESSAGE_BYTES_FORMAT_REQUIRED)

# Get domain from email address
def getEmailAddressDomain(emailAddress):
  atLoc = emailAddress.find(u'@')
  if atLoc == -1:
    return GC.Values[GC.DOMAIN].lower()
  return emailAddress[atLoc+1:].lower()

# Get user name from email address
def getEmailAddressUsername(emailAddress):
  atLoc = emailAddress.find(u'@')
  if atLoc == -1:
    return emailAddress.lower()
  return emailAddress[:atLoc].lower()

# Split email address unto user and domain
def splitEmailAddress(emailAddress):
  atLoc = emailAddress.find(u'@')
  if atLoc == -1:
    return (emailAddress.lower(), GC.Values[GC.DOMAIN].lower())
  return (emailAddress[:atLoc].lower(), emailAddress[atLoc+1:].lower())

def formatFileSize(fileSize):
  if fileSize == 0:
    return u'0kb'
  if fileSize < ONE_KILO_BYTES:
    return u'1kb'
  if fileSize < ONE_MEGA_BYTES:
    return u'{0}kb'.format(fileSize//ONE_KILO_BYTES)
  if fileSize < ONE_GIGA_BYTES:
    return u'{0}mb'.format(fileSize//ONE_MEGA_BYTES)
  return u'{0}gb'.format(fileSize//ONE_GIGA_BYTES)

def formatLocalTime(dateTimeStr):
  if dateTimeStr == NEVER_TIME:
    return GC.Values[GC.NEVER_TIME]
  if not GM.Globals[GM.CONVERT_TO_LOCAL_TIME] or not dateTimeStr.endswith(u'Z'):
    return dateTimeStr
  try:
    timestamp, _ = iso8601.parse_date(dateTimeStr)
    return ISOformatTimeStamp(timestamp.astimezone(GC.Values[GC.TIMEZONE]))
  except iso8601.ParseError:
    return dateTimeStr

def formatLocalTimestamp(timestamp):
  return ISOformatTimeStamp(datetime.datetime.fromtimestamp(int(timestamp)//1000, GC.Values[GC.TIMEZONE]))

def formatLocalDatestamp(timestamp):
  return datetime.datetime.fromtimestamp(int(timestamp)//1000, GC.Values[GC.TIMEZONE]).strftime(YYYYMMDD_FORMAT)

def formatMaxMessageBytes(maxMessageBytes):
  if maxMessageBytes < ONE_KILO_BYTES:
    return maxMessageBytes
  if maxMessageBytes < ONE_MEGA_BYTES:
    return u'{0}K'.format(maxMessageBytes//ONE_KILO_BYTES)
  return u'{0}M'.format(maxMessageBytes//ONE_MEGA_BYTES)

def formatMilliSeconds(millis):
  seconds, millis = divmod(millis, 1000)
  minutes, seconds = divmod(seconds, 60)
  hours, minutes = divmod(minutes, 60)
  return u'%02d:%02d:%02d' % (hours, minutes, seconds)

def currentCount(i, count):
  return u' ({0}/{1})'.format(i, count) if (count > GC.Values[GC.SHOW_COUNTS_MIN]) else u''

def currentCountNL(i, count):
  return u' ({0}/{1})\n'.format(i, count) if (count > GC.Values[GC.SHOW_COUNTS_MIN]) else u'\n'

def getPhraseDNEorSNA(email):
  return [Msg.SERVICE_NOT_APPLICABLE, Msg.DOES_NOT_EXIST][getEmailAddressDomain(email) == GC.Values[GC.DOMAIN]]

def formatHTTPError(http_status, reason, message):
  return u'{0}: {1} - {2}'.format(http_status, reason, message)

def getHTTPError(responses, http_status, reason, message):
  if reason in responses:
    return responses[reason]
  return formatHTTPError(http_status, reason, message)

# Warnings
def printWarningMessage(sysRC, errMessage):
  setSysExitRC(sysRC)
  writeStderr(formatKeyValueList(Ind.Spaces(), [WARNING, errMessage], u'\n'))

def badRequestWarning(entityType, itemType, itemValue):
  printWarningMessage(BAD_REQUEST_RC, u'{0} 0 {1}: {2} {3} - {4}'.format(Msg.GOT, Ent.Plural(entityType),
                                                                         Msg.INVALID, Ent.Singular(itemType),
                                                                         itemValue))

def emptyQuery(query, entityType):
  return u'{0} ({1}) {2}'.format(Ent.Singular(Ent.QUERY), query, Msg.NO_ENTITIES_FOUND.format(Ent.Plural(entityType)))

def invalidQuery(query):
  return u'{0} ({1}) {2}'.format(Ent.Singular(Ent.QUERY), query, Msg.INVALID)

def invalidUserSchema(schema):
  if isinstance(schema, list):
    return u'{0} ({1}) {2}'.format(Ent.Singular(Ent.USER_SCHEMA), u','.join(schema), Msg.INVALID)
  return u'{0} ({1}) {2}'.format(Ent.Singular(Ent.USER_SCHEMA), schema, Msg.INVALID)

def entityServiceNotApplicableWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(SERVICE_NOT_APPLICABLE_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(entityType), entityName, Msg.SERVICE_NOT_APPLICABLE],
                                 currentCountNL(i, count)))

def entityDoesNotExistWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(entityType), entityName, Msg.DOES_NOT_EXIST],
                                 currentCountNL(i, count)))

def entityUnknownWarning(entityType, entityName, i=0, count=0):
  domain = getEmailAddressDomain(entityName)
  if (domain == GC.Values[GC.DOMAIN]) or (domain.endswith(u'google.com')):
    entityDoesNotExistWarning(entityType, entityName, i, count)
  else:
    entityServiceNotApplicableWarning(entityType, entityName, i, count)

def entityOrEntityUnknownWarning(entity1Type, entity1Name, entity2Type, entity2Name, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [u'{0} {1}'.format(Msg.EITHER, Ent.Singular(entity1Type)), entity1Name, getPhraseDNEorSNA(entity1Name), None,
                                  u'{0} {1}'.format(Msg.OR, Ent.Singular(entity2Type)), entity2Name, getPhraseDNEorSNA(entity2Name)],
                                 currentCountNL(i, count)))

def entityDoesNotHaveItemWarning(entityValueList, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Msg.DOES_NOT_EXIST],
                                 currentCountNL(i, count)))

def entityDuplicateWarning(entityValueList, i=0, count=0):
  setSysExitRC(ENTITY_DUPLICATE_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.Failed(), Msg.DUPLICATE],
                                 currentCountNL(i, count)))

def entityActionFailedWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(AC_FAILED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityModifierNewValueActionFailedWarning(entityValueList, modifier, newValue, errMessage, i=0, count=0):
  setSysExitRC(AC_FAILED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1}'.format(Act.ToPerform(), modifier), newValue, Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityNumEntitiesActionFailedWarning(entityType, entityName, itemType, itemCount, errMessage, i=0, count=0):
  setSysExitRC(AC_FAILED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(entityType), entityName,
                                  Ent.Choose(itemType, itemCount), itemCount,
                                  Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityActionNotPerformedWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(AC_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityNumEntitiesActionNotPerformedWarning(entityValueList, itemType, itemCount, errMessage, i=0, count=0):
  setSysExitRC(AC_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Ent.Choose(itemType, itemCount), itemCount, Act.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityBadRequestWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(BAD_REQUEST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[ERROR, errMessage],
                                 currentCountNL(i, count)))

def userSvcNotApplicableOrDriveDisabled(user, errMessage, i=0, count=0):
  if errMessage.find(u'Drive apps') == -1:
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  else:
    entityActionNotPerformedWarning([Ent.USER, user], errMessage, i, count)

# Getting ... utilities
def printGettingAllAccountEntities(entityType, query=u''):
  if GC.Values[GC.SHOW_GETTINGS]:
    if query:
      Ent.SetGettingQuery(entityType, query)
    else:
      Ent.SetGetting(entityType)
    writeStderr(convertUTF8(u'{0} {1}{2}{3}\n'.format(Msg.GETTING_ALL, Ent.PluralGetting(), Ent.GettingPreQualifier(), Ent.MayTakeTime(Ent.ACCOUNT))))

def printGotAccountEntities(count):
  if GC.Values[GC.SHOW_GETTINGS]:
    writeStderr(convertUTF8(u'{0} {1} {2}{3}\n'.format(Msg.GOT, count, Ent.ChooseGetting(count), Ent.GettingPostQualifier())))

def printGettingAllEntityItemsForWhom(entityItem, forWhom, i=0, count=0, query=u'', qualifier=u'', entityType=None):
  if GC.Values[GC.SHOW_GETTINGS]:
    if query:
      Ent.SetGettingQuery(entityItem, query)
    elif qualifier:
      Ent.SetGettingQualifier(entityItem, qualifier)
    else:
      Ent.SetGetting(entityItem)
    Ent.SetGettingForWhom(forWhom)
    writeStderr(convertUTF8(u'{0} {1}{2} {3} {4}{5}{6}'.format(Msg.GETTING_ALL, Ent.PluralGetting(), Ent.GettingPreQualifier(), Msg.FOR, forWhom, Ent.MayTakeTime(entityType), currentCountNL(i, count))))

def printGotEntityItemsForWhom(count):
  if GC.Values[GC.SHOW_GETTINGS]:
    writeStderr(convertUTF8(u'{0} {1} {2}{3} {4} {5}\n'.format(Msg.GOT, count, Ent.ChooseGetting(count), Ent.GettingPostQualifier(), Msg.FOR, Ent.GettingForWhom())))

def printGettingEntityItem(entityType, entityItem, i=0, count=0):
  if GC.Values[GC.SHOW_GETTINGS]:
    writeStderr(convertUTF8(u'{0} {1} {2}{3}'.format(Msg.GETTING, Ent.Singular(entityType), entityItem, currentCountNL(i, count))))

def printGettingEntityItemForWhom(entityItem, forWhom, i=0, count=0):
  if GC.Values[GC.SHOW_GETTINGS]:
    Ent.SetGetting(entityItem)
    Ent.SetGettingForWhom(forWhom)
    writeStderr(convertUTF8(u'{0} {1} {2} {3}{4}'.format(Msg.GETTING, Ent.PluralGetting(), Msg.FOR, forWhom, currentCountNL(i, count))))

FIRST_ITEM_MARKER = u'%%first_item%%'
LAST_ITEM_MARKER = u'%%last_item%%'
NUM_ITEMS_MARKER = u'%%num_items%%'
TOTAL_ITEMS_MARKER = u'%%total_items%%'

def getPageMessage(showTotal=True, showFirstLastItems=False, noNL=False):
  if not GC.Values[GC.SHOW_GETTINGS]:
    return None
  Ent.SetGettingShowTotal(showTotal)
  pageMessage = u'{0} {1} {{0}}'.format(Msg.GOT, [NUM_ITEMS_MARKER, TOTAL_ITEMS_MARKER][showTotal])
  if showFirstLastItems:
    pageMessage += u': {0} - {1}'.format(FIRST_ITEM_MARKER, LAST_ITEM_MARKER)
  else:
    pageMessage += u'...'
  if not noNL:
    pageMessage += u'\n'
  return pageMessage

def getPageMessageForWhom(forWhom=None, showTotal=True, showFirstLastItems=False, noNL=False):
  if not GC.Values[GC.SHOW_GETTINGS]:
    return None
  Ent.SetGettingShowTotal(showTotal)
  if forWhom:
    Ent.SetGettingForWhom(forWhom)
  pageMessage = u'{0} {1} {{0}} {2} {3}'.format(Msg.GOT, [NUM_ITEMS_MARKER, TOTAL_ITEMS_MARKER][showTotal], Msg.FOR, Ent.GettingForWhom())
  if showFirstLastItems:
    pageMessage += u': {0} - {1}'.format(FIRST_ITEM_MARKER, LAST_ITEM_MARKER)
  else:
    pageMessage += u'...'
  if not noNL:
    pageMessage += u'\n'
  return pageMessage

def printLine(message):
  writeStdout(convertUTF8(message+u'\n'))

def printBlankLine():
  writeStdout(u'\n')

def printKeyValueList(kvList):
  writeStdout(formatKeyValueList(Ind.Spaces(), kvList, u'\n'))

def printKeyValueListWithCount(kvList, i, count):
  writeStdout(formatKeyValueList(Ind.Spaces(), kvList, currentCountNL(i, count)))

def printKeyValueDict(kvDict):
  for key, value in iteritems(kvDict):
    writeStdout(formatKeyValueList(Ind.Spaces(), [key, value], u'\n'))

def printKeyValueWithCRsNLs(key, value):
  if value.find(u'\n') >= 0 or value.find(u'\r') >= 0:
    if GC.Values[GC.SHOW_CONVERT_CR_NL]:
      printKeyValueList([key, escapeCRsNLs(value)])
    else:
      printKeyValueList([key, u''])
      Ind.Increment()
      printKeyValueList([Ind.MultiLineText(value)])
      Ind.Decrement()
  else:
    printKeyValueList([key, value])

def printJSONKey(key):
  writeStdout(formatKeyValueList(Ind.Spaces(), [key, None], u''))

def printJSONValue(value):
  writeStdout(formatKeyValueList(u' ', [value], u'\n'))

def printEntity(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList),
                                 currentCountNL(i, count)))

def printEntitiesCount(entityType, entityList):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Plural(entityType), None if entityList is None else u'({0})'.format(len(entityList))],
                                 u'\n'))

def printEntityKVList(entityValueList, infoKVList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+infoKVList,
                                 currentCountNL(i, count)))

def performActionNumItems(itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [u'{0} {1} {2}'.format(Act.ToPerform(), itemCount, Ent.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def performActionModifierNumItems(modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [u'{0} {1} {2} {3}'.format(Act.ToPerform(), modifier, itemCount, Ent.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionNumItems(entityValueList, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1} {2}'.format(Act.ToPerform(), itemCount, Ent.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNumItems(entityValueList, modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1} {2} {3}'.format(Act.ToPerform(), modifier, itemCount, Ent.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionNumItemsModifier(entityValueList, itemCount, itemType, modifier, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1} {2} {3}'.format(Act.ToPerform(), itemCount, Ent.Choose(itemType, itemCount), modifier)],
                                 currentCountNL(i, count)))

def entityPerformActionSubItemModifierNumItems(entityValueList, subitemType, modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1} {2} {3} {4}'.format(Act.ToPerform(), Ent.Plural(subitemType),
                                                                                                           modifier, itemCount, Ent.Choose(itemType, itemCount))],
                                 currentCountNL(i, count)))

def entityPerformActionSubItemModifierNumItemsModifierNewValue(entityValueList, subitemType, modifier1, itemCount, itemType, modifier2, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1} {2} {3} {4} {5}'.format(Act.ToPerform(), Ent.Plural(subitemType),
                                                                                                               modifier1, itemCount, Ent.Choose(itemType, itemCount), modifier2), newValue],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNumItemsModifier(entityValueList, modifier1, itemCount, itemType, modifier2, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1} {2} {3} {4}'.format(Act.ToPerform(), modifier1, itemCount, Ent.Choose(itemType, itemCount), modifier2)],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNewValue(entityValueList, modifier, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1}'.format(Act.ToPerform(), modifier), newValue],
                                 currentCountNL(i, count)))

def entityPerformActionItemValue(entityValueList, itemType, itemValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.ToPerform(), None, Ent.Singular(itemType), itemValue],
                                 currentCountNL(i, count)))

def entityPerformActionInfo(entityValueList, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.ToPerform(), infoValue],
                                 currentCountNL(i, count)))

def entityActionPerformed(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.Performed()],
                                 currentCountNL(i, count)))

def entityActionPerformedMessage(entityValueList, message, i=0, count=0):
  if message:
    writeStdout(formatKeyValueList(Ind.Spaces(),
                                   Ent.FormatEntityValueList(entityValueList)+[Act.Performed(), message],
                                   currentCountNL(i, count)))
  else:
    writeStdout(formatKeyValueList(Ind.Spaces(),
                                   Ent.FormatEntityValueList(entityValueList)+[Act.Performed()],
                                   currentCountNL(i, count)))

def entityModifierNewValueActionPerformed(entityValueList, modifier, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1}'.format(Act.Performed(), modifier), newValue],
                                 currentCountNL(i, count)))

def entityModifierNewValueItemValueListActionPerformed(entityValueList, modifier, newValue, infoTypeValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1}'.format(Act.Performed(), modifier), newValue]+Ent.FormatEntityValueList(infoTypeValueList),
                                 currentCountNL(i, count)))

def entityModifierNewValueKeyValueActionPerformed(entityValueList, modifier, newValue, infoKey, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[u'{0} {1}'.format(Act.Performed(), modifier), newValue, infoKey, infoValue],
                                 currentCountNL(i, count)))

def cleanFilename(filename):
  for ch in u'\\/:':
    filename = filename.replace(ch, u'_')
  return filename

# Open a file
def openFile(filename, mode=u'rU', encoding=GM.Globals[GM.SYS_ENCODING], continueOnError=False, displayError=True):
  try:
    if filename != u'-':
      if mode.endswith(u'b'):
        return open(os.path.expanduser(filename), mode)
      return open(os.path.expanduser(filename), mode, encoding=encoding)
    if mode.startswith(u'r'):
      return StringIOobject(text_type(sys.stdin.read()))
    return sys.stdout
  except IOError as e:
    if continueOnError:
      if displayError:
        stderrWarningMsg(e)
        setSysExitRC(FILE_ERROR_RC)
      return None
    systemErrorExit(FILE_ERROR_RC, e)

# Close a file
def closeFile(f):
  try:
    f.close()
    return True
  except IOError as e:
    stderrErrorMsg(e)
    setSysExitRC(FILE_ERROR_RC)
    return False

# Read a file
def readFile(filename, mode=u'rU', continueOnError=False, displayError=True, encoding=None):
  try:
    if filename != u'-':
      if not encoding:
        with open(os.path.expanduser(filename), mode, encoding=GM.Globals[GM.SYS_ENCODING]) as f:
          return f.read()
      with codecs.open(os.path.expanduser(filename), mode, encoding=encoding) as f:
        content = f.read()
# codecs does not strip UTF-8 BOM (ef:bb:bf) so we must
        if not content.startswith(codecs.BOM_UTF8.decode()):
          return content
        return content[3:]
    return text_type(sys.stdin.read())
  except IOError as e:
    if continueOnError:
      if displayError:
        stderrWarningMsg(e)
        setSysExitRC(FILE_ERROR_RC)
      return None
    systemErrorExit(FILE_ERROR_RC, e)
  except (LookupError, UnicodeDecodeError, UnicodeError) as e:
    Cmd.Backup()
    usageErrorExit(e)

# Write a file
def writeFile(filename, data, mode=DEFAULT_FILE_WRITE_MODE, continueOnError=False, displayError=True):
  try:
    with open(os.path.expanduser(filename), mode, encoding=GM.Globals[GM.SYS_ENCODING]) as f:
      f.write(data)
    return True
  except IOError as e:
    if continueOnError:
      if displayError:
        stderrErrorMsg(e)
      setSysExitRC(FILE_ERROR_RC)
      return False
    systemErrorExit(FILE_ERROR_RC, e)

# Write a file, return error
def writeFileReturnError(filename, data, mode=DEFAULT_FILE_WRITE_MODE):
  try:
    with open(os.path.expanduser(filename), mode, encoding=GM.Globals[GM.SYS_ENCODING]) as f:
      f.write(data)
    return (True, None)
  except IOError as e:
    return (False, e)

# Delete a file
def deleteFile(filename, continueOnError=False, displayError=True):
  if os.path.isfile(filename):
    try:
      os.remove(filename)
    except OSError as e:
      if continueOnError:
        if displayError:
          stderrWarningMsg(e)
        return
      systemErrorExit(FILE_ERROR_RC, e)

# Open a CSV file, get optional arguments [charset <String>] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
def openCSVFileReader(filename):
  encoding = getCharSet()
  if checkArgumentPresent(u'columndelimiter'):
    delimiter = getCharacter()
  else:
    delimiter = GC.Values[GC.CSV_INPUT_COLUMN_DELIMITER]
  if checkArgumentPresent(u'quotechar'):
    quotechar = getCharacter()
  else:
    quotechar = GC.Values[GC.CSV_INPUT_QUOTE_CHAR]
  if checkArgumentPresent(u'fields'):
    fieldnames = shlexSplitList(getString(Cmd.OB_FIELD_NAME_LIST))
  else:
    fieldnames = None
  f = openFile(filename, mode=DEFAULT_CSV_READ_MODE, encoding=encoding)
  csvFile = csv.DictReader(f, fieldnames=fieldnames, delimiter=delimiter, quotechar=quotechar)
  return (f, csvFile)

# Set global variables from config file
# Check for GAM updates based on status of no_update_check in config file
# Return True if there are additional commands on the command line
def SetGlobalVariables():

  def _stringInQuotes(value):
    return (len(value) > 1) and (((value.startswith(u'"') and value.endswith(u'"'))) or ((value.startswith(u"'") and value.endswith(u"'"))))

  def _stripStringQuotes(value):
    if _stringInQuotes(value):
      return value[1:-1]
    return value

  def _quoteStringIfLeadingTrailingBlanks(value):
    if not value:
      return u"''"
    if _stringInQuotes(value):
      return value
    if (value[0] != u' ') and (value[-1] != u' '):
      return value
    return u"'{0}'".format(value)

  def _getDefault(itemName, itemEntry, oldGamPath):
    if GC.VAR_SIGFILE in itemEntry:
      GC.Defaults[itemName] = itemEntry[GC.VAR_SFFT][os.path.isfile(os.path.join(oldGamPath, itemEntry[GC.VAR_SIGFILE]))]
    elif GC.VAR_ENVVAR in itemEntry:
      value = os.environ.get(itemEntry[GC.VAR_ENVVAR], GC.Defaults[itemName])
      if itemEntry[GC.VAR_TYPE] == GC.TYPE_INTEGER:
        try:
          number = int(value)
          minVal, maxVal = itemEntry[GC.VAR_LIMITS]
          if (minVal is not None) and (number < minVal):
            number = minVal
          elif (maxVal is not None) and (number > maxVal):
            number = maxVal
        except ValueError:
          number = GC.Defaults[itemName]
        value = str(number)
      elif itemEntry[GC.VAR_TYPE] == GC.TYPE_STRING:
        value = _quoteStringIfLeadingTrailingBlanks(value)
      GC.Defaults[itemName] = value

  def _selectSection():
    value = getString(Cmd.OB_SECTION_NAME, minLen=0)
    if (not value) or (value.upper() == configparser.DEFAULTSECT):
      return configparser.DEFAULTSECT
    if GM.Globals[GM.PARSER].has_section(value):
      return value
    Cmd.Backup()
    usageErrorExit(formatKeyValueList(u'', [Ent.Singular(Ent.SECTION), value, Msg.NOT_FOUND], u''))

  def _checkMakeDir(itemName):
    if not os.path.isdir(GC.Defaults[itemName]):
      try:
        os.makedirs(GC.Defaults[itemName])
        printKeyValueList([Act.PerformedName(Act.CREATE), GC.Defaults[itemName]])
      except OSError as e:
        if not os.path.isdir(GC.Defaults[itemName]):
          systemErrorExit(FILE_ERROR_RC, e)

  def _copyCfgFile(srcFile, targetDir, oldGamPath):
    if (not srcFile) or os.path.isabs(srcFile):
      return
    dstFile = os.path.join(GC.Defaults[targetDir], srcFile)
    if os.path.isfile(dstFile):
      return
    srcFile = os.path.join(oldGamPath, srcFile)
    if not os.path.isfile(srcFile):
      return
    data = readFile(srcFile, continueOnError=True, displayError=False)
    if (data is not None) and writeFile(dstFile, data, continueOnError=True):
      printKeyValueList([Act.PerformedName(Act.COPY), srcFile, Msg.TO, dstFile])

  def _printValueError(sectionName, itemName, value, errMessage):
    printErrorMessage(CONFIG_ERROR_RC,
                      formatKeyValueList(u'',
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), value,
                                          errMessage],
                                         u''))

  def _getCfgBoolean(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName).lower()
    if value in TRUE_VALUES:
      return True
    if value in FALSE_VALUES:
      return False
    _printValueError(sectionName, itemName, value, u'{0}: {1}'.format(Msg.EXPECTED, formatChoiceList(TRUE_FALSE)))
    status[u'errors'] = True
    return False

  def _getCfgCharacter(sectionName, itemName):
    value = codecs.escape_decode(bytes(_stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)), UTF8))[0].decode(UTF8)
    if (len(value) == 0) and (itemName == u'csv_output_field_delimiter'):
      return u' '
    if len(value) == 1:
      return value
    _printValueError(sectionName, itemName, u'"{0}"'.format(value), u'{0}: {1}'.format(Msg.EXPECTED, integerLimits(1, 1, Msg.STRING_LENGTH)))
    status[u'errors'] = True
    return u''

  def _getCfgChoice(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName))
    choices = GC.VAR_INFO[itemName][GC.VAR_CHOICES]
    if value in choices:
      return choices[value]
    _printValueError(sectionName, itemName, u'"{0}"'.format(value), u'{0}: {1}'.format(Msg.EXPECTED, u','.join(choices)))
    status[u'errors'] = True
    return u''

  def _getCfgInteger(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName)
    minVal, maxVal = GC.VAR_INFO[itemName][GC.VAR_LIMITS]
    try:
      number = int(value)
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        return number
    except ValueError:
      pass
    _printValueError(sectionName, itemName, value, u'{0}: {1}'.format(Msg.EXPECTED, integerLimits(minVal, maxVal)))
    status[u'errors'] = True
    return 0

  def _getCfgSection(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName))
    if (not value) or (value.upper() == configparser.DEFAULTSECT):
      return configparser.DEFAULTSECT
    if GM.Globals[GM.PARSER].has_section(value):
      return value
    _printValueError(sectionName, itemName, value, Msg.NOT_FOUND)
    status[u'errors'] = True
    return configparser.DEFAULTSECT

  def _getCfgString(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName))
    minLen, maxLen = GC.VAR_INFO[itemName].get(GC.VAR_LIMITS, (None, None))
    if ((minLen is None) or (len(value) >= minLen)) and ((maxLen is None) or (len(value) <= maxLen)):
      return value
    _printValueError(sectionName, itemName, u'"{0}"'.format(value), u'{0}: {1}'.format(Msg.EXPECTED, integerLimits(minLen, maxLen, Msg.STRING_LENGTH)))
    status[u'errors'] = True
    return u''

  def _getCfgTimezone(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName).lower())
    if value == u'utc':
      GM.Globals[GM.CONVERT_TO_LOCAL_TIME] = False
      return iso8601.UTC
    GM.Globals[GM.CONVERT_TO_LOCAL_TIME] = True
    if value == u'local':
      return iso8601.Local
    try:
      return iso8601.parse_timezone_str(value)
    except iso8601.ParseError:
      pass
    _printValueError(sectionName, itemName, value, u'{0}: {1}'.format(Msg.EXPECTED, TIMEZONE_FORMAT_REQUIRED))
    status[u'errors'] = True
    return u''

  def _getCfgDirectory(sectionName, itemName):
    dirPath = os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)))
    if (not dirPath) or (not os.path.isabs(dirPath)):
      if (sectionName != configparser.DEFAULTSECT) and (GM.Globals[GM.PARSER].has_option(sectionName, itemName)):
        dirPath = os.path.join(os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(configparser.DEFAULTSECT, itemName))), dirPath)
      if not os.path.isabs(dirPath):
        dirPath = os.path.join(GM.Globals[GM.GAM_CFG_PATH], dirPath)
    return dirPath

  def _getCfgFile(sectionName, itemName):
    value = os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)))
    if value and not os.path.isabs(value):
      value = os.path.expanduser(os.path.join(_getCfgDirectory(sectionName, GC.CONFIG_DIR), value))
    elif not value and itemName == GC.CACERTS_PEM:
      if hasattr(sys, u'_MEIPASS'):
        value = os.path.join(sys._MEIPASS, GC.FN_CACERTS_PEM)
      else:
        value = os.path.join(GM.Globals[GM.GAM_PATH], GC.FN_CACERTS_PEM)
    return value

  def _readGamCfgFile(config, fileName):
    try:
      with open(fileName, u'rU') as f:
        config.readfp(f)
    except (configparser.MissingSectionHeaderError, configparser.ParsingError) as e:
      systemErrorExit(CONFIG_ERROR_RC, formatKeyValueList(u'',
                                                          [Ent.Singular(Ent.CONFIG_FILE), fileName,
                                                           Msg.INVALID, str(e)],
                                                          u''))
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, e)

  def _writeGamCfgFile(config, fileName, action):
    try:
      with open(fileName, DEFAULT_FILE_WRITE_MODE) as f:
        config.write(f)
      printKeyValueList([Ent.Singular(Ent.CONFIG_FILE), fileName, Act.PerformedName(action)])
    except IOError as e:
      stderrErrorMsg(e)

  def _verifyValues(sectionName):
    printKeyValueList([Ent.Singular(Ent.SECTION), sectionName]) # Do not use printEntity
    Ind.Increment()
    for itemName in sorted(GC.VAR_INFO):
      cfgValue = GM.Globals[GM.PARSER].get(sectionName, itemName)
      varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
      if varType == GC.TYPE_CHOICE:
        for choice, value in iteritems(GC.VAR_INFO[itemName][GC.VAR_CHOICES]):
          if cfgValue == value:
            cfgValue = choice
            break
      elif varType not in [GC.TYPE_BOOLEAN, GC.TYPE_INTEGER]:
        cfgValue = _quoteStringIfLeadingTrailingBlanks(cfgValue)
      if varType == GC.TYPE_FILE:
        expdValue = _getCfgFile(sectionName, itemName)
        if cfgValue != u"''" and cfgValue != expdValue:
          cfgValue = u'{0} ; {1}'.format(cfgValue, expdValue)
      elif varType == GC.TYPE_DIRECTORY:
        expdValue = _getCfgDirectory(sectionName, itemName)
        if cfgValue != u"''" and cfgValue != expdValue:
          cfgValue = u'{0} ; {1}'.format(cfgValue, expdValue)
      elif (itemName == GC.SECTION) and (sectionName != configparser.DEFAULTSECT):
        continue
      printLine(u'{0}{1} = {2}'.format(Ind.Spaces(), itemName, cfgValue))
    Ind.Decrement()

  def _chkCfgDirectories(sectionName):
    for itemName in GC.VAR_INFO:
      if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_DIRECTORY:
        dirPath = GC.Values[itemName]
        if (itemName != GC.CACHE_DIR or not GC.Values[GC.NO_CACHE]) and not os.path.isdir(dirPath):
          writeStderr(formatKeyValueList(WARNING_PREFIX,
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), dirPath,
                                          Msg.INVALID_PATH],
                                         u'\n'))

  def _chkCfgFiles(sectionName):
    for itemName in GC.VAR_INFO:
      if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_FILE:
        fileName = GC.Values[itemName]
        if (not fileName) and (itemName == GC.EXTRA_ARGS):
          continue
        if not os.path.isfile(fileName):
          writeStderr(formatKeyValueList([WARNING_PREFIX, ERROR_PREFIX][itemName == GC.CACERTS_PEM],
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), fileName,
                                          Msg.NOT_FOUND],
                                         u'\n'))
          if itemName == GC.CACERTS_PEM:
            status[u'errors'] = True
        elif not os.access(fileName, GC.VAR_INFO[itemName][GC.VAR_ACCESS]):
          writeStderr(formatKeyValueList(ERROR_PREFIX,
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), fileName,
                                          [Msg.NEED_READ_ACCESS, Msg.NEED_READ_WRITE_ACCESS][GC.VAR_INFO[itemName][GC.VAR_ACCESS] == os.R_OK | os.W_OK]],
                                         u'\n'))
          status[u'errors'] = True

  def _setCSVFile(filename, mode, encoding, writeHeader, multi):
    if filename != u'-':
      if filename.startswith(u'./') or filename.startswith(u'.\\'):
        filename = os.path.join(os.getcwd(), filename[2:])
      else:
        filename = os.path.expanduser(filename)
      if not os.path.isabs(filename):
        filename = os.path.join(GC.Values[GC.DRIVE_DIR], filename)
    GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME] = filename
    GM.Globals[GM.CSVFILE][GM.REDIRECT_MODE] = mode
    GM.Globals[GM.CSVFILE][GM.REDIRECT_ENCODING] = encoding
    GM.Globals[GM.CSVFILE][GM.REDIRECT_COLUMN_DELIMITER] = GC.Values[GC.CSV_OUTPUT_COLUMN_DELIMITER]
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUOTE_CHAR] = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
    GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER] = writeHeader
    GM.Globals[GM.CSVFILE][GM.REDIRECT_MULTIPROCESS] = multi
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = None

  def _setSTDFile(stdtype, filename, mode, multi):
    if stdtype == GM.STDOUT:
      GM.Globals[GM.SAVED_STDOUT] = None
    if filename == u'null':
      GM.Globals[stdtype][GM.REDIRECT_FD] = open(os.devnull, mode)
    elif filename == u'-':
      GM.Globals[stdtype][GM.REDIRECT_FD] = os.fdopen(os.dup([sys.stderr.fileno(), sys.stdout.fileno()][stdtype == GM.STDOUT]), mode, encoding=GM.Globals[GM.SYS_ENCODING])
    else:
      if filename.startswith(u'./') or filename.startswith(u'.\\'):
        filename = os.path.join(os.getcwd(), filename[2:])
      else:
        filename = os.path.expanduser(filename)
      if not os.path.isabs(filename):
        filename = os.path.join(GC.Values[GC.DRIVE_DIR], filename)
      if multi and mode == DEFAULT_FILE_WRITE_MODE:
        deleteFile(filename)
        mode = DEFAULT_FILE_APPEND_MODE
      GM.Globals[stdtype][GM.REDIRECT_FD] = openFile(filename, mode)
    GM.Globals[stdtype][GM.REDIRECT_MULTI_FD] = GM.Globals[stdtype][GM.REDIRECT_FD] if not multi else StringIOobject()
    if (stdtype == GM.STDOUT) and (GC.Values[GC.DEBUG_LEVEL] > 0):
      GM.Globals[GM.SAVED_STDOUT] = sys.stdout
      sys.stdout = GM.Globals[stdtype][GM.REDIRECT_MULTI_FD]
    GM.Globals[stdtype][GM.REDIRECT_NAME] = filename
    GM.Globals[stdtype][GM.REDIRECT_MODE] = mode
    GM.Globals[stdtype][GM.REDIRECT_MULTIPROCESS] = multi
    GM.Globals[stdtype][GM.REDIRECT_QUEUE] = [u'stderr', u'stdout'][stdtype == GM.STDOUT]

  if not GM.Globals[GM.PARSER]:
    homePath = os.path.expanduser(u'~')
    GM.Globals[GM.GAM_CFG_PATH] = os.environ.get(u'GAMCFGDIR', None)
    if GM.Globals[GM.GAM_CFG_PATH]:
      GM.Globals[GM.GAM_CFG_PATH] = os.path.expanduser(GM.Globals[GM.GAM_CFG_PATH])
    else:
      GM.Globals[GM.GAM_CFG_PATH] = os.path.join(homePath, u'.gam')
    GC.Defaults[GC.CONFIG_DIR] = GM.Globals[GM.GAM_CFG_PATH]
    GC.Defaults[GC.CACHE_DIR] = os.path.join(GM.Globals[GM.GAM_CFG_PATH], u'gamcache')
    GC.Defaults[GC.DRIVE_DIR] = os.path.join(homePath, u'Downloads')
    GM.Globals[GM.GAM_CFG_FILE] = os.path.join(GM.Globals[GM.GAM_CFG_PATH], FN_GAM_CFG)
    if not os.path.isfile(GM.Globals[GM.GAM_CFG_FILE]):
      for itemName, itemEntry in iteritems(GC.VAR_INFO):
        if itemEntry[GC.VAR_TYPE] == GC.TYPE_DIRECTORY:
          _getDefault(itemName, itemEntry, None)
      oldGamPath = os.environ.get(u'OLDGAMPATH', GC.Defaults[GC.CONFIG_DIR])
      for itemName, itemEntry in iteritems(GC.VAR_INFO):
        if itemEntry[GC.VAR_TYPE] != GC.TYPE_DIRECTORY:
          _getDefault(itemName, itemEntry, oldGamPath)
      GM.Globals[GM.PARSER] = configparser.RawConfigParser(defaults=collections.OrderedDict(sorted(list(GC.Defaults.items()), key=lambda t: t[0])))
      _checkMakeDir(GC.CONFIG_DIR)
      _checkMakeDir(GC.CACHE_DIR)
      _checkMakeDir(GC.DRIVE_DIR)
      for itemName in GC.VAR_INFO:
        if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_FILE:
          srcFile = os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(configparser.DEFAULTSECT, itemName)))
          _copyCfgFile(srcFile, GC.CONFIG_DIR, oldGamPath)
      _writeGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE], Act.INITIALIZE)
    else:
      GM.Globals[GM.PARSER] = configparser.RawConfigParser(defaults=collections.OrderedDict(sorted(list(GC.Defaults.items()), key=lambda t: t[0])))
      _readGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE])
    GM.Globals[GM.LAST_UPDATE_CHECK_TXT] = os.path.join(_getCfgDirectory(configparser.DEFAULTSECT, GC.CONFIG_DIR), FN_LAST_UPDATE_CHECK_TXT)
  status = {u'errors': False}
  sectionName = _getCfgSection(configparser.DEFAULTSECT, GC.SECTION)
# select <SectionName> [save] [verify]
  if checkArgumentPresent(Cmd.SELECT_CMD):
    sectionName = _selectSection()
    while Cmd.ArgumentsRemaining():
      if checkArgumentPresent(u'save'):
        GM.Globals[GM.PARSER].set(configparser.DEFAULTSECT, GC.SECTION, sectionName)
        _writeGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE], Act.SAVE)
      elif checkArgumentPresent(u'verify'):
        _verifyValues(sectionName)
      else:
        break
# config (<VariableName> [=] <Value>)* [save] [verify]
  if checkArgumentPresent(Cmd.CONFIG_CMD):
    while Cmd.ArgumentsRemaining():
      if checkArgumentPresent(u'save'):
        _writeGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE], Act.SAVE)
      elif checkArgumentPresent(u'verify'):
        _verifyValues(sectionName)
      else:
        itemName = getChoice(GC.VAR_INFO, defaultChoice=None)
        if itemName is None:
          break
        checkArgumentPresent(u'=')
        varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
        if varType == GC.TYPE_BOOLEAN:
          value = [FALSE, TRUE][getBoolean()]
        elif varType == GC.TYPE_CHARACTER:
          value = getCharacter()
        elif varType == GC.TYPE_CHOICE:
          value = getChoice(GC.VAR_INFO[itemName][GC.VAR_CHOICES])
        elif varType == GC.TYPE_INTEGER:
          minVal, maxVal = GC.VAR_INFO[itemName][GC.VAR_LIMITS]
          value = text_type(getInteger(minVal=minVal, maxVal=maxVal))
        elif varType == GC.TYPE_TIMEZONE:
          value = getString(Cmd.OB_STRING, checkBlank=True)
        else:
          minLen, maxLen = GC.VAR_INFO[itemName].get(GC.VAR_LIMITS, (0, None))
          value = _quoteStringIfLeadingTrailingBlanks(getString(Cmd.OB_STRING, minLen=minLen, maxLen=maxLen))
        GM.Globals[GM.PARSER].set(sectionName, itemName, value)
  prevExtraArgsTxt = GC.Values.get(GC.EXTRA_ARGS, None)
  prevOauth2serviceJson = GC.Values.get(GC.OAUTH2SERVICE_JSON, None)
# Assign global variables, directories first as other variables depend on them
  for itemName in GC.VAR_INFO:
    if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_DIRECTORY:
      GC.Values[itemName] = _getCfgDirectory(sectionName, itemName)
# Everything else
  for itemName in GC.VAR_INFO:
    varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
    if varType == GC.TYPE_BOOLEAN:
      GC.Values[itemName] = _getCfgBoolean(sectionName, itemName)
    elif varType == GC.TYPE_CHARACTER:
      GC.Values[itemName] = _getCfgCharacter(sectionName, itemName)
    elif varType == GC.TYPE_CHOICE:
      GC.Values[itemName] = _getCfgChoice(sectionName, itemName)
    elif varType == GC.TYPE_INTEGER:
      GC.Values[itemName] = _getCfgInteger(sectionName, itemName)
    elif varType == GC.TYPE_STRING:
      GC.Values[itemName] = _getCfgString(sectionName, itemName)
    elif varType == GC.TYPE_TIMEZONE:
      GC.Values[itemName] = _getCfgTimezone(sectionName, itemName)
    elif varType == GC.TYPE_FILE:
      GC.Values[itemName] = _getCfgFile(sectionName, itemName)
  if status[u'errors']:
    sys.exit(CONFIG_ERROR_RC)
  GC.Values[GC.DOMAIN] = GC.Values[GC.DOMAIN].lower()
# Create/set mode for oauth2.txt.lock
  if not GM.Globals[GM.OAUTH2_TXT_LOCK]:
    fileName = u'{0}.lock'.format(GC.Values[GC.OAUTH2_TXT])
    if not os.path.isfile(fileName):
      closeFile(openFile(fileName, mode=DEFAULT_FILE_APPEND_MODE))
      os.chmod(fileName, 0o666)
    GM.Globals[GM.OAUTH2_TXT_LOCK] = fileName
# Reset global variables if required
  httplib2.debuglevel = GC.Values[GC.DEBUG_LEVEL]
  if prevExtraArgsTxt != GC.Values[GC.EXTRA_ARGS]:
    GM.Globals[GM.EXTRA_ARGS_LIST] = []
    if GC.Values[GC.EXTRA_ARGS]:
      ea_config = configparser.ConfigParser()
      ea_config.optionxform = str
      ea_config.read(GC.Values[GC.EXTRA_ARGS])
      GM.Globals[GM.EXTRA_ARGS_LIST].extend(ea_config.items(u'extra-args'))
  if prevOauth2serviceJson != GC.Values[GC.OAUTH2SERVICE_JSON]:
    GM.Globals[GM.OAUTH2SERVICE_JSON_DATA] = None
    GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID] = None
  Cmd.SetEncoding(GM.Globals[GM.SYS_ENCODING])
  GM.Globals[GM.DATETIME_NOW] = datetime.datetime.now(GC.Values[GC.TIMEZONE])
# redirect csv <FileName> [multiprocess] [append] [noheader] [charset <CharSet>] [columndelimiter <Character>] [quotechar <Character>]]
# redirect stdout <FileName> [multiprocess] [append]
# redirect stdout null
# redirect stderr <FileName> [multiprocess] [append]
# redirect stderr stdout
# redirect stderr null
  while checkArgumentPresent(Cmd.REDIRECT_CMD):
    myarg = getChoice([u'csv', u'stdout', u'stderr'])
    filename = re.sub(r'{{Section}}', sectionName, getString(Cmd.OB_FILE_NAME, checkBlank=True))
    if myarg == u'csv':
      multi = checkArgumentPresent(u'multiprocess')
      mode = [DEFAULT_FILE_WRITE_MODE, DEFAULT_FILE_APPEND_MODE][checkArgumentPresent(u'append')]
      writeHeader = not checkArgumentPresent(u'noheader')
      encoding = getCharSet()
      if checkArgumentPresent(u'columndelimiter'):
        GC.Values[GC.CSV_OUTPUT_COLUMN_DELIMITER] = getCharacter()
      if checkArgumentPresent(u'quotechar'):
        GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR] = getCharacter()
      _setCSVFile(filename, mode, encoding, writeHeader, multi)
    elif myarg == u'stdout':
      if filename.lower() == u'null':
        multi = checkArgumentPresent(u'multiprocess')
        _setSTDFile(GM.STDOUT, u'null', DEFAULT_FILE_WRITE_MODE, multi)
      else:
        multi = checkArgumentPresent(u'multiprocess')
        mode = [DEFAULT_FILE_WRITE_MODE, DEFAULT_FILE_APPEND_MODE][checkArgumentPresent(u'append')]
        _setSTDFile(GM.STDOUT, filename, mode, multi)
        if GM.Globals[GM.CSVFILE].get(GM.REDIRECT_NAME) == u'-':
          GM.Globals[GM.CSVFILE] = {}
    else: # myarg == u'stderr'
      if filename.lower() == u'null':
        multi = checkArgumentPresent(u'multiprocess')
        _setSTDFile(GM.STDERR, u'null', DEFAULT_FILE_WRITE_MODE, multi)
      elif filename.lower() != u'stdout':
        multi = checkArgumentPresent(u'multiprocess')
        mode = [DEFAULT_FILE_WRITE_MODE, DEFAULT_FILE_APPEND_MODE][checkArgumentPresent(u'append')]
        _setSTDFile(GM.STDERR, filename, mode, multi)
      else:
        multi = checkArgumentPresent(u'multiprocess')
        if  not GM.Globals[GM.STDOUT]:
          _setSTDFile(GM.STDOUT, u'-', DEFAULT_FILE_WRITE_MODE, multi)
        GM.Globals[GM.STDERR] = GM.Globals[GM.STDOUT].copy()
        GM.Globals[GM.STDERR][GM.REDIRECT_NAME] = u'stdout'
  if not GM.Globals[GM.STDOUT]:
    _setSTDFile(GM.STDOUT, u'-', DEFAULT_FILE_WRITE_MODE, False)
  if not GM.Globals[GM.STDERR]:
    _setSTDFile(GM.STDERR, u'-', DEFAULT_FILE_WRITE_MODE, False)
  if not GM.Globals[GM.CSVFILE]:
    _setCSVFile(u'-', GM.Globals[GM.STDOUT].get(GM.REDIRECT_MODE, DEFAULT_FILE_WRITE_MODE), GC.Values[GC.CHARSET], True, False)
  if not GC.Values[GC.NO_UPDATE_CHECK]:
    doGAMCheckForUpdates()
# If no select/options commands were executed or some were and there are more arguments on the command line,
# warn if the json files are missing and return True
  if (Cmd.Location() == 1) or (Cmd.ArgumentsRemaining()):
    _chkCfgDirectories(sectionName)
    _chkCfgFiles(sectionName)
    if status[u'errors']:
      sys.exit(CONFIG_ERROR_RC)
    if GC.Values[GC.NO_CACHE]:
      GM.Globals[GM.CACHE_DIR] = None
      GM.Globals[GM.CACHE_DISCOVERY_ONLY] = False
    else:
      GM.Globals[GM.CACHE_DIR] = GC.Values[GC.CACHE_DIR]
      GM.Globals[GM.CACHE_DISCOVERY_ONLY] = GC.Values[GC.CACHE_DISCOVERY_ONLY]
    return True
# We're done, nothing else to do
  return False

def getHttpObj(cache=None):
  return httplib2.Http(cache=cache,
                       ca_certs=GC.Values[GC.CACERTS_PEM],
                       disable_ssl_certificate_validation=GC.Values[GC.NO_VERIFY_SSL])

def doGAMCheckForUpdates(forceCheck=False):
  import calendar

  def _gamLatestVersionNotAvailable():
    if forceCheck:
      systemErrorExit(NETWORK_ERROR_RC, Msg.GAM_LATEST_VERSION_NOT_AVAILABLE)

  current_version = __version__
  now_time = calendar.timegm(time.gmtime())
  if forceCheck:
    check_url = GAM_ALL_RELEASES # includes pre-releases
  else:
    last_check_time_str = readFile(GM.Globals[GM.LAST_UPDATE_CHECK_TXT], continueOnError=True, displayError=False)
    last_check_time = int(last_check_time_str) if last_check_time_str and last_check_time_str.isdigit() else 0
    if last_check_time > now_time-604800:
      return
    check_url = GAM_LATEST_RELEASE # latest full release
  try:
    _, c = getHttpObj().request(check_url, u'GET', headers={u'Accept': u'application/vnd.github.v3.text+json'})
    try:
      release_data = json.loads(c)
    except ValueError:
      _gamLatestVersionNotAvailable()
      return
    if isinstance(release_data, list):
      release_data = release_data[0] # only care about latest release
    if not isinstance(release_data, dict) or u'tag_name' not in release_data:
      _gamLatestVersionNotAvailable()
      return
    latest_version = release_data[u'tag_name']
    if latest_version[0].lower() == u'v':
      latest_version = latest_version[1:]
    if forceCheck or (latest_version > current_version):
      printKeyValueList([u'Version Check', None])
      Ind.Increment()
      printKeyValueList([u'Current', current_version])
      printKeyValueList([u' Latest', latest_version])
      Ind.Decrement()
    if latest_version <= current_version:
      writeFile(GM.Globals[GM.LAST_UPDATE_CHECK_TXT], str(now_time), continueOnError=True, displayError=forceCheck)
      return
    announcement = release_data.get(u'body_text', u'No details about this release')
    writeStderr(u'\nGAM %s release notes:\n\n' % latest_version)
    writeStderr(announcement)
    try:
      printLine(Msg.HIT_CONTROL_C_TO_UPDATE)
      time.sleep(15)
    except KeyboardInterrupt:
      import webbrowser
      webbrowser.open(release_data[u'html_url'])
      printLine(Msg.GAM_EXITING_FOR_UPDATE)
      sys.exit(0)
    writeFile(GM.Globals[GM.LAST_UPDATE_CHECK_TXT], str(now_time), continueOnError=True, displayError=forceCheck)
    return
  except (httplib2.HttpLib2Error, httplib2.ServerNotFoundError,
          google.auth.exceptions.TransportError, httplib2.CertificateValidationUnsupportedInPython31):
    return

def handleOAuthTokenError(e, soft_errors):
  errMsg = str(e)
  if errMsg.replace(u'.', u'') in API.OAUTH2_TOKEN_ERRORS or errMsg.startswith(u'Invalid response'):
    if soft_errors:
      return None
    if not GM.Globals[GM.CURRENT_SVCACCT_USER]:
      APIAccessDeniedExit()
    systemErrorExit(SERVICE_NOT_APPLICABLE_RC, Msg.SERVICE_NOT_APPLICABLE_THIS_ADDRESS.format(GM.Globals[GM.CURRENT_SVCACCT_USER]))
  stderrErrorMsg(u'Authentication Token Error - {0}'.format(errMsg))
  APIAccessDeniedExit()

def getCredentialsForScope(cred_family, filename=None, storageOnly=False):
  try:
    storage = MultiprocessFileStorage(filename or GC.Values[GC.OAUTH2_TXT], cred_family)
    if storageOnly:
      return storage
    return storage.get()
  except (KeyError, ValueError):
    return None
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def getClientCredentials(cred_family):
  credentials = getCredentialsForScope(cred_family)
  if not credentials or credentials.invalid:
    invalidOauth2TxtExit()
  if credentials.access_token_expired:
    try:
      credentials.refresh(getHttpObj())
    except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
      systemErrorExit(NETWORK_ERROR_RC, str(e))
    except (oauth2client.client.AccessTokenRefreshError, google.auth.exceptions.RefreshError) as e:
      handleOAuthTokenError(e, False)
  credentials.user_agent = GAM_INFO
  return credentials

def _getValueFromOAuth(field):
  return getClientCredentials(API.FAM1_SCOPES).id_token.get(field, u'Unknown')

def getSvcAcctCredentials(scopes, act_as):
  try:
    if not GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]:
      json_string = readFile(GC.Values[GC.OAUTH2SERVICE_JSON], continueOnError=True, displayError=True)
      if not json_string:
        invalidOauth2serviceJsonExit()
      GM.Globals[GM.OAUTH2SERVICE_JSON_DATA] = json.loads(json_string)
    credentials = google.oauth2.service_account.Credentials.from_service_account_info(GM.Globals[GM.OAUTH2SERVICE_JSON_DATA])
    credentials = credentials.with_scopes(scopes)
    credentials = credentials.with_subject(act_as)
    GM.Globals[GM.ADMIN] = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA][u'client_email']
    GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID] = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
    return credentials
  except (ValueError, IndexError, KeyError):
    invalidOauth2serviceJsonExit()

def getGDataOAuthToken(gdataObj, credentials=None):
  if not credentials:
    credentials = getClientCredentials(API.FAM2_SCOPES)
  try:
    credentials.refresh(getHttpObj())
  except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
    systemErrorExit(NETWORK_ERROR_RC, str(e))
  except oauth2client.client.AccessTokenRefreshError as e:
    handleOAuthTokenError(e, False)
  gdataObj.additional_headers[u'Authorization'] = u'Bearer {0}'.format(credentials.access_token)
  if not GC.Values[GC.DOMAIN]:
    GC.Values[GC.DOMAIN] = credentials.id_token.get(u'hd', u'UNKNOWN').lower()
  if not GC.Values[GC.CUSTOMER_ID]:
    GC.Values[GC.CUSTOMER_ID] = GC.MY_CUSTOMER
  GM.Globals[GM.ADMIN] = credentials.id_token.get(u'email', u'UNKNOWN').lower()
  GM.Globals[GM.OAUTH2_CLIENT_ID] = credentials.client_id
  gdataObj.domain = GC.Values[GC.DOMAIN]
  gdataObj.source = GAM_INFO
  return True

def checkGDataError(e, service):
  error = e.args
  reason = error[0].get(u'reason', u'')
  body = error[0].get(u'body', u'').decode(u'utf-8')
  # First check for errors that need special handling
  if reason in [u'Token invalid - Invalid token: Stateless token expired', u'Token invalid - Invalid token: Token not found']:
    keep_domain = service.domain
    getGDataOAuthToken(service)
    service.domain = keep_domain
    return (GDATA.TOKEN_EXPIRED, reason)
  error_code = getattr(e, u'error_code', 600)
  if error_code == 600:
    if body.startswith(u'Quota exceeded for the current request'):
      return (GDATA.QUOTA_EXCEEDED, body)
    if body.startswith(u'Request rate higher than configured'):
      return (GDATA.QUOTA_EXCEEDED, body)
    if reason == u'Bad Gateway':
      return (GDATA.BAD_GATEWAY, reason)
    if reason == u'Service Unavailable':
      return (GDATA.SERVICE_UNAVAILABLE, reason)
    if reason == u'Service <jotspot> disabled by G Suite admin.':
      return (GDATA.FORBIDDEN, reason)
    if reason == u'Internal Server Error':
      return (GDATA.INTERNAL_SERVER_ERROR, reason)
    if reason == u'Token invalid - Invalid token: Token disabled, revoked, or expired.':
      return (GDATA.TOKEN_INVALID, u'Token disabled, revoked, or expired. Please delete and re-create oauth.txt')
    if reason == u'Token invalid - AuthSub token has wrong scope':
      return (GDATA.INSUFFICIENT_PERMISSIONS, reason)
    if reason.startswith(u'Only administrators can request entries belonging to'):
      return (GDATA.INSUFFICIENT_PERMISSIONS, reason)
    if reason == u'You are not authorized to access this API':
      return (GDATA.INSUFFICIENT_PERMISSIONS, reason)
    if reason == u'Invalid domain.':
      return (GDATA.INVALID_DOMAIN, reason)
    if reason.startswith(u'You are not authorized to perform operations on the domain'):
      return (GDATA.INVALID_DOMAIN, reason)
    if reason == u'Bad Request':
      if u'already exists' in body:
        return (GDATA.ENTITY_EXISTS, Msg.DUPLICATE)
      return (GDATA.BAD_REQUEST, body)
    if reason == u'Forbidden':
      return (GDATA.FORBIDDEN, body)
    if reason == u'Not Found':
      return (GDATA.NOT_FOUND, Msg.DOES_NOT_EXIST)
    if reason == u'Not Implemented':
      return (GDATA.NOT_IMPLEMENTED, body)
    if reason == u'Precondition Failed':
      return (GDATA.PRECONDITION_FAILED, reason)
  elif error_code == 602:
    if reason == u'Bad Request':
      return (GDATA.BAD_REQUEST, body)
  elif error_code == 610:
    if reason == u'Service <jotspot> disabled by G Suite admin.':
      return (GDATA.FORBIDDEN, reason)

  # We got a "normal" error, define the mapping below
  error_code_map = {
    1000: reason,
    1001: reason,
    1002: u'Unauthorized and forbidden',
    1100: u'User deleted recently',
    1200: u'Domain user limit exceeded',
    1201: u'Domain alias limit exceeded',
    1202: u'Domain suspended',
    1203: u'Domain feature unavailable',
    1300: u'Entity %s exists' % getattr(e, u'invalidInput', u'<unknown>'),
    1301: u'Entity %s Does Not Exist' % getattr(e, u'invalidInput', u'<unknown>'),
    1302: u'Entity Name Is Reserved',
    1303: u'Entity %s name not valid' % getattr(e, u'invalidInput', u'<unknown>'),
    1306: u'%s has members. Cannot delete.' % getattr(e, u'invalidInput', u'<unknown>'),
    1317: u'Invalid input %s, reason %s' % (getattr(e, u'invalidInput', u'<unknown>'), getattr(e, u'reason', u'<unknown>')),
    1400: u'Invalid Given Name',
    1401: u'Invalid Family Name',
    1402: u'Invalid Password',
    1403: u'Invalid Username',
    1404: u'Invalid Hash Function Name',
    1405: u'Invalid Hash Digest Length',
    1406: u'Invalid Email Address',
    1407: u'Invalid Query Parameter Value',
    1408: u'Invalid SSO Signing Key',
    1409: u'Invalid Encryption Public Key',
    1410: u'Feature Unavailable For User',
    1411: u'Invalid Encryption Public Key Format',
    1500: u'Too Many Recipients On Email List',
    1501: u'Too Many Aliases For User',
    1502: u'Too Many Delegates For User',
    1601: u'Duplicate Destinations',
    1602: u'Too Many Destinations',
    1603: u'Invalid Route Address',
    1700: u'Group Cannot Contain Cycle',
    1800: u'Group Cannot Contain Cycle',
    1801: u'Invalid value %s' % getattr(e, u'invalidInput', u'<unknown>'),
  }
  return (error_code, error_code_map.get(error_code, u'Unknown Error: {0}'.format(str(e))))

def waitOnFailure(n, retries, error_code, error_message):
  wait_on_fail = min(2 ** n, 60)+float(random.randint(1, 1000))/1000
  if n > 3:
    writeStderr(u'Temporary error: {0} - {1}, Backing off: {2} seconds, Retry: {3}/{4}\n'.format(error_code, error_message, int(wait_on_fail), n, retries))
    flushStderr()
  time.sleep(wait_on_fail)

def callGData(service, function,
              soft_errors=False, throw_errors=None, retry_errors=None,
              **kwargs):
  import gdata.apps.service
  if throw_errors is None:
    throw_errors = []
  if retry_errors is None:
    retry_errors = []
  all_retry_errors = GDATA.NON_TERMINATING_ERRORS+retry_errors
  method = getattr(service, function)
  retries = 10
  for n in range(1, retries+1):
    try:
      return method(**kwargs)
    except (gdata.service.RequestError, gdata.apps.service.AppsForYourDomainException) as e:
      error_code, error_message = checkGDataError(e, service)
      if (n != retries) and (error_code in all_retry_errors):
        waitOnFailure(n, retries, error_code, error_message)
        continue
      if error_code in throw_errors:
        if error_code in GDATA.ERROR_CODE_EXCEPTION_MAP:
          raise GDATA.ERROR_CODE_EXCEPTION_MAP[error_code](error_message)
        raise
      if soft_errors:
        stderrErrorMsg(u'{0} - {1}{2}'.format(error_code, error_message, [u'', u': Giving up.'][n > 1]))
        return None
      if error_code == GDATA.INSUFFICIENT_PERMISSIONS:
        APIAccessDeniedExit()
      systemErrorExit(GOOGLE_API_ERROR_RC, u'{0} - {1}'.format(error_code, error_message))
    except oauth2client.client.AccessTokenRefreshError as e:
      handleOAuthTokenError(e, GDATA.SERVICE_NOT_APPLICABLE in throw_errors)
      raise GDATA.ERROR_CODE_EXCEPTION_MAP[GDATA.SERVICE_NOT_APPLICABLE](str(e))
    except (http_client.ResponseNotReady, socket.error) as e:
      errMsg = u'Connection error: {0}'.format(str(e) or repr(e))
      if n != retries:
        waitOnFailure(n, retries, SOCKET_ERROR_RC, errMsg)
        continue
      if soft_errors:
        writeStderr(convertUTF8(u'\n{0}{1} - Giving up.\n'.format(ERROR_PREFIX, errMsg)))
        return None
      systemErrorExit(SOCKET_ERROR_RC, errMsg)
    except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
      systemErrorExit(NETWORK_ERROR_RC, str(e))
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, str(e))

def callGDataPages(service, function,
                   page_message=None,
                   soft_errors=False, throw_errors=None, retry_errors=None,
                   uri=None,
                   **kwargs):
  if throw_errors is None:
    throw_errors = []
  if retry_errors is None:
    retry_errors = []
  nextLink = None
  allResults = []
  totalItems = 0
  while True:
    this_page = callGData(service, function,
                          soft_errors=soft_errors, throw_errors=throw_errors, retry_errors=retry_errors,
                          uri=uri,
                          **kwargs)
    if this_page:
      nextLink = this_page.GetNextLink()
      pageItems = len(this_page.entry)
      if pageItems == 0:
        nextLink = None
      totalItems += pageItems
      allResults.extend(this_page.entry)
    else:
      nextLink = None
      pageItems = 0
    if page_message:
      if Ent.GettingShowTotal():
        show_message = page_message.replace(TOTAL_ITEMS_MARKER, str(totalItems))
        count = totalItems
      else:
        show_message = page_message.replace(NUM_ITEMS_MARKER, str(pageItems))
        count = pageItems if nextLink else totalItems
      writeStderr(u'\r')
      flushStderr()
      writeStderr(show_message.format(Ent.ChooseGetting(count)))
    if nextLink is None:
      if page_message and (page_message[-1] != u'\n'):
        writeStderr(u'\r\n')
        flushStderr()
      return allResults
    uri = nextLink.href

def checkGAPIError(e, soft_errors=False, retryOnHttpError=False, service=None):
  try:
    error = json.loads(e.content)
  except ValueError:
    if (e.resp[u'status'] == u'503') and (str(e.content).startswith(u'Quota exceeded for the current request')):
      return (e.resp[u'status'], GAPI.QUOTA_EXCEEDED, str(e.content))
    if (e.resp[u'status'] == u'403') and (str(e.content).startswith(u'Request rate higher than configured')):
      return (e.resp[u'status'], GAPI.QUOTA_EXCEEDED, str(e.content))
    if (e.resp[u'status'] == u'502') and (u'Bad Gateway' in str(e.content)):
      return (e.resp[u'status'], GAPI.BAD_GATEWAY, str(e.content))
    if (e.resp[u'status'] == u'403') and (u'Invalid domain.' in str(e.content)):
      error = {u'error': {u'code': 403, u'errors': [{u'reason': GAPI.NOT_FOUND, u'message': u'Domain not found'}]}}
    elif (e.resp[u'status'] == u'403') and (u'Domain cannot use apis.' in str(e.content)):
      error = {u'error': {u'code': 403, u'errors': [{u'reason': GAPI.DOMAIN_CANNOT_USE_APIS, u'message': u'Domain cannot use apis'}]}}
    elif (e.resp[u'status'] == u'400') and (u'InvalidSsoSigningKey' in str(e.content)):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI.INVALID, u'message': u'InvalidSsoSigningKey'}]}}
    elif (e.resp[u'status'] == u'400') and (u'UnknownError' in str(e.content)):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI.INVALID, u'message': u'UnknownError'}]}}
    elif (e.resp[u'status'] == u'400') and (u'FeatureUnavailableForUser' in str(e.content)):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI.SERVICE_NOT_AVAILABLE, u'message': u'Feature Unavailable For User'}]}}
    elif (e.resp[u'status'] == u'400') and (u'EntityDoesNotExist' in str(e.content)):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI.NOT_FOUND, u'message': u'Entity Does Not Exist'}]}}
    elif (e.resp[u'status'] == u'400') and (u'EntityNameNotValid' in str(e.content)):
      error = {u'error': {u'code': 400, u'errors': [{u'reason': GAPI.INVALID_INPUT, u'message': u'Entity Name Not Valid'}]}}
    elif retryOnHttpError:
      service._http.request.credentials.refresh(getHttpObj())
      return (-1, None, None)
    elif soft_errors:
      stderrErrorMsg(str(e.content))
      return (0, None, None)
    else:
      systemErrorExit(HTTP_ERROR_RC, str(e.content))
  if u'error' in error:
    http_status = error[u'error'][u'code']
    try:
      message = error[u'error'][u'errors'][0][u'message']
    except KeyError:
      message = error[u'error'][u'message']
    if http_status == 500:
      if not message:
        message = Msg.UNKNOWN
        error = {u'error': {u'errors': [{u'reason': GAPI.UNKNOWN_ERROR, u'message': message}]}}
      elif u'Backend Error' in message:
        error = {u'error': {u'errors': [{u'reason': GAPI.BACKEND_ERROR, u'message': message}]}}
      elif u'Role assignment exists: RoleAssignment' in message:
        error = {u'error': {u'errors': [{u'reason': GAPI.DUPLICATE, u'message': message}]}}
      elif u'Operation not supported' in message:
        error = {u'error': {u'errors': [{u'reason': GAPI.OPERATION_NOT_SUPPORTED, u'message': message}]}}
    elif http_status == 409:
      if u'Requested entity already exists' in message:
        error = {u'error': {u'errors': [{u'reason': GAPI.ALREADY_EXISTS, u'message': message}]}}
  else:
    if u'error_description' in error:
      if error[u'error_description'] == u'Invalid Value':
        message = error[u'error_description']
        http_status = 400
        error = {u'error': {u'errors': [{u'reason': GAPI.INVALID, u'message': message}]}}
      else:
        systemErrorExit(GOOGLE_API_ERROR_RC, str(error))
    else:
      systemErrorExit(GOOGLE_API_ERROR_RC, str(error))
  try:
    reason = error[u'error'][u'errors'][0][u'reason']
    for messageItem in GAPI.REASON_MESSAGE_MAP.get(reason, []):
      if messageItem[0] in message:
        if reason in [GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND]:
          message = Msg.DOES_NOT_EXIST
        reason = messageItem[1]
        break
    if reason == GAPI.INVALID_SHARING_REQUEST:
      loc = message.find(u'User message: ')
      if loc != 1:
        message = message[loc+15:]
  except KeyError:
    reason = u'{0}'.format(http_status)
  return (http_status, reason, message)

def callGAPI(service, function,
             bailOnInternalError=False, soft_errors=False, throw_reasons=None, retry_reasons=None,
             **kwargs):
  if throw_reasons is None:
    throw_reasons = []
  if retry_reasons is None:
    retry_reasons = []
  all_retry_reasons = GAPI.DEFAULT_RETRY_REASONS+retry_reasons
  method = getattr(service, function)
  retries = 10
  svcparms = dict(list(kwargs.items())+GM.Globals[GM.EXTRA_ARGS_LIST])
  for n in range(1, retries+1):
    try:
      return method(**svcparms).execute()
    except googleapiclient.errors.HttpError as e:
      http_status, reason, message = checkGAPIError(e, soft_errors=soft_errors, retryOnHttpError=n < 3, service=service)
      if http_status == -1:
        continue
      if http_status == 0:
        return None
      if (n != retries) and (reason in all_retry_reasons):
        if reason == GAPI.INTERNAL_ERROR and bailOnInternalError and n == 2:
          raise GAPI.REASON_EXCEPTION_MAP[reason](message)
        waitOnFailure(n, retries, reason, message)
        continue
      if reason in throw_reasons:
        if reason in GAPI.REASON_EXCEPTION_MAP:
          raise GAPI.REASON_EXCEPTION_MAP[reason](message)
        raise e
      if soft_errors:
        stderrErrorMsg(u'{0}: {1} - {2}{3}'.format(http_status, reason, message, [u'', u': Giving up.'][n > 1]))
        return None
      if reason == GAPI.INSUFFICIENT_PERMISSIONS:
        APIAccessDeniedExit()
      systemErrorExit(HTTP_ERROR_RC, formatHTTPError(http_status, reason, message))
    except (oauth2client.client.AccessTokenRefreshError, google.auth.exceptions.RefreshError) as e:
      handleOAuthTokenError(e, GAPI.SERVICE_NOT_AVAILABLE in throw_reasons)
      raise GAPI.REASON_EXCEPTION_MAP[GAPI.SERVICE_NOT_AVAILABLE](str(e))
    except httplib2.CertificateValidationUnsupportedInPython31:
      noPythonSSLExit()
    except (http_client.ResponseNotReady, socket.error) as e:
      errMsg = u'Connection error: {0}'.format(str(e) or repr(e))
      if n != retries:
        waitOnFailure(n, retries, SOCKET_ERROR_RC, errMsg)
        continue
      if soft_errors:
        writeStderr(convertUTF8(u'\n{0}{1} - Giving up.\n'.format(ERROR_PREFIX, errMsg)))
        return None
      systemErrorExit(SOCKET_ERROR_RC, errMsg)
    except ValueError as e:
      if service._http.cache is not None:
        service._http.cache = None
        continue
      systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
    except TypeError as e:
      systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
    except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
      systemErrorExit(NETWORK_ERROR_RC, str(e))
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, str(e))

def _processGAPIpagesResult(results, items, allResults, totalItems, page_message, message_attribute, entityType):
  if results:
    pageToken = results.get(u'nextPageToken')
    if items in results:
      pageItems = len(results[items])
      totalItems += pageItems
      allResults.extend(results[items])
    else:
      results = {items: []}
      pageItems = 0
  else:
    pageToken = None
    results = {items: []}
    pageItems = 0
  if page_message:
    if Ent.GettingShowTotal():
      show_message = page_message.replace(TOTAL_ITEMS_MARKER, str(totalItems))
      count = totalItems
    else:
      show_message = page_message.replace(NUM_ITEMS_MARKER, str(pageItems))
      count = pageItems if pageToken else totalItems
    if message_attribute:
      try:
        show_message = show_message.replace(FIRST_ITEM_MARKER, str(results[items][0][message_attribute]))
        show_message = show_message.replace(LAST_ITEM_MARKER, str(results[items][-1][message_attribute]))
      except (IndexError, KeyError):
        show_message = show_message.replace(FIRST_ITEM_MARKER, u'')
        show_message = show_message.replace(LAST_ITEM_MARKER, u'')
    writeStderr(u'\r')
    flushStderr()
    writeStderr(show_message.format(Ent.Choose(entityType, count)))
  return (pageToken, totalItems)

def callGAPIpages(service, function, items,
                  page_message=None, message_attribute=None, maxItems=0,
                  throw_reasons=None, retry_reasons=None,
                  **kwargs):
  if throw_reasons is None:
    throw_reasons = []
  if retry_reasons is None:
    retry_reasons = []
  allResults = collections.deque()
  totalItems = 0
  maxResults = kwargs.get(u'maxResults', 0)
  tweakMaxResults = maxItems and maxResults
  entityType = Ent.Getting() if page_message else None
  while True:
    if tweakMaxResults and maxItems-totalItems < maxResults:
      kwargs[u'maxResults'] = maxItems-totalItems
    results = callGAPI(service, function,
                       throw_reasons=throw_reasons, retry_reasons=retry_reasons,
                       **kwargs)
    pageToken, totalItems = _processGAPIpagesResult(results, items, allResults, totalItems, page_message, message_attribute, entityType)
    if not pageToken or maxItems and totalItems >= maxItems:
      if page_message and (page_message[-1] != u'\n'):
        writeStderr(u'\r\n')
        flushStderr()
      return allResults
    kwargs[u'pageToken'] = pageToken

def callGAPIitems(service, function, items,
                  throw_reasons=None, retry_reasons=None,
                  **kwargs):
  if throw_reasons is None:
    throw_reasons = []
  if retry_reasons is None:
    retry_reasons = []
  results = callGAPI(service, function,
                     throw_reasons=throw_reasons, retry_reasons=retry_reasons,
                     **kwargs)
  if results:
    return results.get(items, [])
  return []

def checkCloudPrintResult(result, throw_messages=None):
  if throw_messages is None:
    throw_messages = []
  if isinstance(result, string_types):
    try:
      result = json.loads(result)
    except ValueError:
      systemErrorExit(JSON_LOADS_ERROR_RC, result)
  if not result[u'success']:
    message = result[u'message']
    if message in throw_messages:
      if message in GCP.MESSAGE_EXCEPTION_MAP:
        raise GCP.MESSAGE_EXCEPTION_MAP[message](message)
    systemErrorExit(AC_FAILED_RC, u'{0}: {1}'.format(result[u'errorCode'], result[u'message']))
  return result

def callGCP(service, function,
            throw_messages=None,
            **kwargs):
  result = callGAPI(service, function,
                    **kwargs)
  return checkCloudPrintResult(result, throw_messages=throw_messages)

def readDiscoveryFile(api_version):
  disc_filename = u'%s.json' % (api_version)
  disc_file = os.path.join(GM.Globals[GM.GAM_PATH], disc_filename)
  if hasattr(sys, u'_MEIPASS'):
    json_string = readFile(os.path.join(sys._MEIPASS, disc_filename), continueOnError=True, displayError=True)
  elif os.path.isfile(disc_file):
    json_string = readFile(disc_file, continueOnError=True, displayError=True)
  else:
    json_string = None
  if not json_string:
    invalidDiscoveryJsonExit(disc_file)
  try:
    discovery = json.loads(json_string)
    return (disc_file, discovery)
  except ValueError:
    invalidDiscoveryJsonExit(disc_file)

def getAPIversionHttpService(api):
  hasLocalJSON = API.hasLocalJSON(api)
  api, version, api_version, cred_family = API.getVersion(api)
  httpObj = getHttpObj(cache=GM.Globals[GM.CACHE_DIR])
  if api in GM.Globals[GM.CURRENT_API_SERVICES] and version in GM.Globals[GM.CURRENT_API_SERVICES][api]:
    service = googleapiclient.discovery.build_from_document(GM.Globals[GM.CURRENT_API_SERVICES][api][version], http=httpObj)
    if GM.Globals[GM.CACHE_DISCOVERY_ONLY]:
      httpObj.cache = None
    return (api_version, httpObj, service, cred_family)
  if not hasLocalJSON:
    retries = 3
    for n in range(1, retries+1):
      try:
        service = googleapiclient.discovery.build(api, version, http=httpObj, cache_discovery=False)
        GM.Globals[GM.CURRENT_API_SERVICES].setdefault(api, {})
        GM.Globals[GM.CURRENT_API_SERVICES][api][version] = service._rootDesc.copy()
        if GM.Globals[GM.CACHE_DISCOVERY_ONLY]:
          httpObj.cache = None
        return (api_version, httpObj, service, cred_family)
      except googleapiclient.errors.UnknownApiNameOrVersion as e:
        systemErrorExit(GOOGLE_API_ERROR_RC, Msg.UNKNOWN_API_OR_VERSION.format(str(e), __author__))
      except (googleapiclient.errors.InvalidJsonError, KeyError, ValueError):
        httpObj.cache = None
        if n != retries:
          waitOnFailure(n, retries, INVALID_JSON_RC, Msg.INVALID_JSON_INFORMATION)
          continue
        systemErrorExit(INVALID_JSON_RC, Msg.INVALID_JSON_INFORMATION)
      except (http_client.ResponseNotReady, socket.error) as e:
        errMsg = u'Connection error: {0}'.format(str(e) or repr(e))
        if n != retries:
          waitOnFailure(n, retries, SOCKET_ERROR_RC, errMsg)
          continue
        systemErrorExit(SOCKET_ERROR_RC, errMsg)
      except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
        systemErrorExit(NETWORK_ERROR_RC, str(e))
      except IOError as e:
        systemErrorExit(FILE_ERROR_RC, str(e))
  disc_file, discovery = readDiscoveryFile(api_version)
  try:
    service = googleapiclient.discovery.build_from_document(discovery, http=httpObj)
    GM.Globals[GM.CURRENT_API_SERVICES].setdefault(api, {})
    GM.Globals[GM.CURRENT_API_SERVICES][api][version] = service._rootDesc.copy()
    if GM.Globals[GM.CACHE_DISCOVERY_ONLY]:
      httpObj.cache = None
    return (api_version, httpObj, service, cred_family)
  except (KeyError, ValueError):
    invalidDiscoveryJsonExit(disc_file)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, str(e))

def buildGAPIObject(api):
  _, httpObj, service, cred_family = getAPIversionHttpService(api)
  credentials = getClientCredentials(cred_family)
  try:
    API_Scopes = set(list(service._rootDesc[u'auth'][u'oauth2'][u'scopes']))
  except KeyError:
    API_Scopes = set(API.VAULT_SCOPES) if api == API.VAULT else set()
  GM.Globals[GM.CURRENT_CLIENT_API] = api
  GM.Globals[GM.CURRENT_CLIENT_API_SCOPES] = API_Scopes.intersection(credentials.scopes)
  if not GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, Msg.NO_SCOPES_FOR_API.format(service._rootDesc[u'title']))
  try:
    service._http = credentials.authorize(httpObj)
  except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
    systemErrorExit(NETWORK_ERROR_RC, str(e))
  except (oauth2client.client.AccessTokenRefreshError, google.auth.exceptions.RefreshError) as e:
    handleOAuthTokenError(e, False)
  if not GC.Values[GC.DOMAIN]:
    GC.Values[GC.DOMAIN] = credentials.id_token.get(u'hd', u'UNKNOWN').lower()
  if not GC.Values[GC.CUSTOMER_ID]:
    GC.Values[GC.CUSTOMER_ID] = GC.MY_CUSTOMER
  GM.Globals[GM.ADMIN] = credentials.id_token.get(u'email', u'UNKNOWN').lower()
  GM.Globals[GM.OAUTH2_CLIENT_ID] = credentials.client_id
  return service

# Override and wrap google_auth_httplib2 request methods so that the GAM
# user-agent string is inserted into HTTP request headers.
def _request_with_user_agent(request_method):
  """Inserts the GAM user-agent header kwargs sent to a method."""
  GAM_USER_AGENT = GAM_INFO

  def wrapped_request_method(self, *args, **kwargs):
    if kwargs.get('headers') is not None:
      if kwargs['headers'].get('user-agent'):
        if GAM_USER_AGENT not in kwargs['headers']['user-agent']:
          # Save the existing user-agent header and tack on the GAM user-agent.
          kwargs['headers']['user-agent'] = '%s %s' % (GAM_USER_AGENT, kwargs['headers']['user-agent'])
      else:
        kwargs['headers']['user-agent'] = GAM_USER_AGENT
    else:
      kwargs['headers'] = {'user-agent': GAM_USER_AGENT}
    return request_method(self, *args, **kwargs)

  return wrapped_request_method

google_auth_httplib2.Request.__call__ = _request_with_user_agent(google_auth_httplib2.Request.__call__)
google_auth_httplib2.AuthorizedHttp.request = _request_with_user_agent(google_auth_httplib2.AuthorizedHttp.request)

def buildGAPIServiceObject(api, user, i, count, displayError=True):
  userEmail = convertUIDtoEmailAddress(user)
  _, httpObj, service, _ = getAPIversionHttpService(api)
  GM.Globals[GM.CURRENT_SVCACCT_API] = api
  GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES] = API.getSvcAcctScopesSet(api)
  GM.Globals[GM.CURRENT_SVCACCT_USER] = userEmail
  credentials = getSvcAcctCredentials(GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES], userEmail)
  request = google_auth_httplib2.Request(httpObj)
  try:
    credentials.refresh(request)
    service._http = google_auth_httplib2.AuthorizedHttp(credentials, http=httpObj)
  except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
    systemErrorExit(NETWORK_ERROR_RC, str(e))
  except google.auth.exceptions.RefreshError as e:
    if isinstance(e.args, tuple):
      e = e.args[0]
    handleOAuthTokenError(e, True)
    if displayError:
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return (userEmail, None)
  return (userEmail, service)

def initGDataObject(gdataObj, api):
  os.environ['REQUESTS_CA_BUNDLE'] = GC.Values[GC.CACERTS_PEM]
  os.environ['DEFAULT_CA_BUNDLE_PATH'] = GC.Values[GC.CACERTS_PEM]
  os.environ['SSL_CERT_FILE'] = GC.Values[GC.CACERTS_PEM]
  _, _, api_version, cred_family = API.getVersion(api)
  disc_file, discovery = readDiscoveryFile(api_version)
  GM.Globals[GM.CURRENT_CLIENT_API] = api
  credentials = getClientCredentials(cred_family)
  try:
    GM.Globals[GM.CURRENT_CLIENT_API_SCOPES] = set(list(discovery[u'auth'][u'oauth2'][u'scopes'])).intersection(credentials.scopes)
  except KeyError:
    invalidDiscoveryJsonExit(disc_file)
  if not GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, Msg.NO_SCOPES_FOR_API.format(discovery.get(u'title', api_version)))
  getGDataOAuthToken(gdataObj, credentials)
  if GC.Values[GC.DEBUG_LEVEL] > 0:
    gdataObj.debug = True
  return gdataObj

def getGDataUserCredentials(api, user, i, count):
  userEmail = convertUIDtoEmailAddress(user)
  _, _, api_version, cred_family = API.getVersion(api)
  disc_file, discovery = readDiscoveryFile(api_version)
  GM.Globals[GM.CURRENT_SVCACCT_API] = api
  GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES] = set(list(discovery[u'auth'][u'oauth2'][u'scopes']))
  GM.Globals[GM.CURRENT_SVCACCT_USER] = userEmail
  credentials = getClientCredentials(cred_family)
  try:
    GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES] = GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES].intersection(credentials.scopes)
  except KeyError:
    invalidDiscoveryJsonExit(disc_file)
  if not GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, Msg.NO_SCOPES_FOR_API.format(discovery.get(u'title', api_version)))
  credentials = getSvcAcctCredentials(GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES], userEmail)
  request = google_auth_httplib2.Request(getHttpObj())
  try:
    credentials.refresh(request)
    return (userEmail, credentials)
  except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
    systemErrorExit(NETWORK_ERROR_RC, str(e))
  except google.auth.exceptions.RefreshError as e:
    if isinstance(e.args, tuple):
      e = e.args[0]
    handleOAuthTokenError(e, True)
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return (userEmail, None)

def getAdminSettingsObject():
  import gdata.apps.adminsettings.service
  return initGDataObject(gdata.apps.adminsettings.service.AdminSettingsService(), API.ADMIN_SETTINGS)

def getContactsObject(entityType=Ent.DOMAIN, entityName=None, i=0, count=0, contactFeed=True):
  import gdata.apps.contacts.service
  if entityType == Ent.DOMAIN:
    contactsObject = initGDataObject(gdata.apps.contacts.service.ContactsService(contactFeed=contactFeed),
                                     API.CONTACTS)
    return (entityName or GC.Values[GC.DOMAIN], contactsObject)
  userEmail, credentials = getGDataUserCredentials(API.CONTACTS, entityName, i, count)
  if not credentials:
    return (userEmail, None)
  contactsObject = gdata.apps.contacts.service.ContactsService(source=GAM_INFO, contactFeed=contactFeed,
                                                               additional_headers={u'Authorization': u'Bearer {0}'.format(credentials.token)})
  if GC.Values[GC.DEBUG_LEVEL] > 0:
    contactsObject.debug = True
  return (userEmail, contactsObject)

def getContactsQuery(**kwargs):
  import gdata.apps.contacts.service
  return gdata.apps.contacts.service.ContactsQuery(**kwargs)

def getEmailAuditObject():
  import gdata.apps.audit.service
  return initGDataObject(gdata.apps.audit.service.AuditService(), API.EMAIL_AUDIT)

def getEmailSettingsObject():
  import gdata.apps.emailsettings.service
  return initGDataObject(gdata.apps.emailsettings.service.EmailSettingsService(), API.EMAIL_SETTINGS)

def getSitesObject(entityType=Ent.DOMAIN, entityName=None, i=0, count=0):
  import gdata.apps.sites.service
  if entityType == Ent.DOMAIN:
    sitesObject = initGDataObject(gdata.apps.sites.service.SitesService(), API.SITES)
    return (entityName or GC.Values[GC.DOMAIN], sitesObject)
  userEmail, credentials = getGDataUserCredentials(API.SITES, entityName, i, count)
  if not credentials:
    return (userEmail, None)
  sitesObject = gdata.apps.sites.service.SitesService(source=GAM_INFO,
                                                      additional_headers={u'Authorization': u'Bearer {0}'.format(credentials.token)})
  if GC.Values[GC.DEBUG_LEVEL] > 0:
    sitesObject.debug = True
  return (userEmail, sitesObject)

def getSitesQuery(**kwargs):
  import gdata.apps.sites.service
  return gdata.apps.sites.service.SitesQuery(**kwargs)

# Convert UID to email address
def convertUIDtoEmailAddress(emailAddressOrUID, cd=None, emailType=u'user', checkForCustomerId=False):
  if checkForCustomerId and (emailAddressOrUID == GC.Values[GC.CUSTOMER_ID]):
    return emailAddressOrUID
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  if normalizedEmailAddressOrUID.find(u'@') > 0:
    return normalizedEmailAddressOrUID
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  if emailType != u'group':
    try:
      result = callGAPI(cd.users(), u'get',
                        throw_reasons=GAPI.USER_GET_THROW_REASONS,
                        userKey=normalizedEmailAddressOrUID, fields=u'primaryEmail')
      if u'primaryEmail' in result:
        return result[u'primaryEmail'].lower()
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      pass
  if emailType != u'user':
    try:
      result = callGAPI(cd.groups(), u'get',
                        throw_reasons=GAPI.GROUP_GET_THROW_REASONS,
                        groupKey=normalizedEmailAddressOrUID, fields=u'email')
      if u'email' in result:
        return result[u'email'].lower()
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      pass
  return normalizedEmailAddressOrUID

# Convert email address to User/Group UID; called immediately after getting email address from command line
def convertEmailAddressToUID(emailAddressOrUID, cd=None, emailType=u'user', savedLocation=None):
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  if normalizedEmailAddressOrUID.find(u'@') == -1:
    return normalizedEmailAddressOrUID
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  if emailType != u'group':
    try:
      return callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=normalizedEmailAddressOrUID, fields=u'id')[u'id']
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      if emailType == u'user':
        if savedLocation is not None:
          Cmd.SetLocation(savedLocation)
        entityDoesNotExistExit(Ent.USER, normalizedEmailAddressOrUID, errMsg=getPhraseDNEorSNA(normalizedEmailAddressOrUID))
  try:
    return callGAPI(cd.groups(), u'get',
                    throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                    groupKey=normalizedEmailAddressOrUID, fields=u'id')[u'id']
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError):
    if savedLocation is not None:
      Cmd.SetLocation(savedLocation)
    entityDoesNotExistExit([Ent.USER, Ent.GROUP][emailType == u'group'], normalizedEmailAddressOrUID, errMsg=getPhraseDNEorSNA(normalizedEmailAddressOrUID))

# Convert User UID from API call to email address
def convertUserIDtoEmail(uid, cd=None):
  if GM.Globals[GM.MAP_USER_ID_TO_NAME] is None:
    GM.Globals[GM.MAP_USER_ID_TO_NAME] = {}
    primaryEmail = None
  else:
    primaryEmail = GM.Globals[GM.MAP_USER_ID_TO_NAME].get(uid)
  if not primaryEmail:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    try:
      primaryEmail = callGAPI(cd.users(), u'get',
                              throw_reasons=GAPI.USER_GET_THROW_REASONS,
                              userKey=uid, fields=u'primaryEmail')[u'primaryEmail']
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      primaryEmail = u'uid:{0}'.format(uid)
    GM.Globals[GM.MAP_USER_ID_TO_NAME][uid] = primaryEmail
  return primaryEmail

# Convert UID to split email address
# Return (foo@bar.com, foo, bar.com)
def splitEmailAddressOrUID(emailAddressOrUID):
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  atLoc = normalizedEmailAddressOrUID.find(u'@')
  if atLoc > 0:
    return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID[:atLoc], normalizedEmailAddressOrUID[atLoc+1:])
  try:
    cd = buildGAPIObject(API.DIRECTORY)
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=normalizedEmailAddressOrUID, fields=u'primaryEmail')
    if u'primaryEmail' in result:
      normalizedEmailAddressOrUID = result[u'primaryEmail'].lower()
      atLoc = normalizedEmailAddressOrUID.find(u'@')
      return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID[:atLoc], normalizedEmailAddressOrUID[atLoc+1:])
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
    pass
  return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID, GC.Values[GC.DOMAIN])

# Convert Org Unit Id to Org Unit Path
def convertOrgUnitIDtoPath(orgUnitId, cd):
  if GM.Globals[GM.MAP_ORGUNIT_ID_TO_NAME] is None:
    GM.Globals[GM.MAP_ORGUNIT_ID_TO_NAME] = {}
    orgUnitPath = None
  else:
    orgUnitPath = GM.Globals[GM.MAP_ORGUNIT_ID_TO_NAME].get(orgUnitId)
  if not orgUnitPath:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    try:
      orgUnitPath = callGAPI(cd.orgunits(), u'get',
                             throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                             customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=orgUnitId, fields=u'orgUnitPath')[u'orgUnitPath']
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError, GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      orgUnitPath = orgUnitId
    GM.Globals[GM.MAP_ORGUNIT_ID_TO_NAME][orgUnitId] = orgUnitPath
  return orgUnitPath

def shlexSplitList(entity, dataDelimiter=u' ,'):
  import shlex
  lexer = shlex.shlex(entity, posix=True)
  lexer.whitespace = dataDelimiter
  lexer.whitespace_split = True
  return list(lexer)

def getQueries(myarg):
  if myarg == u'query':
    return [getString(Cmd.OB_QUERY)]
  else:
    return shlexSplitList(getString(Cmd.OB_QUERY_LIST))

def convertEntityToList(entity, shlexSplit=False, nonListEntityType=False):
  if not entity:
    return []
  if isinstance(entity, (list, set, dict)):
    return list(entity)
  if nonListEntityType:
    return [entity.strip()]
  if not shlexSplit:
    return entity.replace(u',', u' ').split()
  return shlexSplitList(entity)

GROUP_ROLES_MAP = {
  u'owner': Ent.ROLE_OWNER,
  u'owners': Ent.ROLE_OWNER,
  u'manager': Ent.ROLE_MANAGER,
  u'managers': Ent.ROLE_MANAGER,
  u'member': Ent.ROLE_MEMBER,
  u'members': Ent.ROLE_MEMBER,
  }

def _getRoleVerification(memberRoles, fields):
  if memberRoles and memberRoles.find(Ent.ROLE_MEMBER) != -1:
    return (set(memberRoles.split(u',')), None, fields if fields.find(u'role') != -1 else fields[:-1]+u',role)')
  else:
    return (set(), memberRoles, fields)

# Turn the entity into a list of Users/CrOS devices
def getUsersToModify(entityType, entity, memberRoles=None, checkSuspended=None, includeSuspendedInAll=False, groupMemberType=u'USER'):
  def _addGroupMembersToUsers(group, domains, recursive):
    doNotExist = 0
    try:
      printGettingAllEntityItemsForWhom(memberRoles if memberRoles else Ent.ROLE_MANAGER_MEMBER_OWNER, group, entityType=Ent.GROUP)
      validRoles, listRoles, listFields = _getRoleVerification(memberRoles, u'nextPageToken,members(email,type,status)')
      result = callGAPIpages(cd.members(), u'list', u'members',
                             page_message=getPageMessageForWhom(noNL=True),
                             throw_reasons=GAPI.MEMBERS_THROW_REASONS,
                             groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      while result:
        member = result.popleft()
        if member[u'type'] == u'USER':
          if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles:
            email = member[u'email'].lower()
            if domains:
              _, domain = splitEmailAddress(email)
              if domain not in domains:
                continue
            if (checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED')) and email not in entitySet:
              entitySet.add(email)
              entityList.append(email)
        elif recursive and member[u'type'] == u'GROUP':
          doNotExist += _addGroupMembersToUsers(member[u'email'], domains, recursive)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group)
      doNotExist += 1
    return doNotExist

  def _showInvalidEntity(entityType, entityName):
    printErrorMessage(USAGE_ERROR_RC, formatKeyValueList(u'', [Ent.Singular(entityType), entityName, Msg.INVALID], u''))

  doNotExist = invalid = 0
  entityList = []
  entitySet = set()
  if entityType in [Cmd.ENTITY_USER, Cmd.ENTITY_USERS]:
    buildGAPIObject(API.DIRECTORY)
    result = convertEntityToList(entity, nonListEntityType=entityType == Cmd.ENTITY_USER)
    for user in result:
      if validateEmailAddressOrUID(user):
        if user not in entitySet:
          entitySet.add(user)
          entityList.append(user)
      else:
        _showInvalidEntity(Ent.USER, user)
        invalid += 1
  elif entityType == Cmd.ENTITY_ALL_USERS:
    cd = buildGAPIObject(API.DIRECTORY)
    query = None if includeSuspendedInAll else u'isSuspended=False'
    try:
      printGettingAllAccountEntities(Ent.USER)
      result = callGAPIpages(cd.users(), u'list', u'users',
                             page_message=getPageMessage(noNL=True),
                             throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customer=GC.Values[GC.CUSTOMER_ID],
                             query=query, fields=u'nextPageToken,users(primaryEmail)',
                             maxResults=GC.Values[GC.USER_MAX_RESULTS])
      while result:
        entityList.append(result.popleft()[u'primaryEmail'])
      printGotAccountEntities(len(entityList))
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)
  elif entityType in [Cmd.ENTITY_GROUP, Cmd.ENTITY_GROUPS, Cmd.ENTITY_GROUP_NS, Cmd.ENTITY_GROUPS_NS, Cmd.ENTITY_GROUP_SUSP, Cmd.ENTITY_GROUPS_SUSP]:
    if entityType in [Cmd.ENTITY_GROUP_NS, Cmd.ENTITY_GROUPS_NS]:
      checkSuspended = False
    elif entityType in [Cmd.ENTITY_GROUP_SUSP, Cmd.ENTITY_GROUPS_SUSP]:
      checkSuspended = True
    cd = buildGAPIObject(API.DIRECTORY)
    groups = convertEntityToList(entity, nonListEntityType=entityType in [Cmd.ENTITY_GROUP, Cmd.ENTITY_GROUP_NS, Cmd.ENTITY_GROUP_SUSP])
    for group in groups:
      if validateEmailAddressOrUID(group):
        try:
          group = normalizeEmailAddressOrUID(group)
          printGettingAllEntityItemsForWhom(memberRoles if memberRoles else Ent.ROLE_MANAGER_MEMBER_OWNER, group, entityType=Ent.GROUP)
          validRoles, listRoles, listFields = _getRoleVerification(memberRoles, u'nextPageToken,members(email,id,type,status)')
          result = callGAPIpages(cd.members(), u'list', u'members',
                                 page_message=getPageMessageForWhom(noNL=True),
                                 throw_reasons=GAPI.MEMBERS_THROW_REASONS,
                                 groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
          while result:
            member = result.popleft()
            email = member[u'email'].lower() if member[u'type'] != u'CUSTOMER' else member[u'id']
            if (((groupMemberType == u'ALL') or (groupMemberType == member[u'type'])) and
                (not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles) and
                (checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED')) and email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
          entityUnknownWarning(Ent.GROUP, group)
          doNotExist += 1
      else:
        _showInvalidEntity(Ent.GROUP, group)
        invalid += 1
  elif entityType in [Cmd.ENTITY_GROUP_USERS, Cmd.ENTITY_GROUP_USERS_NS, Cmd.ENTITY_GROUP_USERS_SUSP]:
    if entityType == Cmd.ENTITY_GROUP_USERS_NS:
      checkSuspended = False
    elif entityType == Cmd.ENTITY_GROUP_USERS_SUSP:
      checkSuspended = True
    cd = buildGAPIObject(API.DIRECTORY)
    groups = convertEntityToList(entity)
    recursive = False
    domains = []
    rolesSet = set()
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in GROUP_ROLES_MAP:
        rolesSet.add(GROUP_ROLES_MAP[myarg])
      elif myarg == u'primarydomain':
        domains.append(GC.Values[GC.DOMAIN])
      elif myarg == u'domains':
        domains.extend(getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY))
      elif myarg == u'recursive':
        recursive = True
      elif myarg == u'end':
        break
      else:
        Cmd.Backup()
        missingArgumentExit(u'end')
    if rolesSet:
      memberRoles = u','.join(sorted(rolesSet))
    for group in groups:
      if validateEmailAddressOrUID(group):
        doNotExist += _addGroupMembersToUsers(normalizeEmailAddressOrUID(group), domains, recursive)
      else:
        _showInvalidEntity(Ent.GROUP, group)
        invalid += 1
  elif entityType in [Cmd.ENTITY_OU, Cmd.ENTITY_OUS, Cmd.ENTITY_OU_AND_CHILDREN, Cmd.ENTITY_OUS_AND_CHILDREN,
                      Cmd.ENTITY_OU_NS, Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OU_AND_CHILDREN_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS,
                      Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OU_AND_CHILDREN_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP]:
    if entityType in [Cmd.ENTITY_OU_NS, Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OU_AND_CHILDREN_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS]:
      checkSuspended = False
    elif entityType in [Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OU_AND_CHILDREN_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP]:
      checkSuspended = True
    cd = buildGAPIObject(API.DIRECTORY)
    ous = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType in [Cmd.ENTITY_OU, Cmd.ENTITY_OU_AND_CHILDREN,
                                                                                        Cmd.ENTITY_OU_NS, Cmd.ENTITY_OU_AND_CHILDREN_NS,
                                                                                        Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OU_AND_CHILDREN_SUSP])
    directlyInOU = entityType in [Cmd.ENTITY_OU, Cmd.ENTITY_OUS, Cmd.ENTITY_OU_NS, Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OUS_SUSP]
    qualifier = [Msg.IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT)),
                 Msg.DIRECTLY_IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT))][directlyInOU]
    fields = u'nextPageToken,users(primaryEmail,orgUnitPath)' if directlyInOU else u'nextPageToken,users(primaryEmail)'
    prevLen = 0
    for ou in ous:
      try:
        ou = makeOrgUnitPathAbsolute(ou)
        if ou.startswith(u'id:'):
          ou = callGAPI(cd.orgunits(), u'get',
                        throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR,
                                       GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=ou, fields=u'orgUnitPath')[u'orgUnitPath']
        printGettingAllEntityItemsForWhom(Ent.USER, ou, qualifier=qualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
        result = callGAPIpages(cd.users(), u'list', u'users',
                               page_message=getPageMessageForWhom(noNL=True),
                               throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND,
                                              GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], query=orgUnitPathQuery(ou, checkSuspended),
                               fields=fields, maxResults=GC.Values[GC.USER_MAX_RESULTS])
        if directlyInOU:
          ou = ou.lower()
          while result:
            user = result.popleft()
            if ou == user[u'orgUnitPath'].lower():
              entityList.append(user[u'primaryEmail'])
        else:
          while result:
            entityList.append(result.popleft()[u'primaryEmail'])
        totalLen = len(entityList)
        printGotEntityItemsForWhom(totalLen-prevLen)
        prevLen = totalLen
      except (GAPI.badRequest, GAPI.invalidInput, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError,
              GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ou)
        doNotExist += 1
  elif entityType in [Cmd.ENTITY_QUERY, Cmd.ENTITY_QUERIES]:
    cd = buildGAPIObject(API.DIRECTORY)
    queries = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType == Cmd.ENTITY_QUERY)
    prevLen = 0
    for query in queries:
      printGettingAllAccountEntities(Ent.USER, query)
      try:
        result = callGAPIpages(cd.users(), u'list', u'users',
                               page_message=getPageMessage(noNL=True),
                               throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND,
                                              GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], query=query,
                               fields=u'nextPageToken,users(primaryEmail,suspended)',
                               maxResults=GC.Values[GC.USER_MAX_RESULTS])
        while result:
          user = result.popleft()
          email = user[u'primaryEmail']
          if (checkSuspended is None or (not checkSuspended and user[u'status'] != u'SUSPENDED') or (checkSuspended and user[u'status'] == u'SUSPENDED')) and email not in entitySet:
            entitySet.add(email)
            entityList.append(email)
        totalLen = len(entityList)
        printGotAccountEntities(totalLen-prevLen)
        prevLen = totalLen
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.invalidInput):
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_QUERY)
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
  elif entityType == Cmd.ENTITY_LICENSES:
    entityList = doPrintLicenses(returnFields=u'userId', skus=entity.split(u','))
  elif entityType in [Cmd.ENTITY_COURSEPARTICIPANTS, Cmd.ENTITY_TEACHERS, Cmd.ENTITY_STUDENTS]:
    croom = buildGAPIObject(API.CLASSROOM)
    courses = convertEntityToList(entity)
    for course in courses:
      courseId = addCourseIdScope(course)
      try:
        if entityType in [Cmd.ENTITY_COURSEPARTICIPANTS, Cmd.ENTITY_TEACHERS]:
          printGettingAllEntityItemsForWhom(Ent.TEACHER, removeCourseIdScope(courseId), entityType=Ent.COURSE)
          result = callGAPIpages(croom.courses().teachers(), u'list', u'teachers',
                                 page_message=getPageMessageForWhom(noNL=True),
                                 throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                 courseId=courseId, fields=u'nextPageToken,teachers/profile/emailAddress',
                                 pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
          while result:
            teacher = result.popleft()
            email = teacher[u'profile'].get(u'emailAddress', None)
            if email and (email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
        if entityType in [Cmd.ENTITY_COURSEPARTICIPANTS, Cmd.ENTITY_STUDENTS]:
          printGettingAllEntityItemsForWhom(Ent.STUDENT, removeCourseIdScope(courseId), entityType=Ent.COURSE)
          result = callGAPIpages(croom.courses().students(), u'list', u'students',
                                 page_message=getPageMessageForWhom(noNL=True),
                                 throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                 courseId=courseId, fields=u'nextPageToken,students/profile/emailAddress',
                                 pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
          while result:
            student = result.popleft()
            email = student[u'profile'].get(u'emailAddress', None)
            if email and (email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
      except GAPI.notFound:
        entityDoesNotExistWarning(Ent.COURSE, removeCourseIdScope(courseId))
        doNotExist += 1
      except (GAPI.forbidden, GAPI.badRequest):
        APIAccessDeniedExit()
  elif entityType == Cmd.ENTITY_CROS:
    buildGAPIObject(API.DIRECTORY)
    result = convertEntityToList(entity)
    for deviceId in result:
      if deviceId not in entitySet:
        entitySet.add(deviceId)
        entityList.append(deviceId)
  elif entityType == Cmd.ENTITY_ALL_CROS:
    cd = buildGAPIObject(API.DIRECTORY)
    try:
      printGettingAllAccountEntities(Ent.CROS_DEVICE)
      result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                             page_message=getPageMessage(noNL=True),
                             throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customerId=GC.Values[GC.CUSTOMER_ID],
                             fields=u'nextPageToken,chromeosdevices(deviceId)',
                             maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
      while result:
        device = result.popleft()
        entityList.append(device[u'deviceId'])
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)
  elif entityType in [Cmd.ENTITY_CROS_QUERY, Cmd.ENTITY_CROS_QUERIES, Cmd.ENTITY_CROS_SN]:
    cd = buildGAPIObject(API.DIRECTORY)
    queries = convertEntityToList(entity, shlexSplit=entityType == Cmd.ENTITY_CROS_QUERIES,
                                  nonListEntityType=entityType == Cmd.ENTITY_CROS_QUERY)
    if entityType == Cmd.ENTITY_CROS_SN:
      queries = [u'id:{0}'.format(query) for query in queries]
    prevLen = 0
    for query in queries:
      printGettingAllAccountEntities(Ent.CROS_DEVICE, query)
      try:
        result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                               page_message=getPageMessage(noNL=True),
                               throw_reasons=[GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customerId=GC.Values[GC.CUSTOMER_ID], query=query,
                               fields=u'nextPageToken,chromeosdevices(deviceId)',
                               maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        while result:
          device = result.popleft()
          deviceId = device[u'deviceId']
          if deviceId not in entitySet:
            entitySet.add(deviceId)
            entityList.append(deviceId)
        totalLen = len(entityList)
        printGotAccountEntities(totalLen-prevLen)
        prevLen = totalLen
      except GAPI.invalidInput:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_QUERY)
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
  elif entityType in [Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OU_AND_CHILDREN, Cmd.ENTITY_CROS_OUS, Cmd.ENTITY_CROS_OUS_AND_CHILDREN]:
    cd = buildGAPIObject(API.DIRECTORY)
    ous = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType in [Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OU_AND_CHILDREN])
    directlyInOU = entityType in [Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OUS]
    numOus = len(ous)
    allQualifier = [Msg.IN_THE.format(Ent.Choose(Ent.ORGANIZATIONAL_UNIT, numOus)),
                    Msg.DIRECTLY_IN_THE.format(Ent.Choose(Ent.ORGANIZATIONAL_UNIT, numOus))][directlyInOU]
    if entityType in [Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OUS]:
      oneQualifier = [Msg.IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT)),
                      Msg.DIRECTLY_IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT))][directlyInOU]
      for ou in ous:
        ou = makeOrgUnitPathAbsolute(ou)
        try:
          printGettingAllEntityItemsForWhom(Ent.CROS_DEVICE, ou, qualifier=oneQualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
          result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                                 page_message=getPageMessage(noNL=True),
                                 throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                 customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=ou,
                                 fields=u'nextPageToken,chromeosdevices(deviceId)',
                                 maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
          while result:
            device = result.popleft()
            entityList.append(device[u'deviceId'])
        except (GAPI.badRequest, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.resourceNotFound, GAPI.forbidden):
          checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ou)
          doNotExist += 1
      Ent.SetGettingQualifier(Ent.CROS_DEVICE, allQualifier)
      Ent.SetGettingForWhom(u','.join(ous))
      printGotEntityItemsForWhom(len(entityList))
    else:
      ouSet = set()
      for ou in ous:
        ou = makeOrgUnitPathAbsolute(ou)
        try:
          result = callGAPI(cd.orgunits(), u'get',
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                            customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(ou)), fields=u'orgUnitPath')
          ouSet.add(result[u'orgUnitPath'].lower())
        except (GAPI.badRequest, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError, GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
          checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ou)
          doNotExist += 1
      if doNotExist == 0:
        try:
          qualifier = Msg.IN_THE.format(Ent.Choose(Ent.ORGANIZATIONAL_UNIT, len(ous)))
          printGettingAllEntityItemsForWhom(Ent.CROS_DEVICE, u','.join(ous), qualifier=allQualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
          result = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                                 page_message=getPageMessage(noNL=True),
                                 throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                 customerId=GC.Values[GC.CUSTOMER_ID],
                                 fields=u'nextPageToken,chromeosdevices(deviceId,orgUnitPath)',
                                 maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
          while result:
            device = result.popleft()
            deviceOu = device[u'orgUnitPath'].lower()
            for ou in ouSet:
              if deviceOu.startswith(ou):
                entityList.append(device[u'deviceId'])
                break
          printGotEntityItemsForWhom(len(entityList))
        except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          accessErrorExit(cd)
  else:
    systemErrorExit(UNKNOWN_ERROR_RC, u'getUsersToModify coding error')
  if doNotExist == 0 and invalid == 0:
    return entityList
  if doNotExist > 0:
    badEntitiesExit(Ent.ENTITY, doNotExist, [Msg.DO_NOT_EXIST, Msg.DOES_NOT_EXIST], backupArg=True)
  if invalid > 0:
    badEntitiesExit(Ent.ENTITY, invalid, [Msg.INVALID, Msg.INVALID], backupArg=True)

def splitEntityList(entity, dataDelimiter, shlexSplit):
  if not entity:
    return []
  if not dataDelimiter:
    return [entity,]
  if not shlexSplit:
    return entity.split(dataDelimiter)
  return shlexSplitList(entity, dataDelimiter)

# <FileName> [charset <String>] [delimiter <Character>]
def getEntitiesFromFile(shlexSplit):
  filename = getString(Cmd.OB_FILE_NAME)
  encoding = getCharSet()
  dataDelimiter = getDelimiter()
  entitySet = set()
  entityList = []
  f = openFile(filename, encoding=encoding)
  for row in f:
    for item in splitEntityList(row.strip(), dataDelimiter, shlexSplit):
      item = item.strip()
      if item and (item not in entitySet):
        entitySet.add(item)
        entityList.append(item)
  closeFile(f)
  return entityList

# <FileName>(:<FieldName>)+ [charset <String>] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>] (matchfield <FieldName> <RegularExpression>)* [delimiter <Character>]
def getEntitiesFromCSVFile(shlexSplit):
  drive, fileFieldName = os.path.splitdrive(getString(Cmd.OB_FILE_NAME_FIELD_NAME))
  if fileFieldName.find(u':') == -1:
    Cmd.Backup()
    invalidArgumentExit(Cmd.OB_FILE_NAME_FIELD_NAME)
  fileFieldNameList = fileFieldName.split(u':')
  f, csvFile = openCSVFileReader(drive+fileFieldNameList[0])
  for fieldName in fileFieldNameList[1:]:
    if fieldName not in csvFile.fieldnames:
      csvFieldErrorExit(fieldName, csvFile.fieldnames, backupArg=True, checkForCharset=True)
  matchFields = getMatchFields(csvFile.fieldnames)
  dataDelimiter = getDelimiter()
  entitySet = set()
  entityList = []
  for row in csvFile:
    if not matchFields or checkMatchFields(row, matchFields):
      for fieldName in fileFieldNameList[1:]:
        for item in splitEntityList(row[fieldName].strip(), dataDelimiter, shlexSplit):
          item = item.strip()
          if item and (item not in entitySet):
            entitySet.add(item)
            entityList.append(item)
  closeFile(f)
  return entityList

# <FileName> [charset <String>] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
#	keyfield <FieldName> [keypattern <RegularExpression>] [keyvalue <String>] [delimiter <Character>]
#	subkeyfield <FieldName> [keypattern <RegularExpression>] [keyvalue <String>] [delimiter <Character>]
#	(matchfield <FieldName> <RegularExpression>)*
#	[datafield <FieldName>(:<FieldName>)* [delimiter <Character>]]
def getEntitiesFromCSVbyField():

  def getKeyFieldInfo(keyword, required, globalKeyField):
    if not checkArgumentPresent(keyword, required=required):
      GM.Globals[globalKeyField] = None
      return (None, None, None, None)
    keyField = GM.Globals[globalKeyField] = getString(Cmd.OB_FIELD_NAME)
    if keyField not in csvFile.fieldnames:
      csvFieldErrorExit(keyField, csvFile.fieldnames, backupArg=True)
    if checkArgumentPresent(u'keypattern'):
      keyPattern = getREPattern()
    else:
      keyPattern = None
    if checkArgumentPresent(u'keyvalue'):
      keyValue = getString(Cmd.OB_STRING)
    else:
      keyValue = keyField
    keyDelimiter = getDelimiter()
    return (keyField, keyPattern, keyValue, keyDelimiter)

  def getKeyList(row, keyField, keyPattern, keyValue, keyDelimiter, matchFields):
    item = row[keyField].strip()
    if not item:
      return []
    if matchFields and not checkMatchFields(row, matchFields):
      return []
    if keyPattern:
      keyList = [keyPattern.sub(keyValue, keyItem.strip()) for keyItem in splitEntityList(item, keyDelimiter, False)]
    else:
      keyList = [re.sub(keyField, keyItem.strip(), keyValue) for keyItem in splitEntityList(item, keyDelimiter, False)]
    return [key for key in keyList if key]

  filename = getString(Cmd.OB_FILE_NAME)
  f, csvFile = openCSVFileReader(filename)
  mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter = getKeyFieldInfo(u'keyfield', True, GM.CSV_KEY_FIELD)
  subKeyField, subKeyPattern, subKeyValue, subKeyDelimiter = getKeyFieldInfo(u'subkeyfield', False, GM.CSV_SUBKEY_FIELD)
  matchFields = getMatchFields(csvFile.fieldnames)
  if checkArgumentPresent(u'datafield'):
    if GM.Globals[GM.CSV_DATA_DICT]:
      csvDataAlreadySavedErrorExit()
    GM.Globals[GM.CSV_DATA_FIELD] = getString(Cmd.OB_FIELD_NAME, checkBlank=True)
    dataFields = GM.Globals[GM.CSV_DATA_FIELD].split(u':')
    for dataField in dataFields:
      if dataField not in csvFile.fieldnames:
        csvFieldErrorExit(dataField, csvFile.fieldnames, backupArg=True)
    dataDelimiter = getDelimiter()
  else:
    GM.Globals[GM.CSV_DATA_FIELD] = None
    dataFields = []
    dataDelimiter = None
  entitySet = set()
  entityList = []
  csvDataKeys = {}
  GM.Globals[GM.CSV_DATA_DICT] = {}
  if not subKeyField:
    for row in csvFile:
      mainKeyList = getKeyList(row, mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter, matchFields)
      if not mainKeyList:
        continue
      for mainKey in mainKeyList:
        if mainKey not in entitySet:
          entitySet.add(mainKey)
          entityList.append(mainKey)
          if GM.Globals[GM.CSV_DATA_FIELD]:
            csvDataKeys[mainKey] = set()
            GM.Globals[GM.CSV_DATA_DICT][mainKey] = []
      for dataField in dataFields:
        if dataField in row:
          dataList = splitEntityList(row[dataField].strip(), dataDelimiter, False)
          for dataValue in dataList:
            dataValue = dataValue.strip()
            if not dataValue:
              continue
            for mainKey in mainKeyList:
              if dataValue not in csvDataKeys[mainKey]:
                csvDataKeys[mainKey].add(dataValue)
                GM.Globals[GM.CSV_DATA_DICT][mainKey].append(dataValue)
  else:
    csvSubKeys = {}
    for row in csvFile:
      mainKeyList = getKeyList(row, mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter, matchFields)
      if not mainKeyList:
        continue
      for mainKey in mainKeyList:
        if mainKey not in entitySet:
          entitySet.add(mainKey)
          entityList.append(mainKey)
          csvSubKeys[mainKey] = set()
          csvDataKeys[mainKey] = {}
          GM.Globals[GM.CSV_DATA_DICT][mainKey] = {}
      subKeyList = getKeyList(row, subKeyField, subKeyPattern, subKeyValue, subKeyDelimiter, {})
      if not subKeyList:
        continue
      for mainKey in mainKeyList:
        for subKey in subKeyList:
          if subKey not in csvSubKeys[mainKey]:
            csvSubKeys[mainKey].add(subKey)
            if GM.Globals[GM.CSV_DATA_FIELD]:
              csvDataKeys[mainKey][subKey] = set()
              GM.Globals[GM.CSV_DATA_DICT][mainKey][subKey] = []
      for dataField in dataFields:
        if dataField in row:
          dataList = splitEntityList(row[dataField].strip(), dataDelimiter, False)
          for dataValue in dataList:
            dataValue = dataValue.strip()
            if not dataValue:
              continue
            for mainKey in mainKeyList:
              for subKey in subKeyList:
                if dataValue not in csvDataKeys[mainKey][subKey]:
                  csvDataKeys[mainKey][subKey].add(dataValue)
                  GM.Globals[GM.CSV_DATA_DICT][mainKey][subKey].append(dataValue)
  closeFile(f)
  return entityList

# Typically used to map courseparticipants to students or teachers
def mapEntityType(entityType, typeMap):
  if (typeMap is not None) and (entityType in typeMap):
    return typeMap[entityType]
  return entityType

def getEntityArgument(entityList):
  if entityList is None:
    return (0, 0, entityList)
  if isinstance(entityList, dict):
    clLoc = Cmd.Location()
    Cmd.SetLocation(GM.Globals[GM.ENTITY_CL_DELAY_START])
    entityList = getUsersToModify(**entityList)
    Cmd.SetLocation(clLoc)
  return (0, len(entityList), entityList)

def getEntityToModify(defaultEntityType=None, returnOnError=False, crosAllowed=False, userAllowed=True, typeMap=None, checkSuspended=None, groupMemberType=u'USER', delayGet=False):
  selectorChoices = Cmd.BASE_ENTITY_SELECTORS[:]
  if userAllowed:
    selectorChoices += Cmd.USER_ENTITY_SELECTORS+Cmd.USER_CSVDATA_ENTITY_SELECTORS
  if crosAllowed:
    selectorChoices += Cmd.CROS_ENTITY_SELECTORS+Cmd.CROS_CSVDATA_ENTITY_SELECTORS
  entitySelector = getChoice(selectorChoices, defaultChoice=None)
  if entitySelector:
    choices = []
    if entitySelector == Cmd.ENTITY_SELECTOR_ALL:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_ALL_SUBTYPES
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_ALL_SUBTYPES
      entityType = Cmd.ENTITY_SELECTOR_ALL_SUBTYPES_MAP[getChoice(choices)]
      if not delayGet:
        return ([Cmd.ENTITY_CROS, Cmd.ENTITY_USERS][entityType == Cmd.ENTITY_ALL_USERS],
                getUsersToModify(entityType, None))
      else:
        GM.Globals[GM.ENTITY_CL_DELAY_START] = Cmd.Location()
        buildGAPIObject(API.DIRECTORY)
        return ([Cmd.ENTITY_CROS, Cmd.ENTITY_USERS][entityType == Cmd.ENTITY_ALL_USERS],
                {u'entityType': entityType, u'entity': None})
    if userAllowed:
      if entitySelector == Cmd.ENTITY_SELECTOR_FILE:
        return (Cmd.ENTITY_USERS,
                getUsersToModify(Cmd.ENTITY_USERS, getEntitiesFromFile(False)))
      if entitySelector in [Cmd.ENTITY_SELECTOR_CSV, Cmd.ENTITY_SELECTOR_CSVFILE]:
        return (Cmd.ENTITY_USERS,
                getUsersToModify(Cmd.ENTITY_USERS, getEntitiesFromCSVFile(False)))
    if crosAllowed:
      if entitySelector == Cmd.ENTITY_SELECTOR_CROSFILE:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS, getEntitiesFromFile(False)))
      if entitySelector == Cmd.ENTITY_SELECTOR_CROSFILE_SN:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS_SN, getEntitiesFromFile(False)))
      if entitySelector in [Cmd.ENTITY_SELECTOR_CROSCSV, Cmd.ENTITY_SELECTOR_CROSCSVFILE]:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS, getEntitiesFromCSVFile(False)))
      if entitySelector in [Cmd.ENTITY_SELECTOR_CROSCSV_SN, Cmd.ENTITY_SELECTOR_CROSCSVFILE_SN]:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS_SN, getEntitiesFromCSVFile(False)))
    if entitySelector == Cmd.ENTITY_SELECTOR_DATAFILE:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices), typeMap)
      return ([Cmd.ENTITY_CROS, Cmd.ENTITY_USERS][entityType not in Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES],
              getUsersToModify(entityType, getEntitiesFromFile(shlexSplit=entityType in [Cmd.ENTITY_OUS, Cmd.ENTITY_OUS_AND_CHILDREN,
                                                                                         Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS,
                                                                                         Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP,
                                                                                         Cmd.ENTITY_CROS_OUS, Cmd.ENTITY_CROS_OUS_AND_CHILDREN])))
    if entitySelector == Cmd.ENTITY_SELECTOR_CSVKMD:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices, choiceAliases=Cmd.ENTITY_ALIAS_MAP), typeMap)
      return ([Cmd.ENTITY_CROS, Cmd.ENTITY_USERS][entityType not in Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES],
              getUsersToModify(entityType, getEntitiesFromCSVbyField()))
    if entitySelector in [Cmd.ENTITY_SELECTOR_CSVDATA, Cmd.ENTITY_SELECTOR_CROSCSVDATA]:
      checkDataField()
      return ([Cmd.ENTITY_CROS, Cmd.ENTITY_USERS][entitySelector == Cmd.ENTITY_SELECTOR_CSVDATA],
              GM.Globals[GM.CSV_DATA_DICT])
  entityChoices = []
  if userAllowed:
    entityChoices += Cmd.USER_ENTITIES
  if crosAllowed:
    entityChoices += Cmd.CROS_ENTITIES
  entityType = mapEntityType(getChoice(entityChoices, choiceAliases=Cmd.ENTITY_ALIAS_MAP, defaultChoice=defaultEntityType), typeMap)
  if entityType:
    if entityType not in Cmd.CROS_ENTITIES:
      entityClass = Cmd.ENTITY_USERS
      entityItem = getString(Cmd.OB_USER_ENTITY, minLen=0)
    else:
      entityClass = Cmd.ENTITY_CROS
      entityItem = getString(Cmd.OB_CROS_ENTITY, minLen=0)
    if not delayGet:
      if entityClass == Cmd.ENTITY_USERS:
        return (entityClass,
                getUsersToModify(entityType, entityItem, checkSuspended=checkSuspended, groupMemberType=groupMemberType))
      else:
        return (entityClass,
                getUsersToModify(entityType, entityItem))
    else:
      GM.Globals[GM.ENTITY_CL_DELAY_START] = Cmd.Location()
      buildGAPIObject(API.DIRECTORY)
      if entityClass == Cmd.ENTITY_USERS:
        if entityType in [Cmd.ENTITY_GROUP_USERS, Cmd.ENTITY_GROUP_USERS_NS, Cmd.ENTITY_GROUP_USERS_SUSP]:
          # Skip over sub-arguments
          while Cmd.ArgumentsRemaining():
            myarg = getArgument()
            if myarg in GROUP_ROLES_MAP or myarg in [u'primarydomain', u'domains', u'recursive']:
              pass
            elif myarg == u'end':
              break
            else:
              Cmd.Backup()
              missingArgumentExit(u'end')
        return (entityClass,
                {u'entityType': entityType, u'entity': entityItem, u'checkSuspended': checkSuspended, u'groupMemberType': groupMemberType})
      else:
        return (entityClass,
                {u'entityType': entityType, u'entity': entityItem})
  if returnOnError:
    return (None, None)
  invalidChoiceExit(selectorChoices+entityChoices, False)

def getEntitySelector():
  return getChoice(Cmd.ENTITY_LIST_SELECTORS, defaultChoice=None)

def getEntitySelection(entitySelector, shlexSplit):
  if entitySelector in [Cmd.ENTITY_SELECTOR_FILE]:
    return getEntitiesFromFile(shlexSplit)
  if entitySelector in [Cmd.ENTITY_SELECTOR_CSV, Cmd.ENTITY_SELECTOR_CSVFILE]:
    return getEntitiesFromCSVFile(shlexSplit)
  if entitySelector == Cmd.ENTITY_SELECTOR_CSVKMD:
    return getEntitiesFromCSVbyField()
  if entitySelector in [Cmd.ENTITY_SELECTOR_CSVSUBKEY]:
    checkSubkeyField()
    return GM.Globals[GM.CSV_DATA_DICT]
  if entitySelector in [Cmd.ENTITY_SELECTOR_CSVDATA]:
    checkDataField()
    return GM.Globals[GM.CSV_DATA_DICT]
  return []

def getEntityList(item, shlexSplit=False):
  entitySelector = getEntitySelector()
  if entitySelector:
    return getEntitySelection(entitySelector, shlexSplit)
  return convertEntityToList(getString(item, minLen=0), shlexSplit=shlexSplit)

def getUserObjectEntity(clObject, itemType):
  entity = {u'item': itemType, u'list': getEntityList(clObject), u'dict': None}
  if isinstance(entity[u'list'], dict):
    entity[u'dict'] = entity[u'list']
  return entity

def _validateUserGetObjectList(user, i, count, entity):
  if entity[u'dict']:
    entityList = entity[u'dict'][user]
  else:
    entityList = entity[u'list']
  user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
  if not gmail:
    return (user, None, [], 0)
  jcount = len(entityList)
  entityPerformActionNumItems([Ent.USER, user], jcount, entity[u'item'], i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (user, gmail, entityList, jcount)

def _validateUserGetMessageIds(user, i, count, entity):
  if entity:
    if entity[u'dict']:
      entityList = entity[u'dict'][user]
    else:
      entityList = entity[u'list']
  else:
    entityList = []
  user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
  if not gmail:
    return (user, None, None)
  return (user, gmail, entityList)

def _validateDelegatorGetObjectList(user, i, count, entity):
  if entity[u'dict']:
    entityList = entity[u'dict'][user]
  else:
    entityList = entity[u'list']
  jcount = len(entityList)
  delegatorEmail, delegatorName, delegatorDomain = splitEmailAddressOrUID(user)
  entityPerformActionNumItems([Ent.DELEGATOR, delegatorEmail], jcount, entity[u'item'], i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (delegatorEmail, delegatorName, delegatorDomain, entityList, jcount)

def checkUserExists(cd, user, i=0, count=0):
  user = normalizeEmailAddressOrUID(user)
  try:
    return callGAPI(cd.users(), u'get',
                    throw_reasons=GAPI.USER_GET_THROW_REASONS,
                    userKey=user, fields=u'primaryEmail')[u'primaryEmail']
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
    entityUnknownWarning(Ent.USER, user, i, count)
    return None

def getTodriveParameters():
  def invalidTodriveFileIdExit(entityType, message):
    Cmd.SetLocation(tdfileidLocation-1)
    usageErrorExit(Msg.INVALID_ENTITY_MESSAGE.format(Ent.Singular(entityType), message))

  def invalidTodriveParentExit(entityType, message):
    Cmd.SetLocation(tdparentLocation-1)
    if not localParent:
      usageErrorExit(Msg.INVALID_ENTITY_MESSAGE.format(Ent.Singular(entityType),
                                                       formatKeyValueList(u'',
                                                                          [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                                                           Ent.Singular(Ent.ITEM), GC.TODRIVE_PARENT,
                                                                           Ent.Singular(Ent.VALUE), todrive[u'parent'],
                                                                           message],
                                                                          u'')))
    else:
      usageErrorExit(Msg.INVALID_ENTITY_MESSAGE.format(Ent.Singular(entityType), message))

  def invalidTodriveUserExit(entityType, message):
    Cmd.SetLocation(tduserLocation-1)
    if not localUser:
      usageErrorExit(Msg.INVALID_ENTITY_MESSAGE.format(Ent.Singular(entityType),
                                                       formatKeyValueList(u'',
                                                                          [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                                                           Ent.Singular(Ent.ITEM), GC.TODRIVE_USER,
                                                                           Ent.Singular(Ent.VALUE), todrive[u'user'],
                                                                           message],
                                                                          u'')))
    else:
      usageErrorExit(Msg.INVALID_ENTITY_MESSAGE.format(Ent.Singular(entityType), message))

  localUser = localParent = False
  tduserLocation = tdparentLocation = tdfileidLocation = Cmd.Location()
  todrive = {u'title': None, u'user': GC.Values[GC.TODRIVE_USER], u'parent': GC.Values[GC.TODRIVE_PARENT],
             u'timestamp': GC.Values[GC.TODRIVE_TIMESTAMP], u'daysoffset': 0, u'hoursoffset': 0,
             u'localcopy': GC.Values[GC.TODRIVE_LOCALCOPY],
             u'fileId': None, u'parentId': None, u'nobrowser': GC.Values[GC.NO_BROWSER]}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'tdtitle':
      todrive[u'title'] = getString(Cmd.OB_STRING)
    elif myarg == u'tduser':
      todrive[u'user'] = getString(Cmd.OB_EMAIL_ADDRESS)
      tduserLocation = Cmd.Location()
      localUser = True
    elif myarg == u'tdparent':
      todrive[u'parent'] = escapeDriveFileName(getString(Cmd.OB_DRIVE_FOLDER_NAME, minLen=0))
      tdparentLocation = Cmd.Location()
      localParent = True
    elif myarg == u'tdtimestamp':
      todrive[u'timestamp'] = getBoolean()
    elif myarg == u'tddaysoffset':
      todrive[u'daysoffset'] = getInteger(minVal=0)
    elif myarg == u'tdhoursoffset':
      todrive[u'hoursoffset'] = getInteger(minVal=0)
    elif myarg == u'tdlocalcopy':
      todrive[u'localcopy'] = getBoolean()
    elif myarg == u'tdfileid':
      todrive[u'fileId'] = getString(Cmd.OB_DRIVE_FILE_ID)
      tdfileidLocation = Cmd.Location()
    elif myarg == u'tdnobrowser':
      todrive[u'nobrowser'] = getBoolean()
    else:
      Cmd.Backup()
      break
  if not todrive[u'user']:
    todrive[u'user'] = _getValueFromOAuth(u'email')
  user = checkUserExists(buildGAPIObject(API.DIRECTORY), todrive[u'user'])
  if not user:
    invalidTodriveUserExit(Ent.USER, Msg.NOT_FOUND)
  todrive[u'user'] = user
  if todrive[u'fileId']:
    _, drive = buildGAPIServiceObject(API.DRIVE3, todrive[u'user'], 0, 0)
    try:
      result = callGAPI(drive.files(), u'get',
                        throw_reasons=[GAPI.FILE_NOT_FOUND],
                        fileId=todrive[u'fileId'], fields=VX_ID_MIMETYPE_CANEDIT, supportsTeamDrives=True)
      if result[u'mimeType'] == MIMETYPE_GA_FOLDER:
        invalidTodriveFileIdExit(Ent.DRIVE_FILE_ID, Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FILE)))
      if not result[u'capabilities'][u'canEdit']:
        invalidTodriveFileIdExit(Ent.DRIVE_FILE_ID, Msg.NOT_WRITABLE)
    except GAPI.fileNotFound:
      invalidTodriveFileIdExit(Ent.DRIVE_FILE_ID, Msg.NOT_FOUND)
  elif not todrive[u'parent'] or todrive[u'parent'] == u'root':
    todrive[u'parentId'] = u'root'
  else:
    _, drive = buildGAPIServiceObject(API.DRIVE3, todrive[u'user'], 0, 0)
    if todrive[u'parent'].startswith(u'id:'):
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=[GAPI.FILE_NOT_FOUND],
                          fileId=todrive[u'parent'][3:], fields=VX_ID_MIMETYPE_CANEDIT, supportsTeamDrives=True)
        if result[u'mimeType'] != MIMETYPE_GA_FOLDER:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER)))
        if not result[u'capabilities'][u'canEdit']:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, Msg.NOT_WRITABLE)
        todrive[u'parentId'] = result[u'id']
      except GAPI.fileNotFound:
        invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, Msg.NOT_FOUND)
    else:
      try:
        results = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                throw_reasons=[GAPI.INVALID_QUERY],
                                q=VX_WITH_ANY_FILE_NAME.format(todrive[u'parent']),
                                fields=VX_NPT_FILES_ID_MIMETYPE_CANEDIT, pageSize=1, supportsTeamDrives=True)
        if not results:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_FOUND)
        if results[0][u'mimeType'] != MIMETYPE_GA_FOLDER:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER)))
        if not results[0][u'capabilities'][u'canEdit']:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_WRITABLE)
        todrive[u'parentId'] = results[0][u'id']
      except GAPI.invalidQuery:
        invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_FOUND)
  return todrive

# Send an email
def send_email(msgSubject, msgBody, msgTo, i=0, count=0, msgFrom=None, msgReplyTo=None, html=False, charset=u'utf-8'):
  from email.mime.text import MIMEText
  if msgFrom is None:
    msgFrom = _getValueFromOAuth(u'email')
  userId, gmail = buildGAPIServiceObject(API.GMAIL, msgFrom, 0, 0)
  if not gmail:
    return
  msg = MIMEText(msgBody, [u'plain', u'html'][html], charset)
  msg[u'Subject'] = msgSubject
  msg[u'From'] = userId
  msg[u'To'] = msgTo
  if msgReplyTo is not None:
    msg[u'Reply-To'] = msgReplyTo
  action = Act.Get()
  Act.Set(Act.SENDEMAIL)
  try:
    callGAPI(gmail.users().messages(), u'send',
             userId=userId, body={u'raw': base64.urlsafe_b64encode(msg.as_bytes()).decode()}, fields=u'')
    entityActionPerformed([Ent.RECIPIENT, msgTo, Ent.MESSAGE, msgSubject], i, count)
  except googleapiclient.errors.HttpError as e:
    entityActionFailedWarning([Ent.RECIPIENT, msgTo, Ent.MESSAGE, msgSubject], str(e), i, count)
  Act.Set(action)

def addFieldToFieldsList(fieldName, fieldsChoiceMap, fieldsList):
  fields = fieldsChoiceMap[fieldName.lower()]
  if isinstance(fields, list):
    fieldsList.extend(fields)
  else:
    fieldsList.append(fields)

def _getFieldsList():
  return getString(Cmd.OB_FIELD_NAME_LIST).lower().replace(u',', u' ').split()

def _addInitialField(fieldsList, initialField):
  if isinstance(initialField, list):
    fieldsList.extend(initialField)
  else:
    fieldsList.append(initialField)

# fieldName is command line argument
# fieldNameMap maps fieldName to API field names
#FIELD_CHOICES_MAP = {
#  u'foo': u'foo',
#  u'foobar': u'fooBar',
#  }
# fieldsList is the list of API fields
def getFieldsList(fieldName, fieldsChoiceMap, fieldsList, initialField=None):
  if fieldName in fieldsChoiceMap:
    if not fieldsList and initialField is not None:
      _addInitialField(fieldsList, initialField)
    fieldsList.append(fieldsChoiceMap[fieldName])
  elif fieldName == u'fields':
    if not fieldsList and initialField is not None:
      _addInitialField(fieldsList, initialField)
    for field in _getFieldsList():
      if field in fieldsChoiceMap:
        fieldsList.append(fieldsChoiceMap[field])
      else:
        invalidChoiceExit(fieldsChoiceMap, True)
  else:
    return False
  return True

def getFieldsListTitles(fieldName, fieldsChoiceMap, fieldsList, titles, initialField=None):
  if fieldName in fieldsChoiceMap:
    if not fieldsList and initialField is not None:
      _addInitialField(fieldsList, initialField)
    addFieldToCSVfile(fieldName, fieldsChoiceMap, fieldsList, titles)
  elif fieldName == u'fields':
    if not fieldsList and initialField is not None:
      _addInitialField(fieldsList, initialField)
    for field in  _getFieldsList():
      if field in fieldsChoiceMap:
        addFieldToCSVfile(field, fieldsChoiceMap, fieldsList, titles)
      else:
        invalidChoiceExit(fieldsChoiceMap, True)
  else:
    return False
  return True

# Write a CSV file
def addTitleToCSVfile(title, titles):
  titles[u'set'].add(title)
  titles[u'list'].append(title)

def addTitlesToCSVfile(addTitles, titles):
  if isinstance(addTitles, list):
    for title in addTitles:
      if title not in titles[u'set']:
        addTitleToCSVfile(title, titles)
  elif addTitles not in titles[u'set']:
    addTitleToCSVfile(addTitles, titles)

def removeTitlesFromCSVfile(removeTitles, titles):
  for title in removeTitles:
    if title in titles[u'set']:
      titles[u'set'].remove(title)
      titles[u'list'].remove(title)

def addRowTitlesToCSVfile(row, csvRows, titles):
  csvRows.append(row)
  for title in row:
    if title not in titles[u'set']:
      addTitleToCSVfile(title, titles)

# fieldName is command line argument
# fieldNameMap maps fieldName to API field names; CSV file header will be API field name
#ARGUMENT_TO_PROPERTY_MAP = {
#  u'admincreated': u'adminCreated',
#  u'aliases': [u'aliases', u'nonEditableAliases'],
#  }
# fieldsList is the list of API fields
def addFieldToCSVfile(fieldName, fieldNameMap, fieldsList, titles):
  fields = fieldNameMap[fieldName.lower()]
  if isinstance(fields, list):
    for field in fields:
      if field not in fieldsList:
        fieldsList.append(field)
        addTitlesToCSVfile(field, titles)
  elif fields not in fieldsList:
    fieldsList.append(fields)
    addTitlesToCSVfile(fields, titles)

# fieldName is command line argument
# fieldNameTitleMap maps fieldName to API field name and CSV file header
#ARGUMENT_TO_PROPERTY_TITLE_MAP = {
#  u'admincreated': [u'adminCreated', u'Admin_Created'],
#  u'aliases': [u'aliases', u'Aliases', u'nonEditableAliases', u'NonEditableAliases'],
#  }
# fieldsList is the list of API fields
# fieldsTitles maps the API field name to the CSV file header
# nativeTitles is the list of native (unmapped) titles
def addFieldTitleToCSVfile(fieldName, fieldNameTitleMap, fieldsList, fieldsTitles, titles, nativeTitles):
  ftList = fieldNameTitleMap[fieldName.lower()]
  for i in range(0, len(ftList), 2):
    if ftList[i] not in fieldsTitles:
      fieldsList.append(ftList[i])
      fieldsTitles[ftList[i]] = ftList[i+1]
      addTitlesToCSVfile(ftList[i+1], titles)
    if ftList[i] not in nativeTitles:
      nativeTitles.append(ftList[i])

def convertToNativeTitles(fieldsTitles, titles, nativeTitles):
  for field in fieldsTitles:
    fieldsTitles[field] = field
  titles[u'set'] = set(nativeTitles)
  titles[u'list'] = nativeTitles

def initializeTitlesCSVfile(baseTitles):
  titles = {u'set': set(), u'list': []}
  csvRows = []
  if baseTitles is not None:
    addTitlesToCSVfile(baseTitles, titles)
  return (titles, csvRows)

def sortCSVTitles(sortTitles, titles):
  restoreTitles = []
  for title in sortTitles:
    if title in titles[u'set']:
      titles[u'list'].remove(title)
      restoreTitles.append(title)
  titles[u'list'].sort()
  for title in restoreTitles[::-1]:
    titles[u'list'].insert(0, title)

def writeCSVfile(csvRows, titles, list_type, todrive, sortTitles=None, quotechar=None, fixPaths=False):

  def writeCSVData(writer):
    try:
      if GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER]:
        writer.writerow(dict((item, item) for item in writer.fieldnames))
      writer.writerows(csvRows)
      return True
    except IOError as e:
      stderrErrorMsg(e)
      return False

  def writeCSVToStdout():
    csvFile = StringIOobject()
    writer = csv.DictWriter(csvFile, titles[u'list'],
                            quoting=csv.QUOTE_MINIMAL, quotechar=quotechar,
                            delimiter=delimiter, lineterminator='\n')
    if writeCSVData(writer):
      try:
        GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].write(csvFile.getvalue())
      except IOError as e:
        stderrErrorMsg(e)
        setSysExitRC(FILE_ERROR_RC)
    closeFile(csvFile)

  def writeCSVToFile():
    csvFile = openFile(GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME], GM.Globals[GM.CSVFILE][GM.REDIRECT_MODE], continueOnError=True)
    if csvFile:
      writer = csv.DictWriter(csvFile, titles[u'list'],
                              quoting=csv.QUOTE_MINIMAL, quotechar=quotechar,
                              delimiter=delimiter, lineterminator=str(GC.Values[GC.CSV_OUTPUT_LINE_TERMINATOR]))
      writeCSVData(writer)
      closeFile(csvFile)

  def writeCSVToDrive():
    csvFile = StringIOobject()
    writer = csv.DictWriter(csvFile, titles[u'list'],
                            quoting=csv.QUOTE_MINIMAL, quotechar=quotechar,
                            delimiter=delimiter, lineterminator='\n')
    if writeCSVData(writer):
      if GC.Values[GC.TODRIVE_CONVERSION]:
        columns = len(titles[u'list'])
        rows = len(csvRows)
        cell_count = rows * columns
        mimeType = MIMETYPE_GA_SPREADSHEET
        if cell_count > 2000000 or columns > 256:
          printKeyValueList([WARNING, Msg.RESULTS_TOO_LARGE_FOR_GOOGLE_SPREADSHEET])
          mimeType = u'text/csv'
      else:
        mimeType = u'text/csv'
      title = todrive[u'title'] or u'{0} - {1}'.format(GC.Values[GC.DOMAIN], list_type)
      if todrive[u'timestamp']:
        timestamp = datetime.datetime.now(GC.Values[GC.TIMEZONE])+datetime.timedelta(days=-todrive[u'daysoffset'], hours=-todrive[u'hoursoffset'])
        title += u' - '+ISOformatTimeStamp(timestamp)
      _, drive = buildGAPIServiceObject(API.DRIVE3, todrive[u'user'], 0, 0)
      try:
        if not todrive[u'fileId']:
          result = callGAPI(drive.files(), u'create',
                            throw_reasons=[GAPI.INSUFFICIENT_PERMISSIONS, GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR],
                            body={u'parents': [todrive[u'parentId']], u'description': u' '.join(Cmd.AllArguments()), V3_FILENAME: title, u'mimeType': mimeType},
                            media_body=googleapiclient.http.MediaIoBaseUpload(csvFile, mimetype=u'text/csv', resumable=True), fields=VX_WEB_VIEW_LINK, supportsTeamDrives=True)
        else:
          result = callGAPI(drive.files(), u'update',
                            throw_reasons=[GAPI.INSUFFICIENT_PERMISSIONS, GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR],
                            fileId=todrive[u'fileId'], body={u'description': u' '.join(Cmd.AllArguments()), V3_FILENAME: title, u'mimeType': mimeType},
                            media_body=googleapiclient.http.MediaIoBaseUpload(csvFile, mimetype=u'text/csv', resumable=True), fields=VX_WEB_VIEW_LINK, supportsTeamDrives=True)
        file_url = result[VX_WEB_VIEW_LINK]
        if todrive[u'nobrowser']:
          msg_txt = u'{0}:\n{1}'.format(Msg.DATA_UPLOADED_TO_DRIVE_FILE, file_url)
          send_email(title, msg_txt, todrive[u'user'])
          printKeyValueList([msg_txt])
        else:
          import webbrowser
          webbrowser.open(file_url)
      except GAPI.insufficientPermissions:
        printWarningMessage(INSUFFICIENT_PERMISSIONS_RC, Msg.INSUFFICIENT_PERMISSIONS_TO_PERFORM_TASK)
      except (GAPI.fileNotFound, GAPI.unknownError) as e:
        if not todrive[u'fileId']:
          entityActionFailedWarning([Ent.DRIVE_FOLDER, todrive[u'parentId']], str(e))
        else:
          entityActionFailedWarning([Ent.DRIVE_FILE, todrive[u'fileId']], str(e))
    closeFile(csvFile)

  if GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] is not None:
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_NAME, list_type))
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_TODRIVE, todrive))
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_TITLES, titles[u'list']))
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_SORTTITLES, sortTitles))
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_QUOTECHAR, quotechar))
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_FIXPATHS, fixPaths))
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_DATA, csvRows))
    return
  if sortTitles is not None:
    sortCSVTitles(sortTitles, titles)
# Put paths before path.0
  if fixPaths:
    try:
      index = titles[u'list'].index(u'path.0')
      titles[u'list'].remove(u'paths')
      titles[u'list'].insert(index, u'paths')
    except ValueError:
      pass
  if quotechar is None:
    quotechar = GM.Globals[GM.CSVFILE][GM.REDIRECT_QUOTE_CHAR]
  quotechar = str(quotechar)
  delimiter = str(GM.Globals[GM.CSVFILE][GM.REDIRECT_COLUMN_DELIMITER])
  if (not todrive) or todrive[u'localcopy']:
    if GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME] == u'-':
      if GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]:
        writeCSVToStdout()
      else:
        GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME] = GM.Globals[GM.STDOUT][GM.REDIRECT_NAME]
        writeCSVToFile()
    else:
      writeCSVToFile()
  if todrive:
    writeCSVToDrive()
  if GM.Globals[GM.CSVFILE][GM.REDIRECT_MODE] == DEFAULT_FILE_APPEND_MODE:
    GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER] = False

DEFAULT_SKIP_OBJECTS = set([u'kind', u'etag', u'etags'])

# Clean a JSON object
def cleanJSON(structure, key, listLimit=None, skipObjects=None, timeObjects=None):
  if skipObjects is None:
    skipObjects = set()
  if timeObjects is None:
    timeObjects = set()
  if not isinstance(structure, (dict, list, collections.deque)):
    if key not in timeObjects:
      if isinstance(structure, string_types) and GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]:
        return escapeCRsNLs(structure)
      else:
        return structure
    else:
      if isinstance(structure, string_types) and not structure.isdigit():
        return formatLocalTime(structure)
      else:
        return formatLocalTimestamp(structure)
  elif isinstance(structure, list):
    listLen = len(structure)
    listLen = min(listLen, listLimit or listLen)
    return [cleanJSON(v, u'', listLimit, skipObjects, timeObjects) for v in structure[0:listLen]]
  elif isinstance(structure, collections.deque):
    listLen = len(structure)
    listLen = min(listLen, listLimit or listLen)
    return [cleanJSON(structure[i], u'', listLimit, skipObjects, timeObjects) for i in range(listLen)]
  else:
    return {k: cleanJSON(v, k, listLimit, skipObjects, timeObjects) for k, v in sorted(iteritems(structure)) if k not in DEFAULT_SKIP_OBJECTS and k not in skipObjects}

# Flatten a JSON object
def flattenJSON(structure, key=u'', path=u'', flattened=None, listLimit=None, skipObjects=None, timeObjects=None, noLenObjects=None, simpleLists=None):
  if flattened is None:
    flattened = {}
  if skipObjects is None:
    skipObjects = set()
  if timeObjects is None:
    timeObjects = set()
  if noLenObjects is None:
    noLenObjects = set()
  if simpleLists is None:
    simpleLists = set()
  if not isinstance(structure, (dict, list, collections.deque)):
    if key not in timeObjects:
      if isinstance(structure, string_types) and (structure.find(u'\n') >= 0 or structure.find(u'\r') >= 0):
        if GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]:
          flattened[((path+u'.') if path else u'')+key] = escapeCRsNLs(structure)
        else:
          flattened[((path+u'.') if path else u'')+key] = structure
      else:
        flattened[((path+u'.') if path else u'')+key] = structure
    else:
      if isinstance(structure, string_types) and not structure.isdigit():
        flattened[((path+u'.') if path else u'')+key] = formatLocalTime(structure)
      else:
        flattened[((path+u'.') if path else u'')+key] = formatLocalTimestamp(structure)
  elif isinstance(structure, (list, collections.deque)):
    listLen = len(structure)
    listLen = min(listLen, listLimit or listLen)
    if key in simpleLists:
      flattened[((path+u'.') if path else u'')+key] = u','.join(structure[:listLen])
    else:
      if key not in noLenObjects:
        flattened[((path+u'.') if path else u'')+key] = listLen
      for i in range(listLen):
        flattenJSON(structure[i], u'{0}'.format(i), u'.'.join([item for item in [path, key] if item]), flattened, listLimit, skipObjects, timeObjects, noLenObjects, simpleLists)
  else:
    for k, v in sorted(iteritems(structure)):
      if k not in DEFAULT_SKIP_OBJECTS and k not in skipObjects:
        flattenJSON(v, k, u'.'.join([item for item in [path, key] if item]), flattened, listLimit, skipObjects, timeObjects, noLenObjects, simpleLists)
  return flattened

# Show a json object
def showJSON(object_name, object_value, skipObjects=None, timeObjects=None, dictObjectsKey=None, subObjectKey=None, level=0):
  if skipObjects is None:
    skipObjects = set()
  if timeObjects is None:
    timeObjects = set()
  if dictObjectsKey is None:
    dictObjectsKey = {}
  if object_name in DEFAULT_SKIP_OBJECTS or object_name in skipObjects:
    return
  if object_name is not None:
    printJSONKey(object_name)
    subObjectKey = dictObjectsKey.get(object_name)
  if isinstance(object_value, (list, collections.deque)):
    if len(object_value) == 1 and isinstance(object_value[0], non_compound_types):
      if object_name is not None:
        printJSONValue(object_value[0])
      else:
        printKeyValueList([object_value[0]])
      return
    if object_name is not None:
      printBlankLine()
      Ind.Increment()
    for subValue in object_value:
      if isinstance(subValue, non_compound_types):
        printKeyValueList([subValue])
      else:
        showJSON(None, subValue, skipObjects, timeObjects, dictObjectsKey, subObjectKey, level+1)
    if object_name is not None:
      Ind.Decrement()
  elif isinstance(object_value, dict):
    indentAfterFirst = unindentAfterLast = False
    if object_name is not None:
      printBlankLine()
      Ind.Increment()
    elif level > 0:
      indentAfterFirst = unindentAfterLast = True
    subObjects = sorted(object_value)
    if subObjectKey and (subObjectKey in subObjects):
      subObjects.remove(subObjectKey)
      subObjects.insert(0, subObjectKey)
      subObjectKey = None
    for subObject in subObjects:
      if subObject not in skipObjects:
        showJSON(subObject, object_value[subObject], skipObjects, timeObjects, dictObjectsKey, subObjectKey, level+1)
        if indentAfterFirst:
          Ind.Increment()
          indentAfterFirst = False
    if object_name is not None or ((not indentAfterFirst) and unindentAfterLast):
      Ind.Decrement()
  else:
    if object_name not in timeObjects:
      if isinstance(object_value, string_types) and (object_value.find(u'\n') >= 0 or object_value.find(u'\r') >= 0):
        if GC.Values[GC.SHOW_CONVERT_CR_NL]:
          printJSONValue(escapeCRsNLs(object_value))
        else:
          printBlankLine()
          Ind.Increment()
          printKeyValueList([Ind.MultiLineText(object_value)])
          Ind.Decrement()
      else:
        printJSONValue(object_value)
    else:
      if isinstance(object_value, string_types) and not object_value.isdigit():
        printJSONValue(formatLocalTime(object_value))
      else:
        printJSONValue(formatLocalTimestamp(object_value))

# Batch processing request_id fields
RI_ENTITY = 0
RI_I = 1
RI_COUNT = 2
RI_J = 3
RI_JCOUNT = 4
RI_ITEM = 5
RI_ROLE = 6

def batchRequestID(entityName, i, count, j, jcount, item, role=u''):
  return u'{0}\n{1}\n{2}\n{3}\n{4}\n{5}\n{6}'.format(entityName, i, count, j, jcount, item, role)

# gam version
def doVersion(checkForArgs=True):
  forceCheck = simple = False
  if checkForArgs:
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'check':
        forceCheck = True
      elif myarg == u'simple':
        simple = True
      else:
        unknownArgumentExit()
  if simple:
    writeStdout(__version__)
    return
  import struct
  version_data = u'GAM {0} - {1}\n{2}\nPython {3}.{4}.{5} {6}-bit {7}\ngoogle-api-python-client {8}\noauth2client {9}\n{10} {11}\nPath: {12}\n'
  writeStdout(version_data.format(__version__, GAM_URL, __author__, sys.version_info[0],
                                  sys.version_info[1], sys.version_info[2], struct.calcsize(u'P')*8,
                                  sys.version_info[3], googleapiclient.__version__, oauth2client.__version__, platform.platform(),
                                  platform.machine(), GM.Globals[GM.GAM_PATH]))
  if forceCheck:
    doGAMCheckForUpdates(forceCheck=True)

# gam help
def doUsage():
  printBlankLine()
  doVersion(checkForArgs=False)
  writeStdout(Msg.HELP_SYNTAX.format(os.path.join(GM.Globals[GM.GAM_PATH], FN_GAMCOMMANDS_TXT)))
  writeStdout(Msg.HELP_WIKI.format(GAM_WIKI))

class NullHandler(logging.Handler):
  def emit(self, record):
    pass

def initializeLogging():
  nh = NullHandler()
  logging.getLogger().addHandler(nh)

def saveNonPickleableValues():
  savedValues = {GM.STDOUT: {}, GM.STDERR: {}}
  savedValues[GM.STDOUT][GM.REDIRECT_FD] = GM.Globals[GM.STDOUT].get(GM.REDIRECT_FD, None)
  GM.Globals[GM.STDOUT].pop(GM.REDIRECT_FD, None)
  savedValues[GM.STDERR][GM.REDIRECT_FD] = GM.Globals[GM.STDERR].get(GM.REDIRECT_FD, None)
  GM.Globals[GM.STDERR].pop(GM.REDIRECT_FD, None)
  savedValues[GM.STDOUT][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, None)
  GM.Globals[GM.STDOUT].pop(GM.REDIRECT_MULTI_FD, None)
  savedValues[GM.STDERR][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, None)
  GM.Globals[GM.STDERR].pop(GM.REDIRECT_MULTI_FD, None)
  return savedValues

def restoreNonPickleableValues(savedValues):
  GM.Globals[GM.STDOUT][GM.REDIRECT_FD] = savedValues[GM.STDOUT][GM.REDIRECT_FD]
  GM.Globals[GM.STDERR][GM.REDIRECT_FD] = savedValues[GM.STDERR][GM.REDIRECT_FD]
  GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD] = savedValues[GM.STDOUT][GM.REDIRECT_MULTI_FD]
  GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = savedValues[GM.STDERR][GM.REDIRECT_MULTI_FD]

def CSVFileQueueHandler(mpQueue):
  global Cmd
  if sys.platform.startswith(u'win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
  if GM.Globals[GM.WINDOWS]:
    Cmd = glclargs.GamCLArgs()
  titles, csvRows = initializeTitlesCSVfile(None)
  list_type = u'CSV'
  todrive = {}
  quotechar = sortTitles = None
  fixPaths = False
  while True:
    dataType, dataItem = mpQueue.get()
    if dataType == GM.REDIRECT_QUEUE_NAME:
      list_type = dataItem
    elif dataType == GM.REDIRECT_QUEUE_TODRIVE:
      todrive = dataItem
    elif dataType == GM.REDIRECT_QUEUE_TITLES:
      addTitlesToCSVfile(dataItem, titles)
    elif dataType == GM.REDIRECT_QUEUE_SORTTITLES:
      sortTitles = dataItem
    elif dataType == GM.REDIRECT_QUEUE_QUOTECHAR:
      quotechar = dataItem
    elif dataType == GM.REDIRECT_QUEUE_FIXPATHS:
      fixPaths = dataItem
    elif dataType == GM.REDIRECT_QUEUE_DATA:
      csvRows.extend(dataItem)
    elif dataType == GM.REDIRECT_QUEUE_ARGS:
      Cmd.InitializeArguments(dataItem)
    elif dataType == GM.REDIRECT_QUEUE_GLOBALS:
      GM.Globals = dataItem
    elif dataType == GM.REDIRECT_QUEUE_VALUES:
      GC.Values = dataItem
    else:
      break
  writeCSVfile(csvRows, titles, list_type, todrive, sortTitles, quotechar, fixPaths)

def initializeCSVFileQueueHandler():
  mpQueue = multiprocessing.Manager().Queue()
  mpQueueHandler = multiprocessing.Process(target=CSVFileQueueHandler, args=(mpQueue,))
  mpQueueHandler.start()
  return (mpQueue, mpQueueHandler)

def terminateCSVFileQueueHandler(mpQueue, mpQueueHandler):
  GM.Globals[GM.PARSER] = None
  GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = None
  if GM.Globals[GM.WINDOWS]:
    mpQueue.put((GM.REDIRECT_QUEUE_ARGS, Cmd.AllArguments()))
    savedValues = saveNonPickleableValues()
    mpQueue.put((GM.REDIRECT_QUEUE_GLOBALS, GM.Globals))
    restoreNonPickleableValues(savedValues)
    mpQueue.put((GM.REDIRECT_QUEUE_VALUES, GC.Values))
  mpQueue.put((GM.REDIRECT_QUEUE_EOF, None))
  mpQueueHandler.join()

def StdQueueHandler(mpQueue, stdtype, gmGlobals, gcValues):

  PROCESS_MSG = u'{0}: {1:6d}, {2:>5s}: {3}, RC: {4:3d}, Cmd: {5}\n'

  def _writePidData(pid, data):
    try:
      if pid != 0 and GC.Values[GC.SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid][u'queue'], pid, u'Start', pidData[pid][u'start'], data[0], pidData[pid][u'cmd']))
      if data[1] is not None:
        fd.write(data[1])
      if GC.Values[GC.SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid][u'queue'], pid, u'End', ISOformatTimeStamp(datetime.datetime.now(GC.Values[GC.TIMEZONE])), data[0], pidData[pid][u'cmd']))
      fd.flush()
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, e)

  if sys.platform.startswith(u'win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    GM.Globals = gmGlobals.copy()
    GC.Values = gcValues.copy()
  pid0DataItem = [KEYBOARD_INTERRUPT_RC, None]
  pidData = {}
  if GM.Globals[GM.WINDOWS]:
    if GM.Globals[stdtype][GM.REDIRECT_NAME] == u'null':
      fd = open(os.devnull, GM.Globals[stdtype][GM.REDIRECT_MODE])
    elif GM.Globals[stdtype][GM.REDIRECT_NAME] == u'-':
      fd = os.fdopen(os.dup([sys.stderr.fileno(), sys.stdout.fileno()][GM.Globals[stdtype][GM.REDIRECT_QUEUE] == u'stdout']), GM.Globals[stdtype][GM.REDIRECT_MODE], encoding=GM.Globals[GM.SYS_ENCODING])
    elif GM.Globals[stdtype][GM.REDIRECT_NAME] == u'stdout'and GM.Globals[stdtype][GM.REDIRECT_QUEUE] == u'stderr':
      fd = os.fdopen(os.dup(sys.stdout.fileno()), GM.Globals[stdtype][GM.REDIRECT_MODE], encoding=GM.Globals[GM.SYS_ENCODING])
    else:
      fd = openFile(GM.Globals[stdtype][GM.REDIRECT_NAME], GM.Globals[stdtype][GM.REDIRECT_MODE])
  else:
    fd = GM.Globals[stdtype][GM.REDIRECT_FD]
  while True:
    pid, dataType, dataItem = mpQueue.get()
    if dataType == GM.REDIRECT_QUEUE_START:
      pidData[pid] = {u'queue': GM.Globals[stdtype][GM.REDIRECT_QUEUE],
                      u'start': ISOformatTimeStamp(datetime.datetime.now(GC.Values[GC.TIMEZONE])),
                      u'cmd': Cmd.QuotedArgumentList(dataItem)}
      if pid == 0 and GC.Values[GC.SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid][u'queue'], pid, u'Start', pidData[pid][u'start'], 0, pidData[pid][u'cmd']))
    elif dataType == GM.REDIRECT_QUEUE_END:
      if pid != 0:
        _writePidData(pid, dataItem)
        del pidData[pid]
      else:
        pid0DataItem = dataItem
    else:
      break
  for pid in pidData:
    if pid != 0:
      _writePidData(pid, [KEYBOARD_INTERRUPT_RC, None])
  _writePidData(0, pid0DataItem)
  if fd not in [sys.stdout, sys.stderr]:
    try:
      fd.close()
    except IOError:
      pass
  GM.Globals[stdtype][GM.REDIRECT_FD] = None

def initializeStdQueueHandler(stdtype, gmGlobals, gcValues):
  mpQueue = multiprocessing.Manager().Queue()
  mpQueueHandler = multiprocessing.Process(target=StdQueueHandler, args=(mpQueue, stdtype, gmGlobals, gcValues))
  mpQueueHandler.start()
  return (mpQueue, mpQueueHandler)

def terminateStdQueueHandler(mpQueue, mpQueueHandler):
  mpQueue.put((0, GM.REDIRECT_QUEUE_EOF, None))
  mpQueueHandler.join()

def ProcessGAMCommandMulti(pid, mpQueueCSVFile, mpQueueStdout, mpQueueStderr, args):
  initializeLogging()
  if sys.platform.startswith(u'win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
  GM.Globals[GM.PID] = pid
  GM.Globals[GM.CSVFILE] = {}
  if mpQueueCSVFile:
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = mpQueueCSVFile
  if mpQueueStdout:
    GM.Globals[GM.STDOUT] = {GM.REDIRECT_NAME: u'', GM.REDIRECT_FD: None, GM.REDIRECT_MULTI_FD: StringIOobject()}
    if GM.Globals[GM.SAVED_STDOUT] is not None:
      GM.Globals[GM.SAVED_STDOUT] = sys.stdout
      sys.stdout = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]
    mpQueueStdout.put((pid, GM.REDIRECT_QUEUE_START, args))
  else:
    GM.Globals[GM.STDOUT] = {}
  if mpQueueStderr:
    if mpQueueStderr is not mpQueueStdout:
      GM.Globals[GM.STDERR] = {GM.REDIRECT_NAME: u'', GM.REDIRECT_FD: None, GM.REDIRECT_MULTI_FD: StringIOobject()}
      mpQueueStderr.put((pid, GM.REDIRECT_QUEUE_START, args))
    else:
      GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]
  else:
    GM.Globals[GM.STDERR] = {}
  sysRC = ProcessGAMCommand(args)
  if mpQueueStdout:
    mpQueueStdout.put((pid, GM.REDIRECT_QUEUE_END, [sysRC, GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD] = None
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((pid, GM.REDIRECT_QUEUE_END, [sysRC, GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = None

def batchWriteStderr(data):
  fd = GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr)
  if fd != sys.stderr:
    try:
      sys.stderr.write(data)
      sys.stderr.flush()
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, e)
  try:
    fd.write(data)
    fd.flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

ERROR_PLURAL_SINGULAR = [Msg.ERRORS, Msg.ERROR]
PROCESS_PLURAL_SINGULAR = [Msg.PROCESSES, Msg.PROCESS]
THREAD_PLURAL_SINGULAR = [Msg.THREADS, Msg.THREAD]

def MultiprocessGAMCommands(items, logCmds):
  if not items:
    return
  numPoolProcesses = min(len(items), GC.Values[GC.NUM_THREADS])
  origSigintHandler = signal.signal(signal.SIGINT, signal.SIG_IGN)
  try:
    pool = multiprocessing.Pool(processes=numPoolProcesses)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)
  except AssertionError as e:
    Cmd.SetLocation(0)
    usageErrorExit(str(e))
  if GM.Globals[GM.WINDOWS]:
    savedValues = saveNonPickleableValues()
  if GM.Globals[GM.STDOUT][GM.REDIRECT_MULTIPROCESS]:
    mpQueueStdout, mpQueueHandlerStdout = initializeStdQueueHandler(GM.STDOUT, GM.Globals, GC.Values)
    mpQueueStdout.put((0, GM.REDIRECT_QUEUE_START, Cmd.AllArguments()))
  else:
    mpQueueStdout = None
  if GM.Globals[GM.STDERR][GM.REDIRECT_MULTIPROCESS]:
    if GM.Globals[GM.STDERR][GM.REDIRECT_NAME] != u'stdout':
      mpQueueStderr, mpQueueHandlerStderr = initializeStdQueueHandler(GM.STDERR, GM.Globals, GC.Values)
      mpQueueStderr.put((0, GM.REDIRECT_QUEUE_START, Cmd.AllArguments()))
    else:
      mpQueueStderr = mpQueueStdout
  else:
    mpQueueStderr = None
  if GM.Globals[GM.WINDOWS]:
    restoreNonPickleableValues(savedValues)
  if GM.Globals[GM.CSVFILE][GM.REDIRECT_MULTIPROCESS]:
    mpQueueCSVFile, mpQueueHandlerCSVFile = initializeCSVFileQueueHandler()
  else:
    mpQueueCSVFile = None
  signal.signal(signal.SIGINT, origSigintHandler)
  batchWriteStderr(Msg.USING_N_PROCESSES.format(numPoolProcesses, PROCESS_PLURAL_SINGULAR[numPoolProcesses == 1]))
  try:
    pid = 0
    poolProcessesInUse = 0
    poolProcessResults = {}
    while items:
      item = items.popleft()
      if item[0] == Cmd.COMMIT_BATCH_CMD:
        batchWriteStderr(Msg.COMMIT_BATCH_WAIT_N_PROCESSES.format(poolProcessesInUse, PROCESS_PLURAL_SINGULAR[poolProcessesInUse == 1]))
        while poolProcessesInUse > 0:
          for ppid in list(poolProcessResults):
            try:
              if poolProcessResults[ppid].ready():
                poolProcessesInUse -= 1
                del poolProcessResults[ppid]
            except (TypeError, IOError):
              pass
          if poolProcessesInUse > 0:
            time.sleep(1)
        batchWriteStderr(Msg.COMMIT_BATCH_COMPLETE.format(Msg.PROCESSES))
        continue
      if item[0] == Cmd.PRINT_CMD:
        batchWriteStderr(Cmd.QuotedArgumentList(item[1:])+u'\n')
        continue
      pid += 1
      if pid % 100 == 0:
        batchWriteStderr(Msg.PROCESSING_ITEM_N.format(pid))
      if logCmds:
        batchWriteStderr(Cmd.QuotedArgumentList(item)+u'\n')
      poolProcessResults[pid] = pool.apply_async(ProcessGAMCommandMulti, [pid, mpQueueCSVFile, mpQueueStdout, mpQueueStderr, item])
      poolProcessesInUse += 1
      while poolProcessesInUse == numPoolProcesses:
        for ppid in list(poolProcessResults):
          try:
            if poolProcessResults[ppid].ready():
              poolProcessesInUse -= 1
              del poolProcessResults[ppid]
          except (TypeError, IOError):
            pass
        if poolProcessesInUse == numPoolProcesses:
          time.sleep(1)
  except KeyboardInterrupt:
    setSysExitRC(KEYBOARD_INTERRUPT_RC)
    pool.terminate()
  else:
    pool.close()
  pool.join()
  if mpQueueCSVFile:
    terminateCSVFileQueueHandler(mpQueueCSVFile, mpQueueHandlerCSVFile)
  if mpQueueStdout:
    mpQueueStdout.put((0, GM.REDIRECT_QUEUE_END, [GM.Globals[GM.SYSEXITRC], GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD] = None
    terminateStdQueueHandler(mpQueueStdout, mpQueueHandlerStdout)
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((0, GM.REDIRECT_QUEUE_END, [GM.Globals[GM.SYSEXITRC], GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = None
    terminateStdQueueHandler(mpQueueStderr, mpQueueHandlerStderr)

def threadBatchWorker():
  import subprocess
  while True:
    item = GM.Globals[GM.TBATCH_QUEUE].get()
    subprocess.call(item, stdout=GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout), stderr=GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr))
    GM.Globals[GM.TBATCH_QUEUE].task_done()

def ThreadBatchGAMCommands(items, logCmds):
  import queue
  import threading

  pythonCmd = [sys.executable.lower(),]
  if not getattr(sys, u'frozen', False): # we're not frozen
    pythonCmd.append(os.path.realpath(Cmd.Argument(0)))
  numWorkerThreads = min(len(items), GC.Values[GC.NUM_TBATCH_THREADS])
  GM.Globals[GM.TBATCH_QUEUE] = queue.Queue(maxsize=numWorkerThreads) # GM.Globals[GM.TBATCH_QUEUE].put() gets blocked when trying to create more items than there are workers
  batchWriteStderr(Msg.USING_N_PROCESSES.format(numWorkerThreads, THREAD_PLURAL_SINGULAR[numWorkerThreads == 1]))
  for _ in range(numWorkerThreads):
    t = threading.Thread(target=threadBatchWorker)
    t.daemon = True
    t.start()
  pid = 0
  numThreadsInUse = 0
  while items:
    item = items.popleft()
    if item[0] == Cmd.COMMIT_BATCH_CMD:
      batchWriteStderr(Msg.COMMIT_BATCH_WAIT_N_PROCESSES.format(numThreadsInUse, THREAD_PLURAL_SINGULAR[numThreadsInUse == 1]))
      GM.Globals[GM.TBATCH_QUEUE].join()
      batchWriteStderr(Msg.COMMIT_BATCH_COMPLETE.format(Msg.THREADS))
      numThreadsInUse = 0
      continue
    if item[0] == Cmd.PRINT_CMD:
      batchWriteStderr(Cmd.QuotedArgumentList(item[1:])+u'\n')
      continue
    pid += 1
    if pid % 100 == 0:
      batchWriteStderr(Msg.PROCESSING_ITEM_N.format(pid))
    if logCmds:
      batchWriteStderr(Cmd.QuotedArgumentList(item)+u'\n')
    GM.Globals[GM.TBATCH_QUEUE].put(pythonCmd+item[1:])
    numThreadsInUse += 1
  GM.Globals[GM.TBATCH_QUEUE].join()

# gam batch <FileName>|- [charset <Charset>] [showcmds]
def doBatch(threadBatch=False):
  import shlex
  filename = getString(Cmd.OB_FILE_NAME)
  if (filename == u'-') and (GC.Values[GC.DEBUG_LEVEL] > 0):
    Cmd.Backup()
    usageErrorExit(Msg.BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(Cmd.BATCH_CMD))
  encoding = getCharSet()
  logCmds = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'showcmds':
      logCmds = getBoolean()
    else:
      unknownArgumentExit()
  items = collections.deque()
  f = openFile(filename, encoding=encoding)
  errors = 0
  try:
    for line in f:
      try:
        argv = shlex.split(line)
      except ValueError as e:
        writeStderr(convertUTF8(u'Command: >>>{0}<<<\n'.format(line.strip())))
        writeStderr(u'{0}{1}\n'.format(ERROR_PREFIX, str(e)))
        errors += 1
        continue
      if len(argv) > 0:
        cmd = argv[0].strip().lower()
        if (not cmd) or cmd.startswith(u'#') or ((len(argv) == 1) and (cmd not in [Cmd.COMMIT_BATCH_CMD, Cmd.PRINT_CMD])):
          continue
        if cmd == Cmd.GAM_CMD:
          items.append(argv)
        elif cmd == Cmd.COMMIT_BATCH_CMD:
          items.append([cmd])
        elif cmd == Cmd.PRINT_CMD:
          items.append(argv)
        else:
          writeStderr(convertUTF8(u'Command: >>>{0}<<< {1}\n'.format(Cmd.QuotedArgumentList([argv[0]]), Cmd.QuotedArgumentList(argv[1:]))))
          writeStderr(u'{0}{1}: {2} <{3}>\n'.format(ERROR_PREFIX, Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1],
                                                    Msg.EXPECTED, formatChoiceList([Cmd.GAM_CMD, Cmd.COMMIT_BATCH_CMD, Cmd.PRINT_CMD])))
          errors += 1
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)
  closeFile(f)
  if errors == 0:
    if not threadBatch:
      MultiprocessGAMCommands(items, logCmds)
    else:
      ThreadBatchGAMCommands(items, logCmds)
  else:
    writeStderr(Msg.BATCH_NOT_PROCESSED_ERRORS.format(ERROR_PREFIX, filename, errors, ERROR_PLURAL_SINGULAR[errors == 1]))
    setSysExitRC(USAGE_ERROR_RC)

# gam tbatch <FileName>|- [charset <Charset>] [showcmds]
def doThreadBatch():
  adjustRedirectedSTDFilesIfNotMultiprocessing()
  doBatch(True)

def doAutoBatch(entityType, entityList, CL_command):
  remaining = Cmd.Remaining()
  items = collections.deque()
  for entity in entityList:
    items.append([Cmd.GAM_CMD, entityType, entity, CL_command]+remaining)
  MultiprocessGAMCommands(items, False)

# Process command line arguments, find substitutions
# An argument containing instances of ~~xxx~!~pattern~!~replacement~~ has ~~...~~ replaced by re.sub(pattern, replacement, value of field xxx from the CSV file)
# For example, ~~primaryEmail~!~^(.+)@(.+)$~!~\1 AT \2~~ would replace foo@bar.com (from the primaryEmail column) with foo AT bar.com
# An argument containing instances of ~~xxx~~ has xxx replaced by the value of field xxx from the CSV file
# An argument containing exactly ~xxx is replaced by the value of field xxx from the CSV file
# Otherwise, the argument is preserved as is

SUB_PATTERN = re.compile(r'~~(.+?)~~')
RE_PATTERN = re.compile(r'~~(.+?)~!~(.+?)~!~(.+?)~~')
SUB_TYPE = u'sub'
RE_TYPE = u're'

# SubFields is a dictionary; the key is the argument number, the value is a list of tuples that mark
# the substition (type, fieldname, start, end). Type is 'sub' for simple substitution, 're' for regex substitution.
# Example: update user '~User' address type work unstructured '~~Street~~, ~~City~~, ~~State~~ ~~ZIP~~' primary
# {2: [('sub', 'User', 0, 5)], 7: [('sub', 'Street', 0, 10), ('sub', 'City', 12, 20), ('sub', 'State', 22, 31), ('sub', 'ZIP', 32, 39)]}
def getSubFields(initial_argv, fieldNames):
  subFields = {}
  GAM_argv = initial_argv[:]
  GAM_argvI = len(GAM_argv)
  while Cmd.ArgumentsRemaining():
    myarg = Cmd.Current()
    if not myarg:
      GAM_argv.append(myarg)
    elif SUB_PATTERN.search(myarg):
      pos = 0
      subFields.setdefault(GAM_argvI, [])
      while True:
        submatch = SUB_PATTERN.search(myarg, pos)
        if not submatch:
          break
        rematch = RE_PATTERN.match(submatch.group(0))
        if not rematch:
          fieldName = submatch.group(1)
          if fieldName not in fieldNames:
            csvFieldErrorExit(fieldName, fieldNames)
          subFields[GAM_argvI].append((SUB_TYPE, fieldName, submatch.start(), submatch.end()))
        else:
          fieldName = rematch.group(1)
          if fieldName not in fieldNames:
            csvFieldErrorExit(fieldName, fieldNames)
          try:
            re.compile(rematch.group(2))
            subFields[GAM_argvI].append((RE_TYPE, fieldName, submatch.start(), submatch.end(), rematch.group(2), rematch.group(3)))
          except re.error as e:
            usageErrorExit(u'{0} {1}: {2}'.format(Cmd.OB_RE_PATTERN, Msg.ERROR, e))
        pos = submatch.end()
      GAM_argv.append(myarg)
    elif myarg[0] == u'~':
      fieldName = myarg[1:]
      if fieldName in fieldNames:
        subFields[GAM_argvI] = [(SUB_TYPE, fieldName, 0, len(myarg))]
        GAM_argv.append(myarg)
      else:
        csvFieldErrorExit(fieldName, fieldNames)
    else:
      GAM_argv.append(myarg)
    GAM_argvI += 1
    Cmd.Advance()
  return(GAM_argv, subFields)

def processSubFields(GAM_argv, row, subFields):
  argv = GAM_argv[:]
  for GAM_argvI, fields in iteritems(subFields):
    oargv = argv[GAM_argvI][:]
    argv[GAM_argvI] = u''
    pos = 0
    for field in fields:
      argv[GAM_argvI] += oargv[pos:field[2]]
      if field[0] == SUB_TYPE:
        if row[field[1]]:
          argv[GAM_argvI] += row[field[1]]
      else:
        if row[field[1]]:
          argv[GAM_argvI] += re.sub(field[4], field[5], row[field[1]])
      pos = field[3]
    argv[GAM_argvI] += oargv[pos:]
  return argv

# gam csv <FileName>|- [charset <Charset>] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>] (matchfield <FieldName> <RegularExpression>)* gam <GAM argument list>
def doCSV():
  filename = getString(Cmd.OB_FILE_NAME)
  if (filename == u'-') and (GC.Values[GC.DEBUG_LEVEL] > 0):
    Cmd.Backup()
    usageErrorExit(Msg.BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(Cmd.CSV_CMD))
  f, csvFile = openCSVFileReader(filename)
  matchFields = getMatchFields(csvFile.fieldnames)
  checkArgumentPresent(Cmd.GAM_CMD, required=True)
  if not Cmd.ArgumentsRemaining():
    missingArgumentExit(Cmd.OB_GAM_ARGUMENT_LIST)
  GAM_argv, subFields = getSubFields([Cmd.GAM_CMD,], csvFile.fieldnames)
  items = collections.deque()
  for row in csvFile:
    if (not matchFields) or checkMatchFields(row, matchFields):
      items.append(processSubFields(GAM_argv, row, subFields))
  closeFile(f)
  MultiprocessGAMCommands(items, False)

def _doList(entityList, entityType):
  buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent(u'todrive'):
    todrive = getTodriveParameters()
  else:
    todrive = {}
  if entityList is None:
    entityList = getEntityList(Cmd.OB_ENTITY)
  if GM.Globals[GM.CSV_DATA_DICT]:
    keyField = GM.Globals[GM.CSV_KEY_FIELD]
    dataField = GM.Globals[GM.CSV_DATA_FIELD]
  else:
    keyField = u'Entity'
    dataField = u'Data'
  titles, csvRows = initializeTitlesCSVfile([keyField])
  showData = checkArgumentPresent(u'data')
  if showData:
    if not entityType:
      itemType, itemList = getEntityToModify(crosAllowed=True)
    else:
      itemType = None
      itemList = getEntityList(Cmd.OB_ENTITY)
    entityItemLists = itemList if isinstance(itemList, dict) else None
    addTitleToCSVfile(dataField, titles)
  else:
    entityItemLists = None
  dataDelimiter = getDelimiter()
  checkForExtraneousArguments()
  _, _, entityList = getEntityArgument(entityList)
  for entity in entityList:
    entityEmail = normalizeEmailAddressOrUID(entity)
    if showData:
      if entityItemLists:
        if entity not in entityItemLists:
          csvRows.append({keyField: entityEmail})
          continue
        itemList = entityItemLists[entity]
        if itemType == Cmd.ENTITY_USERS:
          for i, item in enumerate(itemList):
            itemList[i] = normalizeEmailAddressOrUID(item)
      if dataDelimiter:
        csvRows.append({keyField: entityEmail, dataField: dataDelimiter.join(itemList)})
      else:
        for item in itemList:
          csvRows.append({keyField: entityEmail, dataField: item})
    else:
      csvRows.append({keyField: entityEmail})
  writeCSVfile(csvRows, titles, u'Entity', todrive)

# gam list [todrive [<ToDriveAttributes>]] <EntityList> [data <CrOSTypeEntity>|<UserTypeEntity> [delimiter <Character>]]
def doListType():
  _doList(None, None)

# gam <CrOSTypeEntity> list [todrive [<ToDriveAttributes>]] [data <EntityList> [delimiter <Character>]]
def doListCrOS(entityList):
  _doList(entityList, Cmd.ENTITY_CROS)

# gam <UserTypeEntity> list [todrive [<ToDriveAttributes>]] [data <EntityList> [delimiter <Character>]]
def doListUser(entityList):
  _doList(entityList, Cmd.ENTITY_USERS)

def revokeCredentials(credFamilyList):
  httpObj = getHttpObj()
  for cred_family in credFamilyList:
    credentials = getCredentialsForScope(cred_family)
    if credentials and not credentials.invalid:
      credentials.revoke_uri = oauth2client.GOOGLE_REVOKE_URI
      try:
        credentials.revoke(httpObj)
        time.sleep(2)
      except oauth2client.client.TokenRevokeError as e:
        printErrorMessage(INVALID_TOKEN_RC, str(e))

VALIDEMAIL_PATTERN = re.compile(r'^[^@]+@[^@]+\.[^@]+$')

def getValidateLoginHint(login_hint):
  if login_hint:
    login_hint = login_hint.strip()
    if VALIDEMAIL_PATTERN.match(login_hint):
      return login_hint
  while True:
    login_hint = readStdin(u'\nWhat is your G Suite admin email address? ').strip()
    if VALIDEMAIL_PATTERN.match(login_hint):
      return login_hint
    sys.stdout.write(u'Error: that is not a valid email address\n')

def getOAuthClientIDAndSecret():
  cs_data = readFile(GC.Values[GC.CLIENT_SECRETS_JSON], continueOnError=True, displayError=True)
  if not cs_data:
    invalidClientSecretsJsonExit()
  try:
    cs_json = json.loads(cs_data)
    # chop off .apps.googleusercontent.com suffix as it's not needed and we need to keep things short for the Auth URL.
    return (re.sub(r'\.apps\.googleusercontent\.com$', u'', cs_json[u'installed'][u'client_id']),
            cs_json[u'installed'][u'client_secret'])
  except (ValueError, IndexError, KeyError):
    invalidClientSecretsJsonExit()

def getScopesFromUser():
  OAUTH2_CMDS = [u's', u'u', u'e', u'c']
  oauth2_menu = u'''
Select the authorized scopes by entering a number.
Append an 'r' to grant read-only access or an 'a' to grant action-only access.

'''
  for a_scope in API.OAUTH2_SCOPES:
    oauth2_menu += u'[%%%%s] %%2d)  %s' % (a_scope[u'name'])
    if a_scope[u'subscopes']:
      oauth2_menu += u' (supports %s)' % (u' and '.join(a_scope[u'subscopes']))
    oauth2_menu += u'\n'
  oauth2_menu += u'''
     s)  Select all scopes
     u)  Unselect all scopes
     e)  Exit without changes
     c)  Continue to authorization
'''
  num_scopes = len(API.OAUTH2_SCOPES)
  menu = oauth2_menu % tuple(range(num_scopes))
  selectedScopes = [u'*'] * num_scopes
  for cred_family in API.FAM_LIST:
    credentials = getCredentialsForScope(cred_family)
    if credentials and not credentials.invalid:
      currentScopes = sorted(credentials.scopes)
      i = 0
      for a_scope in API.OAUTH2_SCOPES:
        if cred_family == a_scope[u'credfam']:
          selectedScopes[i] = u' '
          possibleScope = a_scope[u'scope']
          for currentScope in currentScopes:
            if currentScope == possibleScope:
              selectedScopes[i] = u'*'
              break
            if u'readonly' in a_scope[u'subscopes']:
              if currentScope == possibleScope+u'.readonly':
                selectedScopes[i] = u'R'
                break
            if u'action' in a_scope[u'subscopes']:
              if currentScope == possibleScope+u'.action':
                selectedScopes[i] = u'A'
                break
        i += 1
    else:
      i = 0
      for a_scope in API.OAUTH2_SCOPES:
        if cred_family == a_scope[u'credfam']:
          selectedScopes[i] = [u'*', u' '][a_scope.get(u'offByDefault', False)]
        i += 1
  prompt = u'Please enter 0-{0}[a|r] or {1}: '.format(num_scopes-1, u'|'.join(OAUTH2_CMDS))
  while True:
    os.system([u'clear', u'cls'][GM.Globals[GM.WINDOWS]])
    sys.stdout.write(menu % tuple(selectedScopes))
    while True:
      choice = readStdin(prompt)
      if choice:
        selection = choice.lower()
        if selection.find(u'r') >= 0:
          mode = u'R'
          selection = selection.replace(u'r', u'')
        elif selection.find(u'a') >= 0:
          mode = u'A'
          selection = selection.replace(u'a', u'')
        else:
          mode = u' '
        if selection and selection.isdigit():
          selection = int(selection)
        if isinstance(selection, int) and selection < num_scopes:
          if mode == u'R':
            if u'readonly' not in API.OAUTH2_SCOPES[selection][u'subscopes']:
              sys.stdout.write(u'{0}Scope {1} does not support read-only mode!\n'.format(ERROR_PREFIX, selection))
              continue
          elif mode == u'A':
            if u'action' not in API.OAUTH2_SCOPES[selection][u'subscopes']:
              sys.stdout.write(u'{0}Scope {1} does not support action-only mode!\n'.format(ERROR_PREFIX, selection))
              continue
          elif selectedScopes[selection] != u'*':
            mode = u'*'
          else:
            mode = u' '
          selectedScopes[selection] = mode
          break
        elif isinstance(selection, string_types) and selection in OAUTH2_CMDS:
          if selection == u's':
            for i in range(num_scopes):
              selectedScopes[i] = u'*'
          elif selection == u'u':
            for i in range(num_scopes):
              selectedScopes[i] = u' '
          elif selection == u'e':
            return None
          break
        sys.stdout.write(u'{0}Invalid input "{1}"\n'.format(ERROR_PREFIX, choice))
    if selection == u'c':
      break
  return selectedScopes

class cmd_flags(object):
  def __init__(self, noLocalWebserver):
    self.short_url = True
    self.noauth_local_webserver = noLocalWebserver
    self.logging_level = u'ERROR'
    self.auth_host_name = u'localhost'
    self.auth_host_port = [8080, 9090]

# gam oauth|oauth2 create|request [<EmailAddress>]
def doOAuthRequest():
  client_id, client_secret = getOAuthClientIDAndSecret()
  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  selectedScopes = getScopesFromUser()
  if selectedScopes is None:
    return
  login_hint = getValidateLoginHint(login_hint)
  revokeCredentials(API.FAM_LIST)
  flags = cmd_flags(noLocalWebserver=GC.Values[GC.NO_BROWSER])
  httpObj = getHttpObj()
  for cred_family in API.FAM_LIST:
    scopes = [API.EMAIL_SCOPE, API.PROFILE_SCOPE] # Email Display Scope, always included for client
    i = 0
    for a_scope in API.OAUTH2_SCOPES:
      if cred_family == a_scope[u'credfam']:
        if selectedScopes[i] == u'*':
          scopes.append(a_scope[u'scope'])
        elif selectedScopes[i] == u'R':
          scopes.append(u'{0}.readonly'.format(a_scope[u'scope']))
        elif selectedScopes[i] == u'A':
          scopes.append(u'{0}.action'.format(a_scope[u'scope']))
      i += 1
    flow = oauth2client.client.OAuth2WebServerFlow(client_id=client_id,
                                                   client_secret=client_secret, scope=scopes, redirect_uri=oauth2client.client.OOB_CALLBACK_URN,
                                                   user_agent=GAM_INFO, response_type=u'code', login_hint=login_hint)
    storage = getCredentialsForScope(cred_family, storageOnly=True)
    try:
      oauth2client.tools.run_flow(flow=flow, storage=storage, flags=flags, http=httpObj)
      time.sleep(3)
    except httplib2.CertificateValidationUnsupportedInPython31:
      noPythonSSLExit()
  entityActionPerformed([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]])

CRED_FAMILY_CHOICE_MAP = [u'current', u'previous']

# gam oauth|oauth2 delete|revoke
def doOAuthDelete():
  currPrev = getChoice(CRED_FAMILY_CHOICE_MAP, defaultChoice=None)
  checkForExtraneousArguments()
  if os.path.isfile(GC.Values[GC.OAUTH2_TXT]):
    if currPrev is None:
      entityType = Ent.OAUTH2_TXT_FILE
      entityName = GC.Values[GC.OAUTH2_TXT]
    else:
      entityType = Ent.CREDENTIALS
      entityName = currPrev
    sys.stdout.write(u'{0}: {1}, will be Deleted in 3...'.format(Ent.Singular(entityType), entityName))
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(u'2...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(u'1...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(u'boom!\n')
    sys.stdout.flush()
    if currPrev == u'current':
      revokeCredentials(API.FAM_LIST)
    elif currPrev == u'previous':
      revokeCredentials(API.PREV_FAM_LIST)
    else:
      revokeCredentials(API.FAM_LIST)
      revokeCredentials(API.PREV_FAM_LIST)
      deleteFile(GC.Values[GC.OAUTH2_TXT], continueOnError=True)
    entityActionPerformed([entityType, entityName])

# gam oauth|oauth2 info [<AccessToken>]
def doOAuthInfo():

  def _printCredentials(credentials):
    if not credentials or credentials.invalid:
      return
    printKeyValueList([u'Client ID', credentials.client_id])
    printKeyValueList([u'Secret', credentials.client_secret])
    scopes = sorted(credentials.scopes)
    for scope in [API.EMAIL_SCOPE, API.PROFILE_SCOPE]:
      if scope in scopes:
        scopes.remove(scope)
    printKeyValueList([u'Scopes', len(scopes)])
    Ind.Increment()
    for scope in scopes:
      printKeyValueList([scope])
    Ind.Decrement()
    printKeyValueList([u'G Suite Admin', credentials.id_token.get(u'email', u'Unknown')])
    printBlankLine()

  access_token = getString(Cmd.OB_ACCESS_TOKEN, optional=True)
  checkForExtraneousArguments()
  if access_token:
    for cred_family in API.FAM_LIST:
      credentials = getClientCredentials(cred_family)
      if credentials.access_token == access_token:
        _printCredentials(credentials)
        break
    else:
      entityActionFailedWarning([Ent.ACCESS_TOKEN, access_token], Msg.DOES_NOT_EXIST)
  else:
    if os.path.isfile(GC.Values[GC.OAUTH2_TXT]):
      printEntity([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]])
      fam1Credentials = getCredentialsForScope(API.FAM1_SCOPES)
      fam2Credentials = getCredentialsForScope(API.FAM2_SCOPES)
      if (fam1Credentials and not fam1Credentials.invalid and
          fam2Credentials and not fam2Credentials.invalid and
          fam1Credentials.client_id == fam2Credentials.client_id and
          fam1Credentials.client_secret == fam2Credentials.client_secret and
          fam1Credentials.id_token.get(API.EMAIL_SCOPE) == fam2Credentials.id_token.get(API.EMAIL_SCOPE)):
        fam1Credentials.scopes = fam1Credentials.scopes.union(fam2Credentials.scopes)
        _printCredentials(fam1Credentials)
      else:
        _printCredentials(fam1Credentials)
        _printCredentials(fam2Credentials)
    else:
      invalidOauth2TxtExit()

# gam oauth|oauth2 export [<FileName>]
def doOAuthExport():
  if Cmd.ArgumentsRemaining():
    exportFile = getString(Cmd.OB_FILE_NAME)
    checkForExtraneousArguments()
  else:
    exportFile = None
  oauth2Export = {}
  if os.path.isfile(GC.Values[GC.OAUTH2_TXT]):
    for cred_family in API.FAM_LIST:
      credentials = getCredentialsForScope(cred_family)
      if credentials and not credentials.invalid:
        oauth2Export[cred_family] = {u'_module': u'oauth2client.client',
                                     u'_class': 'OAuth2Credentials',
                                     u'access_token': credentials.access_token,
                                     u'client_id': credentials.client_id,
                                     u'client_secret': credentials.client_secret,
                                     u'id_token': credentials.id_token,
                                     u'id_token_jwt': credentials.id_token_jwt,
                                     u'invalid': credentials.invalid,
                                     u'refresh_token': credentials.refresh_token,
                                     u'revoke_uri': credentials.revoke_uri,
                                     u'scopes': sorted(list(credentials.scopes)),
                                     u'token_expiry': datetime.datetime.strftime(credentials.token_expiry, u'%Y-%m-%dT%H:%M:%SZ'),
                                     u'token_info_uri': credentials.token_info_uri,
                                     u'token_uri': credentials.token_uri,
                                     u'user_agent': credentials.user_agent}
      else:
        invalidOauth2TxtExit()
  else:
    invalidOauth2TxtExit()
  if exportFile:
    writeFile(exportFile, json.dumps(oauth2Export, ensure_ascii=False, sort_keys=True, indent=2))
    entityModifierNewValueActionPerformed([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]], Act.MODIFIER_TO, exportFile)
  else:
    writeStdout(json.dumps(oauth2Export, ensure_ascii=False, sort_keys=True, indent=2)+u'\n')

# gam oauth|oauth2 import <FileName>
def doOAuthImport():
  importFile = getString(Cmd.OB_FILE_NAME)
  checkForExtraneousArguments()
  jsonData = readFile(importFile, u'rb')
  try:
    jsonDict = json.loads(jsonData)
    if u'client_id' in jsonDict:
      importCredentials = oauth2client.client.Credentials.new_from_json(jsonData)
      if not importCredentials or importCredentials.invalid:
        invalidOauth2TxtImportExit(importFile)
      for cred_family in API.FAM_LIST:
        getCredentialsForScope(cred_family, storageOnly=True).put(importCredentials)
    elif (u'credentials' in jsonDict) and (jsonDict.get(u'file_version') == 2):
      for cred_family in API.FAM_LIST:
        importCredentials = getCredentialsForScope(cred_family, filename=importFile)
        if not importCredentials or importCredentials.invalid:
          invalidOauth2TxtImportExit(importFile)
        getCredentialsForScope(cred_family, storageOnly=True).put(importCredentials)
    elif (API.FAM1_SCOPES in jsonDict) and (API.FAM2_SCOPES in jsonDict):
      for cred_family in API.FAM_LIST:
        importCredentials = oauth2client.client.Credentials.new_from_json(json.dumps(jsonDict[cred_family], ensure_ascii=False, sort_keys=True))
        if not importCredentials or importCredentials.invalid:
          invalidOauth2TxtImportExit(importFile)
        getCredentialsForScope(cred_family, storageOnly=True).put(importCredentials)
    else:
      invalidOauth2TxtImportExit(importFile)
  except (KeyError, ValueError):
    invalidOauth2TxtImportExit(importFile)
  entityModifierNewValueActionPerformed([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]], Act.MODIFIER_FROM, importFile)

# gam <UserTypeEntity> check serviceaccount
def checkServiceAccount(users):
  checkForExtraneousArguments()
  all_scopes, jcount = API.getSortedSvcAcctScopesList()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    all_scopes_pass = True
    user = convertUIDtoEmailAddress(user)
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.SCOPE, i, count)
    Ind.Increment()
    j = 0
    for scope in all_scopes:
      j += 1
      credentials = getSvcAcctCredentials([scope], user)
      request = google_auth_httplib2.Request(getHttpObj())
      try:
        credentials.refresh(request)
        result = u'PASS'
      except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
        systemErrorExit(NETWORK_ERROR_RC, str(e))
      except google.auth.exceptions.RefreshError:
        result = u'FAIL'
        all_scopes_pass = False
      entityActionPerformedMessage([Ent.SCOPE, u'{0:60}'.format(scope)], result, j, jcount)
    Ind.Decrement()
    service_account = GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID]
    _, _, user_domain = splitEmailAddressOrUID(user)
    if all_scopes_pass:
      printLine(Msg.SCOPE_AUTHORIZATION_PASSED.format(service_account))
    else:
      printErrorMessage(SCOPES_NOT_AUTHORIZED, Msg.SCOPE_AUTHORIZATION_FAILED.format(user_domain, service_account, u',\n'.join(all_scopes)))
    printBlankLine()

def getCRMService(login_hint):
  from oauth2client.contrib.dictionary_storage import DictionaryStorage
  scope = u'https://www.googleapis.com/auth/cloud-platform'
  client_id = u'297408095146-fug707qsjv4ikron0hugpevbrjhkmsk7.apps.googleusercontent.com'
  client_secret = u'qM3dP8f_4qedwzWQE1VR4zzU'
  flow = oauth2client.client.OAuth2WebServerFlow(client_id=client_id,
                                                 client_secret=client_secret, scope=scope, redirect_uri=oauth2client.client.OOB_CALLBACK_URN,
                                                 user_agent=GAM_INFO, access_type=u'online', response_type=u'code', login_hint=login_hint)
  storage_dict = {}
  storage = DictionaryStorage(storage_dict, u'credentials')
  flags = cmd_flags(noLocalWebserver=GC.Values[GC.NO_BROWSER])
  httpObj = getHttpObj()
  try:
    credentials = oauth2client.tools.run_flow(flow=flow, storage=storage, flags=flags, http=httpObj)
  except httplib2.CertificateValidationUnsupportedInPython31:
    noPythonSSLExit()
  credentials.user_agent = GAM_INFO
  httpObj = credentials.authorize(getHttpObj())
  return (googleapiclient.discovery.build(u'cloudresourcemanager', u'v1', http=httpObj, cache_discovery=False), httpObj)

def enableProjectAPIs(httpObj, projectName, checkEnabled):
  apis = API.PROJECT_APIS[:]
  serveman = googleapiclient.discovery.build(u'servicemanagement', u'v1', http=httpObj, cache_discovery=False)
  if checkEnabled:
    enabledServices = callGAPIpages(serveman.services(), u'list', u'services',
                                    consumerId=projectName, fields=u'nextPageToken,services(serviceName)')
    for service in sorted(enabledServices, key=lambda k: k[u'serviceName']):
      if u'serviceName' in service:
        if service[u'serviceName'] in apis:
          printEntityKVList([Ent.API, service[u'serviceName']], [u'already enabled...',])
          apis.remove(service[u'serviceName'])
        else:
          printEntityKVList([Ent.API, service[u'serviceName']], [u'(non-GAM) already enabled...',])
  Act.Set(Act.ENABLE)
  count = len(apis)
  performActionNumItems(count, Ent.API)
  Ind.Increment()
  i = 0
  for api in apis:
    i += 1
    while True:
      try:
        callGAPI(serveman.services(), u'enable',
                 throw_reasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 serviceName=api, body={u'consumerId': projectName})
        entityActionPerformed([Ent.API, api], i, count)
        break
      except GAPI.failedPrecondition as e:
        entityActionFailedWarning([Ent.API, api], str(e), i, count)
        writeStderr(u'\nPlease resolve error as described above\n\n')
        readStdin(u'Press enter once resolved and we will try enabling the API again.')
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.API, api], str(e), i, count)
        break
  Ind.Decrement()

# gam create project [<EmailAddress>]
def doCreateProject():

  def _checkClientAndSecret(simplehttp, client_id, client_secret):
    url = u'https://www.googleapis.com/oauth2/v4/token'
    post_data = {u'client_id': client_id, u'client_secret': client_secret,
                 u'code': u'ThisIsAnInvalidCodeOnlyBeingUsedToTestIfClientAndSecretAreValid',
                 u'redirect_uri': u'urn:ietf:wg:oauth:2.0:oob', u'grant_type': u'authorization_code'}
    headers = {'Content-type': 'application/x-www-form-urlencoded'}
    from urllib import urlencode
    _, content = simplehttp.request(url, u'POST', urlencode(post_data), headers=headers)
    try:
      content = json.loads(content)
    except ValueError:
      sys.stderr.write(u'Unknown error: {0}\n'.format(content))
      return False
    if not u'error' in content or not u'error_description' in content:
      sys.stderr.write(u'Unknown error: {0}\n'.format(content))
      return False
    if content[u'error'] == u'invalid_grant':
      return True
    if content[u'error_description'] == u'The OAuth client was not found.':
      sys.stderr.write(u'Ooops!!\n\n{0}\n\nIs not a valid client ID. Please make sure you are following the directions exactly and that there are no extra spaces in your client ID.\n'.format(client_id))
      return False
    if content[u'error_description'] == u'Unauthorized':
      sys.stderr.write(u'Ooops!!\n\n{0}\n\nIs not a valid client secret. Please make sure you are following the directions exactly and that there are no extra spaces in your client secret.\n'.format(client_secret))
      return False
    sys.stderr.write(u'Unknown error: {0}\n'.format(content))
    return False

  service_account_file = GC.Values[GC.OAUTH2SERVICE_JSON]
  client_secrets_file = GC.Values[GC.CLIENT_SECRETS_JSON]
  for a_file in [service_account_file, client_secrets_file]:
    if os.path.exists(a_file):
      systemErrorExit(USAGE_ERROR_RC, u'{0} already exists. Please delete or rename it before attempting to create another project.'.format(a_file))
  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  login_hint = getValidateLoginHint(login_hint)
  login_domain = getEmailAddressDomain(login_hint)
  crm, httpObj = getCRMService(login_hint)
  project_id = u'gam-project'
  for _ in range(3):
    project_id += u'-%s' % u''.join(random.choice(string.digits + string.ascii_lowercase) for _ in range(3))
  projectName = u'project:%s' % project_id
  body = {u'projectId': project_id, u'name': u'GAM Project'}
  while True:
    create_again = False
    sys.stdout.write(u'Creating project "{0}"...\n'.format(body[u'name']))
    create_operation = callGAPI(crm.projects(), u'create',
                                body=body)
    operation_name = create_operation[u'name']
    time.sleep(5) # Google recommends always waiting at least 5 seconds
    for i in range(1, 5):
      sys.stdout.write(u'Checking project status...\n')
      status = callGAPI(crm.operations(), u'get',
                        name=operation_name)
      if u'error' in status:
        if status[u'error'].get(u'message', u'') == u'No permission to create project in organization':
          sys.stdout.write(u'Hmm... Looks like you have no rights to your Google Cloud Organization.\nAttempting to fix that...\n')
          getorg = callGAPI(crm.organizations(), u'search',
                            body={u'filter': u'domain:{0}'.format(login_domain)})
          try:
            organization = getorg[u'organizations'][0][u'name']
            sys.stdout.write(u'Your organization name is {0}\n'.format(organization))
          except (KeyError, IndexError):
            systemErrorExit(3, u'You have no rights to create projects for your organization and you don\'t seem to be a super admin! Sorry, there\'s nothing more I can do.')
          org_policy = callGAPI(crm.organizations(), u'getIamPolicy',
                                resource=organization, body={})
          if u'bindings' not in org_policy:
            org_policy[u'bindings'] = []
            sys.stdout.write(u'Looks like no one has rights to your Google Cloud Organization. Attempting to give you create rights...\n')
          else:
            sys.stdout.write(u'The following rights seem to exist:\n')
            for a_policy in org_policy[u'bindings']:
              if u'role' in a_policy:
                sys.stdout.write(u'  Role: {0}\n'.format(a_policy[u'role']))
              if u'members' in a_policy:
                sys.stdout.write(u'  Members:\n')
                for member in a_policy[u'members']:
                  sys.stdout.write(u'    {0}\n'.format(member))
          my_role = u'roles/resourcemanager.projectCreator'
          sys.stdout.write(u'Giving {0} the role of {1}...\n'.format(login_hint, my_role))
          org_policy[u'bindings'].append({u'role': my_role, u'members': [u'user:{0}'.format(login_hint)]})
          callGAPI(crm.organizations(), u'setIamPolicy',
                   resource=organization, body={u'policy': org_policy})
          create_again = True
          break
        try:
          if status[u'error'][u'details'][0][u'violations'][0][u'description'] == u'Callers must accept Terms of Service':
            readStdin(u'''Please go to:

https://console.cloud.google.com/start

and accept the Terms of Service (ToS). As soon as you've accepted the ToS popup, you can return here and press enter.\n''')
            create_again = True
            break
        except (IndexError, KeyError):
          pass
        systemErrorExit(1, str(status)+u'\n')
      if status.get(u'done', False):
        break
      sleep_time = i ** 2
      sys.stdout.write(u'Project still being created. Sleeping {0} seconds\n'.format(sleep_time))
      time.sleep(sleep_time)
    if create_again:
      continue
    if not status.get(u'done', False):
      systemErrorExit(1, u'Failed to create project: {0}\n'.format(status))
    elif u'error' in status:
      systemErrorExit(2, status[u'error']+u'\n')
    break
  simplehttp = getHttpObj()
  enableProjectAPIs(httpObj, projectName, False)
  iam = googleapiclient.discovery.build(u'iam', u'v1', http=httpObj, cache_discovery=False)
  sys.stdout.write(u'Creating Service Account\n')
  service_account = callGAPI(iam.projects().serviceAccounts(), u'create',
                             name=u'projects/%s' % project_id,
                             body={u'accountId': project_id, u'serviceAccount': {u'displayName': u'GAM Project'}})
  key = callGAPI(iam.projects().serviceAccounts().keys(), u'create',
                 name=service_account[u'name'], body={u'privateKeyType': u'TYPE_GOOGLE_CREDENTIALS_FILE', u'keyAlgorithm': u'KEY_ALG_RSA_2048'})
  oauth2service_data = base64.b64decode(key[u'privateKeyData'])
  writeFile(service_account_file, oauth2service_data, continueOnError=False)
  console_credentials_url = u'https://console.developers.google.com/apis/credentials?project=%s' % project_id
  while True:
    sys.stdout.write(u'''Please go to:

{0}

1. Click the blue "Create credentials" button. Choose "OAuth client ID".
2. Click the blue "Configure consent screen" button. Enter "GAM" for "Product name to show to users".
3. Leave other fields blank. Click "Save" button.
3. Choose "Other" and click the blue "Create" button.
4. Copy your "client ID" value.

\n'''.format(console_credentials_url))
    client_id = readStdin(u'Enter your Client ID: ').strip()
    sys.stdout.write(u'\nNow go back to your browser and copy your client secret.\n')
    client_secret = readStdin(u'Enter your Client Secret: ').strip()
    client_valid = _checkClientAndSecret(simplehttp, client_id, client_secret)
    if client_valid:
      break
    sys.stdout.write(u'\n')
  cs_data = u'''{
    "installed": {
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "client_id": "%s",
        "client_secret": "%s",
        "project_id": "%s",
        "redirect_uris": [
            "urn:ietf:wg:oauth:2.0:oob",
            "http://localhost"
        ],
        "token_uri": "https://accounts.google.com/o/oauth2/token"
    }
}''' % (client_id, client_secret, project_id)
  writeFile(client_secrets_file, cs_data, continueOnError=False)
  sys.stdout.write(u'''Almost there! Now please switch back to your browser and:

1. Click OK to close "OAuth client" popup if it's still open.
2. Click "Manage service accounts" on the right of the screen.
3. Click the 3 dots to the right of your service account.
4. Choose Edit.
5. Check the "Enable G Suite Domain-wide Delegation" box and click Save.
\n''')
  readStdin(u'Press Enter when done...')
  sys.stdout.write(u'That\'s it! Your GAM Project is created and ready to use.\n')

# gam delete projects [<EmailAddress>]
def doDeleteProjects():
  # Leave undocumented. Most users should never need.
  # Deletes all projects with ID gam-project-*
  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  login_hint = getValidateLoginHint(login_hint)
  crm, _ = getCRMService(login_hint)
  projects = callGAPIpages(crm.projects(), u'list', u'projects')
  gam_pids = [project[u'projectId'] for project in projects if project[u'projectId'].startswith(u'gam-project-')]
  count = len(gam_pids)
  performActionNumItems(count, Ent.PROJECT)
  Ind.Increment()
  i = 0
  for pid in gam_pids:
    i += 1
    try:
      callGAPI(crm.projects(), u'delete',
               throw_reasons=[GAPI.FORBIDDEN],
               projectId=pid)
      entityActionPerformed([Ent.PROJECT, pid], i, count)
    except GAPI.forbidden as e:
      entityActionFailedWarning([Ent.PROJECT, pid], str(e), i, count)
  Ind.Decrement()

# gam update project [<EmailAddress>]
def doUpdateProject():
  login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  login_hint = getValidateLoginHint(login_hint)
  _, httpObj = getCRMService(login_hint)
  cs_data = readFile(GC.Values[GC.CLIENT_SECRETS_JSON], mode=u'rb', continueOnError=True, displayError=True, encoding=None)
  if not cs_data:
    systemErrorExit(14, u'Your client secrets file:\n\n%s\n\nis missing. Please recreate the file.' % GC.Values[GC.CLIENT_SECRETS_JSON])
  try:
    cs_json = json.loads(cs_data)
    projectName = 'project:%s' % cs_json[u'installed'][u'project_id']
  except (ValueError, IndexError, KeyError):
    systemErrorExit(3, u'The format of your client secrets file:\n\n%s\n\nis incorrect. Please recreate the file.' % GC.Values[GC.CLIENT_SECRETS_JSON])
  enableProjectAPIs(httpObj, projectName, True)

# gam whatis <EmailItem> [noinfo]
def doWhatIs():
  def _showEmailType(entityType, email):
    printEntity([entityType, email])

  cd = buildGAPIObject(API.DIRECTORY)
  email = getEmailAddress()
  showInfo = not checkArgumentPresent(u'noinfo')
  if not showInfo:
    checkForExtraneousArguments()
  try:
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=email, fields=u'id,primaryEmail')
    if (result[u'primaryEmail'].lower() == email) or (result[u'id'] == email):
      if showInfo:
        infoUsers(entityList=[email])
      else:
        _showEmailType(Ent.USER, email)
      setSysExitRC(ENTITY_IS_A_USER_RC)
    else:
      if showInfo:
        infoAliases(entityList=[email])
      else:
        _showEmailType(Ent.USER_ALIAS, email)
      setSysExitRC(ENTITY_IS_A_USER_ALIAS_RC)
    return
  except (GAPI.userNotFound, GAPI.badRequest):
    pass
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.backendError, GAPI.systemError):
    entityUnknownWarning(Ent.EMAIL, email)
    setSysExitRC(ENTITY_IS_UKNOWN_RC)
    return
  try:
    result = callGAPI(cd.groups(), u'get',
                      throw_reasons=GAPI.GROUP_GET_THROW_REASONS,
                      groupKey=email, fields=u'id,email')
    if (result[u'email'].lower() == email) or (result[u'id'] == email):
      if showInfo:
        infoGroups(entityList=[email])
      else:
        _showEmailType(Ent.GROUP, email)
      setSysExitRC(ENTITY_IS_A_GROUP_RC)
    else:
      if showInfo:
        infoAliases(entityList=[email])
      else:
        _showEmailType(Ent.GROUP_ALIAS, email)
      setSysExitRC(ENTITY_IS_A_GROUP_ALIAS_RC)
    return
  except GAPI.groupNotFound:
    pass
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
    entityUnknownWarning(Ent.EMAIL, email)
    setSysExitRC(ENTITY_IS_UKNOWN_RC)
    return
  entityUnknownWarning(Ent.EMAIL, email)
  setSysExitRC(ENTITY_IS_UKNOWN_RC)

def _adjustTryDate(errMsg, noDateChange):
  match_date = re.match(u'Data for dates later than (.*) is not yet available. Please check back later', errMsg)
  if not match_date:
    match_date = re.match(u'Start date can not be later than (.*)', errMsg)
  if (not match_date) or noDateChange:
    printWarningMessage(DATA_NOT_AVALIABLE_RC, errMsg)
    return None
  return match_date.group(1)

def _checkFullDataAvailable(warnings, tryDate, fullDataRequired):
  for warning in warnings:
    if warning[u'code'] == u'PARTIAL_DATA_AVAILABLE':
      for app in warning[u'data']:
        if app[u'key'] == u'application' and app[u'value'] != u'docs' and (not fullDataRequired or app[u'value'] in fullDataRequired):
          tryDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)-datetime.timedelta(days=1)
          return (0, tryDateTime.strftime(YYYYMMDD_FORMAT))
    elif warning[u'code'] == u'DATA_NOT_AVAILABLE':
      for app in warning[u'data']:
        if app[u'key'] == u'application' and app[u'value'] != u'docs' and (not fullDataRequired or app[u'value'] in fullDataRequired):
          return (-1, tryDate)
  return (1, tryDate)

NL_SPACES_PATTERN = re.compile(r'\n +')

REPORTS_PARAMETERS_SIMPLE_TYPES = [u'intValue', u'boolValue', u'datetimeValue', u'stringValue',]

REPORT_CHOICE_MAP = {
  u'admin': u'admin',
  u'calendar': u'calendar',
  u'calendars': u'calendar',
  u'customer': u'customer',
  u'customers': u'customer',
  u'doc': u'drive',
  u'docs': u'drive',
  u'domain': u'customer',
  u'drive': u'drive',
  u'gplus': u'gplus',
  u'group': u'groups',
  u'groups': u'groups',
  u'login': u'login',
  u'logins': u'login',
  u'mobile': u'mobile',
  u'rules': u'rules',
  u'token': u'token',
  u'tokens': u'token',
  u'user': u'user',
  u'users': u'user',
  }

REPORT_FULLDATA_APPS = [
  u'accounts',
  u'app_maker',
  u'apps_scripts',
  u'calendar',
  u'classroom',
  u'cros',
  u'device_management',
  u'drive',
  u'gmail',
  u'gplus',
  u'meet',
  u'mobile',
  u'sites',
  ]

REPORT_ACTIVITIES_TIME_OBJECTS = set([u'time',])

# gam report <users|user> [todrive [<ToDriveAttributes>]] [date <Date>] [nodatechange | (fulldatarequired all|<ReportAppsList>)]
#	[user all|<UserItem>] [select <UserTypeEntity>] [filter|filters <String>] [fields|parameters <String>]
#	[maxactivities <Number>] [maxresults <Number>]
# gam report <customers|customer|domain> [todrive [<ToDriveAttributes>]] [date <Date>] [nodatechange | (fulldatarequired all|<ReportAppsList>)]
#	[fields|parameters <String>]
# gam report <admin|calendars|drive|docs|doc|gplus|groups|group|logins|login|mobile|rules|tokens|token> [todrive [<ToDriveAttributes>]] [maxresults <Number>] [maxactivities <Number>]
#	[([start <Time>] [end <Time>])|yesterday] [user all|<UserItem>] [select <UserTypeEntity>] [event <String>] [filter|filters <String>] [fields|parameters <String>] [ip <String>] countsonly summary
def doReport():
  report = getChoice(REPORT_CHOICE_MAP, mapChoice=True)
  rep = buildGAPIObject(API.REPORTS)
  customerId = GC.Values[GC.CUSTOMER_ID]
  if customerId == GC.MY_CUSTOMER:
    customerId = None
  filters = parameters = actorIpAddress = startTime = endTime = startDateTime = endDateTime = eventName = None
  tryDate = todaysDate().strftime(YYYYMMDD_FORMAT)
  maxActivities = 0
  maxResults = 1000
  countsOnly = exitUserLoop = noDateChange = normalizeUsers = select = summary = False
  todrive = {}
  userKey = u'all'
  filtersUserValid = report != u'customer'
  usageReports = report in [u'customer', u'user']
  activityReports = not usageReports
  fullDataRequired = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif usageReports and myarg == u'date':
      tryDate = getYYYYMMDD()
    elif usageReports and myarg == u'nodatechange':
      noDateChange = True
    elif usageReports and myarg in [u'fields', u'parameters']:
      parameters = getString(Cmd.OB_STRING)
    elif usageReports and myarg == u'fulldatarequired':
      fullDataRequired = []
      fdr = getString(Cmd.OB_FIELD_NAME_LIST, minLen=0).lower()
      if len(fdr) > 0  and fdr != u'all':
        for field in fdr.replace(u',', u' ').split():
          if field in REPORT_FULLDATA_APPS:
            fullDataRequired.append(field)
          else:
            invalidChoiceExit(REPORT_FULLDATA_APPS, True)
    elif activityReports and myarg == u'start':
      startDateTime, tzinfo, startTime = getTimeOrDeltaFromNow(True)
      earliestDateTime = datetime.datetime.now(tzinfo)-datetime.timedelta(days=180)
      if startDateTime < earliestDateTime:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_TIME_RANGE.format(u'start', startTime, Msg.GOOGLE_EARLIEST_REPORT_TIME, ISOformatTimeStamp(earliestDateTime)))
      if endDateTime and endDateTime < startDateTime:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_TIME_RANGE.format(u'end', endTime, u'start', startTime))
    elif activityReports and myarg == u'end':
      endDateTime, _, endTime = getTimeOrDeltaFromNow(True)
      if startDateTime and endDateTime < startDateTime:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_TIME_RANGE.format(u'end', endTime, u'start', startTime))
    elif activityReports and myarg == u'yesterday':
      startDateTime = todaysDate()+datetime.timedelta(days=-1)
      startTime = ISOformatTimeStamp(startDateTime)
      endDateTime = todaysDate()+datetime.timedelta(seconds=-1)
      endTime = ISOformatTimeStamp(endDateTime)
    elif activityReports and myarg == u'event':
      eventName = getString(Cmd.OB_STRING)
    elif activityReports and myarg == u'ip':
      actorIpAddress = getString(Cmd.OB_STRING)
    elif activityReports and myarg == u'countsonly':
      countsOnly = True
    elif activityReports and myarg == u'summary':
      summary = True
    elif filtersUserValid and myarg == u'maxresults':
      maxResults = getInteger(minVal=1, maxVal=1000)
    elif filtersUserValid and myarg == u'maxactivities':
      maxActivities = getInteger(minVal=0)
    elif filtersUserValid and myarg == u'user':
      userKey = getString(Cmd.OB_EMAIL_ADDRESS)
    elif filtersUserValid and myarg == u'select':
      _, users = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
      select = True
    elif filtersUserValid and myarg in [u'filter', u'filters']:
      filters = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  if report == u'user':
    if select:
      page_message = None
      normalizeUsers = True
    elif userKey == u'all':
      printGettingAllAccountEntities(Ent.USER)
      page_message = getPageMessage(showTotal=False)
      users = [u'all']
    else:
      Ent.SetGetting(Ent.USER)
      page_message = getPageMessage(showTotal=False)
      users = [normalizeEmailAddressOrUID(userKey)]
    titles, csvRows = initializeTitlesCSVfile([u'email', u'date'])
    i = 0
    count = len(users)
    for user in users:
      i += 1
      if normalizeUsers:
        user = normalizeEmailAddressOrUID(user)
      printGettingEntityItemForWhom(Ent.REPORT, user, i, count)
      while True:
        try:
          if fullDataRequired is not None:
            warnings = callGAPIitems(rep.userUsageReport(), u'get', u'warnings',
                                     throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                     userKey=user, date=tryDate, customerId=customerId, fields=u'warnings')
            fullData, tryDate = _checkFullDataAvailable(warnings, tryDate, fullDataRequired)
            if fullData < 0:
              printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_REPORT_AVAILABLE.format(report))
              return
            if fullData == 0:
              continue
          usage = callGAPIpages(rep.userUsageReport(), u'get', u'usageReports',
                                page_message=page_message, maxItems=maxActivities,
                                throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                userKey=user, date=tryDate, customerId=customerId, filters=filters, parameters=parameters,
                                maxResults=maxResults)
          if not usage:
            printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_REPORT_AVAILABLE.format(report))
            return
          while usage:
            user_report = usage.popleft()
            if u'entity' not in user_report:
              continue
            row = {u'email': user_report[u'entity'][u'userEmail'], u'date': tryDate}
            for item in user_report.get(u'parameters', {}):
              if u'name' not in item:
                continue
              name = item[u'name']
              if name not in titles[u'set']:
                addTitleToCSVfile(name, titles)
              for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
                if ptype in item:
                  if ptype != u'datetimeValue':
                    row[name] = item[ptype]
                  else:
                    row[name] = formatLocalTime(item[ptype])
                  break
              else:
                row[name] = u''
            csvRows.append(row)
          break
        except GAPI.invalid as e:
          tryDate = _adjustTryDate(str(e), noDateChange)
          if not tryDate:
            return
        except GAPI.badRequest:
          if user != u'all':
            entityUnknownWarning(Ent.USER, user, i, count)
          else:
            printErrorMessage(BAD_REQUEST_RC, Msg.BAD_REQUEST)
            exitUserLoop = True
          break
        except GAPI.forbidden:
          accessErrorExit(None)
      if exitUserLoop:
        break
    writeCSVfile(csvRows, titles, u'User Reports - {0}'.format(tryDate), todrive, [u'email', u'date'])
  elif report == u'customer':
    titles, csvRows = initializeTitlesCSVfile([u'name', u'value', u'client_id'])
    auth_apps = []
    while True:
      try:
        if fullDataRequired is not None:
          warnings = callGAPIitems(rep.customerUsageReports(), u'get', u'warnings',
                                   throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                   date=tryDate, customerId=customerId, fields=u'warnings')
          fullData, tryDate = _checkFullDataAvailable(warnings, tryDate, fullDataRequired)
          if fullData < 0:
            printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_REPORT_AVAILABLE.format(report))
            return
          if fullData == 0:
            continue
        usage = callGAPIpages(rep.customerUsageReports(), u'get', u'usageReports',
                              throw_reasons=[GAPI.INVALID, GAPI.FORBIDDEN],
                              date=tryDate, customerId=customerId, parameters=parameters)
        if not usage:
          printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_REPORT_AVAILABLE.format(report))
          return
        for item in usage[0][u'parameters']:
          if u'name' not in item:
            continue
          name = item[u'name']
          for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
            if ptype in item:
              if ptype != u'datetimeValue':
                csvRows.append({u'name': name, u'value': item[ptype]})
              else:
                csvRows.append({u'name': name, u'value': formatLocalTime(item[ptype])})
              break
          else:
            if u'msgValue' in item:
              if name == u'accounts:authorized_apps':
                for subitem in item[u'msgValue']:
                  app = {}
                  for an_item in subitem:
                    if an_item == u'client_name':
                      app[u'name'] = u'App: {0}'.format(escapeCRsNLs(subitem[an_item]))
                    elif an_item == u'num_users':
                      app[u'value'] = u'{0} users'.format(subitem[an_item])
                    elif an_item == u'client_id':
                      app[u'client_id'] = subitem[an_item]
                  auth_apps.append(app)
              else:
                values = []
                for subitem in item[u'msgValue']:
                  if u'count' in subitem:
                    mycount = myvalue = None
                    for key, value in subitem.items():
                      if key == u'count':
                        mycount = value
                      else:
                        myvalue = value
                      if mycount and myvalue:
                        values.append(u'%s:%s' % (myvalue, mycount))
                    value = u' '.join(values)
                  elif u'version_number' in subitem and u'num_devices' in subitem:
                    values.append(u'%s:%s' % (subitem[u'version_number'], subitem[u'num_devices']))
                  else:
                    continue
                  value = u' '.join(sorted(values, reverse=True))
                csvRows.append({u'name': name, u'value': value})
        csvRows.sort(key=lambda k: k[u'name'])
        for row in sorted(auth_apps, key=lambda k: k[u'name'].lower()):
          csvRows.append(row)
        break
      except GAPI.invalid as e:
        tryDate = _adjustTryDate(str(e), noDateChange)
        if not tryDate:
          return
      except GAPI.forbidden:
        accessErrorExit(None)
    writeCSVfile(csvRows, titles, u'Customer Report - {0}'.format(tryDate), todrive)
  else:     # admin, calendar, drive, gplus, groups, login, mobile, rules, token
    if select:
      page_message = None
      normalizeUsers = True
    elif userKey == u'all':
      printGettingAllAccountEntities(Ent.ACTIVITY)
      page_message = getPageMessage(showTotal=False)
      users = [u'all']
    else:
      Ent.SetGetting(Ent.ACTIVITY)
      page_message = getPageMessage(showTotal=False)
      users = [normalizeEmailAddressOrUID(userKey)]
    eventCounts = {}
    titles, csvRows = initializeTitlesCSVfile(None)
    i = 0
    count = len(users)
    for user in users:
      i += 1
      if normalizeUsers:
        user = normalizeEmailAddressOrUID(user)
      if select or userKey != u'all':
        printGettingEntityItemForWhom(Ent.ACTIVITY, user, i, count)
      try:
        feed = callGAPIpages(rep.activities(), u'list', u'items',
                             page_message=page_message, maxItems=maxActivities,
                             throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.AUTH_ERROR],
                             applicationName=report, userKey=user, customerId=customerId,
                             actorIpAddress=actorIpAddress, startTime=startTime, endTime=endTime, eventName=eventName, filters=filters,
                             maxResults=maxResults)
        while feed:
          activity = feed.popleft()
          events = activity.pop(u'events')
          if not countsOnly:
            activity_row = flattenJSON(activity, timeObjects=REPORT_ACTIVITIES_TIME_OBJECTS)
            for event in events:
              for item in event.get(u'parameters', []):
                if item[u'name'] in [u'start_time', u'end_time']:
                  val = item.get(u'intValue')
                  if val is not None:
                    val = int(val)
                    if val >= 62135683200:
                      item[u'dateTimeValue'] = ISOformatTimeStamp(datetime.datetime.fromtimestamp(val-62135683200, GC.Values[GC.TIMEZONE]))
                      item.pop(u'intValue')
                if u'value' in item:
                  item[u'value'] = NL_SPACES_PATTERN.sub(u'', item[u'value'])
              row = flattenJSON(event)
              row.update(activity_row)
              addRowTitlesToCSVfile(row, csvRows, titles)
          elif not summary:
            actor = activity[u'actor'][u'email']
            eventCounts.setdefault(actor, {})
            for event in events:
              eventCounts[actor].setdefault(event[u'name'], 0)
              eventCounts[actor][event[u'name']] += 1
          else:
            for event in events:
              eventCounts.setdefault(event[u'name'], 0)
              eventCounts[event[u'name']] += 1
      except GAPI.badRequest:
        if user != u'all':
          entityUnknownWarning(Ent.USER, user, i, count)
        else:
          printErrorMessage(BAD_REQUEST_RC, Msg.BAD_REQUEST)
          break
      except GAPI.invalid as e:
        systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
      except GAPI.authError:
        accessErrorExit(None)
    if not countsOnly:
      sortCSVTitles([u'name',], titles)
    elif not summary:
      addTitlesToCSVfile(u'emailAddress', titles)
      for actor, events in iteritems(eventCounts):
        row = {u'emailAddress': actor}
        for event, count in iteritems(events):
          row[event] = count
        addRowTitlesToCSVfile(row, csvRows, titles)
      sortCSVTitles([u'emailAddress',], titles)
    else:
      addTitlesToCSVfile([u'event', u'count'], titles)
      for event in sorted(eventCounts):
        csvRows.append({u'event': event, u'count': eventCounts[event]})
    writeCSVfile(csvRows, titles, u'{0} Activity Report'.format(report.capitalize()), todrive)

# Substitute for #user#, #email#, #usernamne#
def _substituteForUser(field, user, userName):
  if field.find(u'#') == -1:
    return field
  return field.replace(u'#user#', user).replace(u'#email#', user).replace(u'#username#', userName)

# Tag utilities
TAG_ADDRESS_ARGUMENT_TO_FIELD_MAP = {
  u'country': u'country',
  u'countrycode': u'countryCode',
  u'customtype': u'customType',
  u'extendedaddress': u'extendedAddress',
  u'formatted': u'formatted',
  u'locality': u'locality',
  u'pobox': u'poBox',
  u'postalcode': u'postalCode',
  u'region': u'region',
  u'streetaddress': u'streetAddress',
  u'type': u'type',
  }

TAG_EMAIL_ARGUMENT_TO_FIELD_MAP = {
  u'domain': u'domain',
  u'primaryemail': u'primaryEmail',
  u'username': u'username',
  }

TAG_LOCATION_ARGUMENT_TO_FIELD_MAP = {
  u'area': u'area',
  u'buildingid': u'buildingId',
  u'buildingname': u'buildingName',
  u'customtype': u'customType',
  u'deskcode': u'deskCode',
  u'floorname': u'floorName',
  u'floorsection': u'floorSection',
  u'type': u'type',
  }

TAG_NAME_ARGUMENT_TO_FIELD_MAP = {
  u'familyname': u'familyName',
  u'fullname': u'fullName',
  u'givenname': u'givenName',
  }

TAG_ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
  u'costcenter': u'costCenter',
  u'customtype': u'customType',
  u'department': u'department',
  u'description': u'description',
  u'domain': u'domain',
  u'fulltimeequivalent': u'fullTimeEquivalent',
  u'location': u'location',
  u'name': u'name',
  u'symbol': u'symbol',
  u'title': u'title',
  u'type': u'type',
  }

TAG_PHONE_ARGUMENT_TO_FIELD_MAP = {
  u'customtype': u'customType',
  u'type': u'type',
  u'value': u'value',
  }

TAG_FIELD_SUBFIELD_CHOICE_MAP = {
  u'address': (u'addresses', TAG_ADDRESS_ARGUMENT_TO_FIELD_MAP),
  u'addresses': (u'addresses', TAG_ADDRESS_ARGUMENT_TO_FIELD_MAP),
  u'email': (u'primaryEmail', TAG_EMAIL_ARGUMENT_TO_FIELD_MAP),
  u'location': (u'locations', TAG_LOCATION_ARGUMENT_TO_FIELD_MAP),
  u'locations': (u'locations', TAG_LOCATION_ARGUMENT_TO_FIELD_MAP),
  u'name': (u'name', TAG_NAME_ARGUMENT_TO_FIELD_MAP),
  u'organization': (u'organizations', TAG_ORGANIZATION_ARGUMENT_TO_FIELD_MAP),
  u'organizations': (u'organizations', TAG_ORGANIZATION_ARGUMENT_TO_FIELD_MAP),
  u'phone': (u'phones', TAG_PHONE_ARGUMENT_TO_FIELD_MAP),
  u'phones': (u'phones', TAG_PHONE_ARGUMENT_TO_FIELD_MAP),
  }

def _initTagReplacements():
  return {u'cd': None, u'tags': {}, u'subs': False,
          u'fieldsSet': set(), u'fields': u'',
          u'schemasSet': set(), u'customFieldMask': None}

def _getTagReplacement(tagReplacements, allowSubs):
  matchTag = getString(Cmd.OB_TAG)
  matchReplacement = getString(Cmd.OB_STRING, minLen=0)
  if matchReplacement.startswith(u'field:'):
    if not allowSubs:
      usageErrorExit(Msg.USER_SUBS_NOT_ALLOWED_TAG_REPLACEMENT)
    tagReplacements[u'subs'] = True
    field = matchReplacement[6:].strip().lower()
    if field.find(u'.') != -1:
      field, subfield = field.split(u'.', 1)
    else:
      field = u''
    if not field or field not in TAG_FIELD_SUBFIELD_CHOICE_MAP:
      invalidChoiceExit(TAG_FIELD_SUBFIELD_CHOICE_MAP, True)
    field, subfieldsChoiceMap = TAG_FIELD_SUBFIELD_CHOICE_MAP[field]
    if subfield not in subfieldsChoiceMap:
      invalidChoiceExit(subfieldsChoiceMap, True)
    subfield = subfieldsChoiceMap[subfield]
    tagReplacements[u'fieldsSet'].add(field)
    tagReplacements[u'fields'] = u','.join(tagReplacements[u'fieldsSet'])
    tagReplacements[u'tags'][matchTag] = {u'field': field, u'subfield': subfield, u'value': u''}
    if field == u'locations' and subfield == u'buildingName':
      _makeBuildingIdNameMap()
  elif matchReplacement.startswith(u'schema:'):
    if not allowSubs:
      usageErrorExit(Msg.USER_SUBS_NOT_ALLOWED_TAG_REPLACEMENT)
    tagReplacements[u'subs'] = True
    matchReplacement = matchReplacement[7:].strip()
    if matchReplacement.find(u'.') != -1:
      schemaName, schemaField = matchReplacement.split(u'.', 1)
    else:
      schemaName = u''
    if not schemaName or not schemaField:
      invalidArgumentExit(Cmd.OB_SCHEMA_NAME_FIELD_NAME)
    tagReplacements[u'fieldsSet'].add(u'customSchemas')
    tagReplacements[u'fields'] = u','.join(tagReplacements[u'fieldsSet'])
    tagReplacements[u'schemasSet'].add(schemaName)
    tagReplacements[u'customFieldMask'] = u','.join(tagReplacements[u'schemasSet'])
    tagReplacements[u'tags'][matchTag] = {u'schema': schemaName, u'schemafield': schemaField, u'value': u''}
  elif ((matchReplacement.find(u'#') >= 0) and
        (matchReplacement.find(u'#user#') >= 0) or (matchReplacement.find(u'#email#') >= 0) or (matchReplacement.find(u'#username#') >= 0)):
    if not allowSubs:
      usageErrorExit(Msg.USER_SUBS_NOT_ALLOWED_TAG_REPLACEMENT)
    tagReplacements[u'subs'] = True
    tagReplacements[u'tags'][matchTag] = {u'template': matchReplacement, u'value': u''}
  else:
    tagReplacements[u'tags'][matchTag] = {u'value': matchReplacement}

def _getTagReplacementFieldValues(user, i, count, tagReplacements):
  if tagReplacements[u'fields'] and tagReplacements[u'fields'] != u'primaryEmail':
    if not tagReplacements[u'cd']:
      tagReplacements[u'cd'] = buildGAPIObject(API.DIRECTORY)
    try:
      results = callGAPI(tagReplacements[u'cd'].users(), u'get',
                         throw_reasons=GAPI.USER_GET_THROW_REASONS,
                         userKey=user, projection=u'custom', customFieldMask=tagReplacements[u'customFieldMask'], fields=tagReplacements[u'fields'])
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER, user, i, count)
      return
  else:
    results = {u'primaryEmail': user}
  userName, domain = splitEmailAddress(user)
  for _, tag in iteritems(tagReplacements[u'tags']):
    if tag.get(u'field'):
      field = tag[u'field']
      if field == u'primaryEmail':
        subfield = tag[u'subfield']
        if subfield == u'username':
          tag[u'value'] = userName
        elif subfield == u'domain':
          tag[u'value'] = domain
        else:
          tag[u'value'] = user
      else:
        if field in [u'addresses', u'organizations', u'phones']:
          items = results.get(field, [])
          for data in items:
            if data.get(u'primary'):
              break
          else:
            if len(items) > 0:
              data = items[0]
            else:
              data = {}
        elif field == u'locations':
          items = results.get(field, [])
          if len(items) > 0:
            data = items[0]
            data[u'buildingName'] = GM.Globals[GM.MAP_BUILDING_ID_TO_NAME].get(data.get(u'buildingId', u''), u'')
          else:
            data = {}
        else:
          data = results.get(field, {})
        tag[u'value'] = str(data.get(tag[u'subfield'], u''))
    elif tag.get(u'schema'):
      tag[u'value'] = str(results.get(u'customSchemas', {}).get(tag[u'schema'], {}).get(tag[u'schemafield'], u''))
    elif tag.get(u'template'):
      tag[u'value'] = _substituteForUser(tag[u'template'], user, userName)

RT_PATTERN = re.compile(r'(?s){RT}.*?{(.+?)}.*?{/RT}')
RT_OPEN_PATTERN = re.compile(r'{RT}')
RT_CLOSE_PATTERN = re.compile(r'{/RT}')
RT_STRIP_PATTERN = re.compile(r'(?s){RT}.*?{/RT}')
RT_TAG_REPLACE_PATTERN = re.compile(r'{(.*?)}')

def _processTagReplacements(tagReplacements, message):
  while True:
    match = RT_PATTERN.search(message)
    if not match:
      break
    if tagReplacements[u'tags'].get(match.group(1), {u'value': u''})[u'value']:
      message = RT_OPEN_PATTERN.sub(u'', message, count=1)
      message = RT_CLOSE_PATTERN.sub(u'', message, count=1)
    else:
      message = RT_STRIP_PATTERN.sub(u'', message, count=1)
  while True:
    match = RT_TAG_REPLACE_PATTERN.search(message)
    if not match:
      break
    message = re.sub(match.group(0), tagReplacements[u'tags'].get(match.group(1), {u'value': u''})[u'value'], message)
  return message

def sendCreateUpdateUserNotification(notify, body, i=0, count=0, createMessage=True):
  def _makeSubstitutions(field):
    notify[field] = _substituteForUser(notify[field], body[u'primaryEmail'], userName)
    notify[field] = notify[field].replace(u'#domain#', domain)
    notify[field] = notify[field].replace(u'#givenname#', body[u'name'].get(u'givenName', u''))
    notify[field] = notify[field].replace(u'#familyname#', body[u'name'].get(u'familyName', u''))
    notify[field] = notify[field].replace(u'#password#', notify[u'password'])

  userName, domain = splitEmailAddress(body[u'primaryEmail'])
  if not notify.get(u'subject'):
    notify[u'subject'] = [Msg.UPDATE_USER_PASSWORD_CHANGE_NOTIFY_SUBJECT, Msg.CREATE_USER_NOTIFY_SUBJECT][createMessage]
  _makeSubstitutions(u'subject')
  if not notify.get(u'message'):
    notify[u'message'] = [Msg.UPDATE_USER_PASSWORD_CHANGE_NOTIFY_MESSAGE, Msg.CREATE_USER_NOTIFY_MESSAGE][createMessage]
  _makeSubstitutions(u'message')
  send_email(notify[u'subject'], notify[u'message'], notify[u'emailAddress'], i, count, html=notify[u'html'], charset=notify[u'charset'])

# gam sendemail <RecipientEntity> [from <UserItem>] [replyto <EmailAddress>] subject <String> (message <String>)|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)* [html [<Boolean>]]
#	[newuser <EmailAddress> firstname|givenname <String> lastname|familyname <string> password <Password>]
def doSendEmail():
  body = {}
  notify = {u'html': False, u'charset': u'utf-8'}
  msgFrom = msgReplyTo = None
  tagReplacements = _initTagReplacements()
  recipients = getEntityList(Cmd.OB_RECIPIENT_ENTITY)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'from':
      msgFrom = getString(Cmd.OB_EMAIL_ADDRESS)
    elif myarg == u'replyto':
      msgReplyTo = getString(Cmd.OB_EMAIL_ADDRESS)
    elif myarg == u'subject':
      notify[u'subject'] = getString(Cmd.OB_STRING)
    elif myarg == u'message':
      if checkArgumentPresent(u'file'):
        filename = getString(Cmd.OB_FILE_NAME)
        notify[u'charset'] = getCharSet()
        notify[u'message'] = readFile(filename, encoding=notify[u'charset'])
      else:
        notify[u'message'] = getString(Cmd.OB_STRING)
    elif myarg == u'html':
      notify[u'html'] = getBoolean()
    elif myarg == u'newuser':
      body[u'primaryEmail'] = getEmailAddress()
    elif myarg in [u'firstname', u'givenname']:
      body.setdefault(u'name', {})
      body[u'name'][u'givenName'] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
    elif myarg in [u'lastname', u'familyname']:
      body.setdefault(u'name', {})
      body[u'name'][u'familyName'] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
    elif myarg == u'password':
      body[u'password'] = notify[u'password'] = getString(Cmd.OB_PASSWORD, maxLen=100)
    elif myarg == u'replace':
      _getTagReplacement(tagReplacements, False)
    else:
      unknownArgumentExit()
  if u'message' in notify:
    notify[u'message'] = notify[u'message'].replace(u'\r', u'').replace(u'\\n', u'\n')
    if tagReplacements[u'tags']:
      notify[u'message'] = _processTagReplacements(tagReplacements, notify['message'])
  if u'subject' in notify:
    if tagReplacements[u'tags']:
      notify[u'subject'] = _processTagReplacements(tagReplacements, notify[u'subject'])
  i = 0
  count = len(recipients)
  if body.get(u'primaryEmail'):
    if (count == 1) and (u'password' in body) and (u'name' in body) and (u'givenName' in body[u'name']) and (u'familyName' in body[u'name']):
      notify[u'emailAddress'] = recipients[0]
      sendCreateUpdateUserNotification(notify, body)
    else:
      usageErrorExit(Msg.NEWUSER_REQUIREMENTS, True)
    return
  if not notify.get(u'subject'):
    missingArgumentExit(u'subject')
  if not notify.get(u'message'):
    missingArgumentExit(u'message')
  performActionModifierNumItems(Act.MODIFIER_TO, count, Ent.RECIPIENT)
  for recipient in recipients:
    i += 1
    send_email(notify[u'subject'], notify[u'message'], recipient, i, count, msgFrom, msgReplyTo, notify[u'html'], notify[u'charset'])

ADDRESS_FIELDS_PRINT_ORDER = [u'contactName', u'organizationName', u'addressLine1', u'addressLine2', u'addressLine3', u'locality', u'region', u'postalCode', u'countryCode']

def _showCustomerAddressPhoneNumber(customerInfo):
  if u'postalAddress' in customerInfo:
    printKeyValueList([u'Address', None])
    Ind.Increment()
    for field in ADDRESS_FIELDS_PRINT_ORDER:
      if field in customerInfo[u'postalAddress']:
        printKeyValueList([field, customerInfo[u'postalAddress'][field]])
    Ind.Decrement()
  if u'phoneNumber' in customerInfo:
    printKeyValueList([u'Phone', customerInfo[u'phoneNumber']])

ADDRESS_FIELDS_ARGUMENT_MAP = {
  u'contact': u'contactName', u'contactname': u'contactName',
  u'name': u'organizationName', u'organizationname': u'organizationName',
  u'address': u'addressLine1', u'address1': u'addressLine1', u'addressline1': u'addressLine1',
  u'address2': u'addressLine2', u'addressline2': u'addressLine2',
  u'address3': u'addressLine3', u'addressline3': u'addressLine3',
  u'city': u'locality', u'locality': u'locality',
  u'state': u'region', u'region': u'region',
  u'zipcode': u'postalCode', u'postal': u'postalCode', u'postalcode': u'postalCode',
  u'country': u'countryCode', u'countrycode': u'countryCode',
  }

def _getResoldCustomerAttr():
  body = {}
  customerAuthToken = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADDRESS_FIELDS_ARGUMENT_MAP:
      body.setdefault(u'postalAddress', {})
      body[u'postalAddress'][ADDRESS_FIELDS_ARGUMENT_MAP[myarg]] = getString(Cmd.OB_STRING, minLen=0, maxLen=255)
    elif myarg in [u'email', u'alternateemail']:
      body[u'alternateEmail'] = getEmailAddress(noUid=True)
    elif myarg in [u'phone', u'phonenumber']:
      body[u'phoneNumber'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in [u'customerauthtoken', u'transfertoken']:
      customerAuthToken = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  return customerAuthToken, body

# gam create resoldcustomer <CustomerDomain> (customer_auth_token <String>) <ResoldCustomerAttributes>+
def doCreateResoldCustomer():
  res = buildGAPIObject(API.RESELLER)
  customerDomain = getString(u'customerDomain')
  customerAuthToken, body = _getResoldCustomerAttr()
  body[u'customerDomain'] = customerDomain
  try:
    result = callGAPI(res.customers(), u'insert',
                      throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      body=body, customerAuthToken=customerAuthToken, fields=u'customerId')
    result = json.loads(readFile(u'custInfo.json'))
    entityActionPerformed([Ent.CUSTOMER_DOMAIN, body[u'customerDomain'], Ent.CUSTOMER_ID, result[u'customerId']])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_DOMAIN, body[u'customerDomain']], str(e))

# gam update resoldcustomer <CustomerID> [customer_auth_token <String>] <ResoldCustomerAttributes>+
def doUpdateResoldCustomer():
  res = buildGAPIObject(API.RESELLER)
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  customerAuthToken, body = _getResoldCustomerAttr()
  try:
    callGAPI(res.customers(), u'patch',
             throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerId=customerId, body=body, customerAuthToken=customerAuthToken, fields=u'')
    entityActionPerformed([Ent.CUSTOMER_ID, customerId])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

# gam info resoldcustomer <CustomerID>
def doInfoResoldCustomer():
  res = buildGAPIObject(API.RESELLER)
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  checkForExtraneousArguments()
  try:
    customerInfo = callGAPI(res.customers(), u'get',
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId)
    printKeyValueList([u'Customer ID', customerInfo[u'customerId']])
    printKeyValueList([u'Customer Domain', customerInfo[u'customerDomain']])
    printKeyValueList([u'Customer Domain Verified', customerInfo[u'customerDomainVerified']])
    _showCustomerAddressPhoneNumber(customerInfo)
    printKeyValueList([u'Customer Alternate Email', customerInfo[u'alternateEmail']])
    printKeyValueList([u'Customer Admin Console URL', customerInfo[u'resourceUiUrl']])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

def getCustomerSubscription(res):
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  skuId = getString(Cmd.OB_SKU_ID)
  try:
    subscriptions = callGAPIpages(res.subscriptions(), u'list', u'subscriptions',
                                  throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                  customerId=customerId, fields=u'nextPageToken,subscriptions(skuId,subscriptionId)')
    for subscription in subscriptions:
      if skuId == subscription[u'skuId']:
        return (customerId, skuId, subscription[u'subscriptionId'])
    Cmd.Backup()
    usageErrorExit(u'{0}, {1}'.format(Ent.FormatEntityValueList([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId]), Msg.SUBSCRIPTION_NOT_FOUND))
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.SUBSCRIPTION, None], str(e))
    sys.exit(GM.Globals[GM.SYSEXITRC])

PLAN_NAME_MAP = {
  u'annualmonthlypay': u'ANNUAL_MONTHLY_PAY',
  u'annualyearlypay': u'ANNUAL_YEARLY_PAY',
  u'flexible': u'FLEXIBLE',
  u'trial': u'TRIAL',
  }

def _getResoldSubscriptionAttr(customerId):
  body = {u'customerId': customerId,
          u'plan': {},
          u'seats': {},
          u'skuId': None,
         }
  customerAuthToken = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'deal', u'dealcode']:
      body[u'dealCode'] = getString(u'dealCode')
    elif myarg in [u'plan', u'planname']:
      body[u'plan'][u'planName'] = getChoice(PLAN_NAME_MAP, mapChoice=True)
    elif myarg in [u'purchaseorderid', u'po']:
      body[u'purchaseOrderId'] = getString(u'purchaseOrderId')
    elif myarg in [u'seats']:
      body[u'seats'][u'numberOfSeats'] = getInteger()
      body[u'seats'][u'maximumNumberOfSeats'] = getInteger()
    elif myarg in [u'sku', u'skuid']:
      _, body[u'skuId'] = SKU.getProductAndSKU(getString(Cmd.OB_SKU_ID))
    elif myarg in [u'customerauthtoken', u'transfertoken']:
      customerAuthToken = getString(u'customer_auth_token')
    else:
      unknownArgumentExit()
  for field in [u'plan', u'seats', u'skuId']:
    if not body[field]:
      missingArgumentExit(field.lower())
  return customerAuthToken, body

SUBSCRIPTION_SKIP_OBJECTS = set([u'customerId', u'skuId', u'subscriptionId'])
SUBSCRIPTION_TIME_OBJECTS = set([u'creationTime', u'startTime', u'endTime', u'trialEndTime', u'transferabilityExpirationTime'])

def _showSubscription(subscription):
  Ind.Increment()
  printEntity([Ent.SUBSCRIPTION, subscription[u'subscriptionId']])
  showJSON(None, subscription, skipObjects=SUBSCRIPTION_SKIP_OBJECTS, timeObjects=SUBSCRIPTION_TIME_OBJECTS)
  Ind.Decrement()

# gam create resoldsubscription <CustomerID> (sku <SKUID>)
#	 (plan annual_monthly_pay|annual_yearly_pay|flexible|trial) (seats <NumberOfSeats> <MaximumNumberOfSeats>)
#	 [customer_auth_token <String>] [deal <String>] [purchaseorderid <String>]
def doCreateResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  customerAuthToken, body = _getResoldSubscriptionAttr(customerId)
  try:
    subscription = callGAPI(res.subscriptions(), u'insert',
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId, customerAuthToken=customerAuthToken, body=body)
    entityActionPerformed([Ent.CUSTOMER_ID, customerId, Ent.SKU, subscription[u'skuId']])
    _showSubscription(subscription)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

RENEWAL_TYPE_MAP = {
  u'autorenewmonthlypay': u'AUTO_RENEW_MONTHLY_PAY',
  u'autorenewyearlypay': u'AUTO_RENEW_YEARLY_PAY',
  u'cancel': u'CANCEL',
  u'renewcurrentusersmonthlypay': u'RENEW_CURRENT_USERS_MONTHLY_PAY',
  u'renewcurrentusersyearlypay': u'RENEW_CURRENT_USERS_YEARLY_PAY',
  u'switchtopayasyougo': u'SWITCH_TO_PAY_AS_YOU_GO',
  }

# gam update resoldsubscription <CustomerID> <SKUID>
#	activate|suspend|startpaidservice|
#	(renewal auto_renew_monthly_pay|auto_renew_yearly_pay|cancel|renew_current_users_monthly_pay|renew_current_users_yearly_pay|switch_to_pay_as_you_go)|
#	(seats <NumberOfSeats> [<MaximumNumberOfSeats>])|
#	(plan annual_monthly_pay|annual_yearly_pay|flexible|trial [deal <String>] [purchaseorderid <String>] [seats <NumberOfSeats> [<MaximumNumberOfSeats>]])
def doUpdateResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  function = None
  customerId, skuId, subscriptionId = getCustomerSubscription(res)
  kwargs = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'activate':
      function = u'activate'
    elif myarg == u'suspend':
      function = u'suspend'
    elif myarg == u'startpaidservice':
      function = u'startPaidService'
    elif myarg in [u'renewal', u'renewaltype']:
      function = u'changeRenewalSettings'
      kwargs[u'body'] = {u'renewalType': getChoice(RENEWAL_TYPE_MAP, mapChoice=True)}
    elif myarg in [u'seats']:
      function = u'changeSeats'
      kwargs[u'body'] = {u'numberOfSeats': getInteger()}
      if Cmd.ArgumentsRemaining() and Cmd.Current().isdigit():
        kwargs[u'body'][u'maximumNumberOfSeats'] = getInteger()
    elif myarg in [u'plan']:
      function = u'changePlan'
      kwargs[u'body'] = {u'planName': getChoice(PLAN_NAME_MAP, mapChoice=True)}
      while Cmd.ArgumentsRemaining():
        planarg = getArgument()
        if planarg == u'seats':
          kwargs[u'body'][u'seats'] = {u'numberOfSeats': getInteger()}
          if Cmd.ArgumentsRemaining() and Cmd.Current().isdigit():
            kwargs[u'body'][u'seats'][u'maximumNumberOfSeats'] = getInteger()
        elif planarg in [u'purchaseorderid', u'po']:
          kwargs[u'body'][u'purchaseOrderId'] = getString(u'purchaseOrderId')
        elif planarg in [u'dealcode', u'deal']:
          kwargs[u'body'][u'dealCode'] = getString(u'dealCode')
        else:
          unknownArgumentExit()
    else:
      unknownArgumentExit()
  try:
    subscription = callGAPI(res.subscriptions(), function,
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId, subscriptionId=subscriptionId, **kwargs)
    entityActionPerformed([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])
    if subscription:
      _showSubscription(subscription)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

DELETION_TYPE_MAP = {
  u'cancel': u'cancel',
  u'downgrade': u'downgrade',
  u'transfertodirect': u'transfer_to_direct',
  }

# gam delete resoldsubscription <CustomerID> <SKUID> cancel|downgrade|transfer_to_direct
def doDeleteResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  customerId, skuId, subscriptionId = getCustomerSubscription(res)
  deletionType = getChoice(DELETION_TYPE_MAP, mapChoice=True)
  checkForExtraneousArguments()
  try:
    callGAPI(res.subscriptions(), u'delete',
             throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerId=customerId, subscriptionId=subscriptionId, deletionType=deletionType)
    entityActionPerformed([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId], str(e))

# gam info resoldsubscription <CustomerID> <SKUID>
def doInfoResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  customerId, skuId, subscriptionId = getCustomerSubscription(res)
  checkForExtraneousArguments()
  try:
    subscription = callGAPI(res.subscriptions(), u'get',
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId, subscriptionId=subscriptionId)
    printEntity([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])
    _showSubscription(subscription)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId], str(e))

PRINT_RESOLD_SUBSCRIPTIONS_TITLES = [u'customerId', u'skuId', u'subscriptionId']

def _doPrintShowResoldSubscriptions(csvFormat):
  res = buildGAPIObject(API.RESELLER)
  kwargs = {}
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(PRINT_RESOLD_SUBSCRIPTIONS_TITLES)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'customerid']:
      kwargs[u'customerId'] = getString(Cmd.OB_CUSTOMER_ID)
    elif myarg in [u'customerauthtoken', u'transfertoken']:
      kwargs[u'customerAuthToken'] = getString(Cmd.OB_CUSTOMER_AUTH_TOKEN)
    elif myarg == u'customerprefix':
      kwargs[u'customerNamePrefix'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  try:
    subscriptions = callGAPIpages(res.subscriptions(), u'list', u'subscriptions',
                                  throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                  fields=u'nextPageToken,subscriptions', **kwargs)
    jcount = len(subscriptions)
    if not csvFormat:
      performActionNumItems(jcount, Ent.SUBSCRIPTION)
      Ind.Increment()
      j = 0
      for subscription in subscriptions:
        j += 1
        printEntity([Ent.CUSTOMER_ID, subscription[u'customerId'], Ent.SKU, subscription[u'skuId']], j, jcount)
        _showSubscription(subscription)
      Ind.Decrement()
    else:
      for subscription in subscriptions:
        addRowTitlesToCSVfile(flattenJSON(subscription, timeObjects=SUBSCRIPTION_TIME_OBJECTS), csvRows, titles)
      writeCSVfile(csvRows, titles, u'Resold Subscriptions', todrive, PRINT_RESOLD_SUBSCRIPTIONS_TITLES)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.SUBSCRIPTION, None], str(e))

# gam print resoldsubscriptions [todrive [<ToDriveAttributes>]] [customerid <CustomerID>] [customer_auth_token <String>] [customer_prefix <String>]
def doPrintResoldSubscriptions():
  _doPrintShowResoldSubscriptions(True)

# gam show resoldsubscriptions [customerid <CustomerID>] [customer_auth_token <String>] [customer_prefix <String>]
def doShowResoldSubscriptions():
  _doPrintShowResoldSubscriptions(False)

# gam create domainalias|aliasdomain <DomainAlias> <DomainName>
def doCreateDomainAlias():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {u'domainAliasName': getString(Cmd.OB_DOMAIN_ALIAS)}
  body[u'parentDomainName'] = getString(Cmd.OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domainAliases(), u'insert',
             throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.DUPLICATE, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformed([Ent.DOMAIN, body[u'parentDomainName'], Ent.DOMAIN_ALIAS, body[u'domainAliasName']])
  except GAPI.domainNotFound:
    entityActionFailedWarning([Ent.DOMAIN, body[u'parentDomainName']], Msg.DOES_NOT_EXIST)
  except GAPI.duplicate:
    entityActionFailedWarning([Ent.DOMAIN, body[u'parentDomainName'], Ent.DOMAIN_ALIAS, body[u'domainAliasName']], Msg.DUPLICATE)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete domainalias|aliasdomain <DomainAlias>
def doDeleteDomainAlias():
  cd = buildGAPIObject(API.DIRECTORY)
  domainAliasName = getString(Cmd.OB_DOMAIN_ALIAS)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domainAliases(), u'delete',
             throw_reasons=[GAPI.DOMAIN_ALIAS_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], domainAliasName=domainAliasName)
    entityActionPerformed([Ent.DOMAIN_ALIAS, domainAliasName])
  except GAPI.domainAliasNotFound:
    entityActionFailedWarning([Ent.DOMAIN_ALIAS, domainAliasName], Msg.DOES_NOT_EXIST)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

DOMAIN_TIME_OBJECTS = set([u'creationTime',])
DOMAIN_ALIAS_PRINT_ORDER = [u'parentDomainName', u'creationTime', u'verified',]
DOMAIN_ALIAS_SKIP_OBJECTS = set([u'domainAliasName',])

def _showDomainAlias(alias, aliasSkipObjects):
  printEntity([Ent.DOMAIN_ALIAS, alias[u'domainAliasName']])
  Ind.Increment()
  if u'creationTime' in alias:
    alias[u'creationTime'] = formatLocalTimestamp(alias[u'creationTime'])
  for field in DOMAIN_ALIAS_PRINT_ORDER:
    if field in alias:
      printKeyValueList([field, alias[field]])
      aliasSkipObjects.add(field)
  showJSON(None, alias, aliasSkipObjects)
  Ind.Decrement()

# gam info domainalias|aliasdomain <DomainAlias>
def doInfoDomainAlias():
  cd = buildGAPIObject(API.DIRECTORY)
  domainAliasName = getString(Cmd.OB_DOMAIN_ALIAS)
  checkForExtraneousArguments()
  try:
    result = callGAPI(cd.domainAliases(), u'get',
                      throw_reasons=[GAPI.DOMAIN_ALIAS_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      customer=GC.Values[GC.CUSTOMER_ID], domainAliasName=domainAliasName)
    aliasSkipObjects = DOMAIN_ALIAS_SKIP_OBJECTS
    _showDomainAlias(result, aliasSkipObjects)
  except GAPI.domainAliasNotFound:
    entityActionFailedWarning([Ent.DOMAIN_ALIAS, domainAliasName], Msg.DOES_NOT_EXIST)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

def _printDomain(domain, titles, csvRows):
  row = {}
  for attr in domain:
    if attr not in DEFAULT_SKIP_OBJECTS:
      if attr in DOMAIN_TIME_OBJECTS:
        row[attr] = formatLocalTimestamp(domain[attr])
      else:
        row[attr] = domain[attr]
      if attr not in titles[u'set']:
        addTitleToCSVfile(attr, titles)
  csvRows.append(row)

# gam print domainaliases [todrive [<ToDriveAttributes>]]
def doPrintDomainAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'domainAliasName',])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    domainAliases = callGAPIitems(cd.domainAliases(), u'list', u'domainAliases',
                                  throw_reasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                  customer=GC.Values[GC.CUSTOMER_ID])
    for domainAlias in domainAliases:
      _printDomain(domainAlias, titles, csvRows)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Domain Aliases', todrive, [u'domainAliasName', u'parentDomainName', u'creationTime', u'verified'])

# gam create domain <DomainName>
def doCreateDomain():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {u'domainName': getString(Cmd.OB_DOMAIN_NAME)}
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domains(), u'insert',
             throw_reasons=[GAPI.DUPLICATE, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformed([Ent.DOMAIN, body[u'domainName']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.DOMAIN, body[u'domainName']])
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam update domain <DomainName> primary
def doUpdateDomain():
  cd = buildGAPIObject(API.DIRECTORY)
  domainName = getString(Cmd.OB_DOMAIN_NAME)
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'primary':
      body[u'customerDomain'] = domainName
    else:
      unknownArgumentExit()
  if not body:
    missingArgumentExit(u'primary')
  try:
    callGAPI(cd.customers(), u'update',
             throw_reasons=[GAPI.DOMAIN_NOT_VERIFIED_SECONDARY, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerKey=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformedMessage([Ent.DOMAIN, domainName], Msg.NOW_THE_PRIMARY_DOMAIN)
  except GAPI.domainNotVerifiedSecondary:
    entityActionFailedWarning([Ent.DOMAIN, domainName], Msg.DOMAIN_NOT_VERIFIED_SECONDARY)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete domain <DomainName>
def doDeleteDomain():
  cd = buildGAPIObject(API.DIRECTORY)
  domainName = getString(Cmd.OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domains(), u'delete',
             throw_reasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], domainName=domainName)
    entityActionPerformed([Ent.DOMAIN, domainName])
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

DOMAIN_PRINT_ORDER = [u'customerDomain', u'creationTime', u'isPrimary', u'verified',]
DOMAIN_SKIP_OBJECTS = set([u'domainName', u'domainAliases'])

# gam info domain [<DomainName>] [formatjson]
def doInfoDomain():
  if (not Cmd.ArgumentsRemaining()) or (Cmd.Current().lower() in [u'logo', u'formatjson']):
    doInfoInstance()
    return
  cd = buildGAPIObject(API.DIRECTORY)
  domainName = getString(Cmd.OB_DOMAIN_NAME)
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'formatjson':
      formatJSON = True
    else:
      unknownArgumentExit()
  try:
    result = callGAPI(cd.domains(), u'get',
                      throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      customer=GC.Values[GC.CUSTOMER_ID], domainName=domainName)
    if formatJSON:
      printLine(json.dumps(cleanJSON(result, u'', timeObjects=DOMAIN_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
      return
    skipObjects = DOMAIN_SKIP_OBJECTS
    printEntity([Ent.DOMAIN, result[u'domainName']])
    Ind.Increment()
    if u'creationTime' in result:
      result[u'creationTime'] = formatLocalTimestamp(result[u'creationTime'])
    for field in DOMAIN_PRINT_ORDER:
      if field in result:
        printKeyValueList([field, result[field]])
        skipObjects.add(field)
    field = u'domainAliases'
    aliases = result.get(field)
    if aliases:
      skipObjects.add(field)
      aliasSkipObjects = DOMAIN_ALIAS_SKIP_OBJECTS
      for alias in aliases:
        _showDomainAlias(alias, aliasSkipObjects)
        showJSON(None, alias, aliasSkipObjects)
    showJSON(None, result, skipObjects)
    Ind.Decrement()
  except GAPI.domainNotFound:
    entityActionFailedWarning([Ent.DOMAIN, domainName], Msg.DOES_NOT_EXIST)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam print domains [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>]
def doPrintDomains():
  cd = buildGAPIObject(API.DIRECTORY)
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'domainName',])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == "formatjson":
      formatJSON = True
      addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  try:
    domains = callGAPIitems(cd.domains(), u'list', u'domains',
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                            customer=GC.Values[GC.CUSTOMER_ID])
    for domain in domains:
      if formatJSON:
        csvRows.append({u'domainName': domain[u'domainName'],
                        u'JSON': json.dumps(cleanJSON(domain, u'', timeObjects=DOMAIN_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
        continue
      domain[u'type'] = [u'secondary', u'primary'][domain.pop(u'isPrimary')]
      domainAliases = domain.pop(u'domainAliases', [])
      _printDomain(domain, titles, csvRows)
      for domainAlias in domainAliases:
        domainAlias[u'type'] = u'alias'
        domainAlias[u'domainName'] = domainAlias.pop(u'domainAliasName')
        _printDomain(domainAlias, titles, csvRows)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Domains', todrive, quotechar=quotechar)

PRINT_PRIVILEGES_FIELDS = [u'serviceId', u'serviceName', u'privilegeName', u'isOuScopable', u'childPrivileges']

# gam print privileges [todrive [<ToDriveAttributes>]]
def _doPrintShowPrivileges(csvFormat):
  def _showPrivilege(privilege, i, count):
    printEntity([Ent.PRIVILEGE, privilege[u'privilegeName']], i, count)
    Ind.Increment()
    printKeyValueList([u'serviceId', privilege[u'serviceId']])
    printKeyValueList([u'serviceName', privilege.get(u'serviceName', u'Unknown')])
    printKeyValueList([u'isOuScopable', privilege[u'isOuScopable']])
    jcount = len(privilege.get(u'childPrivileges', []))
    if jcount > 0:
      printKeyValueList([u'childPrivileges', jcount])
      Ind.Increment()
      j = 0
      for childPrivilege in privilege[u'childPrivileges']:
        j += 1
        _showPrivilege(childPrivilege, j, jcount)
      Ind.Decrement()
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(PRINT_PRIVILEGES_FIELDS)
  fields = u'items({0})'.format(u','.join(PRINT_PRIVILEGES_FIELDS))
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    privileges = callGAPIitems(cd.privileges(), u'list', u'items',
                               throw_reasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
    if not csvFormat:
      count = len(privileges)
      performActionNumItems(count, Ent.PRIVILEGE)
      Ind.Increment()
      i = 0
      for privilege in privileges:
        i += 1
        _showPrivilege(privilege, i, count)
      Ind.Decrement()
    else:
      for privilege in privileges:
        addRowTitlesToCSVfile(flattenJSON(privilege), csvRows, titles)
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Privileges', todrive, PRINT_PRIVILEGES_FIELDS)

# gam print privileges [todrive [<ToDriveAttributes>]]
def doPrintPrivileges():
  _doPrintShowPrivileges(True)

# gam show privileges
def doShowPrivileges():
  _doPrintShowPrivileges(False)

PRINT_ADMIN_ROLES_FIELDS = [u'roleId', u'roleName', u'roleDescription', u'isSuperAdminRole', u'isSystemRole']

def _doPrintShowAdminRoles(csvFormat):
  cd = buildGAPIObject(API.DIRECTORY)
  fieldsList = PRINT_ADMIN_ROLES_FIELDS[:]
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(fieldsList)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'privileges':
      if csvFormat:
        addFieldToCSVfile(myarg, {myarg: u'rolePrivileges'}, fieldsList, titles)
      else:
        fieldsList.append(u'rolePrivileges')
    else:
      unknownArgumentExit()
  fields = u'nextPageToken,items({0})'.format(u','.join(set(fieldsList)))
  try:
    roles = callGAPIpages(cd.roles(), u'list', u'items',
                          throw_reasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                          customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
    for role in roles:
      role.setdefault(u'isSuperAdminRole', False)
      role.setdefault(u'isSystemRole', False)
    if not csvFormat:
      count = len(roles)
      performActionNumItems(count, Ent.ROLE)
      Ind.Increment()
      i = 0
      for role in roles:
        i += 1
        printEntity([Ent.ROLE, role[u'roleName']], i, count)
        Ind.Increment()
        for field in PRINT_ADMIN_ROLES_FIELDS:
          if field != u'roleName' and field in role:
            printKeyValueList([field, role[field]])
        jcount = len(role.get(u'rolePrivileges', []))
        if jcount > 0:
          printKeyValueList([u'rolePrivileges', jcount])
          Ind.Increment()
          j = 0
          for rolePrivilege in role[u'rolePrivileges']:
            j += 1
            printKeyValueList([u'privilegeName', rolePrivilege[u'privilegeName']])
            Ind.Increment()
            printKeyValueList([u'serviceId', rolePrivilege[u'serviceId']])
            Ind.Decrement()
          Ind.Decrement()
        Ind.Decrement()
      Ind.Decrement()
    else:
      for role in roles:
        addRowTitlesToCSVfile(flattenJSON(role), csvRows, titles)
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Admin Roles', todrive, PRINT_ADMIN_ROLES_FIELDS)

# gam print adminroles|roles [todrive [<ToDriveAttributes>]] [privileges]
def doPrintAdminRoles():
  _doPrintShowAdminRoles(True)

# gam show adminroles|roles [privileges]
def doShowAdminRoles():
  _doPrintShowAdminRoles(False)

def buildRoleIdToNameToIdMap():
  cd = buildGAPIObject(API.DIRECTORY)
  try:
    result = callGAPIpages(cd.roles(), u'list', u'items',
                           throw_reasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                           customer=GC.Values[GC.CUSTOMER_ID],
                           fields=u'nextPageToken,items(roleId,roleName)',
                           maxResults=100)
    GM.Globals[GM.MAP_ROLE_ID_TO_NAME] = {}
    GM.Globals[GM.MAP_ROLE_NAME_TO_ID] = {}
    for role in result:
      GM.Globals[GM.MAP_ROLE_ID_TO_NAME][role[u'roleId']] = role[u'roleName']
      GM.Globals[GM.MAP_ROLE_NAME_TO_ID][role[u'roleName']] = role[u'roleId']
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)

def role_from_roleid(roleid):
  if not GM.Globals[GM.MAP_ROLE_ID_TO_NAME]:
    buildRoleIdToNameToIdMap()
  return GM.Globals[GM.MAP_ROLE_ID_TO_NAME].get(roleid, roleid)

def roleid_from_role(role):
  if not GM.Globals[GM.MAP_ROLE_NAME_TO_ID]:
    buildRoleIdToNameToIdMap()
  return GM.Globals[GM.MAP_ROLE_NAME_TO_ID].get(role, None)

def getRoleId():
  role = getString(Cmd.OB_ROLE_ID)
  if role[:3].lower() == u'id:':
    roleId = role[3:]
  elif role[:4].lower() == u'uid:':
    roleId = role[4:]
  else:
    roleId = roleid_from_role(role)
    if not roleId:
      invalidChoiceExit(GM.Globals[GM.MAP_ROLE_NAME_TO_ID], True)
  return (role, roleId)

def getOrgUnitId(cd=None):
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  orgUnit = getOrgUnitItem()
  if orgUnit[:3] == u'id:':
    return (orgUnit, orgUnit)
  try:
    result = callGAPI(cd.orgunits(), u'get',
                      throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                      customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnit)), fields=u'orgUnitId')
    return (orgUnit, result[u'orgUnitId'])
  except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
    entityDoesNotExistExit(Ent.ORGANIZATIONAL_UNIT, orgUnit)
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    accessErrorExit(cd)

ADMIN_SCOPE_TYPE_CHOICE_MAP = {u'customer': u'CUSTOMER', u'orgunit': u'ORG_UNIT', u'org': u'ORG_UNIT', u'ou': u'ORG_UNIT'}

# gam create admin <UserItem> <RoleItem> customer|(org_unit <OrgUnitItem>)
def doCreateAdmin():
  cd = buildGAPIObject(API.DIRECTORY)
  user = getEmailAddress()
  body = {u'assignedTo': convertEmailAddressToUID(user, cd)}
  role, roleId = getRoleId()
  body[u'roleId'] = roleId
  body[u'scopeType'] = getChoice(ADMIN_SCOPE_TYPE_CHOICE_MAP, mapChoice=True)
  if body[u'scopeType'] == u'ORG_UNIT':
    orgUnit, orgUnitId = getOrgUnitId(cd)
    body[u'orgUnitId'] = orgUnitId[3:]
    scope = u'ORG_UNIT {0}'.format(orgUnit)
  else:
    scope = u'CUSTOMER'
  checkForExtraneousArguments()
  try:
    result = callGAPI(cd.roleAssignments(), u'insert',
                      throw_reasons=[GAPI.INTERNAL_ERROR, GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID_ORGUNIT, GAPI.DUPLICATE],
                      customer=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'roleAssignmentId')
    entityActionPerformedMessage([Ent.ROLE_ASSIGNMENT_ID, result[u'roleAssignmentId']],
                                 u'{0} {1}, {2} {3}, {4} {5}'.format(Ent.Singular(Ent.USER), user,
                                                                     Ent.Singular(Ent.ROLE), role,
                                                                     Ent.Singular(Ent.SCOPE), scope))
  except GAPI.internalError:
    pass
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  except GAPI.invalidOrgunit:
    entityActionFailedWarning([Ent.ADMINISTRATOR, user], Msg.INVALID_ORGUNIT)
  except GAPI.duplicate:
    entityActionFailedWarning([Ent.ADMINISTRATOR, user, Ent.ROLE, role], Msg.DUPLICATE)

# gam delete admin <RoleAssignmentId>
def doDeleteAdmin():
  cd = buildGAPIObject(API.DIRECTORY)
  roleAssignmentId = getString(Cmd.OB_ROLE_ASSIGNMENT_ID)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.roleAssignments(), u'delete',
             throw_reasons=[GAPI.NOT_FOUND, GAPI.OPERATION_NOT_SUPPORTED, GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], roleAssignmentId=roleAssignmentId)
    entityActionPerformed([Ent.ROLE_ASSIGNMENT_ID, roleAssignmentId])
  except (GAPI.notFound, GAPI.operationNotSupported) as e:
    entityActionFailedWarning([Ent.ROLE_ASSIGNMENT_ID, roleAssignmentId], str(e))
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)

PRINT_ADMIN_FIELDS = u'nextPageToken,items({0})'.format(u','.join([u'roleAssignmentId', u'roleId', u'assignedTo', u'scopeType', u'orgUnitId']))
PRINT_ADMIN_TITLES = [u'roleAssignmentId', u'roleId', u'role', u'assignedTo', u'assignedToUser', u'scopeType', u'orgUnitId', u'orgUnit']

def _doPrintShowAdmins(csvFormat):
  def _setNamesFromIds(admin):
    admin[u'assignedToUser'] = convertUserIDtoEmail(admin[u'assignedTo'], cd)
    admin[u'role'] = role_from_roleid(admin[u'roleId'])
    if u'orgUnitId' in admin:
      admin[u'orgUnit'] = convertOrgUnitIDtoPath(u'id:{0}'.format(admin[u'orgUnitId']), cd)

  cd = buildGAPIObject(API.DIRECTORY)
  roleId = None
  userKey = None
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(PRINT_ADMIN_TITLES)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'user':
      userKey = getEmailAddress()
    elif myarg == u'role':
      _, roleId = getRoleId()
    else:
      unknownArgumentExit()
  try:
    admins = callGAPIpages(cd.roleAssignments(), u'list', u'items',
                           throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                           customer=GC.Values[GC.CUSTOMER_ID], userKey=userKey, roleId=roleId, fields=PRINT_ADMIN_FIELDS)
  except GAPI.invalid:
    entityUnknownWarning(Ent.USER, userKey)
    return
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if not csvFormat:
    count = len(admins)
    performActionNumItems(count, Ent.ROLE_ASSIGNMENT_ID)
    Ind.Increment()
    i = 0
    while admins:
      i += 1
      admin = admins.popleft()
      _setNamesFromIds(admin)
      printEntity([Ent.ROLE_ASSIGNMENT_ID, admin[u'roleAssignmentId']], i, count)
      Ind.Increment()
      for field in PRINT_ADMIN_TITLES:
        if field != u'roleAssignmentId' and field in admin:
          printKeyValueList([field, admin[field]])
      Ind.Decrement()
    Ind.Decrement()
  else:
    while admins:
      admin = admins.popleft()
      _setNamesFromIds(admin)
      csvRows.append(flattenJSON(admin))
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Admins', todrive)

# gam print admins [todrive [<ToDriveAttributes>]] [user <UserItem>] [role <RoleItem>]
def doPrintAdmins():
  _doPrintShowAdmins(True)

# gam show admins [user <UserItem>] [role <RoleItem>]
def doShowAdmins():
  _doPrintShowAdmins(False)

USER_COUNTS_MAP = {
  u'accounts:num_users': u'Total Users',
  u'accounts:gsuite_basic_total_licenses': u'G Suite Basic Licenses',
  u'accounts:gsuite_basic_used_licenses': u'G Suite Basic Users',
  u'accounts:gsuite_enterprise_total_licenses': u'G Suite Enterprise Licenses',
  u'accounts:gsuite_enterprise_used_licenses': u'G Suite Enterprise Users',
  u'accounts:gsuite_unlimited_total_licenses': u'G Suite Business Licenses',
  u'accounts:gsuite_unlimited_used_licenses': u'G Suite Business Users'
  }

def _showCustomerLicenseInfo(customerInfo, formatJSON):
  rep = buildGAPIObject(API.REPORTS)
  parameters = u','.join(USER_COUNTS_MAP)
  tryDate = todaysDate().strftime(YYYYMMDD_FORMAT)
  while True:
    try:
      usage = callGAPIpages(rep.customerUsageReports(), u'get', u'usageReports',
                            throw_reasons=[GAPI.INVALID, GAPI.FORBIDDEN],
                            customerId=customerInfo[u'id'], date=tryDate, parameters=parameters)
      break
    except GAPI.invalid as e:
      tryDate = _adjustTryDate(str(e), False)
      if not tryDate:
        return
    except GAPI.forbidden:
      accessErrorExit(None)
  if usage:
    if not formatJSON:
      printKeyValueList([u'User counts as of {0}:'.format(tryDate)])
      Ind.Increment()
    for item in usage[0][u'parameters']:
      api_name = USER_COUNTS_MAP.get(item[u'name'])
      api_value = int(item.get(u'intValue', 0))
      if api_name and api_value:
        if not formatJSON:
          printKeyValueList([api_name, u'{:,}'.format(api_value)])
        else:
          customerInfo[item[u'name']] = api_value
    if not formatJSON:
      Ind.Decrement()
  else:
    printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_USER_COUNTS_DATA_AVAILABLE)

CUSTOMER_TIME_OBJECTS = set([u'customerCreationTime',])

# gam info customer [formatjson]
def doInfoCustomer(returnCustomerInfo=None):
  cd = buildGAPIObject(API.DIRECTORY)
  formatJSON = returnCustomerInfo is not None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'formatjson':
      formatJSON = True
    else:
      unknownArgumentExit()
  try:
    customerInfo = callGAPI(cd.customers(), u'get',
                            throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerKey=GC.Values[GC.CUSTOMER_ID])
    customerInfo[u'verified'] = callGAPI(cd.domains(), u'get',
                                         customer=customerInfo[u'id'], domainName=customerInfo[u'customerDomain'], fields=u'verified')[u'verified']
    if formatJSON:
      _showCustomerLicenseInfo(customerInfo, True)
      if returnCustomerInfo is not None:
        returnCustomerInfo.update(customerInfo)
        return
      printLine(json.dumps(cleanJSON(customerInfo, u'', timeObjects=CUSTOMER_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
      return
    printKeyValueList([u'Customer ID', customerInfo[u'id']])
    printKeyValueList([u'Primary Domain', customerInfo[u'customerDomain']])
    printKeyValueList([u'Customer Creation Time', formatLocalTime(customerInfo[u'customerCreationTime'])])
    printKeyValueList([u'Primary Domain Verified', customerInfo[u'verified']])
    printKeyValueList([u'Default Language', customerInfo[u'language']])
    _showCustomerAddressPhoneNumber(customerInfo)
    printKeyValueList([u'Admin Secondary Email', customerInfo[u'alternateEmail']])
    _showCustomerLicenseInfo(customerInfo, False)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam update customer [primary <DomainName>] [adminsecondaryemail|alternateemail <EmailAddress>] [language <LanguageCode] [phone|phonenumber <String>]
#	[contact|contactname <String>] [name|organizationname <String>]
#	[address1|addressline1 <String>] [address2|addressline2 <String>] [address3|addressline3 <String>]
#	[locality <String>] [region <String>] [postalcode <String>] [country|countrycode <String>]
def doUpdateCustomer():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADDRESS_FIELDS_ARGUMENT_MAP:
      body.setdefault(u'postalAddress', {})
      body[u'postalAddress'][ADDRESS_FIELDS_ARGUMENT_MAP[myarg]] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == u'primary':
      body[u'customerDomain'] = getString(Cmd.OB_DOMAIN_NAME)
    elif myarg in [u'adminsecondaryemail', u'alternateemail']:
      body[u'alternateEmail'] = getEmailAddress(noUid=True)
    elif myarg in [u'phone', u'phonenumber']:
      body[u'phoneNumber'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == u'language':
      body[u'language'] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  if body:
    try:
      callGAPI(cd.customers(), u'patch',
               throw_reasons=[GAPI.DOMAIN_NOT_VERIFIED_SECONDARY, GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerKey=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'')
      entityActionPerformed([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID]])
    except GAPI.domainNotVerifiedSecondary:
      entityActionFailedWarning([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID], Ent.DOMAIN, body[u'customerDomain']], Msg.DOMAIN_NOT_VERIFIED_SECONDARY)
    except (GAPI.invalid, GAPI.invalidInput) as e:
      entityActionFailedWarning([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID]], str(e))
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)

def getTransferApplications(dt):
  try:
    return callGAPIpages(dt.applications(), u'list', u'applications',
                         throw_reasons=[GAPI.UNKNOWN_ERROR, GAPI.FORBIDDEN],
                         customerId=GC.Values[GC.CUSTOMER_ID], fields=u'applications(id,name,transferParams)')
  except (GAPI.unknownError, GAPI.forbidden):
    accessErrorExit(None)

def _convertTransferAppIDtoName(apps, appID):
  for app in apps:
    if appID == app[u'id']:
      return app[u'name']
  return u'applicationId: {0}'.format(appID)

CALENDAR_APP_NAME = u'Calendar'
DRIVE_AND_DOCS_APP_NAME = u'Drive and Docs'
GOOGLE_PLUS_APP_NAME = u'Google+'

SERVICE_NAME_CHOICE_MAP = {
  u'calendar': CALENDAR_APP_NAME,
  u'drive': DRIVE_AND_DOCS_APP_NAME,
  u'drive and docs': DRIVE_AND_DOCS_APP_NAME,
  u'googledrive': DRIVE_AND_DOCS_APP_NAME,
  u'gdrive': DRIVE_AND_DOCS_APP_NAME,
  u'gplus': GOOGLE_PLUS_APP_NAME,
  u'google+': GOOGLE_PLUS_APP_NAME,
  u'googleplus': GOOGLE_PLUS_APP_NAME,
  }

def _validateTransferAppName(apps, appName):
  appName = appName.strip().lower()
  if appName in SERVICE_NAME_CHOICE_MAP:
    appName = SERVICE_NAME_CHOICE_MAP[appName].lower()
  appNameList = []
  for app in apps:
    if appName == app[u'name'].lower():
      return (app[u'name'], app[u'id'])
    appNameList.append(app[u'name'].lower())
  invalidChoiceExit(appNameList, True)

PRIVACY_LEVEL_CHOICE_MAP = {
  u'private': [u'PRIVATE',],
  u'shared': [u'SHARED',],
  u'all': [u'PRIVATE', u'SHARED'],
  }

# gam create datatransfer|transfer <OldOwnerID> <ServiceNameList> <NewOwnerID> [private|shared|all] [release_resources] (<ParameterKey> <ParameterValue>)*
def doCreateDataTransfer():
  def _assignAppParameter(key, value, doubleBackup=False):
    for app in apps:
      for params in app.get(u'transferParams', []):
        if key == params[u'key']:
          appIndex = appIndicies.get(app[u'id'])
          if appIndex is not None:
            body[u'applicationDataTransfers'][appIndex].setdefault(u'applicationTransferParams', [])
            body[u'applicationDataTransfers'][appIndex][u'applicationTransferParams'].append({u'key': key, u'value': value})
            return
          break
    Cmd.Backup()
    if doubleBackup:
      Cmd.Backup()
    usageErrorExit(Msg.NO_DATA_TRANSFER_APP_FOR_PARAMETER.format(key))

  dt = buildGAPIObject(API.DATATRANSFER)
  apps = getTransferApplications(dt)
  old_owner = getEmailAddress()
  body = {u'oldOwnerUserId': convertEmailAddressToUID(old_owner)}
  appIndicies = {}
  appNameList = []
  i = 0
  body[u'applicationDataTransfers'] = []
  for appName in getString(Cmd.OB_SERVICE_NAME_LIST).split(u','):
    appName, appId = _validateTransferAppName(apps, appName)
    body[u'applicationDataTransfers'].append({u'applicationId': appId})
    appIndicies[appId] = i
    i += 1
    appNameList.append(appName)
  new_owner = getEmailAddress()
  body[u'newOwnerUserId'] = convertEmailAddressToUID(new_owner)
  if body[u'oldOwnerUserId'] == body[u'newOwnerUserId']:
    Cmd.Backup()
    usageErrorExit(Msg.NEW_OWNER_MUST_DIFFER_FROM_OLD_OWNER)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in PRIVACY_LEVEL_CHOICE_MAP:
      _assignAppParameter(u'PRIVACY_LEVEL', PRIVACY_LEVEL_CHOICE_MAP[myarg])
    elif myarg == u'releaseresources':
      if getBoolean():
        _assignAppParameter(u'RELEASE_RESOURCES', [u'TRUE',])
    else:
      _assignAppParameter(Cmd.Previous().upper(), getString(Cmd.OB_PARAMETER_VALUE).upper().split(u','), True)
  result = callGAPI(dt.transfers(), u'insert',
                    body=body, fields=u'id')
  entityActionPerformed([Ent.TRANSFER_REQUEST, None])
  Ind.Increment()
  printEntity([Ent.TRANSFER_ID, result[u'id']])
  printEntity([Ent.SERVICE, u','.join(appNameList)])
  printKeyValueList([Msg.FROM, old_owner])
  printKeyValueList([Msg.TO, new_owner])
  Ind.Decrement()

def _showTransfer(apps, transfer, i, count):
  printEntity([Ent.TRANSFER_ID, transfer[u'id']], i, count)
  Ind.Increment()
  printKeyValueList([u'Request Time', formatLocalTime(transfer[u'requestTime'])])
  printKeyValueList([u'Old Owner', convertUserIDtoEmail(transfer[u'oldOwnerUserId'])])
  printKeyValueList([u'New Owner', convertUserIDtoEmail(transfer[u'newOwnerUserId'])])
  printKeyValueList([u'Overall Transfer Status', transfer[u'overallTransferStatusCode']])
  for app in transfer[u'applicationDataTransfers']:
    printKeyValueList([u'Application', _convertTransferAppIDtoName(apps, app[u'applicationId'])])
    Ind.Increment()
    printKeyValueList([u'Status', app[u'applicationTransferStatus']])
    printKeyValueList([u'Parameters'])
    Ind.Increment()
    if u'applicationTransferParams' in app:
      for param in app[u'applicationTransferParams']:
        key = param[u'key']
        value = param.get(u'value', [])
        if value:
          printKeyValueList([key, u','.join(value)])
        else:
          printKeyValueList([key])
    else:
      printKeyValueList([u'None'])
    Ind.Decrement()
    Ind.Decrement()
  Ind.Decrement()

# gam info datatransfer|transfer <TransferID>
def doInfoDataTransfer():
  dt = buildGAPIObject(API.DATATRANSFER)
  apps = getTransferApplications(dt)
  dtId = getString(Cmd.OB_TRANSFER_ID)
  checkForExtraneousArguments()
  try:
    transfer = callGAPI(dt.transfers(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND],
                        dataTransferId=dtId)
    _showTransfer(apps, transfer, 0, 0)
  except GAPI.notFound:
    entityActionFailedWarning([Ent.TRANSFER_ID, dtId], Msg.DOES_NOT_EXIST)

DATA_TRANSFER_STATUS_MAP = {
  u'completed': u'completed',
  u'failed': u'failed',
  u'pending': u'pending',
  u'inprogress': u'inProgress',
  }

def _doPrintShowDataTransfers(csvFormat):
  dt = buildGAPIObject(API.DATATRANSFER)
  apps = getTransferApplications(dt)
  newOwnerUserId = None
  oldOwnerUserId = None
  status = None
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'id',])
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'olduser', u'oldowner']:
      oldOwnerUserId = convertEmailAddressToUID(getEmailAddress())
    elif myarg in [u'newuser', u'newowner']:
      newOwnerUserId = convertEmailAddressToUID(getEmailAddress())
    elif myarg == u'status':
      status = getChoice(DATA_TRANSFER_STATUS_MAP, mapChoice=True)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  try:
    transfers = callGAPIpages(dt.transfers(), u'list', u'dataTransfers',
                              throw_reasons=[GAPI.UNKNOWN_ERROR, GAPI.FORBIDDEN],
                              customerId=GC.Values[GC.CUSTOMER_ID], status=status,
                              newOwnerUserId=newOwnerUserId, oldOwnerUserId=oldOwnerUserId)
    if not csvFormat:
      count = len(transfers)
      performActionNumItems(count, Ent.TRANSFER_REQUEST)
      Ind.Increment()
      i = 0
      for transfer in sorted(transfers, key=lambda k: k[u'requestTime']):
        i += 1
        _showTransfer(apps, transfer, i, count)
      Ind.Decrement()
    else:
      for transfer in sorted(transfers, key=lambda k: k[u'requestTime']):
        row = {}
        row[u'id'] = transfer[u'id']
        row[u'requestTime'] = formatLocalTime(transfer[u'requestTime'])
        row[u'oldOwnerUserEmail'] = convertUserIDtoEmail(transfer[u'oldOwnerUserId'])
        row[u'newOwnerUserEmail'] = convertUserIDtoEmail(transfer[u'newOwnerUserId'])
        row[u'overallTransferStatusCode'] = transfer[u'overallTransferStatusCode']
        for app in transfer[u'applicationDataTransfers']:
          xrow = row.copy()
          xrow[u'application'] = _convertTransferAppIDtoName(apps, app[u'applicationId'])
          xrow[u'applicationId'] = app[u'applicationId']
          xrow[u'status'] = app[u'applicationTransferStatus']
          for param in app.get(u'applicationTransferParams', []):
            key = param[u'key']
            xrow[key] = delimiter.join(param.get(u'value', [] if key != u'RELEASE_RESOURCES' else [u'TRUE',]))
          addRowTitlesToCSVfile(xrow, csvRows, titles)
  except (GAPI.unknownError, GAPI.forbidden):
    accessErrorExit(None)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Data Transfers', todrive,
                 [u'id', u'requestTime', u'oldOwnerUserEmail', u'newOwnerUserEmail',
                  u'overallTransferStatusCode', u'application', u'applicationId', u'status'])

# gam print datatransfers|transfers [todrive [<ToDriveAttributes>]] [olduser|oldowner <UserItem>] [newuser|newowner <UserItem>] [status <String>] [delimiter <Character>]]
def doPrintDataTransfers():
  _doPrintShowDataTransfers(True)

# gam show datatransfers|transfers [olduser|oldowner <UserItem>] [newuser|newowner <UserItem>] [status <String>] [delimiter <Character>]]
def doShowDataTransfers():
  _doPrintShowDataTransfers(False)

# gam show transferapps
def doShowTransferApps():
  dt = buildGAPIObject(API.DATATRANSFER)
  checkForExtraneousArguments()
  Act.Set(Act.SHOW)
  try:
    apps = callGAPIpages(dt.applications(), u'list', u'applications',
                         throw_reasons=[GAPI.UNKNOWN_ERROR, GAPI.FORBIDDEN],
                         customerId=GC.Values[GC.CUSTOMER_ID], fields=u'applications(id,name,transferParams)')
    count = len(apps)
    performActionNumItems(count, Ent.TRANSFER_APPLICATION)
    Ind.Increment()
    i = 0
    for app in apps:
      i += 1
      printKeyValueListWithCount([app[u'name']], i, count)
      Ind.Increment()
      printKeyValueList([u'id', app[u'id']])
      transferParams = app.get(u'transferParams', [])
      if transferParams:
        printKeyValueList([u'Parameters'])
        Ind.Increment()
        for param in transferParams:
          printKeyValueList([u'key', param[u'key']])
          Ind.Increment()
          printKeyValueList([u'value', u','.join(param[u'value'])])
          Ind.Decrement()
        Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  except (GAPI.unknownError, GAPI.forbidden):
    accessErrorExit(None)

UPDATE_INSTANCE_CHOICES = [u'logo', u'ssokey', u'ssosettings',]

# gam update instance
def doUpdateInstance():
  adminSettingsObject = getAdminSettingsObject()
  command = getChoice(UPDATE_INSTANCE_CHOICES)
  try:
    if command == u'logo':
# gam update instance logo <FileName>
      logoFile = getString(Cmd.OB_FILE_NAME)
      checkForExtraneousArguments()
      logoImage = readFile(logoFile, mode=u'rb')
      callGData(adminSettingsObject, u'UpdateDomainLogo',
                throw_errors=[GDATA.INVALID_DOMAIN, GDATA.INVALID_VALUE],
                logoImage=logoImage)
      entityActionPerformed([Ent.INSTANCE, u'', Ent.LOGO, logoFile])
    elif command == u'ssosettings':
# gam update instance sso_settings [enabled <Boolean>] [sign_on_uri <URI>] [sign_out_uri <URI>] [password_uri <URI>] [whitelist <CIDRnetmask>] [use_domain_specific_issuer <Boolean>]
      enableSSO = samlSignonUri = samlLogoutUri = changePasswordUri = ssoWhitelist = useDomainSpecificIssuer = None
      while Cmd.ArgumentsRemaining():
        myarg = getArgument()
        if myarg == u'enabled':
          enableSSO = getBoolean()
        elif myarg == u'signonuri':
          samlSignonUri = getString(Cmd.OB_URI)
        elif myarg == u'signouturi':
          samlLogoutUri = getString(Cmd.OB_URI)
        elif myarg == u'passworduri':
          changePasswordUri = getString(Cmd.OB_URI)
        elif myarg == u'whitelist':
          ssoWhitelist = getString(Cmd.OB_CIDR_NETMASK)
        elif myarg == u'usedomainspecificissuer':
          useDomainSpecificIssuer = getBoolean()
        else:
          unknownArgumentExit()
      callGData(adminSettingsObject, u'UpdateSSOSettings',
                throw_errors=[GDATA.INVALID_DOMAIN, GDATA.INVALID_VALUE],
                enableSSO=enableSSO, samlSignonUri=samlSignonUri, samlLogoutUri=samlLogoutUri, changePasswordUri=changePasswordUri,
                ssoWhitelist=ssoWhitelist, useDomainSpecificIssuer=useDomainSpecificIssuer)
      entityActionPerformed([Ent.INSTANCE, u'', Ent.SSO_SETTINGS, u''])
    elif command == u'ssokey':
# gam update instance sso_key <FileName>
      keyFile = getString(Cmd.OB_FILE_NAME)
      checkForExtraneousArguments()
      keyData = readFile(keyFile)
      callGData(adminSettingsObject, u'UpdateSSOKey',
                throw_errors=[GDATA.INVALID_DOMAIN, GDATA.INVALID_VALUE],
                signingKey=keyData)
      entityActionPerformed([Ent.INSTANCE, u'', Ent.SSO_KEY, keyFile])
  except GDATA.invalidDomain as e:
    printErrorMessage(INVALID_DOMAIN_RC, str(e))
  except GDATA.invalidValue as e:
    printErrorMessage(INVALID_DOMAIN_VALUE_RC, str(e))
#
MAXIMUM_USERS_MAP = [u'maximumNumberOfUsers', u'Maximum Users']
CURRENT_USERS_MAP = [u'currentNumberOfUsers', u'Current Users']
DOMAIN_EDITION_MAP = [u'edition', u'Domain Edition']
CUSTOMER_PIN_MAP = [u'customerPIN', u'Customer PIN']
SINGLE_SIGN_ON_SETTINGS_MAP = [u'enableSSO', u'SSO Enabled',
                               u'samlSignonUri', u'SSO Signon Page',
                               u'samlLogoutUri', u'SSO Logout Page',
                               u'changePasswordUri', u'SSO Password Page',
                               u'ssoWhitelist', u'SSO Whitelist IPs',
                               u'useDomainSpecificIssuer', u'SSO Use Domain Specific Issuer']
SINGLE_SIGN_ON_SIGNING_KEY_MAP = [u'algorithm', u'SSO Key Algorithm',
                                  u'format', u'SSO Key Format',
                                  u'modulus', u'SSO Key Modulus',
                                  u'exponent', u'SSO Key Exponent',
                                  u'yValue', u'SSO Key yValue',
                                  u'signingKey', u'Full SSO Key']

# gam info instance [logo <FileName>] [formatjson]
def doInfoInstance():
  def _printAdminSetting(service, propertyTitleMap):
    try:
      result = callGAPI(service, u'get',
                        throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.INVALID],
                        domainName=GC.Values[GC.DOMAIN])
      if result and (u'entry' in result) and (u'apps$property' in result[u'entry']):
        for i in range(0, len(propertyTitleMap), 2):
          asProperty = propertyTitleMap[i]
          for entry in result[u'entry'][u'apps$property']:
            if entry[u'name'] == asProperty:
              if formatJSON:
                customerInfo[asProperty] = entry[u'value']
              else:
                printKeyValueList([propertyTitleMap[i+1], entry[u'value']])
              break
    except GAPI.domainNotFound:
      systemErrorExit(INVALID_DOMAIN_RC, formatKeyValueList(u'', [Ent.Singular(Ent.DOMAIN), GC.Values[GC.DOMAIN], Msg.DOES_NOT_EXIST], u''))
    except GAPI.invalid:
      pass

  if checkArgumentPresent(u'logo'):
    Act.Set(Act.DOWNLOAD)
    logoFile = getString(Cmd.OB_FILE_NAME)
    checkForExtraneousArguments()
    _, data = getHttpObj().request(u'http://www.google.com/a/cpanel/{0}/images/logo.gif'.format(GC.Values[GC.DOMAIN]), u'GET')
    writeFile(logoFile, data, mode=u'wb')
    entityActionPerformed([Ent.INSTANCE, u'', Ent.LOGO, logoFile])
    return
  formatJSON = False
  customerInfo = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'formatjson':
      formatJSON = True
      customerInfo = {}
    else:
      unknownArgumentExit()
  doInfoCustomer(customerInfo)
  adm = buildGAPIObject(API.ADMIN_SETTINGS)
  _printAdminSetting(adm.maximumNumberOfUsers(), MAXIMUM_USERS_MAP)
  _printAdminSetting(adm.currentNumberOfUsers(), CURRENT_USERS_MAP)
  _printAdminSetting(adm.edition(), DOMAIN_EDITION_MAP)
  _printAdminSetting(adm.customerPIN(), CUSTOMER_PIN_MAP)
  _printAdminSetting(adm.ssoGeneral(), SINGLE_SIGN_ON_SETTINGS_MAP)
  _printAdminSetting(adm.ssoSigningKey(), SINGLE_SIGN_ON_SIGNING_KEY_MAP)
  if formatJSON:
    printLine(json.dumps(cleanJSON(customerInfo, u'', timeObjects=CUSTOMER_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))

# gam create org|ou <String> [description <String>] [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)] [buildpath]
def doCreateOrg():

  def _createOrg(body, parentPath, fullPath):
    try:
      callGAPI(cd.orgunits(), u'insert',
               throw_reasons=[GAPI.INVALID_PARENT_ORGUNIT, GAPI.INVALID_ORGUNIT, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
               customerId=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'')
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, fullPath])
    except GAPI.invalidParentOrgunit:
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, fullPath, Ent.PARENT_ORGANIZATIONAL_UNIT, parentPath], Msg.ENTITY_DOES_NOT_EXIST.format(Ent.Singular(Ent.PARENT_ORGANIZATIONAL_UNIT)))
      return False
    except (GAPI.invalidOrgunit, GAPI.backendError):
      entityDuplicateWarning([Ent.ORGANIZATIONAL_UNIT, fullPath])
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, fullPath)
    return True

  cd = buildGAPIObject(API.DIRECTORY)
  name = getOrgUnitItem(pathOnly=True, absolutePath=False)
  parent = u''
  body = {}
  buildPath = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'description':
      body[u'description'] = getStringWithCRsNLs()
    elif myarg == u'parent':
      parent = getOrgUnitItem()
    elif myarg == u'noinherit':
      body[u'blockInheritance'] = True
    elif myarg == u'inherit':
      body[u'blockInheritance'] = False
    elif myarg in [u'blockinheritance', u'inheritanceblocked']:
      body[u'blockInheritance'] = getBoolean()
    elif myarg == u'buildpath':
      buildPath = True
    else:
      unknownArgumentExit()
  if parent.startswith(u'id:'):
    parentPath = None
    try:
      parentPath = callGAPI(cd.orgunits(), u'get',
                            throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                            customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=parent, fields=u'orgUnitPath')[u'orgUnitPath']
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      pass
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      errMsg = accessErrorMessage(cd)
      if errMsg:
        systemErrorExit(INVALID_DOMAIN_RC, errMsg)
    if not parentPath and not buildPath:
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, name, Ent.PARENT_ORGANIZATIONAL_UNIT, parent], Msg.ENTITY_DOES_NOT_EXIST.format(Ent.Singular(Ent.PARENT_ORGANIZATIONAL_UNIT)))
      return
    parent = parentPath
  if parent == u'/':
    orgUnitPath = parent+name
  else:
    orgUnitPath = parent+u'/'+name
  if orgUnitPath.count(u'/') > 1:
    body[u'parentOrgUnitPath'], body[u'name'] = orgUnitPath.rsplit(u'/', 1)
  else:
    body[u'parentOrgUnitPath'] = u'/'
    body[u'name'] = orgUnitPath[1:]
  parent = body[u'parentOrgUnitPath']
  if _createOrg(body, parent, orgUnitPath) or not buildPath:
    return
  description = body.pop(u'description', None)
  fullPath = u'/'
  getPath = u''
  orgNames = orgUnitPath.split(u'/')
  n = len(orgNames)-1
  for i in range(1, n+1):
    body[u'parentOrgUnitPath'] = fullPath
    if fullPath != u'/':
      fullPath += u'/'
    fullPath += orgNames[i]
    if getPath != u'':
      getPath += u'/'
    getPath += orgNames[i]
    try:
      callGAPI(cd.orgunits(), u'get',
               throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
               customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(getPath), fields=u'')
      printKeyValueList([Ent.Singular(Ent.ORGANIZATIONAL_UNIT), fullPath, Msg.EXISTS])
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      body[u'name'] = orgNames[i]
      if i == n and description:
        body[u'description'] = description
      if not _createOrg(body, body[u'parentOrgUnitPath'], fullPath):
        return
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, fullPath)

def checkOrgUnitPathExists(cd, orgUnitPath, i=0, count=0, showError=False):
  if orgUnitPath == u'/':
    return (True, orgUnitPath)
  try:
    return (True, callGAPI(cd.orgunits(), u'get',
                           throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                           customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnitPath)),
                           fields=u'orgUnitPath')[u'orgUnitPath'])
  except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
    pass
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    errMsg = accessErrorMessage(cd)
    if errMsg:
      systemErrorExit(INVALID_DOMAIN_RC, errMsg)
  if showError:
    entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
  return (False, orgUnitPath)

def _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, i, count, items, quickCrOSMove):
  def _callbackMoveCrOSesToOrgUnit(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Ent.CROS_DEVICE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN]:
        checkEntityItemValueAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Ent.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Ent.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  jcount = len(items)
  entityPerformActionNumItems([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], jcount, Ent.CROS_DEVICE, i, count)
  Ind.Increment()
  if not quickCrOSMove:
    svcargs = dict([(u'customerId', GC.Values[GC.CUSTOMER_ID]), (u'deviceId', None), (u'body', {u'orgUnitPath': orgUnitPath}), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.chromeosdevices(), u'patch')
    dbatch = cd.new_batch_http_request(callback=_callbackMoveCrOSesToOrgUnit)
    bcount = 0
    j = 0
    for deviceId in items:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'deviceId'] = deviceId
      dbatch.add(method(**svcparms), request_id=batchRequestID(orgUnitPath, 0, 0, j, jcount, deviceId))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackMoveCrOSesToOrgUnit)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
  else:
    bcount = 0
    j = 0
    while bcount < jcount:
      kcount = min(jcount-bcount, GC.Values[GC.BATCH_SIZE])
      try:
        deviceIds = items[bcount:bcount+kcount]
        callGAPI(cd.chromeosdevices(), u'moveDevicesToOu',
                 throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                 customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=orgUnitPath,
                 body={u'deviceIds': deviceIds})
        for deviceId in deviceIds:
          j += 1
          entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.CROS_DEVICE, deviceId], j, jcount)
        bcount += kcount
      except GAPI.invalidOrgunit:
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.INVALID_ORGUNIT, i, count)
        break
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath, i, count)
  Ind.Decrement()

def _batchMoveUsersToOrgUnit(cd, orgUnitPath, i, count, items):
  _MOVE_USER_REASON_TO_MESSAGE_MAP = {GAPI.USER_NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.DOMAIN_NOT_FOUND: Msg.SERVICE_NOT_APPLICABLE, GAPI.FORBIDDEN: Msg.SERVICE_NOT_APPLICABLE}
  def _callbackMoveUsersToOrgUnit(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Ent.USER, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      errMsg = getHTTPError(_MOVE_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY], Ent.USER, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  jcount = len(items)
  entityPerformActionNumItems([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], jcount, Ent.USER, i, count)
  Ind.Increment()
  svcargs = dict([(u'userKey', None), (u'body', {u'orgUnitPath': orgUnitPath}), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
  method = getattr(cd.users(), u'patch')
  dbatch = cd.new_batch_http_request(callback=_callbackMoveUsersToOrgUnit)
  bcount = 0
  j = 0
  for user in items:
    j += 1
    svcparms = svcargs.copy()
    svcparms[u'userKey'] = normalizeEmailAddressOrUID(user)
    dbatch.add(method(**svcparms), request_id=batchRequestID(orgUnitPath, 0, 0, j, jcount, svcparms[u'userKey']))
    bcount += 1
    if bcount >= GC.Values[GC.BATCH_SIZE]:
      executeBatch(dbatch)
      dbatch = cd.new_batch_http_request(callback=_callbackMoveUsersToOrgUnit)
      bcount = 0
  if bcount > 0:
    executeBatch(dbatch)
  Ind.Decrement()

def _doUpdateOrgs(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent([u'move', u'add']):
    entityType, items = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, crosAllowed=True)
    orgItemLists = items if isinstance(items, dict) else None
    quickCrOSMove = False
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if entityType == Cmd.ENTITY_CROS and myarg == u'quickcrosmove':
        quickCrOSMove = getBoolean()
      else:
        unknownArgumentExit()
    Act.Set(Act.ADD)
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      if orgItemLists:
        items = orgItemLists[orgUnitPath]
      status, orgUnitPath = checkOrgUnitPathExists(cd, orgUnitPath, i, count, True)
      if not status:
        continue
      if entityType == Cmd.ENTITY_USERS:
        _batchMoveUsersToOrgUnit(cd, orgUnitPath, i, count, items)
      else:
        _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, i, count, items, quickCrOSMove)
  else:
    body = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'name':
        body[u'name'] = getString(Cmd.OB_STRING)
      elif myarg == u'description':
        body[u'description'] = getStringWithCRsNLs()
      elif myarg == u'parent':
        parent = getOrgUnitItem()
        if parent.startswith(u'id:'):
          body[u'parentOrgUnitId'] = parent
        else:
          body[u'parentOrgUnitPath'] = parent
      elif myarg == u'noinherit':
        body[u'blockInheritance'] = True
      elif myarg == u'inherit':
        body[u'blockInheritance'] = False
      elif myarg in [u'blockinheritance', u'inheritanceblocked']:
        body[u'blockInheritance'] = getBoolean()
      else:
        unknownArgumentExit()
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      try:
        callGAPI(cd.orgunits(), u'update',
                 throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.INVALID_ORGUNIT_NAME,
                                GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                 customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnitPath)), body=body, fields=u'')
        entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], i, count)
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
      except GAPI.invalidOrgunitName as e:
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.NAME, body[u'name']], str(e), i, count)
      except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam update orgs|ous <OrgUnitEntity> [name <String>] [description <String>] [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)]
# gam update orgs|ous <OrgUnitEntity> add|move <CrosTypeEntity> [quickcrosmove [<Boolean>]]
# gam update orgs|ous <OrgUnitEntity> add|move <UserTypeEntity>
def doUpdateOrgs():
  _doUpdateOrgs(getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam update org|ou <OrgUnitItem> [name <String>] [description <String>]  [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)]
# gam update org|ou <OrgUnitItem> add|move <CrosTypeEntity> [quickcrosmove [<Boolean>]]
# gam update org|ou <OrgUnitItem> add|move <UserTypeEntity>
def doUpdateOrg():
  _doUpdateOrgs([getOrgUnitItem()])

def _doDeleteOrgs(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for orgUnitPath in entityList:
    i += 1
    try:
      orgUnitPath = makeOrgUnitPathAbsolute(orgUnitPath)
      callGAPI(cd.orgunits(), u'delete',
               throw_reasons=[GAPI.CONDITION_NOT_MET, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
               customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnitPath)))
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], i, count)
    except GAPI.conditionNotMet:
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.HAS_CHILD_ORGS.format(Ent.Plural(Ent.ORGANIZATIONAL_UNIT)), i, count)
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam delete orgs|ous <OrgUnitEntity>
def doDeleteOrgs():
  _doDeleteOrgs(getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam delete org|ou <OrgUnitItem>
def doDeleteOrg():
  _doDeleteOrgs([getOrgUnitItem()])

def getTopLevelOrgId(cd, parentOrgUnitPath):
  try:
    temp_org = callGAPI(cd.orgunits(), u'insert',
                        throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], body={u'name': u'temp-delete-me', u'parentOrgUnitPath': parentOrgUnitPath}, fields=u'parentOrgUnitId,orgUnitId')
  except GAPI.invalidOrgunit:
    return None
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, parentOrgUnitPath)
    return None
  try:
    callGAPI(cd.orgunits(), u'delete',
             throw_reasons=[GAPI.CONDITION_NOT_MET, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
             customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=temp_org[u'orgUnitId'])
  except (GAPI.conditionNotMet, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
    pass
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, parentOrgUnitPath)
  return temp_org[u'parentOrgUnitId']

CHECK_SUSPENDED_CHOICE_MAP = {u'notsuspended': False, u'suspended': True}
ORG_FIELD_INFO_ORDER = [u'orgUnitId', u'name', u'description', u'parentOrgUnitPath', u'parentOrgUnitId', u'blockInheritance']
ORG_FIELDS_WITH_CRS_NLS = [u'description']

def _doInfoOrgs(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  getUsers = True
  checkSuspended = None
  showChildren = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'nousers':
      getUsers = False
    elif myarg in [u'children', u'child']:
      showChildren = True
    elif myarg in CHECK_SUSPENDED_CHOICE_MAP:
      checkSuspended = CHECK_SUSPENDED_CHOICE_MAP[myarg]
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for orgUnitPath in entityList:
    i += 1
    try:
      if orgUnitPath == u'/':
        orgs = callGAPI(cd.orgunits(), u'list',
                        throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], type=u'children',
                        fields=u'organizationUnits(parentOrgUnitId)')
        if orgs.get(u'organizationUnits', []):
          orgUnitPath = orgs[u'organizationUnits'][0][u'parentOrgUnitId']
        else:
          topLevelOrgId = getTopLevelOrgId(cd, u'/')
          if topLevelOrgId:
            orgUnitPath = topLevelOrgId
      else:
        orgUnitPath = makeOrgUnitPathRelative(orgUnitPath)
      result = callGAPI(cd.orgunits(), u'get',
                        throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(orgUnitPath))
      printEntity([Ent.ORGANIZATIONAL_UNIT, result[u'orgUnitPath']], i, count)
      Ind.Increment()
      for field in ORG_FIELD_INFO_ORDER:
        value = result.get(field, None)
        if value is not None:
          if field not in ORG_FIELDS_WITH_CRS_NLS:
            printKeyValueList([field, value])
          else:
            printKeyValueWithCRsNLs(field, value)
      if getUsers:
        orgUnitPath = result[u'orgUnitPath']
        users = callGAPIpages(cd.users(), u'list', u'users',
                              throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID_INPUT, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID], query=orgUnitPathQuery(orgUnitPath, checkSuspended),
                              fields=u'nextPageToken,users(primaryEmail,orgUnitPath)',
                              maxResults=GC.Values[GC.USER_MAX_RESULTS])
        printEntitiesCount(Ent.USER, users)
        Ind.Increment()
        orgUnitPath = orgUnitPath.lower()
        for user in users:
          if orgUnitPath == user[u'orgUnitPath'].lower():
            printKeyValueList([user[u'primaryEmail']])
          elif showChildren:
            printKeyValueList([u'{0} (child)'.format(user[u'primaryEmail'])])
        Ind.Decrement()
      Ind.Decrement()
    except (GAPI.invalidInput, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam info orgs|ous <OrgUnitEntity> [nousers] [children|child] [notsuspended|suspended]
def doInfoOrgs():
  _doInfoOrgs(getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam info org|ou <OrgUnitItem> [nousers] [children|child] [notsuspended|suspended]
def doInfoOrg():
  _doInfoOrgs([getOrgUnitItem()])

# CL argument: [API field name, CSV field title]
#
ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP = {
  u'blockinheritance': [u'blockInheritance', u'InheritanceBlocked'],
  u'inheritanceblocked': [u'blockInheritance', u'InheritanceBlocked'],
  u'inherit': [u'blockInheritance', u'InheritanceBlocked'],
  u'description': [u'description', u'Description'],
  u'id': [u'orgUnitId', u'ID'],
  u'name': [u'name', u'Name'],
  u'orgunitid': [u'orgUnitId', u'ID'],
  u'orgunitpath': [u'orgUnitPath', u'Path'],
  u'path': [u'orgUnitPath', u'Path'],
  u'parentorgunitid': [u'parentOrgUnitId', u'ParentID'],
  u'parentid': [u'parentOrgUnitId', u'ParentID'],
  u'parentorgunitpath': [u'parentOrgUnitPath', u'Parent'],
  u'parent': [u'parentOrgUnitPath', u'Parent'],
  }
ORG_FIELD_PRINT_ORDER = [u'orgUnitPath', u'orgUnitId', u'name', u'description', u'parentOrgUnitPath', u'parentOrgUnitId', u'blockInheritance']
PRINT_ORGS_DEFAULT_FIELDS = [u'orgUnitPath', u'orgUnitId', u'name', u'parentOrgUnitId']

def _getOrgUnits(cd, orgUnitPath, fieldsList, listType, showParent, batchSubOrgs):
  def _callbackListOrgUnits(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      orgUnits.extend(response.get(u'organizationUnits', []))
    else:
      http_status, reason, message = checkGAPIError(exception)
      errMsg = getHTTPError({}, http_status, reason, message)
      if reason not in GAPI.DEFAULT_RETRY_REASONS:
        if reason in [GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED]:
          accessErrorExit(cd)
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY]], errMsg)
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.orgunits(), u'list',
                            throw_reasons=[GAPI.ORGUNIT_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                            customerId=GC.Values[GC.CUSTOMER_ID], type=u'all', orgUnitPath=ri[RI_ENTITY], fields=listfields)
        orgUnits.extend(response.get(u'organizationUnits', []))
      except GAPI.orgunitNotFound:
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, ri[RI_ENTITY]], Msg.DOES_NOT_EXIST)
      except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
        accessErrorExit(cd)

  def _batchListOrgUnits(topLevelOrgUnits):
    svcargs = dict([(u'customerId', GC.Values[GC.CUSTOMER_ID]), (u'orgUnitPath', None), (u'type', u'all'), (u'fields', listfields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.orgunits(), u'list')
    dbatch = cd.new_batch_http_request(callback=_callbackListOrgUnits)
    bcount = 0
    for orgUnitPath in topLevelOrgUnits:
      svcparms = svcargs.copy()
      svcparms[u'orgUnitPath'] = orgUnitPath
      dbatch.add(method(**svcparms), request_id=batchRequestID(orgUnitPath, 0, 0, 0, 0, u''))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackListOrgUnits)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)

  deleteOrgUnitId = deleteParentOrgUnitId = False
  if showParent:
    localFieldsList = fieldsList[:]
    if u'orgUnitId' not in fieldsList:
      localFieldsList.append(u'orgUnitId')
      deleteOrgUnitId = True
    if u'parentOrgUnitId' not in fieldsList:
      localFieldsList.append(u'parentOrgUnitId')
      deleteParentOrgUnitId = True
    fields = u','.join(set(localFieldsList))
  else:
    fields = u','.join(set(fieldsList))
  listfields = u'organizationUnits({0})'.format(fields)
  printGettingAllAccountEntities(Ent.ORGANIZATIONAL_UNIT)
  if listType == u'children':
    batchSubOrgs = False
  try:
    orgs = callGAPI(cd.orgunits(), u'list',
                    throw_reasons=[GAPI.ORGUNIT_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                    customerId=GC.Values[GC.CUSTOMER_ID], type=listType if not batchSubOrgs else u'children', orgUnitPath=orgUnitPath, fields=listfields)
  except GAPI.orgunitNotFound:
    entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST)
    return None
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    accessErrorExit(cd)
  orgUnits = orgs.get(u'organizationUnits', [])
  if batchSubOrgs:
    _batchListOrgUnits([orgUnit[u'orgUnitPath'] for orgUnit in orgUnits])
  if showParent:
    parentOrgIds = []
    retrievedOrgIds = []
    if not orgUnits:
      topLevelOrgId = getTopLevelOrgId(cd, orgUnitPath)
      if topLevelOrgId:
        parentOrgIds.append(topLevelOrgId)
    for orgUnit in orgUnits:
      retrievedOrgIds.append(orgUnit[u'orgUnitId'])
      if orgUnit[u'parentOrgUnitId'] not in parentOrgIds:
        parentOrgIds.append(orgUnit[u'parentOrgUnitId'])
    missing_parents = set(parentOrgIds)-set(retrievedOrgIds)
    for missing_parent in missing_parents:
      try:
        result = callGAPI(cd.orgunits(), u'get',
                          throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                          customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=missing_parent, fields=fields)
        orgUnits.append(result)
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError,
              GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
        pass
  printGotAccountEntities(len(orgUnits))
  if deleteOrgUnitId or deleteParentOrgUnitId:
    for orgUnit in orgUnits:
      if deleteOrgUnitId:
        orgUnit.pop(u'orgUnitId', None)
      if deleteParentOrgUnitId:
        orgUnit.pop(u'parentOrgUnitId', None)
  return orgUnits

# gam print orgs|ous [todrive [<ToDriveAttributes>]] [fromparent <OrgUnitItem>] [showparent] [toplevelonly]
#	[allfields|<OrgUnitFieldName>*|(fields <OrgUnitFieldNameList>)] [convertcrnl] [batchsuborgs [Boolean>]]
def doPrintOrgs():
  cd = buildGAPIObject(API.DIRECTORY)
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  todrive = {}
  fieldsList = []
  fieldsTitles = {}
  nativeTitles = []
  titles, csvRows = initializeTitlesCSVfile(None)
  orgUnitPath = u'/'
  listType = u'all'
  batchSubOrgs = showParent = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'fromparent':
      orgUnitPath = getOrgUnitItem()
    elif myarg == u'showparent':
      showParent = getBoolean()
    elif myarg == u'batchsuborgs':
      batchSubOrgs = getBoolean()
    elif myarg == u'toplevelonly':
      listType = u'children'
    elif myarg == u'allfields':
      fieldsList = []
      fieldsTitles = {}
      titles, csvRows = initializeTitlesCSVfile(None)
      for field in ORG_FIELD_PRINT_ORDER:
        addFieldTitleToCSVfile(field, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
    elif myarg in ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP:
      if not fieldsList:
        addFieldTitleToCSVfile(u'orgUnitPath', ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
      addFieldTitleToCSVfile(myarg, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
    elif myarg == u'fields':
      if not fieldsList:
        addFieldTitleToCSVfile(u'orgUnitPath', ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
      for field in _getFieldsList():
        if field in ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP:
          addFieldTitleToCSVfile(field, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
        else:
          invalidChoiceExit(list(ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP), True)
    elif myarg in [u'convertcrnl', u'converttextnl']:
      convertCRNL = True
    else:
      unknownArgumentExit()
  if not fieldsList:
    for field in PRINT_ORGS_DEFAULT_FIELDS:
      addFieldTitleToCSVfile(field, ORG_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
  if GC.Values[GC.PRINT_NATIVE_NAMES]:
    convertToNativeTitles(fieldsTitles, titles, nativeTitles)
  orgUnits = _getOrgUnits(cd, orgUnitPath, fieldsList, listType, showParent, batchSubOrgs)
  if orgUnits is None:
    return
  for orgUnit in orgUnits:
    row = {}
    for field in fieldsList:
      if convertCRNL and field in ORG_FIELDS_WITH_CRS_NLS:
        row[fieldsTitles[field]] = escapeCRsNLs(orgUnit.get(field, u''))
      else:
        row[fieldsTitles[field]] = orgUnit.get(field, u'')
    csvRows.append(row)
  csvRows.sort(key=lambda x: x[fieldsTitles[u'orgUnitPath']].lower(), reverse=False)
  writeCSVfile(csvRows, titles, u'Orgs', todrive)

# gam show orgtree [fromparent <OrgUnitItem>] [batchsuborgs [Boolean>]]
def doShowOrgTree():
  def addOrgUnitToTree(orgPathList, i, n, tree):
    if orgPathList[i] not in tree:
      tree[orgPathList[i]] = {}
    if i < n:
      addOrgUnitToTree(orgPathList, i+1, n, tree[orgPathList[i]])

  def printOrgUnit(parentOrgUnit, tree):
    printKeyValueList([parentOrgUnit])
    Ind.Increment()
    for childOrgUnit in sorted(tree[parentOrgUnit]):
      printOrgUnit(childOrgUnit, tree[parentOrgUnit])
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  orgUnitPath = u'/'
  fieldsList = [u'orgUnitPath',]
  listType = u'all'
  batchSubOrgs = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'fromparent':
      orgUnitPath = getOrgUnitItem()
    elif myarg == u'batchsuborgs':
      batchSubOrgs = getBoolean()
    else:
      unknownArgumentExit()
  orgUnits = _getOrgUnits(cd, orgUnitPath, fieldsList, listType, False, batchSubOrgs)
  if orgUnits is None:
    return
  orgTree = {}
  for orgUnit in orgUnits:
    orgPath = orgUnit[u'orgUnitPath'].split(u'/')
    addOrgUnitToTree(orgPath, 1, len(orgPath)-1, orgTree)
  for org in sorted(orgTree):
    printOrgUnit(org, orgTree)

ALIAS_TARGET_TYPES = [u'user', u'group', u'target',]

def _doCreateUpdateAliases(doUpdate):
  cd = buildGAPIObject(API.DIRECTORY)
  aliasList = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
  targetType = getChoice(ALIAS_TARGET_TYPES)
  targetEmails = getEntityList(Cmd.OB_GROUP_ENTITY)
  entityLists = targetEmails if isinstance(targetEmails, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(aliasList)
  for aliasEmail in aliasList:
    i += 1
    if entityLists:
      targetEmails = entityLists[aliasEmail]
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True, noLower=True)
    body = {u'alias': aliasEmail}
    jcount = len(targetEmails)
    if jcount > 0:
# Only process first target
      targetEmail = normalizeEmailAddressOrUID(targetEmails[0])
      if doUpdate:
        try:
          callGAPI(cd.users().aliases(), u'delete',
                   throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                  GAPI.CONDITION_NOT_MET],
                   userKey=aliasEmail, alias=aliasEmail)
          printEntityKVList([Ent.USER_ALIAS, aliasEmail], [Act.PerformedName(Act.DELETE)], i, count)
        except GAPI.conditionNotMet as e:
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail], str(e), i, count)
          continue
        except (GAPI.userNotFound, GAPI.badRequest, GAPI.invalid, GAPI.forbidden, GAPI.invalidResource):
          try:
            callGAPI(cd.groups().aliases(), u'delete',
                     throw_reasons=[GAPI.GROUP_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                    GAPI.CONDITION_NOT_MET],
                     groupKey=aliasEmail, alias=aliasEmail)
          except GAPI.conditionNotMet as e:
            entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail], str(e), i, count)
            continue
          except GAPI.forbidden:
            entityUnknownWarning(Ent.GROUP_ALIAS, aliasEmail, i, count)
            continue
          except (GAPI.groupNotFound, GAPI.badRequest, GAPI.invalid, GAPI.invalidResource):
            entityUnknownWarning(Ent.ALIAS, aliasEmail, i, count)
      if targetType != u'group':
        try:
          callGAPI(cd.users().aliases(), u'insert',
                   throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST,
                                  GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.FORBIDDEN, GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET],
                   userKey=targetEmail, body=body, fields=u'')
          entityActionPerformed([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], i, count)
          continue
        except GAPI.conditionNotMet as e:
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], str(e), i, count)
          continue
        except GAPI.duplicate:
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], Msg.DUPLICATE, i, count)
          continue
        except (GAPI.invalid, GAPI.invalidInput):
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], Msg.INVALID_ALIAS, i, count)
          continue
        except (GAPI.userNotFound, GAPI.badRequest, GAPI.forbidden):
          if targetType == u'user':
            entityUnknownWarning(Ent.ALIAS_TARGET, targetEmail, i, count)
            continue
      try:
        callGAPI(cd.groups().aliases(), u'insert',
                 throw_reasons=[GAPI.GROUP_NOT_FOUND, GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST,
                                GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.FORBIDDEN, GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET],
                 groupKey=targetEmail, body=body, fields=u'')
        entityActionPerformed([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], i, count)
      except GAPI.conditionNotMet as e:
        entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], str(e), i, count)
      except GAPI.duplicate:
        entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], Msg.DUPLICATE, i, count)
      except (GAPI.invalid, GAPI.invalidInput):
        entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], Msg.INVALID_ALIAS, i, count)
      except (GAPI.groupNotFound, GAPI.userNotFound, GAPI.badRequest, GAPI.forbidden):
        entityUnknownWarning(Ent.ALIAS_TARGET, targetEmail, i, count)

# gam create aliases|nicknames <EmailAddressEntity> user|group|target <UniqueID>|<EmailAddress>
def doCreateAliases():
  _doCreateUpdateAliases(False)

# gam update aliases|nicknames <EmailAddressEntity> user|group|target <UniqueID>|<EmailAddress>
def doUpdateAliases():
  _doCreateUpdateAliases(True)

# gam delete aliases|nicknames [user|group|target] <EmailAddressEntity>
def doDeleteAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  targetType = getChoice(ALIAS_TARGET_TYPES, defaultChoice=u'target')
  entityList = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for aliasEmail in entityList:
    i += 1
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True, noLower=True)
    if targetType != u'group':
      try:
        callGAPI(cd.users().aliases(), u'delete',
                 throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                GAPI.CONDITION_NOT_MET],
                 userKey=aliasEmail, alias=aliasEmail)
        entityActionPerformed([Ent.USER_ALIAS, aliasEmail], i, count)
        continue
      except GAPI.conditionNotMet as e:
        entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail], str(e), i, count)
        continue
      except (GAPI.userNotFound, GAPI.badRequest, GAPI.invalid, GAPI.forbidden, GAPI.invalidResource):
        if targetType == u'user':
          entityUnknownWarning(Ent.USER_ALIAS, aliasEmail, i, count)
          continue
    try:
      callGAPI(cd.groups().aliases(), u'delete',
               throw_reasons=[GAPI.GROUP_NOT_FOUND, GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                              GAPI.CONDITION_NOT_MET],
               groupKey=aliasEmail, alias=aliasEmail)
      entityActionPerformed([Ent.GROUP_ALIAS, aliasEmail], i, count)
      continue
    except GAPI.conditionNotMet as e:
      entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail], str(e), i, count)
      continue
    except (GAPI.groupNotFound, GAPI.userNotFound, GAPI.badRequest, GAPI.invalid, GAPI.forbidden, GAPI.invalidResource):
      if targetType == u'group':
        entityUnknownWarning(Ent.GROUP_ALIAS, aliasEmail, i, count)
        continue
    entityUnknownWarning(Ent.ALIAS, aliasEmail, i, count)

def infoAliases(entityList):

  def _showAliasInfo(uid, email, aliasEmail, entityType, aliasEntityType, i, count):
    if email.lower() != aliasEmail:
      printEntity([aliasEntityType, aliasEmail], i, count)
      Ind.Increment()
      printEntity([entityType, email])
      printEntity([Ent.UNIQUE_ID, uid])
      Ind.Decrement()
    else:
      setSysExitRC(ENTITY_IS_NOT_AN_ALIAS_RC)
      printEntityKVList([Ent.EMAIL, aliasEmail],
                        [u'Is a {0}, not a {1}'.format(Ent.Singular(entityType),
                                                       Ent.Singular(aliasEntityType))],
                        i, count)

  cd = buildGAPIObject(API.DIRECTORY)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
# Ignore info group/user arguments that may have come from whatis
    if (myarg in INFO_GROUP_OPTIONS) or (myarg in INFO_USER_OPTIONS):
      if myarg == u'schemas':
        getString(Cmd.OB_SCHEMA_NAME_LIST)
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for aliasEmail in entityList:
    i += 1
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True, noLower=True)
    try:
      result = callGAPI(cd.users(), u'get',
                        throw_reasons=GAPI.USER_GET_THROW_REASONS,
                        userKey=aliasEmail, fields=u'id,primaryEmail')
      _showAliasInfo(result[u'id'], result[u'primaryEmail'], aliasEmail, Ent.USER_EMAIL, Ent.USER_ALIAS, i, count)
      continue
    except (GAPI.userNotFound, GAPI.badRequest):
      pass
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER_ALIAS, aliasEmail, i, count)
      continue
    try:
      result = callGAPI(cd.groups(), u'get',
                        throw_reasons=GAPI.GROUP_GET_THROW_REASONS,
                        groupKey=aliasEmail, fields=u'id,email')
      _showAliasInfo(result[u'id'], result[u'email'], aliasEmail, Ent.GROUP_EMAIL, Ent.GROUP_ALIAS, i, count)
      continue
    except GAPI.groupNotFound:
      pass
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      entityUnknownWarning(Ent.GROUP_ALIAS, aliasEmail, i, count)
      continue
    entityUnknownWarning(Ent.EMAIL, aliasEmail, i, count)

# gam info aliases|nicknames <EmailAddressEntity>
def doInfoAliases():
  infoAliases(getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY))

# gam print aliases|nicknames [todrive [<ToDriveAttributes>]] [(query <QueryUser>)|(queries <QueryUserList>)] [shownoneditable] [nogroups] [nousers]
def doPrintAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  todrive = {}
  titlesList = [u'Alias', u'Target', u'TargetType']
  userFields = [u'primaryEmail', u'aliases']
  groupFields = [u'email', u'aliases']
  getGroups = getUsers = True
  queries = [None]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'shownoneditable':
      titlesList.insert(1, u'NonEditableAlias')
      userFields.append(u'nonEditableAliases')
      groupFields.append(u'nonEditableAliases')
    elif myarg == u'nogroups':
      getGroups = False
    elif myarg == u'nousers':
      getUsers = False
    elif myarg in [u'query', u'queries']:
      queries = getQueries(myarg)
      getGroups = False
      getUsers = True
    else:
      unknownArgumentExit()
  titles, csvRows = initializeTitlesCSVfile(titlesList)
  if getUsers:
    for query in queries:
      printGettingAllAccountEntities(Ent.USER, query)
      try:
        entityList = callGAPIpages(cd.users(), u'list', u'users',
                                   page_message=getPageMessage(showTotal=False, showFirstLastItems=True), message_attribute=u'primaryEmail',
                                   throw_reasons=[GAPI.INVALID_ORGUNIT, GAPI.INVALID_INPUT,
                                                  GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                   customer=GC.Values[GC.CUSTOMER_ID], query=query, fields=u'nextPageToken,users({0})'.format(u','.join(userFields)),
                                   maxResults=GC.Values[GC.USER_MAX_RESULTS])
        for user in entityList:
          for alias in user.get(u'aliases', []):
            csvRows.append({u'Alias': alias, u'Target': user[u'primaryEmail'], u'TargetType': u'User'})
          for alias in user.get(u'nonEditableAliases', []):
            csvRows.append({u'NonEditableAlias': alias, u'Target': user[u'primaryEmail'], u'TargetType': u'User'})
      except (GAPI.invalidOrgunit, GAPI.invalidInput):
        entityActionFailedWarning([Ent.ALIAS, None], invalidQuery(query))
        return
      except (GAPI.resourceNotFound, GAPI.forbidden, GAPI.badRequest):
        accessErrorExit(cd)
  if getGroups:
    printGettingAllAccountEntities(Ent.GROUP)
    try:
      entityList = callGAPIpages(cd.groups(), u'list', u'groups',
                                 page_message=getPageMessage(showTotal=False, showFirstLastItems=True), message_attribute=u'email',
                                 throw_reasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                 customer=GC.Values[GC.CUSTOMER_ID], fields=u'nextPageToken,groups({0})'.format(u','.join(groupFields)))
      for group in entityList:
        for alias in group.get(u'aliases', []):
          csvRows.append({u'Alias': alias, u'Target': group[u'email'], u'TargetType': u'Group'})
        for alias in group.get(u'nonEditableAliases', []):
          csvRows.append({u'NonEditableAlias': alias, u'Target': group[u'email'], u'TargetType': u'Group'})
    except (GAPI.resourceNotFound, GAPI.forbidden, GAPI.badRequest):
      accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Aliases', todrive)

# gam audit uploadkey [<FileName>]
def doUploadAuditKey():
  auditObject = getEmailAuditObject()
  if Cmd.ArgumentsRemaining():
    filename = getString(Cmd.OB_FILE_NAME)
    auditkey = readFile(filename)
  else:
    filename = u'Read from stdin'
    auditkey = sys.stdin.read()
  checkForExtraneousArguments()
  callGData(auditObject, u'updatePGPKey',
            pgpkey=auditkey)
  entityActionPerformed([Ent.PUBLIC_KEY, filename])

# Audit activity/export command utilities
def checkDownloadResults(results):
  if results[u'status'] != u'COMPLETED':
    printWarningMessage(REQUEST_NOT_COMPLETED_RC, Msg.REQUEST_NOT_COMPLETE.format(results[u'status']))
    return False
  if int(results.get(u'numberOfFiles', u'0') >= 1):
    return True
  printWarningMessage(REQUEST_COMPLETED_NO_RESULTS_RC, Msg.REQUEST_COMPLETED_NO_FILES)
  return False

# Audit command utilities
def getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False):
  auditObject = getEmailAuditObject()
  emailAddress = getEmailAddress(noUid=True, optional=not emailAddressRequired)
  parameters = {}
  if emailAddress:
    parameters[u'auditUser'] = emailAddress
    parameters[u'auditUserName'], auditObject.domain = splitEmailAddress(emailAddress)
    if requestIdRequired:
      parameters[u'requestId'] = getString(Cmd.OB_REQUEST_ID)
    if destUserRequired:
      destEmailAddress = getEmailAddress(noUid=True)
      parameters[u'auditDestUser'] = destEmailAddress
      parameters[u'auditDestUserName'], destDomain = splitEmailAddress(destEmailAddress)
      if auditObject.domain != destDomain:
        Cmd.Backup()
        invalidArgumentExit(u'{0}@{1}'.format(parameters[u'auditDestUserName'], auditObject.domain))
  return (auditObject, parameters)

def _showFileURLs(request):
  if u'numberOfFiles' in request:
    printKeyValueList([u'Number Of Files', request[u'numberOfFiles']])
    Ind.Increment()
    for i in range(int(request[u'numberOfFiles'])):
      printKeyValueList([u'Url{0}'.format(i), request[u'fileUrl'+str(i)]])
    Ind.Decrement()

# Audit export command utilities
def _showMailboxExportRequestStatus(request, i, count, showFilter=False, showDates=False, showFiles=False):
  printEntity([Ent.REQUEST_ID, request[u'requestId']], i, count)
  Ind.Increment()
  printEntity([Ent.USER, request[u'userEmailAddress']])
  printKeyValueList([u'Status', request[u'status']])
  printKeyValueList([u'Request Date', request[u'requestDate']])
  printKeyValueList([u'Requested By', request[u'adminEmailAddress']])
  printKeyValueList([u'Requested Parts', request[u'packageContent']])
  if showFilter:
    printKeyValueList([u'Request Filter', request.get(u'searchQuery', u'None')])
  printKeyValueList([u'Include Deleted', request[u'includeDeleted']])
  if showDates:
    printKeyValueList([u'Begin', request.get(u'beginDate', u'Account creation date')])
    printKeyValueList([u'End', request.get(u'endDate', u'Export request date')])
  if showFiles:
    _showFileURLs(request)
  Ind.Decrement()

# gam audit export request <EmailAddress> [begin <DateTime>] [end <DateTime>] [search <QueryGmail>] [headersonly] [includedeleted]
def doSubmitExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  begin_date = end_date = search_query = None
  headers_only = include_deleted = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'begin':
      begin_date = getYYYYMMDD_HHMM()
    elif myarg == u'end':
      end_date = getYYYYMMDD_HHMM()
    elif myarg == u'search':
      search_query = getString(Cmd.OB_QUERY)
    elif myarg == u'headersonly':
      headers_only = True
    elif myarg == u'includedeleted':
      include_deleted = True
    else:
      unknownArgumentExit()
  try:
    request = callGData(auditObject, u'createMailboxExportRequest',
                        throw_errors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                        user=parameters[u'auditUserName'], begin_date=begin_date, end_date=end_date, include_deleted=include_deleted,
                        search_query=search_query, headers_only=headers_only)
    entityActionPerformed([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, None])
    Ind.Increment()
    _showMailboxExportRequestStatus(request, 0, 0, showFilter=False, showDates=True, showFiles=False)
    Ind.Decrement()
  except (GDATA.invalidDomain, GDATA.doesNotExist):
    entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
  except GDATA.invalidValue as e:
    entityActionFailedWarning([Ent.USER, parameters[u'auditUser']], str(e))

# gam audit export delete <EmailAddress> <RequestID>
def doDeleteExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, u'deleteMailboxExportRequest',
              throw_errors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
              user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    entityActionPerformed([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters[u'requestId']])
  except (GDATA.invalidDomain, GDATA.doesNotExist):
    entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
  except GDATA.invalidValue:
    entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], Msg.INVALID_REQUEST)

# gam audit export download <EmailAddress> <RequestID>
def doDownloadExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    results = callGData(auditObject, u'getMailboxExportRequestStatus',
                        throw_errors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                        user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    if not checkDownloadResults(results):
      return
    count = int(results[u'numberOfFiles'])
    for i in range(count):
      filename = u'export-{0}-{1}-{2}.mbox.gpg'.format(parameters[u'auditUserName'], parameters[u'requestId'], i)
      #don't download existing files. This does not check validity of existing local
      #file so partial/corrupt downloads will need to be deleted manually.
      if not os.path.isfile(filename):
        entityPerformActionInfo([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], filename, i+1, count)
        _, data = getHttpObj().request(results[u'fileUrl'+str(i)], u'GET')
        writeFile(filename, data)
  except (GDATA.invalidDomain, GDATA.doesNotExist):
    entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
  except GDATA.invalidValue:
    entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], Msg.INVALID_REQUEST)

# gam audit export status [<EmailAddress> <RequestID>]
def doStatusExportRequests():
  auditObject, parameters = getAuditParameters(emailAddressRequired=False, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  if parameters:
    try:
      results = [callGData(auditObject, u'getMailboxExportRequestStatus',
                           throw_errors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                           user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])]
      jcount = 1 if (results) else 0
      entityPerformActionNumItems([Ent.USER, parameters[u'auditUser']], jcount, Ent.AUDIT_EXPORT_REQUEST)
    except (GDATA.invalidDomain, GDATA.doesNotExist):
      entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
      return
    except GDATA.invalidValue:
      entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], Msg.INVALID_REQUEST)
      return
  else:
    results = callGData(auditObject, u'getAllMailboxExportRequestsStatus')
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Ent.DOMAIN, GC.Values[GC.DOMAIN]], jcount, Ent.AUDIT_EXPORT_REQUEST)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Ind.Increment()
  j = 0
  for request in results:
    j += 1
    _showMailboxExportRequestStatus(request, j, jcount, showFilter=True, showDates=False, showFiles=True)
  Ind.Decrement()

# gam audit export watch <EmailAddress> <RequestID>
def doWatchExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  while True:
    try:
      results = callGData(auditObject, u'getMailboxExportRequestStatus',
                          throw_errors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                          user=parameters[u'auditUserName'], request_id=parameters[u'requestId'])
    except (GDATA.invalidDomain, GDATA.doesNotExist):
      entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
      break
    except GDATA.invalidValue:
      entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters[u'requestId']], Msg.INVALID_REQUEST)
      break
    if results[u'status'] != u'PENDING':
      printKeyValueList([u'Status is', results[u'status'], u'Sending email.'])
      msg_txt = u'\n'
      msg_txt += u'  {0}: {1}\n'.format(Ent.Singular(Ent.REQUEST_ID), results[u'requestId'])
      msg_txt += u'  {0}: {1}\n'.format(Ent.Singular(Ent.USER), results[u'userEmailAddress'])
      msg_txt += u'  Status: {0}\n'.format(results[u'status'])
      msg_txt += u'  Request Date: {0}\n'.format(results[u'requestDate'])
      msg_txt += u'  Requested By: {0}\n'.format(results[u'adminEmailAddress'])
      msg_txt += u'  Requested Parts: {0}\n'.format(results[u'packageContent'])
      msg_txt += u'  Request Filter: {0}\n'.format(results.get(u'searchQuery', u'None'))
      msg_txt += u'  Include Deleted: {0}\n'.format(results[u'includeDeleted'])
      if u'numberOfFiles' in results:
        msg_txt += u'  Number Of Files: {0}\n'.format(results[u'numberOfFiles'])
        for i in range(int(results[u'numberOfFiles'])):
          msg_txt += u'  Url{0}: {1}\n'.format(i, results[u'fileUrl'+str(i)])
      msg_subj = u'Export #{0} for {1} status is {2}'.format(results[u'requestId'], results[u'userEmailAddress'], results[u'status'])
      send_email(msg_subj, msg_txt, _getValueFromOAuth(u'email'))
      break
    else:
      printKeyValueList([u'Status still PENDING, will check again in 5 minutes...'])
      time.sleep(300)

# Audit monitor command utilities
def _showMailboxMonitorRequestStatus(request, i=0, count=0):
  printKeyValueListWithCount([u'Destination', normalizeEmailAddressOrUID(request[u'destUserName'])], i, count)
  Ind.Increment()
  printKeyValueList([u'Begin', request.get(u'beginDate', u'immediately')])
  printKeyValueList([u'End', request[u'endDate']])
  printKeyValueList([u'Monitor Incoming', request[u'outgoingEmailMonitorLevel']])
  printKeyValueList([u'Monitor Outgoing', request[u'incomingEmailMonitorLevel']])
  printKeyValueList([u'Monitor Chats', request[u'chatMonitorLevel']])
  printKeyValueList([u'Monitor Drafts', request[u'draftMonitorLevel']])
  Ind.Decrement()

# gam audit monitor create <EmailAddress> <DestEmailAddress> [begin <DateTime>] [end <DateTime>] [incoming_headers] [outgoing_headers] [nochats] [nodrafts] [chat_headers] [draft_headers]
def doCreateMonitor():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=True)
  #end_date defaults to 30 days in the future...
  end_date = (GM.Globals[GM.DATETIME_NOW]+datetime.timedelta(days=30)).strftime(YYYYMMDD_HHMM_FORMAT)
  begin_date = None
  incoming_headers_only = outgoing_headers_only = drafts_headers_only = chats_headers_only = False
  drafts = chats = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'begin':
      begin_date = getYYYYMMDD_HHMM()
    elif myarg == u'end':
      end_date = getYYYYMMDD_HHMM()
    elif myarg == u'incomingheaders':
      incoming_headers_only = True
    elif myarg == u'outgoingheaders':
      outgoing_headers_only = True
    elif myarg == u'nochats':
      chats = False
    elif myarg == u'nodrafts':
      drafts = False
    elif myarg == u'chatheaders':
      chats_headers_only = True
    elif myarg == u'draftheaders':
      drafts_headers_only = True
    else:
      unknownArgumentExit()
  try:
    request = callGData(auditObject, u'createEmailMonitor',
                        throw_errors=[GDATA.INVALID_VALUE, GDATA.INVALID_INPUT, GDATA.DOES_NOT_EXIST, GDATA.INVALID_DOMAIN],
                        source_user=parameters[u'auditUserName'], destination_user=parameters[u'auditDestUserName'], end_date=end_date, begin_date=begin_date,
                        incoming_headers_only=incoming_headers_only, outgoing_headers_only=outgoing_headers_only,
                        drafts=drafts, drafts_headers_only=drafts_headers_only, chats=chats, chats_headers_only=chats_headers_only)
    entityActionPerformed([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_MONITOR_REQUEST, None])
    Ind.Increment()
    _showMailboxMonitorRequestStatus(request)
    Ind.Decrement()
  except (GDATA.invalidValue, GDATA.invalidInput) as e:
    entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))
  except (GDATA.doesNotExist, GDATA.invalidDomain) as e:
    if str(e).find(parameters[u'auditUser']) != -1:
      entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
    else:
      entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))

# gam audit monitor delete <EmailAddress> <DestEmailAddress>
def doDeleteMonitor():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=True)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, u'deleteEmailMonitor',
              throw_errors=[GDATA.INVALID_INPUT, GDATA.DOES_NOT_EXIST, GDATA.INVALID_DOMAIN],
              source_user=parameters[u'auditUserName'], destination_user=parameters[u'auditDestUserName'])
    entityActionPerformed([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_MONITOR_REQUEST, parameters[u'auditDestUser']])
  except GDATA.invalidInput as e:
    entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))
  except (GDATA.doesNotExist, GDATA.invalidDomain) as e:
    if str(e).find(parameters[u'auditUser']) != -1:
      entityUnknownWarning(Ent.USER, parameters[u'auditUser'])
    else:
      entityActionFailedWarning([Ent.USER, parameters[u'auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))

# gam audit monitor list <EmailAddress>
def doShowMonitors():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    results = callGData(auditObject, u'getEmailMonitors',
                        throw_errors=[GDATA.DOES_NOT_EXIST, GDATA.INVALID_DOMAIN],
                        user=parameters[u'auditUserName'])
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Ent.USER, parameters[u'auditUser']], jcount, Ent.AUDIT_MONITOR_REQUEST)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      return
    Ind.Increment()
    j = 0
    for request in results:
      j += 1
      _showMailboxMonitorRequestStatus(request, j, jcount)
    Ind.Decrement()
  except (GDATA.doesNotExist, GDATA.invalidDomain):
    entityUnknownWarning(Ent.USER, parameters[u'auditUser'])

# Contact commands utilities
#
CONTACT_JSON = u'JSON'

CONTACT_ID = u'ContactID'
CONTACT_UPDATED = u'Updated'
CONTACT_NAME_PREFIX = u'Name Prefix'
CONTACT_GIVEN_NAME = u'Given Name'
CONTACT_ADDITIONAL_NAME = u'Additional Name'
CONTACT_FAMILY_NAME = u'Family Name'
CONTACT_NAME_SUFFIX = u'Name Suffix'
CONTACT_NAME = u'Name'
CONTACT_NICKNAME = u'Nickname'
CONTACT_MAIDENNAME = u'Maiden Name'
CONTACT_SHORTNAME = u'Short Name'
CONTACT_INITIALS = u'Initials'
CONTACT_BIRTHDAY = u'Birthday'
CONTACT_GENDER = u'Gender'
CONTACT_LOCATION = u'Location'
CONTACT_PRIORITY = u'Priority'
CONTACT_SENSITIVITY = u'Sensitivity'
CONTACT_SUBJECT = u'Subject'
CONTACT_LANGUAGE = u'Language'
CONTACT_NOTES = u'Notes'
CONTACT_OCCUPATION = u'Occupation'
CONTACT_BILLING_INFORMATION = u'Billing Information'
CONTACT_MILEAGE = u'Mileage'
CONTACT_DIRECTORY_SERVER = u'Directory Server'
CONTACT_ADDRESSES = u'Addresses'
CONTACT_CALENDARS = u'Calendars'
CONTACT_EMAILS = u'Emails'
CONTACT_EXTERNALIDS = u'External IDs'
CONTACT_EVENTS = u'Events'
CONTACT_HOBBIES = u'Hobbies'
CONTACT_IMS = u'IMs'
CONTACT_JOTS = u'Jots'
CONTACT_ORGANIZATIONS = u'Organizations'
CONTACT_PHONES = u'Phones'
CONTACT_RELATIONS = u'Relations'
CONTACT_USER_DEFINED_FIELDS = u'User Defined Fields'
CONTACT_WEBSITES = u'Websites'
CONTACT_GROUPS = u'ContactGroups'
CONTACT_GROUPS_LIST = u'ContactGroupsList'
#
CONTACT_GROUP_ID = u'ContactGroupID'
CONTACT_GROUP_UPDATED = u'Updated'
CONTACT_GROUP_NAME = u'ContactGroupName'
#
class ContactsManager(object):
  import gdata.apps.contacts

  CONTACT_ARGUMENT_TO_PROPERTY_MAP = {
    u'json': CONTACT_JSON,
    u'name': CONTACT_NAME,
    u'prefix': CONTACT_NAME_PREFIX,
    u'givenname': CONTACT_GIVEN_NAME,
    u'additionalname': CONTACT_ADDITIONAL_NAME,
    u'familyname': CONTACT_FAMILY_NAME,
    u'firstname': CONTACT_GIVEN_NAME,
    u'middlename': CONTACT_ADDITIONAL_NAME,
    u'lastname': CONTACT_FAMILY_NAME,
    u'suffix': CONTACT_NAME_SUFFIX,
    u'nickname': CONTACT_NICKNAME,
    u'maidenname': CONTACT_MAIDENNAME,
    u'shortname': CONTACT_SHORTNAME,
    u'initials': CONTACT_INITIALS,
    u'birthday': CONTACT_BIRTHDAY,
    u'gender': CONTACT_GENDER,
    u'location': CONTACT_LOCATION,
    u'priority': CONTACT_PRIORITY,
    u'sensitivity': CONTACT_SENSITIVITY,
    u'subject': CONTACT_SUBJECT,
    u'language': CONTACT_LANGUAGE,
    u'note': CONTACT_NOTES,
    u'notes': CONTACT_NOTES,
    u'occupation': CONTACT_OCCUPATION,
    u'billinginfo': CONTACT_BILLING_INFORMATION,
    u'mileage': CONTACT_MILEAGE,
    u'directoryserver': CONTACT_DIRECTORY_SERVER,
    u'address': CONTACT_ADDRESSES,
    u'addresses': CONTACT_ADDRESSES,
    u'calendar': CONTACT_CALENDARS,
    u'calendars': CONTACT_CALENDARS,
    u'email': CONTACT_EMAILS,
    u'emails': CONTACT_EMAILS,
    u'externalid': CONTACT_EXTERNALIDS,
    u'externalids': CONTACT_EXTERNALIDS,
    u'event': CONTACT_EVENTS,
    u'events': CONTACT_EVENTS,
    u'hobby': CONTACT_HOBBIES,
    u'hobbies': CONTACT_HOBBIES,
    u'im': CONTACT_IMS,
    u'ims': CONTACT_IMS,
    u'jot': CONTACT_JOTS,
    u'jots': CONTACT_JOTS,
    u'organization': CONTACT_ORGANIZATIONS,
    u'organizations': CONTACT_ORGANIZATIONS,
    u'phone': CONTACT_PHONES,
    u'phones': CONTACT_PHONES,
    u'relation': CONTACT_RELATIONS,
    u'relations': CONTACT_RELATIONS,
    u'userdefinedfield': CONTACT_USER_DEFINED_FIELDS,
    u'userdefinedfields': CONTACT_USER_DEFINED_FIELDS,
    u'website': CONTACT_WEBSITES,
    u'websites': CONTACT_WEBSITES,
    u'contactgroup': CONTACT_GROUPS,
    u'contactgroups': CONTACT_GROUPS,
    u'updated': CONTACT_UPDATED,
    }

  GENDER_CHOICE_MAP = {u'male': u'male', u'female': u'female',}

  PRIORITY_CHOICE_MAP = {u'low': u'low', u'normal': u'normal', u'high': u'high',}

  SENSITIVITY_CHOICE_MAP = {
    u'confidential': u'confidential',
    u'normal': u'normal',
    u'personal': u'personal',
    u'private': u'private',
    }

  PRIMARY_NOTPRIMARY_CHOICE_MAP = {u'primary': u'true', u'notprimary': u'false',}

  CONTACT_NAME_FIELDS = (
    CONTACT_NAME_PREFIX,
    CONTACT_GIVEN_NAME,
    CONTACT_ADDITIONAL_NAME,
    CONTACT_FAMILY_NAME,
    CONTACT_NAME_SUFFIX,
    )

  ADDRESS_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'home': gdata.apps.contacts.REL_HOME,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  ADDRESS_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_HOME: u'home',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  ADDRESS_ARGUMENT_TO_FIELD_MAP = {
    u'streetaddress': u'street',
    u'pobox': u'pobox',
    u'neighborhood': u'neighborhood',
    u'locality': u'city',
    u'region': u'region',
    u'postalcode': u'postcode',
    u'country': u'country',
    u'formatted': u'value', u'unstructured': u'value',
    }

  ADDRESS_FIELD_TO_ARGUMENT_MAP = {
    u'street': u'streetaddress',
    u'pobox': u'pobox',
    u'neighborhood': u'neighborhood',
    u'city': u'locality',
    u'region': u'region',
    u'postcode': u'postalcode',
    u'country': u'country',
    }

  ADDRESS_FIELD_PRINT_ORDER = [
    u'street',
    u'pobox',
    u'neighborhood',
    u'city',
    u'region',
    u'postcode',
    u'country',
    ]

  CALENDAR_TYPE_ARGUMENT_TO_REL = {
    u'work': u'work',
    u'home': u'home',
    u'free-busy': u'free-busy',
    }

  CALENDAR_REL_TO_TYPE_ARGUMENT = {
    u'work': u'work',
    u'home': u'home',
    u'free-busy': u'free-busy',
    }

  EMAIL_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'home': gdata.apps.contacts.REL_HOME,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  EMAIL_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_HOME: u'home',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  EVENT_TYPE_ARGUMENT_TO_REL = {
    u'anniversary': u'anniversary',
    u'other': u'other',
    }

  EVENT_REL_TO_TYPE_ARGUMENT = {
    u'anniversary': u'anniversary',
    u'other': u'other',
    }

  EXTERNALID_TYPE_ARGUMENT_TO_REL = {
    u'account': u'account',
    u'customer': u'customer',
    u'network': u'network',
    u'organization': u'organization',
    }

  EXTERNALID_REL_TO_TYPE_ARGUMENT = {
    u'account': u'account',
    u'customer': u'customer',
    u'network': u'network',
    u'organization': u'organization',
    }

  IM_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'home': gdata.apps.contacts.REL_HOME,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  IM_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_HOME: u'home',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  IM_PROTOCOL_TO_REL_MAP = {
    u'aim': gdata.apps.contacts.IM_AIM,
    u'gtalk': gdata.apps.contacts.IM_GOOGLE_TALK,
    u'icq': gdata.apps.contacts.IM_ICQ,
    u'jabber': gdata.apps.contacts.IM_JABBER,
    u'msn': gdata.apps.contacts.IM_MSN,
    u'netmeeting': gdata.apps.contacts.IM_NETMEETING,
    u'qq': gdata.apps.contacts.IM_QQ,
    u'skype': gdata.apps.contacts.IM_SKYPE,
    u'xmpp': gdata.apps.contacts.IM_JABBER,
    u'yahoo': gdata.apps.contacts.IM_YAHOO,
    }

  IM_REL_TO_PROTOCOL_MAP = {
    gdata.apps.contacts.IM_AIM: u'aim',
    gdata.apps.contacts.IM_GOOGLE_TALK: u'gtalk',
    gdata.apps.contacts.IM_ICQ: u'icq',
    gdata.apps.contacts.IM_JABBER: u'jabber',
    gdata.apps.contacts.IM_MSN: u'msn',
    gdata.apps.contacts.IM_NETMEETING: u'netmeeting',
    gdata.apps.contacts.IM_QQ: u'qq',
    gdata.apps.contacts.IM_SKYPE: u'skype',
    gdata.apps.contacts.IM_YAHOO: u'yahoo',
    }

  JOT_TYPE_ARGUMENT_TO_REL = {
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'keywords': u'keywords',
    u'user': u'user',
    }

  JOT_REL_TO_TYPE_ARGUMENT = {
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'keywords': u'keywords',
    u'user': u'user',
    }

  ORGANIZATION_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.REL_WORK,
    u'other': gdata.apps.contacts.REL_OTHER,
    }

  ORGANIZATION_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: u'work',
    gdata.apps.contacts.REL_OTHER: u'other',
    }

  ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
    u'location': u'where',
    u'department': u'department',
    u'title': u'title',
    u'jobdescription': u'jobdescription',
    u'symbol': u'symbol',
    }

  ORGANIZATION_FIELD_TO_ARGUMENT_MAP = {
    u'where': u'location',
    u'department': u'department',
    u'title': u'title',
    u'jobdescription': u'jobdescription',
    u'symbol': u'symbol',
    }

  ORGANIZATION_FIELD_PRINT_ORDER = [
    u'where',
    u'department',
    u'title',
    u'jobdescription',
    u'symbol',
    ]

  PHONE_TYPE_ARGUMENT_TO_REL = {
    u'work': gdata.apps.contacts.PHONE_WORK,
    u'home': gdata.apps.contacts.PHONE_HOME,
    u'other': gdata.apps.contacts.PHONE_OTHER,
    u'fax': gdata.apps.contacts.PHONE_HOME_FAX,
    u'home_fax': gdata.apps.contacts.PHONE_HOME_FAX,
    u'work_fax': gdata.apps.contacts.PHONE_WORK_FAX,
    u'other_fax': gdata.apps.contacts.PHONE_OTHER_FAX,
    u'main': gdata.apps.contacts.PHONE_MAIN,
    u'company_main': gdata.apps.contacts.PHONE_COMPANY_MAIN,
    u'assistant': gdata.apps.contacts.PHONE_ASSISTANT,
    u'mobile': gdata.apps.contacts.PHONE_MOBILE,
    u'work_mobile': gdata.apps.contacts.PHONE_WORK_MOBILE,
    u'pager': gdata.apps.contacts.PHONE_PAGER,
    u'work_pager': gdata.apps.contacts.PHONE_WORK_PAGER,
    u'car': gdata.apps.contacts.PHONE_CAR,
    u'radio': gdata.apps.contacts.PHONE_RADIO,
    u'callback': gdata.apps.contacts.PHONE_CALLBACK,
    u'isdn': gdata.apps.contacts.PHONE_ISDN,
    u'telex': gdata.apps.contacts.PHONE_TELEX,
    u'tty_tdd': gdata.apps.contacts.PHONE_TTY_TDD,
    }

  PHONE_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.PHONE_WORK: u'work',
    gdata.apps.contacts.PHONE_HOME: u'home',
    gdata.apps.contacts.PHONE_OTHER: u'other',
    gdata.apps.contacts.PHONE_HOME_FAX: u'fax',
    gdata.apps.contacts.PHONE_HOME_FAX: u'home_fax',
    gdata.apps.contacts.PHONE_WORK_FAX: u'work_fax',
    gdata.apps.contacts.PHONE_OTHER_FAX: u'other_fax',
    gdata.apps.contacts.PHONE_MAIN: u'main',
    gdata.apps.contacts.PHONE_COMPANY_MAIN: u'company_main',
    gdata.apps.contacts.PHONE_ASSISTANT: u'assistant',
    gdata.apps.contacts.PHONE_MOBILE: u'mobile',
    gdata.apps.contacts.PHONE_WORK_MOBILE: u'work_mobile',
    gdata.apps.contacts.PHONE_PAGER: u'pager',
    gdata.apps.contacts.PHONE_WORK_PAGER: u'work_pager',
    gdata.apps.contacts.PHONE_CAR: u'car',
    gdata.apps.contacts.PHONE_RADIO: u'radio',
    gdata.apps.contacts.PHONE_CALLBACK: u'callback',
    gdata.apps.contacts.PHONE_ISDN: u'isdn',
    gdata.apps.contacts.PHONE_TELEX: u'telex',
    gdata.apps.contacts.PHONE_TTY_TDD: u'tty_tdd',
    }

  RELATION_TYPE_ARGUMENT_TO_REL = {
    u'spouse': u'spouse',
    u'child': u'child',
    u'mother': u'mother',
    u'father': u'father',
    u'parent': u'parent',
    u'brother': u'brother',
    u'sister': u'sister',
    u'friend': u'friend',
    u'relative': u'relative',
    u'manager': u'manager',
    u'assistant': u'assistant',
    u'referredby': u'referred-by',
    u'partner': u'partner',
    u'domesticpartner': u'domestic-partner',
    }

  RELATION_REL_TO_TYPE_ARGUMENT = {
    u'spouse' : u'spouse',
    u'child' : u'child',
    u'mother' : u'mother',
    u'father' : u'father',
    u'parent' : u'parent',
    u'brother' : u'brother',
    u'sister' : u'sister',
    u'friend' : u'friend',
    u'relative' : u'relative',
    u'manager' : u'manager',
    u'assistant' : u'assistant',
    u'referred-by' : u'referred_by',
    u'partner' : u'partner',
    u'domestic-partner' : u'domestic_partner',
    }

  WEBSITE_TYPE_ARGUMENT_TO_REL = {
    u'home-page': u'home-page',
    u'blog': u'blog',
    u'profile': u'profile',
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'ftp': u'ftp',
    u'reservations': u'reservations',
    u'app-install-page': u'app-install-page',
    }

  WEBSITE_REL_TO_TYPE_ARGUMENT = {
    u'home-page': u'home-page',
    u'blog': u'blog',
    u'profile': u'profile',
    u'work': u'work',
    u'home': u'home',
    u'other': u'other',
    u'ftp': u'ftp',
    u'reservations': u'reservations',
    u'app-install-page': u'app-install-page',
    }

  CONTACT_NAME_PROPERTY_PRINT_ORDER = [
    CONTACT_UPDATED,
    CONTACT_NAME,
    CONTACT_NAME_PREFIX,
    CONTACT_GIVEN_NAME,
    CONTACT_ADDITIONAL_NAME,
    CONTACT_FAMILY_NAME,
    CONTACT_NAME_SUFFIX,
    CONTACT_NICKNAME,
    CONTACT_MAIDENNAME,
    CONTACT_SHORTNAME,
    CONTACT_INITIALS,
    CONTACT_BIRTHDAY,
    CONTACT_GENDER,
    CONTACT_LOCATION,
    CONTACT_PRIORITY,
    CONTACT_SENSITIVITY,
    CONTACT_SUBJECT,
    CONTACT_LANGUAGE,
    CONTACT_NOTES,
    CONTACT_OCCUPATION,
    CONTACT_BILLING_INFORMATION,
    CONTACT_MILEAGE,
    CONTACT_DIRECTORY_SERVER,
    ]

  CONTACT_ARRAY_PROPERTY_PRINT_ORDER = [
    CONTACT_ADDRESSES,
    CONTACT_EMAILS,
    CONTACT_IMS,
    CONTACT_PHONES,
    CONTACT_CALENDARS,
    CONTACT_ORGANIZATIONS,
    CONTACT_EXTERNALIDS,
    CONTACT_EVENTS,
    CONTACT_HOBBIES,
    CONTACT_JOTS,
    CONTACT_RELATIONS,
    CONTACT_WEBSITES,
    CONTACT_USER_DEFINED_FIELDS,
    ]

  CONTACT_ARRAY_PROPERTIES = {
    CONTACT_ADDRESSES: {u'relMap': ADDRESS_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'formatted', u'primary': True},
    CONTACT_EMAILS: {u'relMap': EMAIL_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'address', u'primary': True},
    CONTACT_IMS: {u'relMap': IM_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'address', u'primary': True},
    CONTACT_PHONES: {u'relMap': PHONE_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': True},
    CONTACT_CALENDARS: {u'relMap': CALENDAR_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'address', u'primary': True},
    CONTACT_ORGANIZATIONS: {u'relMap': ORGANIZATION_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'name', u'primary': True},
    CONTACT_EXTERNALIDS: {u'relMap': EXTERNALID_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': False},
    CONTACT_EVENTS: {u'relMap': EVENT_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'date', u'primary': False},
    CONTACT_HOBBIES: {u'relMap': None, u'infoTitle': u'value', u'primary': False},
    CONTACT_JOTS: {u'relMap': JOT_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': False},
    CONTACT_RELATIONS: {u'relMap': RELATION_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': False},
    CONTACT_USER_DEFINED_FIELDS: {u'relMap': None, u'infoTitle': u'value', u'primary': False},
    CONTACT_WEBSITES: {u'relMap': WEBSITE_REL_TO_TYPE_ARGUMENT, u'infoTitle': u'value', u'primary': True},
    }

  CONTACT_GROUP_ARGUMENT_TO_PROPERTY_MAP = {
    u'json': CONTACT_JSON,
    u'name': CONTACT_GROUP_NAME,
    }

  @staticmethod
  def GetContactShortId(contactEntry):
    full_id = str(contactEntry.id.text)
    return full_id[full_id.rfind(u'/')+1:]

  @staticmethod
  def GetContactFields(entityType):

    fields = {}

    def CheckClearFieldsList(fieldName):
      if checkArgumentPresent(Cmd.CLEAR_NONE_ARGUMENT):
        fields.pop(fieldName, None)
        fields[fieldName] = []
        return True
      return False

    def InitArrayItem(choices):
      item = {}
      rel = getChoice(choices, mapChoice=True, defaultChoice=None)
      if rel:
        item[u'rel'] = rel
        item[u'label'] = None
      else:
        item[u'rel'] = None
        item[u'label'] = getString(Cmd.OB_STRING)
      return item

    def AppendItemToFieldsList(fieldName, fieldValue, checkBlankField=None):
      fields.setdefault(fieldName, [])
      if checkBlankField is None or fieldValue[checkBlankField]:
        fields[fieldName].append(fieldValue)

    while Cmd.ArgumentsRemaining():
      fieldName = getChoice(ContactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP, mapChoice=True)
      if fieldName == CONTACT_JSON:
        fields.update(getJSON([u'ContactID',]))
      elif fieldName == CONTACT_BIRTHDAY:
        fields[fieldName] = getYYYYMMDD(minLen=0)
      elif fieldName == CONTACT_GENDER:
        fields[fieldName] = getChoice(ContactsManager.GENDER_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_PRIORITY:
        fields[fieldName] = getChoice(ContactsManager.PRIORITY_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_SENSITIVITY:
        fields[fieldName] = getChoice(ContactsManager.SENSITIVITY_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_LANGUAGE:
        fields[fieldName] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
      elif fieldName == CONTACT_NOTES:
        if checkArgumentPresent(u'file'):
          filename = getString(Cmd.OB_FILE_NAME)
          encoding = getCharSet()
          fields[fieldName] = readFile(filename, encoding=encoding)
        else:
          fields[fieldName] = getStringWithCRsNLs()
      elif fieldName == CONTACT_ADDRESSES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.ADDRESS_TYPE_ARGUMENT_TO_REL)
        entry[u'primary'] = u'false'
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in ContactsManager.ADDRESS_ARGUMENT_TO_FIELD_MAP:
            value = getString(Cmd.OB_STRING, minLen=0)
            if value:
              entry[ContactsManager.ADDRESS_ARGUMENT_TO_FIELD_MAP[argument]] = value.replace(u'\\n', u'\n')
          elif argument in ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP:
            entry[u'primary'] = ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP[argument]
            break
          else:
            unknownArgumentExit()
        AppendItemToFieldsList(fieldName, entry)
      elif fieldName == CONTACT_CALENDARS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.CALENDAR_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_EMAILS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.EMAIL_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getEmailAddress(noUid=True, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_EVENTS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.EVENT_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getYYYYMMDD(minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_EXTERNALIDS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.EXTERNALID_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_HOBBIES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = {u'value': getString(Cmd.OB_STRING, minLen=0)}
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_IMS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.IM_TYPE_ARGUMENT_TO_REL)
        entry[u'protocol'] = getChoice(ContactsManager.IM_PROTOCOL_TO_REL_MAP, mapChoice=True)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_JOTS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = {u'rel': getChoice(ContactsManager.JOT_TYPE_ARGUMENT_TO_REL, mapChoice=True)}
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_ORGANIZATIONS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.ORGANIZATION_TYPE_ARGUMENT_TO_REL)
        entry[u'primary'] = u'false'
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in ContactsManager.ORGANIZATION_ARGUMENT_TO_FIELD_MAP:
            value = getString(Cmd.OB_STRING, minLen=0)
            if value:
              entry[ContactsManager.ORGANIZATION_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif argument in ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP:
            entry[u'primary'] = ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP[argument]
            break
          else:
            unknownArgumentExit()
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_PHONES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.PHONE_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_RELATIONS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.RELATION_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_USER_DEFINED_FIELDS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = {u'rel': getString(Cmd.OB_STRING, minLen=0), u'value': getString(Cmd.OB_STRING, minLen=0)}
        if not entry[u'rel'] or entry[u'rel'].lower() == u'none':
          entry[u'rel'] = None
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_WEBSITES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.WEBSITE_TYPE_ARGUMENT_TO_REL)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        entry[u'primary'] = getChoice(ContactsManager.PRIMARY_NOTPRIMARY_CHOICE_MAP, mapChoice=True)
        AppendItemToFieldsList(fieldName, entry, u'value')
      elif fieldName == CONTACT_GROUPS:
        if entityType != Ent.USER:
          Cmd.Backup()
          unknownArgumentExit()
        AppendItemToFieldsList(CONTACT_GROUPS_LIST, getString(Cmd.OB_STRING))
      else:
        fields[fieldName] = getString(Cmd.OB_STRING, minLen=0)
    return fields

  @staticmethod
  def FieldsToContact(fields):
    import gdata.apps.contacts

    def GetField(fieldName):
      return fields.get(fieldName)

    def SetClassAttribute(value, fieldClass, processNLs, attr):
      if value:
        if processNLs:
          value = value.replace(u'\\n', u'\n')
        if attr == u'text':
          return fieldClass(text=value)
        if attr == u'code':
          return fieldClass(code=value)
        if attr == u'rel':
          return fieldClass(rel=value)
        if attr == u'value':
          return fieldClass(value=value)
        if attr == u'value_string':
          return fieldClass(value_string=value)
        if attr == u'when':
          return fieldClass(when=value)
      return None

    def GetContactField(fieldName, fieldClass, processNLs=False, attr=u'text'):
      return SetClassAttribute(fields.get(fieldName), fieldClass, processNLs, attr)

    def GetListEntryField(entry, fieldName, fieldClass, processNLs=False, attr=u'text'):
      return SetClassAttribute(entry.get(fieldName), fieldClass, processNLs, attr)

    contactEntry = gdata.apps.contacts.ContactEntry()
    value = GetField(CONTACT_NAME)
    if not value:
      value = u' '.join([fields[fieldName] for fieldName in ContactsManager.CONTACT_NAME_FIELDS if fieldName in fields])
    contactEntry.name = gdata.apps.contacts.Name(full_name=gdata.apps.contacts.FullName(text=value))
    contactEntry.name.name_prefix = GetContactField(CONTACT_NAME_PREFIX, gdata.apps.contacts.NamePrefix)
    contactEntry.name.given_name = GetContactField(CONTACT_GIVEN_NAME, gdata.apps.contacts.GivenName)
    contactEntry.name.additional_name = GetContactField(CONTACT_ADDITIONAL_NAME, gdata.apps.contacts.AdditionalName)
    contactEntry.name.family_name = GetContactField(CONTACT_FAMILY_NAME, gdata.apps.contacts.FamilyName)
    contactEntry.name.name_suffix = GetContactField(CONTACT_NAME_SUFFIX, gdata.apps.contacts.NameSuffix)
    contactEntry.nickname = GetContactField(CONTACT_NICKNAME, gdata.apps.contacts.Nickname)
    contactEntry.maidenName = GetContactField(CONTACT_MAIDENNAME, gdata.apps.contacts.MaidenName)
    contactEntry.shortName = GetContactField(CONTACT_SHORTNAME, gdata.apps.contacts.ShortName)
    contactEntry.initials = GetContactField(CONTACT_INITIALS, gdata.apps.contacts.Initials)
    contactEntry.birthday = GetContactField(CONTACT_BIRTHDAY, gdata.apps.contacts.Birthday, attr=u'when')
    contactEntry.gender = GetContactField(CONTACT_GENDER, gdata.apps.contacts.Gender, attr=u'value')
    contactEntry.where = GetContactField(CONTACT_LOCATION, gdata.apps.contacts.Where, attr=u'value_string')
    contactEntry.priority = GetContactField(CONTACT_PRIORITY, gdata.apps.contacts.Priority, attr=u'rel')
    contactEntry.sensitivity = GetContactField(CONTACT_SENSITIVITY, gdata.apps.contacts.Sensitivity, attr=u'rel')
    contactEntry.subject = GetContactField(CONTACT_SUBJECT, gdata.apps.contacts.Subject)
    contactEntry.language = GetContactField(CONTACT_LANGUAGE, gdata.apps.contacts.Language, attr=u'code')
    contactEntry.content = GetContactField(CONTACT_NOTES, gdata.apps.contacts.Content, processNLs=True)
    contactEntry.occupation = GetContactField(CONTACT_OCCUPATION, gdata.apps.contacts.Occupation)
    contactEntry.billingInformation = GetContactField(CONTACT_BILLING_INFORMATION, gdata.apps.contacts.BillingInformation, processNLs=True)
    contactEntry.mileage = GetContactField(CONTACT_MILEAGE, gdata.apps.contacts.Mileage)
    contactEntry.directoryServer = GetContactField(CONTACT_DIRECTORY_SERVER, gdata.apps.contacts.DirectoryServer)
    value = GetField(CONTACT_ADDRESSES)
    if value:
      for address in value:
        street = GetListEntryField(address, u'street', gdata.apps.contacts.Street)
        pobox = GetListEntryField(address, u'pobox', gdata.apps.contacts.PoBox)
        neighborhood = GetListEntryField(address, u'neighborhood', gdata.apps.contacts.Neighborhood)
        city = GetListEntryField(address, u'city', gdata.apps.contacts.City)
        region = GetListEntryField(address, u'region', gdata.apps.contacts.Region)
        postcode = GetListEntryField(address, u'postcode', gdata.apps.contacts.Postcode)
        country = GetListEntryField(address, u'country', gdata.apps.contacts.Country)
        formatted_address = GetListEntryField(address, u'value', gdata.apps.contacts.FormattedAddress, processNLs=True)
        contactEntry.structuredPostalAddress.append(gdata.apps.contacts.StructuredPostalAddress(street=street, pobox=pobox, neighborhood=neighborhood,
                                                                                                city=city, region=region,
                                                                                                postcode=postcode, country=country,
                                                                                                formatted_address=formatted_address,
                                                                                                rel=address[u'rel'], label=address[u'label'], primary=address[u'primary']))
    value = GetField(CONTACT_CALENDARS)
    if value:
      for calendarLink in value:
        contactEntry.calendarLink.append(gdata.apps.contacts.CalendarLink(href=calendarLink[u'value'], rel=calendarLink[u'rel'], label=calendarLink[u'label'], primary=calendarLink[u'primary']))
    value = GetField(CONTACT_EMAILS)
    if value:
      for emailaddr in value:
        contactEntry.email.append(gdata.apps.contacts.Email(address=emailaddr[u'value'], rel=emailaddr[u'rel'], label=emailaddr[u'label'], primary=emailaddr[u'primary']))
    value = GetField(CONTACT_EXTERNALIDS)
    if value:
      for externalid in value:
        contactEntry.externalId.append(gdata.apps.contacts.ExternalId(value=externalid[u'value'], rel=externalid[u'rel'], label=externalid[u'label']))
    value = GetField(CONTACT_EVENTS)
    if value:
      for event in value:
        contactEntry.event.append(gdata.apps.contacts.Event(rel=event[u'rel'], label=event[u'label'],
                                                            when=gdata.apps.contacts.When(startTime=event[u'value'])))
    value = GetField(CONTACT_HOBBIES)
    if value:
      for hobby in value:
        contactEntry.hobby.append(gdata.apps.contacts.Hobby(text=hobby[u'value']))
    value = GetField(CONTACT_IMS)
    if value:
      for im in value:
        contactEntry.im.append(gdata.apps.contacts.IM(address=im[u'value'], protocol=im[u'protocol'], rel=im[u'rel'], label=im[u'label'], primary=im[u'primary']))
    value = GetField(CONTACT_JOTS)
    if value:
      for jot in value:
        contactEntry.jot.append(gdata.apps.contacts.Jot(text=jot[u'value'], rel=jot[u'rel']))
    value = GetField(CONTACT_ORGANIZATIONS)
    if value:
      for organization in value:
        org_name = gdata.apps.contacts.OrgName(text=organization[u'value'])
        department = GetListEntryField(organization, u'department', gdata.apps.contacts.OrgDepartment)
        title = GetListEntryField(organization, u'title', gdata.apps.contacts.OrgTitle)
        job_description = GetListEntryField(organization, u'jobdescription', gdata.apps.contacts.OrgJobDescription)
        symbol = GetListEntryField(organization, u'symbol', gdata.apps.contacts.OrgSymbol)
        where = GetListEntryField(organization, u'where', gdata.apps.contacts.Where, attr=u'value_string')
        contactEntry.organization.append(gdata.apps.contacts.Organization(name=org_name, department=department,
                                                                          title=title, job_description=job_description,
                                                                          symbol=symbol, where=where,
                                                                          rel=organization[u'rel'], label=organization[u'label'], primary=organization[u'primary']))
    value = GetField(CONTACT_PHONES)
    if value:
      for phone in value:
        contactEntry.phoneNumber.append(gdata.apps.contacts.PhoneNumber(text=phone[u'value'], rel=phone[u'rel'], label=phone[u'label'], primary=phone[u'primary']))
    value = GetField(CONTACT_RELATIONS)
    if value:
      for relation in value:
        contactEntry.relation.append(gdata.apps.contacts.Relation(text=relation[u'value'], rel=relation[u'rel'], label=relation[u'label']))
    value = GetField(CONTACT_USER_DEFINED_FIELDS)
    if value:
      for userdefinedfield in value:
        contactEntry.userDefinedField.append(gdata.apps.contacts.UserDefinedField(key=userdefinedfield[u'rel'], value=userdefinedfield[u'value']))
    value = GetField(CONTACT_WEBSITES)
    if value:
      for website in value:
        contactEntry.website.append(gdata.apps.contacts.Website(href=website[u'value'], rel=website[u'rel'], label=website[u'label'], primary=website[u'primary']))
    return contactEntry

  @staticmethod
  def AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user):
    import gdata.apps.contacts

    contactEntry.groupMembershipInfo = []
    for groupId in contactGroupsList:
      if groupId != u'clear':
        contactEntry.groupMembershipInfo.append(gdata.apps.contacts.GroupMembershipInfo(deleted=u'false',
                                                                                        href=contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)))
      else:
        contactEntry.groupMembershipInfo = []

  @staticmethod
  def ContactToFields(contactEntry):
    fields = {}

    def GetContactField(fieldName, attrlist):
      objAttr = contactEntry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = str(objAttr)

    def GetListEntryField(entry, attrlist):
      objAttr = entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return None
      return str(objAttr)

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)

    fields[CONTACT_ID] = ContactsManager.GetContactShortId(contactEntry)
    GetContactField(CONTACT_UPDATED, [u'updated', u'text'])
    if not contactEntry.deleted:
      GetContactField(CONTACT_NAME, [u'title', u'text'])
    else:
      fields[CONTACT_NAME] = u'Deleted'
    GetContactField(CONTACT_NAME_PREFIX, [u'name', u'name_prefix', u'text'])
    GetContactField(CONTACT_GIVEN_NAME, [u'name', u'given_name', u'text'])
    GetContactField(CONTACT_ADDITIONAL_NAME, [u'name', u'additional_name', u'text'])
    GetContactField(CONTACT_FAMILY_NAME, [u'name', u'family_name', u'text'])
    GetContactField(CONTACT_NAME_SUFFIX, [u'name', u'name_suffix', u'text'])
    GetContactField(CONTACT_NICKNAME, [u'nickname', u'text'])
    GetContactField(CONTACT_MAIDENNAME, [u'maidenName', u'text'])
    GetContactField(CONTACT_SHORTNAME, [u'shortName', u'text'])
    GetContactField(CONTACT_INITIALS, [u'initials', u'text'])
    GetContactField(CONTACT_BIRTHDAY, [u'birthday', u'when'])
    GetContactField(CONTACT_GENDER, [u'gender', u'value'])
    GetContactField(CONTACT_SUBJECT, [u'subject', u'text'])
    GetContactField(CONTACT_LANGUAGE, [u'language', u'code'])
    GetContactField(CONTACT_PRIORITY, [u'priority', u'rel'])
    GetContactField(CONTACT_SENSITIVITY, [u'sensitivity', u'rel'])
    GetContactField(CONTACT_NOTES, [u'content', u'text'])
    GetContactField(CONTACT_LOCATION, [u'where', u'value_string'])
    GetContactField(CONTACT_OCCUPATION, [u'occupation', u'text'])
    GetContactField(CONTACT_BILLING_INFORMATION, [u'billingInformation', u'text'])
    GetContactField(CONTACT_MILEAGE, [u'mileage', u'text'])
    GetContactField(CONTACT_DIRECTORY_SERVER, [u'directoryServer', u'text'])
    for address in contactEntry.structuredPostalAddress:
      AppendItemToFieldsList(CONTACT_ADDRESSES,
                             {u'rel': address.rel,
                              u'label': address.label,
                              u'value': GetListEntryField(address, [u'formatted_address', u'text']),
                              u'street': GetListEntryField(address, [u'street', u'text']),
                              u'pobox': GetListEntryField(address, [u'pobox', u'text']),
                              u'neighborhood': GetListEntryField(address, [u'neighborhood', u'text']),
                              u'city': GetListEntryField(address, [u'city', u'text']),
                              u'region': GetListEntryField(address, [u'region', u'text']),
                              u'postcode': GetListEntryField(address, [u'postcode', u'text']),
                              u'country': GetListEntryField(address, [u'country', u'text']),
                              u'primary': address.primary})
    for calendarLink in contactEntry.calendarLink:
      AppendItemToFieldsList(CONTACT_CALENDARS,
                             {u'rel': calendarLink.rel,
                              u'label': calendarLink.label,
                              u'value': calendarLink.href,
                              u'primary': calendarLink.primary})
    for emailaddr in contactEntry.email:
      AppendItemToFieldsList(CONTACT_EMAILS,
                             {u'rel': emailaddr.rel,
                              u'label': emailaddr.label,
                              u'value': emailaddr.address,
                              u'primary': emailaddr.primary})
    for externalid in contactEntry.externalId:
      AppendItemToFieldsList(CONTACT_EXTERNALIDS,
                             {u'rel': externalid.rel,
                              u'label': externalid.label,
                              u'value': externalid.value})
    for event in contactEntry.event:
      AppendItemToFieldsList(CONTACT_EVENTS,
                             {u'rel': event.rel,
                              u'label': event.label,
                              u'value': GetListEntryField(event, [u'when', u'startTime'])})
    for hobby in contactEntry.hobby:
      AppendItemToFieldsList(CONTACT_HOBBIES,
                             {u'value': hobby.text})
    for im in contactEntry.im:
      AppendItemToFieldsList(CONTACT_IMS,
                             {u'rel': im.rel,
                              u'label': im.label,
                              u'value': im.address,
                              u'protocol': im.protocol,
                              u'primary': im.primary})
    for jot in contactEntry.jot:
      AppendItemToFieldsList(CONTACT_JOTS,
                             {u'rel': jot.rel,
                              u'value': jot.text})
    for organization in contactEntry.organization:
      AppendItemToFieldsList(CONTACT_ORGANIZATIONS,
                             {u'rel': organization.rel,
                              u'label': organization.label,
                              u'value': GetListEntryField(organization, [u'name', u'text']),
                              u'department': GetListEntryField(organization, [u'department', u'text']),
                              u'title': GetListEntryField(organization, [u'title', u'text']),
                              u'symbol': GetListEntryField(organization, [u'symbol', u'text']),
                              u'jobdescription': GetListEntryField(organization, [u'job_description', u'text']),
                              u'where': GetListEntryField(organization, [u'where', u'value_string']),
                              u'primary': organization.primary})
    for phone in contactEntry.phoneNumber:
      AppendItemToFieldsList(CONTACT_PHONES,
                             {u'rel': phone.rel,
                              u'label': phone.label,
                              u'value': phone.text,
                              u'primary': phone.primary})
    for relation in contactEntry.relation:
      AppendItemToFieldsList(CONTACT_RELATIONS,
                             {u'rel': relation.rel,
                              u'label': relation.label,
                              u'value': relation.text})
    for userdefinedfield in contactEntry.userDefinedField:
      AppendItemToFieldsList(CONTACT_USER_DEFINED_FIELDS,
                             {u'rel': userdefinedfield.key,
                              u'value': userdefinedfield.value})
    for website in contactEntry.website:
      AppendItemToFieldsList(CONTACT_WEBSITES,
                             {u'rel': website.rel,
                              u'label': website.label,
                              u'value': website.href,
                              u'primary': website.primary})
    for group in contactEntry.groupMembershipInfo:
      AppendItemToFieldsList(CONTACT_GROUPS, group.href[group.href.rfind(u'/')+1:])
    return fields

  @staticmethod
  def GetContactGroupFields():

    fields = {}
    while Cmd.ArgumentsRemaining():
      fieldName = getChoice(ContactsManager.CONTACT_GROUP_ARGUMENT_TO_PROPERTY_MAP, mapChoice=True)
      if fieldName == CONTACT_JSON:
        fields.update(getJSON([u'ContactGroupID',]))
      elif fieldName == CONTACT_GROUP_NAME:
        fields[fieldName] = getString(Cmd.OB_STRING)
      else:
        fields[fieldName] = getString(Cmd.OB_STRING, minLen=0)
    if not fields.get(CONTACT_GROUP_NAME):
      missingArgumentExit(u'name')
    return fields

  @staticmethod
  def FieldsToContactGroup(fields):
    import atom
    import gdata.apps.contacts

    groupEntry = gdata.apps.contacts.GroupEntry(title=atom.Title(text=fields[CONTACT_GROUP_NAME]))
    return groupEntry

  @staticmethod
  def ContactGroupToFields(groupEntry):
    fields = {}

    def GetGroupField(fieldName, attrlist):
      objAttr = groupEntry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = str(objAttr)

    fields[CONTACT_GROUP_ID] = ContactsManager.GetContactShortId(groupEntry)
    GetGroupField(CONTACT_GROUP_UPDATED, [u'updated', u'text'])
    if not groupEntry.deleted:
      GetGroupField(CONTACT_GROUP_NAME, [u'title', u'text'])
    else:
      fields[CONTACT_GROUP_NAME] = u'Deleted'
    return fields

CONTACTS_PROJECTION_CHOICE_MAP = {u'basic': u'thin', u'thin': u'thin', u'full': u'full',}
CONTACTS_ORDERBY_CHOICE_MAP = {u'lastmodified': u'lastmodified',}

def normalizeContactId(contactId):
  if contactId.startswith(u'id:'):
    return contactId[3:]
  return contactId

def _initContactQueryAttributes():
  return {u'query': None, u'projection': u'full', u'url_params': {u'max-results': str(GC.Values[GC.CONTACT_MAX_RESULTS])},
          u'contactGroup': None, u'group': None, u'emailMatchPattern': None, u'emailMatchType': None}

def _getContactQueryAttributes(contactQuery, myarg, entityType, errorOnUnknown, allowOutputAttributes):
  if myarg == u'query':
    contactQuery[u'query'] = getString(Cmd.OB_QUERY)
  elif myarg == u'contactgroup':
    if entityType == Ent.USER:
      contactQuery[u'contactGroup'] = getString(Cmd.OB_CONTACT_GROUP_ITEM)
    else:
      unknownArgumentExit()
  elif myarg == u'emailmatchpattern':
    contactQuery[u'emailMatchPattern'] = getREPattern(re.IGNORECASE)
  elif myarg == u'emailmatchtype':
    contactQuery[u'emailMatchType'] = getString(Cmd.OB_CONTACT_EMAIL_TYPE)
  elif myarg == u'updatedmin':
    contactQuery[u'url_params'][u'updated-min'] = getYYYYMMDD()
  elif myarg == u'endquery':
    return False
  elif not allowOutputAttributes:
    if errorOnUnknown:
      unknownArgumentExit()
    Cmd.Backup()
    return False
  elif myarg == u'orderby':
    contactQuery[u'url_params'][u'orderby'] = getChoice(CONTACTS_ORDERBY_CHOICE_MAP, mapChoice=True)
    contactQuery[u'url_params'][u'sortorder'] = getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ascending')
  elif myarg in CONTACTS_PROJECTION_CHOICE_MAP:
    contactQuery[u'projection'] = CONTACTS_PROJECTION_CHOICE_MAP[myarg]
  elif myarg == u'showdeleted':
    contactQuery[u'url_params'][u'showdeleted'] = u'true'
  else:
    if errorOnUnknown:
      unknownArgumentExit()
    Cmd.Backup()
    return False
  return True

def _getContactEntityList(entityType, errorOnUnknown, allowOutputAttributes):
  contactQuery = _initContactQueryAttributes()
  if peekArgumentPresent([u'query', u'contactgroup', u'emailmatchpattern', u'updatedmin']):
    entityList = None
    queriedContacts = True
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if not _getContactQueryAttributes(contactQuery, myarg, entityType, errorOnUnknown, allowOutputAttributes):
        break
  else:
    entityList = getEntityList(Cmd.OB_CONTACT_ENTITY)
    queriedContacts = False
    if errorOnUnknown:
      checkForExtraneousArguments()
  return (entityList, entityList if isinstance(entityList, dict) else None, contactQuery, queriedContacts)

def queryContacts(contactsObject, contactQuery, entityType, user, i=0, count=0):
  if contactQuery[u'query'] or contactQuery[u'group']:
    uri = getContactsQuery(feed=contactsObject.GetContactFeedUri(contact_list=user, projection=contactQuery[u'projection']),
                           text_query=contactQuery[u'query'], group=contactQuery[u'group']).ToUri()
  else:
    uri = contactsObject.GetContactFeedUri(contact_list=user, projection=contactQuery[u'projection'])
  printGettingAllEntityItemsForWhom(Ent.CONTACT, user, i, count, query=contactQuery[u'query'])
  try:
    entityList = callGDataPages(contactsObject, u'GetContactsFeed',
                                page_message=getPageMessage(),
                                throw_errors=[GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                                retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                                uri=uri, url_params=contactQuery[u'url_params'])
    return entityList
  except GDATA.badRequest as e:
    entityActionFailedWarning([entityType, user, Ent.CONTACT, u''], str(e), i, count)
  except GDATA.forbidden:
    entityServiceNotApplicableWarning(entityType, user, i, count)
  except GDATA.serviceNotApplicable:
    entityUnknownWarning(entityType, user, i, count)
  return None

def contactEmailAddressMatches(contactsManager, contactQuery, fields):
  emailMatchType = contactQuery[u'emailMatchType']
  for item in fields.get(CONTACT_EMAILS, []):
    if contactQuery[u'emailMatchPattern'].match(item[u'value']):
      if not emailMatchType or emailMatchType == item.get(u'label') or emailMatchType == contactsManager.CONTACT_ARRAY_PROPERTIES[CONTACT_EMAILS][u'relMap'].get(item[u'rel'], u'custom'):
        return True
  return False

def getContactGroupsInfo(contactsManager, contactsObject, entityType, entityName, i, count):
  uri = contactsObject.GetContactGroupFeedUri(contact_list=entityName)
  contactGroupIDs = {}
  contactGroupNames = {}
  try:
    groups = callGDataPages(contactsObject, u'GetGroupsFeed',
                            throw_errors=[GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                            retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                            uri=uri)
    if groups:
      for group in groups:
        fields = contactsManager.ContactGroupToFields(group)
        contactGroupIDs[fields[CONTACT_GROUP_ID]] = fields[CONTACT_GROUP_NAME]
        contactGroupNames.setdefault(fields[CONTACT_GROUP_NAME], [])
        contactGroupNames[fields[CONTACT_GROUP_NAME]].append(fields[CONTACT_GROUP_ID])
  except GDATA.forbidden:
    entityServiceNotApplicableWarning(entityType, entityName, i, count)
    return (contactGroupIDs, False)
  except GDATA.serviceNotApplicable:
    entityUnknownWarning(entityType, entityName, i, count)
    return (contactGroupIDs, False)
  return (contactGroupIDs, contactGroupNames)

def validateContactGroup(contactsManager, contactsObject, contactGroupName, contactGroupIDs, contactGroupNames, entityType, entityName, i, count):
  if not contactGroupNames:
    contactGroupIDs, contactGroupNames = getContactGroupsInfo(contactsManager, contactsObject, entityType, entityName, i, count)
    if contactGroupNames is False:
      return (None, contactGroupIDs, contactGroupNames)
  if contactGroupName == u'clear':
    return (contactGroupName, contactGroupIDs, contactGroupNames)
  cg = UID_PATTERN.match(contactGroupName)
  if cg:
    if cg.group(1) in contactGroupIDs:
      return (cg.group(1), contactGroupIDs, contactGroupNames)
  else:
    if contactGroupName in contactGroupNames:
      return (contactGroupNames[contactGroupName][0], contactGroupIDs, contactGroupNames)
  return (None, contactGroupIDs, contactGroupNames)

def validateContactGroupsList(contactsManager, contactsObject, contactId, fields, entityType, entityName, i, count):
  result = True
  contactGroupIDs = contactGroupNames = None
  contactGroupsList = []
  for contactGroup in fields[CONTACT_GROUPS_LIST]:
    groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, entityName, i, count)
    if groupId:
      contactGroupsList.append(groupId)
    else:
      if contactGroupNames:
        entityActionNotPerformedWarning([entityType, entityName, Ent.CONTACT, contactId],
                                        Ent.TypeNameMessage(Ent.CONTACT_GROUP, contactGroup, Msg.DOES_NOT_EXIST))
      result = False
  return (result, contactGroupsList)

def _createContact(users, entityType):
  contactsManager = ContactsManager()
  fields = contactsManager.GetContactFields(entityType)
  contactEntry = contactsManager.FieldsToContact(fields)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if fields.get(CONTACT_GROUPS_LIST):
      result, contactGroupsList = validateContactGroupsList(contactsManager, contactsObject, u'', fields, entityType, user, i, count)
      if not result:
        continue
      contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user)
    try:
      contact = callGData(contactsObject, u'CreateContact',
                          throw_errors=[GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                          new_contact=contactEntry, insert_uri=contactsObject.GetContactFeedUri(contact_list=user))
      entityActionPerformed([entityType, user, Ent.CONTACT, contactsManager.GetContactShortId(contact)], i, count)
    except GDATA.badRequest as e:
      entityActionFailedWarning([entityType, user, Ent.CONTACT, u''], str(e), i, count)
    except GDATA.forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GDATA.serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)

# gam <UserTypeEntity> create contact <ContactAttributes>+
def createUserContact(users):
  _createContact(users, Ent.USER)

# gam create contact <ContactAttributes>+
def doCreateDomainContact():
  _createContact([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _updateContacts(users, entityType):
  contactsManager = ContactsManager()
  entityList, contactIdLists, contactQuery, queriedContacts = _getContactEntityList(entityType, False, False)
  update_fields = contactsManager.GetContactFields(entityType)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if contactQuery[u'contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery[u'contactGroup'], None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery[u'contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery[u'group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)
    if queriedContacts:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    contactGroupsList = None
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        if not queriedContacts:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, u'GetContact',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
          fields = contactsManager.ContactToFields(contact)
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
            continue
        if update_fields.get(CONTACT_GROUPS_LIST) and not contactGroupsList:
          result, contactGroupsList = validateContactGroupsList(contactsManager, contactsObject, contactId, update_fields, entityType, user, i, count)
          if not result:
            break
        for field in update_fields:
          fields[field] = update_fields[field]
        contactEntry = contactsManager.FieldsToContact(fields)
        if contactGroupsList:
          contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user)
        elif fields.get(CONTACT_GROUPS):
          contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, fields[CONTACT_GROUPS], user)
        contactEntry.category = contact.category
        contactEntry.link = contact.link
        contactEntry.etag = contact.etag
        contactEntry.id = contact.id
        callGData(contactsObject, u'UpdateContact',
                  throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.PRECONDITION_FAILED, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), updated_contact=contactEntry, extra_headers={u'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT, contactId], j, jcount)
      except (GDATA.notFound, GDATA.badRequest, GDATA.preconditionFailed) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> update contacts <ContactEntity>|([query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>] [endquery]) [contactgroup <ContactGroupItem>] <ContactAttributes>+
def updateUserContacts(users):
  _updateContacts(users, Ent.USER)

# gam update contacts <ContactEntity>|([query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]) <ContactAttributes>+
def doUpdateDomainContacts():
  _updateContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _deleteContacts(users, entityType):
  contactsManager = ContactsManager()
  entityList, contactIdLists, contactQuery, queriedContacts = _getContactEntityList(entityType, True, False)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if contactQuery[u'contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery[u'contactGroup'], None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery[u'contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery[u'group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)
    if queriedContacts:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    j = 0
    jcount = len(entityList)
    entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        if not queriedContacts:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, u'GetContact',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
            continue
        callGData(contactsObject, u'DeleteContact',
                  throw_errors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), extra_headers={u'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT, contactId], j, jcount)
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete contacts <ContactEntity>|([query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>])
def deleteUserContacts(users):
  _deleteContacts(users, Ent.USER)

# gam delete contacts <ContactEntity>|([query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>])
def doDeleteDomainContacts():
  _deleteContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

CONTACT_TIME_OBJECTS = set([CONTACT_UPDATED])
CONTACT_FIELDS_WITH_CRS_NLS = [CONTACT_NOTES, CONTACT_BILLING_INFORMATION]

def _showContact(contactsManager, fields, displayFieldsList, contactGroupIDs, j, jcount, formatJSON):
  if formatJSON:
    printLine(json.dumps(cleanJSON(fields, u'', timeObjects=CONTACT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.CONTACT, fields[CONTACT_ID]], j, jcount)
  Ind.Increment()
  for key in contactsManager.CONTACT_NAME_PROPERTY_PRINT_ORDER:
    if displayFieldsList and key not in displayFieldsList:
      continue
    if key in fields:
      if key in CONTACT_TIME_OBJECTS:
        printKeyValueList([key, formatLocalTime(fields[key])])
      elif key not in CONTACT_FIELDS_WITH_CRS_NLS:
        printKeyValueList([key, fields[key]])
      else:
        printKeyValueWithCRsNLs(key, fields[key])
  for key in contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER:
    if displayFieldsList and key not in displayFieldsList:
      continue
    if key in fields:
      keymap = contactsManager.CONTACT_ARRAY_PROPERTIES[key]
      printKeyValueList([key, None])
      Ind.Increment()
      for item in fields[key]:
        fn = item.get(u'label')
        if keymap[u'relMap']:
          if not fn:
            fn = keymap[u'relMap'].get(item[u'rel'], u'custom')
          printKeyValueList([u'type', fn])
          Ind.Increment()
        if keymap[u'primary']:
          printKeyValueList([u'rank', [u'notprimary', u'primary'][item[u'primary'] == u'true']])
        value = item[u'value']
        if value is None:
          value = u''
        if key == CONTACT_IMS:
          printKeyValueList([u'protocol', contactsManager.IM_REL_TO_PROTOCOL_MAP.get(item[u'protocol'], item[u'protocol'])])
          printKeyValueList([keymap[u'infoTitle'], value])
        elif key == CONTACT_ADDRESSES:
          printKeyValueWithCRsNLs(keymap[u'infoTitle'], value)
          for org_key in contactsManager.ADDRESS_FIELD_PRINT_ORDER:
            if item[org_key]:
              printKeyValueList([contactsManager.ADDRESS_FIELD_TO_ARGUMENT_MAP[org_key], item[org_key]])
        elif key == CONTACT_ORGANIZATIONS:
          printKeyValueList([keymap[u'infoTitle'], value])
          for org_key in contactsManager.ORGANIZATION_FIELD_PRINT_ORDER:
            if item[org_key]:
              printKeyValueList([contactsManager.ORGANIZATION_FIELD_TO_ARGUMENT_MAP[org_key], item[org_key]])
        elif key == CONTACT_USER_DEFINED_FIELDS:
          printKeyValueList([item.get(u'rel') or u'None', value])
        else:
          printKeyValueList([keymap[u'infoTitle'], value])
        if keymap[u'relMap']:
          Ind.Decrement()
      Ind.Decrement()
  if contactGroupIDs is not None and CONTACT_GROUPS in fields:
    printEntitiesCount(Ent.CONTACT_GROUP, None)
    Ind.Increment()
    for group in fields[CONTACT_GROUPS]:
      if group in contactGroupIDs:
        printKeyValueList([contactGroupIDs[group]])
        Ind.Increment()
        printKeyValueList([u'id', group])
        Ind.Decrement()
      else:
        printKeyValueList([u'id', group])
    Ind.Decrement()
  Ind.Decrement()

def _getContactFieldsList(contactsManager, displayFieldsList):
  for field in _getFieldsList():
    if field in contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP:
      displayFieldsList.append(contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP[field])
    else:
      invalidChoiceExit(contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP, True)

def _infoContacts(users, entityType, contactFeed=True):
  contactsManager = ContactsManager()
  entityList = getEntityList(Cmd.OB_CONTACT_ENTITY)
  contactIdLists = entityList if isinstance(entityList, dict) else None
  contactQuery = _initContactQueryAttributes()
  formatJSON = showContactGroups = False
  displayFieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in CONTACTS_PROJECTION_CHOICE_MAP:
      contactQuery[u'projection'] = CONTACTS_PROJECTION_CHOICE_MAP[myarg]
    elif myarg == u'showgroups':
      showContactGroups = True
    elif myarg == u'fields':
      _getContactFieldsList(contactsManager, displayFieldsList)
      if CONTACT_GROUPS in displayFieldsList:
        showContactGroups = True
    elif myarg == u'formatjson':
      formatJSON = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=contactFeed)
    if not contactsObject:
      continue
    contactGroupIDs = None
    j = 0
    jcount = len(entityList)
    if not formatJSON:
      entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        contactId = normalizeContactId(contact)
        contact = callGData(contactsObject, u'GetContact',
                            throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                            retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                            uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId, projection=contactQuery[u'projection']))
        fields = contactsManager.ContactToFields(contact)
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        _showContact(contactsManager, fields, displayFieldsList, [None, contactGroupIDs][showContactGroups], j, jcount, formatJSON)
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> info contacts <ContactEntity> [basic|full] [showgroups]
#	[fields <ContactFieldNameList>] [formatjson]
def infoUserContacts(users):
  _infoContacts(users, Ent.USER)

# gam info contacts <ContactEntity> [basic|full] [showgroups]
#	[fields <ContactFieldNameList>] [formatjson]
def doInfoDomainContacts():
  _infoContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

# gam info gal <GalEntity> [basic|full]
#	[fields <ContactFieldNameList>] [formatjson]
def doInfoGAL():
  _infoContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False)

def _printShowContacts(users, entityType, csvFormat, contactFeed=True):
  contactsManager = ContactsManager()
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Ent.Singular(entityType), CONTACT_ID, CONTACT_NAME])
  contactQuery = _initContactQueryAttributes()
  formatJSON = showContactGroups = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  displayFieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif contactFeed and myarg == u'showgroups':
      showContactGroups = True
    elif myarg == u'fields':
      _getContactFieldsList(contactsManager, displayFieldsList)
      if contactFeed and CONTACT_GROUPS in displayFieldsList:
        showContactGroups = True
    elif myarg == u'formatjson':
      formatJSON = True
      if csvFormat:
        addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      _getContactQueryAttributes(contactQuery, myarg, entityType, True, True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=contactFeed)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    if contactQuery[u'contactGroup']:
      groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery[u'contactGroup'], contactGroupIDs, contactGroupNames, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery[u'contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery[u'group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)
    contacts = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    if contacts is None:
      continue
    jcount = len(contacts)
    if not csvFormat:
      if not formatJSON:
        entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.CONTACT, i, count)
      Ind.Increment()
      j = 0
      for contact in contacts:
        j += 1
        fields = contactsManager.ContactToFields(contact)
        if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
          continue
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        _showContact(contactsManager, fields, displayFieldsList, [None, contactGroupIDs][showContactGroups], j, jcount, formatJSON)
      Ind.Decrement()
    elif contacts:
      for contact in contacts:
        fields = contactsManager.ContactToFields(contact)
        if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
          continue
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        if formatJSON:
          csvRows.append({Ent.Singular(entityType): user, CONTACT_ID: fields[CONTACT_ID], CONTACT_NAME: fields.get(CONTACT_NAME, u''),
                          u'JSON': json.dumps(cleanJSON(fields, u'', timeObjects=CONTACT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
          continue
        contactRow = {Ent.Singular(entityType): user, CONTACT_ID: fields[CONTACT_ID]}
        for key in contactsManager.CONTACT_NAME_PROPERTY_PRINT_ORDER:
          if displayFieldsList and key not in displayFieldsList:
            continue
          if key in fields:
            if key == CONTACT_UPDATED:
              contactRow[key] = formatLocalTime(fields[key])
            elif (key != CONTACT_NOTES) and (key != CONTACT_BILLING_INFORMATION):
              contactRow[key] = fields[key]
            else:
              contactRow[key] = escapeCRsNLs(fields[key])
        for key in contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER:
          if displayFieldsList and key not in displayFieldsList:
            continue
          if key in fields:
            keymap = contactsManager.CONTACT_ARRAY_PROPERTIES[key]
            contactRow[u'{0}.0.count'.format(key)] = len(fields[key])
            j = 0
            for item in fields[key]:
              j += 1
              fn = u'{0}.{1}.'.format(key, j)
              fnt = item.get(u'label')
              if fnt:
                contactRow[fn+u'type'] = fnt
              elif keymap[u'relMap']:
                contactRow[fn+u'type'] = keymap[u'relMap'].get(item[u'rel'], u'custom')
              if keymap[u'primary']:
                contactRow[fn+u'rank'] = [u'notprimary', u'primary'][item[u'primary'] == u'true']
              value = item[u'value']
              if value is None:
                value = u''
              if key == CONTACT_IMS:
                contactRow[fn+u'protocol'] = contactsManager.IM_REL_TO_PROTOCOL_MAP.get(item[u'protocol'], item[u'protocol'])
                contactRow[fn+keymap[u'infoTitle']] = value
              elif key == CONTACT_ADDRESSES:
                contactRow[fn+keymap[u'infoTitle']] = escapeCRsNLs(value)
                for org_key in contactsManager.ADDRESS_FIELD_PRINT_ORDER:
                  if item[org_key]:
                    contactRow[fn+contactsManager.ADDRESS_FIELD_TO_ARGUMENT_MAP[org_key]] = escapeCRsNLs(item[org_key])
              elif key == CONTACT_ORGANIZATIONS:
                contactRow[fn+keymap[u'infoTitle']] = value
                for org_key in contactsManager.ORGANIZATION_FIELD_PRINT_ORDER:
                  if item[org_key]:
                    contactRow[fn+contactsManager.ORGANIZATION_FIELD_TO_ARGUMENT_MAP[org_key]] = item[org_key]
              elif key == CONTACT_USER_DEFINED_FIELDS:
                contactRow[fn+u'type'] = item.get(u'rel') or u'None'
                contactRow[fn+keymap[u'infoTitle']] = value
              else:
                contactRow[fn+keymap[u'infoTitle']] = value
        if showContactGroups and CONTACT_GROUPS in fields:
          contactRow[u'{0}.0.count'.format(CONTACT_GROUPS)] = len(fields[CONTACT_GROUPS])
          j = 0
          for group in fields[CONTACT_GROUPS]:
            j += 1
            fn = u'{0}.{1}.'.format(CONTACT_GROUPS, j)
            contactRow[fn+CONTACT_GROUP_ID] = u'id:{0}'.format(group)
            if group in contactGroupIDs:
              contactRow[fn+CONTACT_GROUP_NAME] = contactGroupIDs[group]
        addRowTitlesToCSVfile(contactRow, csvRows, titles)
    elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and entityType == Ent.USER:
      csvRows.append({Ent.Singular(entityType): user})
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Contacts', todrive, [Ent.Singular(entityType), CONTACT_ID, CONTACT_NAME], quotechar=quotechar)

# gam <UserTypeEntity> print contacts [todrive [<ToDriveAttributes>]] [query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson] [quotechar <Character>]
def printUserContacts(users):
  _printShowContacts(users, Ent.USER, True)

# gam <UserTypeEntity> show contacts [query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson]
def showUserContacts(users):
  _printShowContacts(users, Ent.USER, False)

# gam print contacts [todrive [<ToDriveAttributes>]] [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson] [quotechar <Character>]
def doPrintDomainContacts():
  _printShowContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, True)

# gam show contacts [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson]
def doShowDomainContacts():
  _printShowContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False)

# gam print gal [todrive [<ToDriveAttributes>]] [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson] [quotechar <Character>]
def doPrintGAL():
  _printShowContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, True, False)

# gam show gal [query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson]
def doShowGAL():
  _printShowContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False, False)

def _processContactPhotos(users, entityType, function):
  def _makeFilenameFromPattern():
    filename = filenamePattern[:]
    if subForContactId:
      filename = filename.replace(u'#contactid#', contactId)
    if subForEmail:
      for email in fields.get(u'Emails', []):
        if email.get(u'primary', u'false') == u'true':
          filename = filename.replace(u'#email#', email[u'value'])
          break
      else:
        filename = filename.replace(u'#email#', contactId)
    return filename

  contactsManager = ContactsManager()
  entityList, contactIdLists, contactQuery, queriedContacts = _getContactEntityList(entityType, False, False)
  if function in [u'ChangePhoto', u'GetPhoto']:
    targetFolder = os.getcwd()
    filenamePattern = u'#contactid#.jpg'
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'drivedir':
        targetFolder = GC.Values[GC.DRIVE_DIR]
      elif myarg in [u'sourcefolder', u'targetfolder']:
        targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
        if function == u'GetPhoto' and not os.path.isdir(targetFolder):
          os.makedirs(targetFolder)
      elif myarg == u'filename':
        filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
      else:
        unknownArgumentExit()
    subForContactId = filenamePattern.find(u'#contactid#') != -1
    subForEmail = filenamePattern.find(u'#email#') != -1
    if not subForContactId and not subForEmail:
      filename = filenamePattern
  else: #elif function == u'DeletePhoto':
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=True)
    if not contactsObject:
      continue
    if contactQuery[u'contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery[u'contactGroup'], None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery[u'contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery[u'group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=u'base', groupId=groupId)
    if queriedContacts:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    j = 0
    jcount = len(entityList)
    entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.PHOTO, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        if not queriedContacts:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, u'GetContact',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
          fields = contactsManager.ContactToFields(contact)
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if contactQuery[u'emailMatchPattern'] and not contactEmailAddressMatches(contactsManager, contactQuery, fields):
            continue
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
        break
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
      try:
        if function == u'ChangePhoto':
          if subForContactId or subForEmail:
            filename = _makeFilenameFromPattern()
          callGData(contactsObject, function,
                    throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                    retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                    media=filename, contact_entry_or_url=contact,
                    content_type=u'image/*', content_length=os.path.getsize(filename), extra_headers={u'If-Match': u'*'})
          entityActionPerformed([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], i, count)
        elif function == u'GetPhoto':
          if subForContactId or subForEmail:
            filename = _makeFilenameFromPattern()
          filename = os.path.join(targetFolder, filename)
          photo_data = callGData(contactsObject, function,
                                 throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                                 retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                                 contact_entry_or_url=contact)
          if photo_data:
            status, e = writeFileReturnError(filename, photo_data)
            if status:
              entityActionPerformed([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], i, count)
            else:
              entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], str(e), i, count)
          else:
            entityDoesNotHaveItemWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, u''], i, count)
        else: #elif function == u'DeletePhoto':
          filename = u''
          callGData(contactsObject, function,
                    throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                    retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                    contact_entry_or_url=contact, extra_headers={u'If-Match': u'*'})
          entityActionPerformed([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], i, count)
      except GDATA.notFound as e:
        entityDoesNotHaveItemWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, u''], i, count)
      except (GDATA.badRequest, OSError, IOError) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> update contactphoto <ContactEntity>|([query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]) [drivedir|(sourcefolder <FilePath>)] [filename <FileNamePattern>]
def updateUserContactPhoto(users):
  _processContactPhotos(users, Ent.USER, u'ChangePhoto')

# gam update contactphoto <ContactEntity>|([query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]) [drivedir|(sourcefolder <FilePath>)] [filename <FileNamePattern>]
def doUpdateDomainContactPhoto():
  _processContactPhotos([GC.Values[GC.DOMAIN]], Ent.DOMAIN, u'ChangePhoto')

# gam <UserTypeEntity> get contactphoto <ContactEntity>|([query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]) [drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>]
def getUserContactPhoto(users):
  _processContactPhotos(users, Ent.USER, u'GetPhoto')

# gam get contactphoto <ContactEntity>|([query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>]) [drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>]
def doGetDomainContactPhoto():
  _processContactPhotos([GC.Values[GC.DOMAIN]], Ent.DOMAIN, u'GetPhoto')

# gam <UserTypeEntity> delete contactphotos <ContactEntity>|([query <QueryContact>] [contactgroup <ContactGroupItem>] [emailmatchpattern <RegularExpression>] [updated_min <Date>])
def deleteUserContactPhoto(users):
  _processContactPhotos(users, Ent.USER, u'DeletePhoto')

# gam delete contactphotos <ContactEntity>|([query <QueryContact>] [emailmatchpattern <RegularExpression>] [updated_min <Date>])
def doDeleteDomainContactPhoto():
  _processContactPhotos([GC.Values[GC.DOMAIN]], Ent.DOMAIN, u'DeletePhoto')

# gam <UserTypeEntity> create contactgroup <ContactGroupAttributes>+
def createUserContactGroup(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  fields = contactsManager.GetContactGroupFields()
  contactGroup = contactsManager.FieldsToContactGroup(fields)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    _, contactGroupNames = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
    if contactGroupNames is False:
      continue
    if fields[CONTACT_GROUP_NAME] in contactGroupNames:
      entityActionFailedWarning([entityType, user], Ent.TypeNameMessage(Ent.CONTACT_GROUP_NAME, fields[CONTACT_GROUP_NAME], Msg.DUPLICATE), i, count)
      continue
    try:
      group = callGData(contactsObject, u'CreateGroup',
                        throw_errors=[GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                        retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                        new_group=contactGroup, insert_uri=contactsObject.GetContactGroupFeedUri(contact_list=user))
      entityActionPerformed([entityType, user, Ent.CONTACT_GROUP, contactsManager.GetContactShortId(group)], i, count)
    except GDATA.badRequest as e:
      entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, u''], str(e), i, count)
    except GDATA.forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GDATA.serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)

# gam <UserTypeEntity> update contactgroups <ContactGroupItem> <ContactAttributes>+
def updateUserContactGroup(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  entityList = getStringReturnInList(Cmd.OB_CONTACT_GROUP_ITEM)
  update_fields = contactsManager.GetContactGroupFields()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contactGroup in entityList:
      j += 1
      groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Msg.DOES_NOT_EXIST, j, jcount)
          continue
        break
      if update_fields[CONTACT_GROUP_NAME] in contactGroupNames and groupId not in contactGroupNames[update_fields[CONTACT_GROUP_NAME]]:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Ent.TypeNameMessage(Ent.CONTACT_GROUP_NAME, update_fields[CONTACT_GROUP_NAME], Msg.DUPLICATE), i, count)
        continue
      contactGroup = contactGroupIDs.get(groupId, contactGroup)
      try:
        group = callGData(contactsObject, u'GetGroup',
                          throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        fields = contactsManager.ContactGroupToFields(group)
        for field in update_fields:
          fields[field] = update_fields[field]
        groupEntry = contactsManager.FieldsToContactGroup(fields)
        groupEntry.category = group.category
        groupEntry.link = group.link
        groupEntry.etag = group.etag
        groupEntry.id = group.id
        callGData(contactsObject, u'UpdateGroup',
                  throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId), updated_group=groupEntry, extra_headers={u'If-Match': group.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT_GROUP, contactGroup], j, jcount)
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], str(e), j, jcount)
      except GDATA.forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete contactgroups <ContactGroupEntity>
def deleteUserContactGroups(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  entityList = getEntityList(Cmd.OB_CONTACT_GROUP_ENTITY, shlexSplit=True)
  contactGroupIdLists = entityList if isinstance(entityList, dict) else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactGroupIdLists:
      entityList = contactGroupIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contactGroup in entityList:
      j += 1
      try:
        groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, user, i, count)
        if not groupId:
          if contactGroupNames:
            entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Msg.DOES_NOT_EXIST, j, jcount)
            continue
          break
        contactGroup = contactGroupIDs.get(groupId, contactGroup)
        group = callGData(contactsObject, u'GetGroup',
                          throw_errors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        callGData(contactsObject, u'DeleteGroup',
                  throw_errors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId), extra_headers={u'If-Match': group.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT_GROUP, contactGroup], j, jcount)
      except GDATA.notFound as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], str(e), j, jcount)
      except GDATA.forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

CONTACT_GROUP_TIME_OBJECTS = set([CONTACT_GROUP_UPDATED])

def _showContactGroup(contactsManager, group, j, jcount, formatJSON):
  fields = contactsManager.ContactGroupToFields(group)
  if formatJSON:
    printLine(json.dumps(cleanJSON(fields, u'', timeObjects=CONTACT_GROUP_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.CONTACT_GROUP, fields[CONTACT_GROUP_NAME]], j, jcount)
  Ind.Increment()
  printKeyValueList([u'updated', formatLocalTime(fields[CONTACT_GROUP_UPDATED])])
  printKeyValueList([u'id', fields[CONTACT_GROUP_ID]])
  Ind.Decrement()

# gam <UserTypeEntity> info contactgroups <ContactGroupEntity> [formatjson]
def infoUserContactGroups(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  entityList = getEntityList(Cmd.OB_CONTACT_GROUP_ENTITY, shlexSplit=True)
  contactGroupIdLists = entityList if isinstance(entityList, dict) else None
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'formatjson':
      formatJSON = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactGroupIdLists:
      entityList = contactGroupIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    if not formatJSON:
      entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contactGroup in entityList:
      j += 1
      try:
        groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup, contactGroupIDs, contactGroupNames, entityType, user, i, count)
        if not groupId:
          if contactGroupNames:
            entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Msg.DOES_NOT_EXIST, j, jcount)
            continue
          break
        contactGroup = contactGroupIDs.get(groupId, contactGroup)
        group = callGData(contactsObject, u'GetGroup',
                          throw_errors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        _showContactGroup(contactsManager, group, j, jcount, formatJSON)
      except GDATA.notFound as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], str(e), j, jcount)
      except GDATA.forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

def _printShowContactGroups(users, csvFormat):
  entityType = Ent.USER
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Ent.Singular(entityType), CONTACT_GROUP_ID, CONTACT_GROUP_NAME])
  projection = u'full'
  url_params = {u'max-results': str(GC.Values[GC.CONTACT_MAX_RESULTS])}
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'orderby':
      url_params[u'orderby'] = getChoice(CONTACTS_ORDERBY_CHOICE_MAP, mapChoice=True)
      url_params[u'sortorder'] = getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ascending')
    elif myarg in CONTACTS_PROJECTION_CHOICE_MAP:
      projection = CONTACTS_PROJECTION_CHOICE_MAP[myarg]
    elif myarg == u'showdeleted':
      url_params[u'showdeleted'] = u'true'
    elif myarg == u'updatedmin':
      url_params[u'updated-min'] = getYYYYMMDD()
    elif myarg == u'formatjson':
      formatJSON = True
      if csvFormat:
        addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  contactsManager = ContactsManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    printGettingAllEntityItemsForWhom(Ent.CONTACT_GROUP, user, i, count)
    uri = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=projection)
    try:
      groups = callGDataPages(contactsObject, u'GetGroupsFeed',
                              page_message=getPageMessage(),
                              throw_errors=[GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=uri, url_params=url_params)
      jcount = len(groups)
      if not csvFormat:
        if not formatJSON:
          entityPerformActionNumItems([Ent.USER, user], jcount, Ent.CONTACT_GROUP, i, count)
        Ind.Increment()
        j = 0
        for group in groups:
          j += 1
          _showContactGroup(contactsManager, group, j, jcount, formatJSON)
        Ind.Decrement()
      else:
        if groups:
          for group in groups:
            fields = contactsManager.ContactGroupToFields(group)
            if formatJSON:
              csvRows.append({Ent.Singular(entityType): user, CONTACT_GROUP_ID: u'id:{0}'.format(fields[CONTACT_GROUP_ID]),
                              CONTACT_GROUP_NAME: fields[CONTACT_GROUP_NAME],
                              u'JSON': json.dumps(cleanJSON(fields, u'', timeObjects=CONTACT_GROUP_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
            else:
              addRowTitlesToCSVfile({Ent.Singular(entityType): user, CONTACT_GROUP_ID: u'id:{0}'.format(fields[CONTACT_GROUP_ID]),
                                     CONTACT_GROUP_NAME: fields[CONTACT_GROUP_NAME], CONTACT_GROUP_UPDATED: formatLocalTime(fields[CONTACT_GROUP_UPDATED])}, csvRows, titles)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and entityType == Ent.USER:
          csvRows.append({Ent.Singular(entityType): user})
    except GDATA.forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GDATA.serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Contact Groups', todrive, quotechar=quotechar)

# gam <UserTypeEntity> print contactgroups [todrive [<ToDriveAttributes>]] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[formatjson] [quotechar <Character>]
def printUserContactGroups(users):
  _printShowContactGroups(users, True)

# gam <UserTypeEntity> show contactgroups [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[formatjson]
def showUserContactGroups(users):
  _printShowContactGroups(users, False)

# CrOS commands utilities
def getCrOSDeviceEntity():
  if checkArgumentPresent(u'crossn'):
    return getUsersToModify(Cmd.ENTITY_CROS_SN, getString(Cmd.OB_SERIAL_NUMBER_LIST))
  if checkArgumentPresent(u'query'):
    return getUsersToModify(Cmd.ENTITY_CROS_QUERY, getString(Cmd.OB_QUERY))
  deviceId = getString(Cmd.OB_CROS_DEVICE_ENTITY)
  if deviceId[:6].lower() == u'query:':
    query = deviceId[6:]
    if query[:12].lower() == u'orgunitpath:':
      return getUsersToModify(Cmd.ENTITY_CROS_OU, query[12:])
    return getUsersToModify(Cmd.ENTITY_CROS_QUERY, query)
  Cmd.Backup()
  return getEntityList(Cmd.OB_CROS_ENTITY)

UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP = {
  u'annotatedassetid': u'annotatedAssetId',
  u'annotatedlocation': u'annotatedLocation',
  u'annotateduser': u'annotatedUser',
  u'asset': u'annotatedAssetId',
  u'assetid': u'annotatedAssetId',
  u'location': u'annotatedLocation',
  u'notes': u'notes',
  u'org': u'orgUnitPath',
  u'orgunitpath': u'orgUnitPath',
  u'ou': u'orgUnitPath',
  u'tag': u'annotatedAssetId',
  u'user': u'annotatedUser',
  }

CROS_ACTION_CHOICE_MAP = {
  u'deprovisionsamemodelreplace': (u'deprovision', u'same_model_replacement'),
  u'deprovisionsamemodelreplacement': (u'deprovision', u'same_model_replacement'),
  u'deprovisiondifferentmodelreplace': (u'deprovision', u'different_model_replacement'),
  u'deprovisiondifferentmodelreplacement': (u'deprovision', u'different_model_replacement'),
  u'deprovisionretiringdevice': (u'deprovision', u'retiring_device'),
  u'disable': (u'disable', None),
  u'reenable': (u'reenable', None)
  }

CROS_ACTION_NAME_MAP = {
  u'deprovision': Act.DEPROVISION,
  u'disable': Act.DISABLE,
  u'reenable': Act.REENABLE,
  }

# gam <CrOSTypeEntity> update (<CrOSAttributes>+ [quickcrosmove [<Boolean>]])|(action <CrOSAction> [acknowledge_device_touch_requirement])
def updateCrOSDevices(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  update_body = {}
  action_body = {}
  orgUnitPath = None
  ackWipe = quickCrOSMove = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP:
      up = UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP[myarg]
      if up == u'orgUnitPath':
        orgUnitPath = getOrgUnitItem()
      elif up == u'notes':
        update_body[up] = getStringWithCRsNLs()
      else:
        update_body[up] = getString(Cmd.OB_STRING, minLen=[0, 1][up == u'annotatedAssetId'])
    elif myarg == u'action':
      actionLocation = Cmd.Location()
      action_body[u'action'], deprovisionReason = getChoice(CROS_ACTION_CHOICE_MAP, mapChoice=True)
      if deprovisionReason:
        action_body[u'deprovisionReason'] = deprovisionReason
      Act.Set(CROS_ACTION_NAME_MAP[action_body[u'action']])
    elif myarg == u'acknowledgedevicetouchrequirement':
      ackWipe = True
    elif myarg == u'quickcrosmove':
      quickCrOSMove = getBoolean()
    else:
      unknownArgumentExit()
  if action_body and update_body:
    Cmd.SetLocation(actionLocation-1)
    usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format(u'action', u'<CrOSAttributes>'))
  if orgUnitPath:
    status, orgUnitPath = checkOrgUnitPathExists(cd, orgUnitPath)
    if not status:
      entityActionFailedWarning([Ent.CROS_DEVICE, u''], u'{0}: {1}, {2}'.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT), orgUnitPath, Msg.DOES_NOT_EXIST))
      return
  i, count, entityList = getEntityArgument(entityList)
  function = None
  if action_body:
    if action_body[u'action'] == u'deprovision' and not ackWipe:
      stderrWarningMsg(Msg.REFUSING_TO_DEPROVISION_DEVICES.format(count))
      systemErrorExit(AC_NOT_PERFORMED_RC, None)
    function = u'action'
    parmId = u'resourceId'
    kwargs = {parmId: None, u'body': action_body}
  else:
    if update_body:
      if orgUnitPath and not quickCrOSMove:
        update_body[u'orgUnitPath'] = orgUnitPath
        orgUnitPath = None
      function = u'update'
      parmId = u'deviceId'
      kwargs = {parmId: None, u'body': update_body, u'fields': u''}
    if orgUnitPath:
      Act.Set(Act.ADD)
      _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, 0, 0, entityList, quickCrOSMove)
      Act.Set(Act.UPDATE)
  if function is None:
    return
  for deviceId in entityList:
    i += 1
    kwargs[parmId] = deviceId
    try:
      callGAPI(cd.chromeosdevices(), function,
               throw_reasons=[GAPI.INVALID, GAPI.CONDITION_NOT_MET, GAPI.INVALID_ORGUNIT,
                              GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerId=GC.Values[GC.CUSTOMER_ID], **kwargs)
      entityActionPerformed([Ent.CROS_DEVICE, deviceId], i, count)
    except (GAPI.invalid, GAPI.conditionNotMet) as e:
      entityActionFailedWarning([Ent.CROS_DEVICE, deviceId], str(e), i, count)
    except GAPI.invalidOrgunit:
      entityActionFailedWarning([Ent.CROS_DEVICE, deviceId], Msg.INVALID_ORGUNIT, i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, deviceId, i, count)

# gam update cros|croses <CrOSEntity> (<CrOSAttributes>+ [quickcrosmove [<Boolean>]])|(action <CrOSAction> [acknowledge_device_touch_requirement])
def doUpdateCrOSDevices():
  updateCrOSDevices(getCrOSDeviceEntity())

# From https://www.chromium.org/chromium-os/tpm_firmware_update
CROS_TPM_VULN_VERSIONS = [u'41f', u'420', u'628', u'8520',]
CROS_TPM_FIXED_VERSIONS = [u'422', u'62b', u'8521',]

def _checkTPMVulnerability(cros):
  if u'tpmVersionInfo' in cros and u'firmwareVersion' in cros[u'tpmVersionInfo']:
    if cros[u'tpmVersionInfo'][u'firmwareVersion'] in CROS_TPM_VULN_VERSIONS:
      cros[u'tpmVersionInfo'][u'tpmVulnerability'] = u'VULNERABLE'
    elif cros[u'tpmVersionInfo'][u'firmwareVersion'] in CROS_TPM_FIXED_VERSIONS:
      cros[u'tpmVersionInfo'][u'tpmVulnerability'] = u'UPDATED'
    else:
      cros[u'tpmVersionInfo'][u'tpmVulnerability'] = u'NOT IMPACTED'

def _filterTimeRanges(activeTimeRanges, startDate, endDate):
  if startDate is None and endDate is None:
    return activeTimeRanges
  filteredTimeRanges = []
  for timeRange in activeTimeRanges:
    activityDate = datetime.datetime.strptime(timeRange[u'date'], YYYYMMDD_FORMAT)
    if ((startDate is None) or (activityDate >= startDate)) and ((endDate is None) or (activityDate <= endDate)):
      filteredTimeRanges.append(timeRange)
  return filteredTimeRanges

def _filterDeviceFiles(deviceFiles, startTime, endTime):
  if startTime is None and endTime is None:
    return deviceFiles
  filteredDeviceFiles = []
  for deviceFile in deviceFiles:
    createTime, _ = iso8601.parse_date(deviceFile[u'createTime'])
    if ((startTime is None) or (createTime >= startTime)) and ((endTime is None) or (createTime <= endTime)):
      filteredDeviceFiles.append(deviceFile)
  return filteredDeviceFiles

def _getFilterDateTime():
  filterDate = getYYYYMMDD(returnDateTime=True)
  return (filterDate, filterDate.replace(tzinfo=iso8601.UTC))

CROS_FIELDS_CHOICE_MAP = {
  u'activetimeranges': [u'activeTimeRanges.activeTime', u'activeTimeRanges.date'],
  u'annotatedassetid': u'annotatedAssetId',
  u'annotatedlocation': u'annotatedLocation',
  u'annotateduser': u'annotatedUser',
  u'asset': u'annotatedAssetId',
  u'assetid': u'annotatedAssetId',
  u'bootmode': u'bootMode',
  u'devicefiles': [u'deviceFiles.type', u'deviceFiles.createTime'],
  u'deviceid': u'deviceId',
  u'ethernetmacaddress': u'ethernetMacAddress',
  u'firmwareversion': u'firmwareVersion',
  u'lastenrollmenttime': u'lastEnrollmentTime',
  u'lastsync': u'lastSync',
  u'location': u'annotatedLocation',
  u'macaddress': u'macAddress',
  u'meid': u'meid',
  u'model': u'model',
  u'notes': u'notes',
  u'ordernumber': u'orderNumber',
  u'org': u'orgUnitPath',
  u'orgunitpath': u'orgUnitPath',
  u'osversion': u'osVersion',
  u'ou': u'orgUnitPath',
  u'platformversion': u'platformVersion',
  u'recentusers': [u'recentUsers.email', u'recentUsers.type'],
  u'serialnumber': u'serialNumber',
  u'status': u'status',
  u'supportenddate': u'supportEndDate',
  u'tag': u'annotatedAssetId',
  u'timeranges': [u'activeTimeRanges.activeTime', u'activeTimeRanges.date'],
  u'times': [u'activeTimeRanges.activeTime', u'activeTimeRanges.date'],
  u'tpmversioninfo': u'tpmVersionInfo',
  u'user': u'annotatedUser',
  u'users': [u'recentUsers.email', u'recentUsers.type'],
  u'willautorenew': u'willAutoRenew',
  }
CROS_BASIC_FIELDS_LIST = [u'deviceId', u'annotatedAssetId', u'annotatedLocation', u'annotatedUser', u'lastSync', u'notes', u'serialNumber', u'status']

CROS_SCALAR_PROPERTY_PRINT_ORDER = [
  u'orgUnitPath',
  u'annotatedAssetId',
  u'annotatedLocation',
  u'annotatedUser',
  u'lastSync',
  u'notes',
  u'serialNumber',
  u'status',
  u'model',
  u'firmwareVersion',
  u'platformVersion',
  u'osVersion',
  u'bootMode',
  u'meid',
  u'ethernetMacAddress',
  u'macAddress',
  u'lastEnrollmentTime',
  u'orderNumber',
  u'supportEndDate',
  u'willAutoRenew',
  ]

CROS_TIME_OBJECTS = set([u'lastSync', u'lastEnrollmentTime', u'supportEndDate'])
CROS_FIELDS_WITH_CRS_NLS = [u'notes']
CROS_ACTIVE_TIME_RANGES_ARGUMENTS = [u'timeranges', u'activetimeranges', u'times']
CROS_DEVICE_FILES_ARGUMENTS = [u'devicefiles', u'files']
CROS_RECENT_USERS_ARGUMENTS = [u'recentusers', u'users']
CROS_START_ARGUMENTS = [u'start', u'startdate', u'oldestdate']
CROS_END_ARGUMENTS = [u'end', u'enddate']

# gam <CrOSTypeEntity> info [nolists] [listlimit <Number>] [start <Date>] [end <Date>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>] [downloadfile latest|<Time>] [targetfolder <FilePath>] [formatjson]
def infoCrOSDevices(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  downloadfile = None
  targetFolder = GC.Values[GC.DRIVE_DIR]
  projection = None
  fieldsList = []
  formatJSON = noLists = False
  listLimit = 0
  startDate = endDate = startTime = endTime = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'nolists':
      noLists = True
    elif myarg == u'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg in CROS_START_ARGUMENTS:
      startDate, startTime = _getFilterDateTime()
    elif myarg in CROS_END_ARGUMENTS:
      endDate, endTime = _getFilterDateTime()
    elif myarg == u'allfields':
      projection = u'FULL'
      fieldsList = []
    elif myarg in PROJECTION_CHOICE_MAP:
      projection = PROJECTION_CHOICE_MAP[myarg]
      if projection == u'FULL':
        fieldsList = []
      else:
        fieldsList = CROS_BASIC_FIELDS_LIST[:]
    elif myarg in CROS_FIELDS_CHOICE_MAP:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      addFieldToFieldsList(myarg, CROS_FIELDS_CHOICE_MAP, fieldsList)
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList = [u'deviceId',]
      for field in _getFieldsList():
        if field in CROS_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, CROS_FIELDS_CHOICE_MAP, fieldsList)
          if field in CROS_ACTIVE_TIME_RANGES_ARGUMENTS+CROS_DEVICE_FILES_ARGUMENTS+CROS_RECENT_USERS_ARGUMENTS:
            projection = u'FULL'
            noLists = False
        else:
          invalidChoiceExit(CROS_FIELDS_CHOICE_MAP, True)
    elif myarg == u'downloadfile':
      downloadfile = getString(Cmd.OB_STRING).lower()
      if downloadfile != u'latest':
        Cmd.Backup()
        downloadfile = formatLocalTime(getTimeOrDeltaFromNow())
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  if downloadfile and fieldsList:
    fieldsList.append(u'deviceFiles.downloadUrl')
  fields = u','.join(set(fieldsList)).replace(u'.', u'/') if fieldsList else None
  i, count, entityList = getEntityArgument(entityList)
  for deviceId in entityList:
    i += 1
    try:
      cros = callGAPI(cd.chromeosdevices(), u'get',
                      throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      customerId=GC.Values[GC.CUSTOMER_ID], deviceId=deviceId, projection=projection, fields=fields)
      _checkTPMVulnerability(cros)
      if formatJSON:
        printLine(json.dumps(cleanJSON(cros, u'', timeObjects=CROS_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.CROS_DEVICE, deviceId], i, count)
      Ind.Increment()
      for up in CROS_SCALAR_PROPERTY_PRINT_ORDER:
        if up in cros:
          if up not in CROS_TIME_OBJECTS:
            if up not in CROS_FIELDS_WITH_CRS_NLS:
              printKeyValueList([up, cros[up]])
            else:
              printKeyValueWithCRsNLs(up, cros[up])
          else:
            printKeyValueList([up, formatLocalTime(cros[up])])
      up = u'tpmVersionInfo'
      if up in cros:
        printKeyValueList([up, u''])
        Ind.Increment()
        for key, value in sorted(iteritems(cros[up])):
          printKeyValueList([key, value])
        Ind.Decrement()
      if not noLists:
        activeTimeRanges = _filterTimeRanges(cros.get(u'activeTimeRanges', []), startDate, endDate)
        lenATR = len(activeTimeRanges)
        if lenATR:
          printKeyValueList([u'activeTimeRanges'])
          Ind.Increment()
          for activeTimeRange in activeTimeRanges[:min(lenATR, listLimit or lenATR)]:
            printKeyValueList([u'date', activeTimeRange[u'date']])
            Ind.Increment()
            printKeyValueList([u'activeTime', str(activeTimeRange[u'activeTime'])])
            printKeyValueList([u'duration', formatMilliSeconds(activeTimeRange[u'activeTime'])])
            printKeyValueList([u'minutes', activeTimeRange[u'activeTime']//60000])
            Ind.Decrement()
          Ind.Decrement()
        recentUsers = cros.get(u'recentUsers', [])
        lenRU = len(recentUsers)
        if lenRU:
          printKeyValueList([u'recentUsers'])
          Ind.Increment()
          for recentUser in recentUsers[:min(lenRU, listLimit or lenRU)]:
            printKeyValueList([u'type', recentUser[u'type']])
            Ind.Increment()
            printKeyValueList([u'email', recentUser.get(u'email', [u'Unknown', u'UnmanagedUser'][recentUser[u'type'] == u'USER_TYPE_UNMANAGED'])])
            Ind.Decrement()
          Ind.Decrement()
        deviceFiles = _filterDeviceFiles(cros.get(u'deviceFiles', []), startTime, endTime)
        lenDF = len(deviceFiles)
        if lenDF:
          printKeyValueList([u'deviceFiles'])
          Ind.Increment()
          for deviceFile in deviceFiles[:min(lenDF, listLimit or lenDF)]:
            deviceFile[u'createTime'] = formatLocalTime(deviceFile[u'createTime'])
            printKeyValueList([deviceFile[u'type'], deviceFile[u'createTime']])
          Ind.Decrement()
          if downloadfile:
            if downloadfile == u'latest':
              deviceFile = deviceFiles[-1]
            else:
              for deviceFile in deviceFiles:
                if deviceFile[u'createTime'] == downloadfile:
                  break
              else:
                deviceFile = None
            if deviceFile:
              downloadfilename = os.path.join(targetFolder, u'cros-logs-{0}-{1}.zip'.format(deviceId, deviceFile[u'createTime']))
              _, content = cd._http.request(deviceFile[u'downloadUrl'])
              writeFile(downloadfilename, content, continueOnError=True)
              printKeyValueList([u'Downloaded', downloadfilename])
            else:
              Act.Set(Act.DOWNLOAD)
              entityActionFailedWarning([Ent.CROS_DEVICE, deviceId, Ent.DEVICE_FILE, downloadfile],
                                        Msg.DOES_NOT_EXIST, i, count)
              Act.Set(Act.INFO)
        elif downloadfile:
          Act.Set(Act.DOWNLOAD)
          entityActionNotPerformedWarning([Ent.CROS_DEVICE, deviceId, Ent.DEVICE_FILE, downloadfile],
                                          Msg.NO_ENTITIES_FOUND.format(Ent.Plural(Ent.DEVICE_FILE)), i, count)
          Act.Set(Act.INFO)
      Ind.Decrement()
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, deviceId, i, count)

# gam info cros|croses <CrOSEntity> [nolists] [listlimit <Number>] [start <Date>] [end <Date>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>] [downloadfile latest|<Time>] [targetfolder <FilePath>] [formatjson]
def doInfoCrOSDevices():
  infoCrOSDevices(getCrOSDeviceEntity())

def getDeviceFilesEntity():

  deviceFilesEntity = {u'list': [], u'dict': None, u'count': None, u'time': None, u'range': None}
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      deviceFilesEntity[u'dict'] = entityList
    else:
      deviceFilesEntity[u'list'] = entityList
  else:
    myarg = getString(Cmd.OB_DEVICE_FILE_ENTITY, checkBlank=True)
    mycmd = myarg.lower()
    if mycmd in [u'first', u'last', u'allexceptfirst', u'allexceptlast']:
      deviceFilesEntity[u'count'] = (mycmd, getInteger(minVal=1))
    elif mycmd in [u'before', u'after']:
      dateTime, _, _ = getTimeOrDeltaFromNow(True)
      deviceFilesEntity[u'time'] = (mycmd, dateTime)
    elif mycmd == u'range':
      startDateTime, _, startTime = getTimeOrDeltaFromNow(True)
      endDateTime, _, endTime = getTimeOrDeltaFromNow(True)
      if endDateTime < startDateTime:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_TIME_RANGE.format(u'end', endTime, u'start', startTime))
      deviceFilesEntity[u'range'] = (mycmd, startDateTime, endDateTime)
    else:
      for timeItem in myarg.split(u','):
        try:
          timestamp, _ = iso8601.parse_date(timeItem)
          deviceFilesEntity[u'list'].append(ISOformatTimeStamp(timestamp.astimezone(GC.Values[GC.TIMEZONE])))
        except iso8601.ParseError:
          Cmd.Backup()
          invalidArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)
  return deviceFilesEntity

def _selectDeviceFiles(deviceId, deviceFiles, deviceFilesEntity):
  numDeviceFiles = len(deviceFiles)
  if numDeviceFiles == 0:
    return deviceFiles
  for deviceFile in deviceFiles:
    deviceFile[u'createTime'] = formatLocalTime(deviceFile[u'createTime'])
  if deviceFilesEntity[u'count']:
    countType = deviceFilesEntity[u'count'][0]
    count = deviceFilesEntity[u'count'][1]
    if countType == u'first':
      return deviceFiles[:count]
    if countType == u'last':
      return deviceFiles[-count:]
    if countType == u'allexceptfirst':
      return deviceFiles[count:]
#   if countType == u'allexceptlast':
    return deviceFiles[:-count]
  if deviceFilesEntity[u'time']:
    dateTime = deviceFilesEntity[u'time'][1]
    count = 0
    if deviceFilesEntity[u'time'][0] == u'before':
      for deviceFile in deviceFiles:
        createTime, _ = iso8601.parse_date(deviceFile[u'createTime'])
        if createTime >= dateTime:
          break
        count += 1
      return deviceFiles[:count]
#   if deviceFilesEntity[u'time'][0] == u'after':
    for deviceFile in deviceFiles:
      createTime, _ = iso8601.parse_date(deviceFile[u'createTime'])
      if createTime >= dateTime:
        break
      count += 1
    return deviceFiles[count:]
  if deviceFilesEntity[u'range']:
    dateTime = deviceFilesEntity[u'range'][1]
    spos = 0
    for deviceFile in deviceFiles:
      createTime, _ = iso8601.parse_date(deviceFile[u'createTime'])
      if createTime >= dateTime:
        break
      spos += 1
    dateTime = deviceFilesEntity[u'range'][2]
    epos = spos
    for deviceFile in deviceFiles[spos:]:
      createTime, _ = iso8601.parse_date(deviceFile[u'createTime'])
      if createTime >= dateTime:
        break
      epos += 1
    return deviceFiles[spos:epos]
#  if deviceFilesEntity[u'range'] or deviceFilesEntity[u'dict']:
  if deviceFilesEntity[u'dict']:
    deviceFileCreateTimes = deviceFilesEntity[u'dict'][deviceId]
  else:
    deviceFileCreateTimes = deviceFilesEntity[u'list']
  return [deviceFile for deviceFile in deviceFiles if deviceFile[u'createTime'] in deviceFileCreateTimes]

# gam <CrOSTypeEntity> get devicefile [select <DeviceFileEntity>] [targetfolder <FilePath>]
def getCrOSDeviceFiles(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  targetFolder = GC.Values[GC.DRIVE_DIR]
  deviceFilesEntity = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'select':
      deviceFilesEntity = getDeviceFilesEntity()
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      unknownArgumentExit()
  fields = u'deviceFiles(type,createTime,downloadUrl)'
  i, count, entityList = getEntityArgument(entityList)
  for deviceId in entityList:
    i += 1
    try:
      deviceFiles = callGAPIitems(cd.chromeosdevices(), u'get', u'deviceFiles',
                                  throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                  customerId=GC.Values[GC.CUSTOMER_ID], deviceId=deviceId, fields=fields)
      if deviceFilesEntity:
        deviceFiles = _selectDeviceFiles(deviceId, deviceFiles, deviceFilesEntity)
      jcount = len(deviceFiles)
      entityPerformActionNumItems([Ent.CROS_DEVICE, deviceId], jcount, Ent.DEVICE_FILE, i, count)
      Ind.Increment()
      j = 0
      for deviceFile in deviceFiles:
        j += 1
        downloadfilename = os.path.join(targetFolder, u'cros-logs-{0}-{1}.zip'.format(deviceId, deviceFile[u'createTime']))
        _, content = cd._http.request(deviceFile[u'downloadUrl'])
        writeFile(downloadfilename, content, continueOnError=True)
        entityActionPerformed([Ent.DEVICE_FILE, downloadfilename], j, jcount)
      Ind.Decrement()
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, deviceId, i, count)

# gam get devicefile <CrOSEntity> [select <DeviceFileEntity>] [targetfolder <FilePath>]
def doGetCrOSDeviceFiles():
  getCrOSDeviceFiles(getCrOSDeviceEntity())

CROS_ORDERBY_CHOICE_MAP = {
  u'lastsync': u'lastSync',
  u'location': u'annotatedLocation',
  u'notes': u'notes',
  u'serialnumber': u'serialNumber',
  u'status': u'status',
  u'supportenddate': u'supportEndDate',
  u'user': u'annotatedUser',
  }

# gam [<CrOSTypeEntity>] print cros [todrive [<ToDriveAttributes>]] [(query <QueryCrOS>)|(queries <QueryCrOSList>)|(select <CrOSTypeEntity>)] [limittoou <OrgUnitItem>]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]] [nolists|recentusers|timeranges|devicefiles] [listlimit <Number>] [start <Date>] [end <Date>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>] [sortheaders] [formatjson] [quotechar <Character>]
def doPrintCrOSDevices(entityList=None):
  def _printCrOS(cros):
    _checkTPMVulnerability(cros)
    if formatJSON:
      csvRows.append({u'deviceId': cros[u'deviceId'],
                      u'JSON': json.dumps(cleanJSON(cros, u'', listLimit=listLimit, timeObjects=CROS_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
      return
    if u'notes' in cros:
      cros[u'notes'] = escapeCRsNLs(cros[u'notes'])
    if (not noLists) and (not selectActiveTimeRanges) and (not selectRecentUsers) and (not selectDeviceFiles):
      addRowTitlesToCSVfile(flattenJSON(cros, listLimit=listLimit, timeObjects=CROS_TIME_OBJECTS), csvRows, titles)
      return
    row = {}
    for attrib in cros:
      if attrib not in set([u'kind', u'etag', u'tpmVersionInfo', u'recentUsers', u'activeTimeRanges', u'deviceFiles']):
        if attrib not in titles[u'set']:
          addTitleToCSVfile(attrib, titles)
        if attrib not in CROS_TIME_OBJECTS:
          row[attrib] = cros[attrib]
        else:
          row[attrib] = formatLocalTime(cros[attrib])
    attrib = u'tpmVersionInfo'
    if attrib in cros:
      for key, value in sorted(iteritems(cros[attrib])):
        attribKey = u'{0}.{1}'.format(attrib, key)
        if attribKey not in titles[u'set']:
          addTitleToCSVfile(attribKey, titles)
        row[attribKey] = value
    activeTimeRanges = _filterTimeRanges(cros.get(u'activeTimeRanges', []) if selectActiveTimeRanges else [], startDate, endDate)
    recentUsers = cros.get(u'recentUsers', []) if selectRecentUsers else []
    deviceFiles = _filterDeviceFiles(cros.get(u'deviceFiles', []) if selectDeviceFiles else [], startTime, endTime)
    if noLists or (not activeTimeRanges and not recentUsers and not deviceFiles):
      csvRows.append(row)
      return
    lenATR = len(activeTimeRanges)
    lenRU = len(recentUsers)
    lenDF = len(deviceFiles)
    for i in range(min(max(lenATR, lenRU, lenDF), listLimit or max(lenATR, lenRU, lenDF))):
      new_row = row.copy()
      if i < lenATR:
        new_row[u'activeTimeRanges.date'] = activeTimeRanges[i][u'date']
        new_row[u'activeTimeRanges.activeTime'] = str(activeTimeRanges[i][u'activeTime'])
        new_row[u'activeTimeRanges.duration'] = formatMilliSeconds(activeTimeRanges[i][u'activeTime'])
        new_row[u'activeTimeRanges.minutes'] = activeTimeRanges[i][u'activeTime']//60000
      if i < lenRU:
        new_row[u'recentUsers.email'] = recentUsers[i].get(u'email', [u'Unknown', u'UnmanagedUser'][recentUsers[i][u'type'] == u'USER_TYPE_UNMANAGED'])
        new_row[u'recentUsers.type'] = recentUsers[i][u'type']
      if i < lenDF:
        new_row[u'deviceFiles.type'] = deviceFiles[i][u'type']
        new_row[u'deviceFiles.createTime'] = formatLocalTime(deviceFiles[i][u'createTime'])
      csvRows.append(new_row)

  def _callbackPrintCrOS(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printCrOS(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN]:
        checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  cd = buildGAPIObject(API.DIRECTORY)
  todrive = {}
  fieldsList = []
  titles, csvRows = initializeTitlesCSVfile(None)
  addFieldToCSVfile(u'deviceId', CROS_FIELDS_CHOICE_MAP, fieldsList, titles)
  sortHeaders = False
  orgUnitPath = projection = orderBy = sortOrder = None
  queries = [None]
  formatJSON = noLists = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  listLimit = 0
  startDate = endDate = startTime = endTime = None
  selectActiveTimeRanges = selectDeviceFiles = selectRecentUsers = False
  selectLookup = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'limittoou':
      orgUnitPath = getOrgUnitItem()
    elif myarg in [u'query', u'queries']:
      queries = getQueries(myarg)
    elif myarg == u'select':
      _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_CROS, crosAllowed=True, userAllowed=False)
    elif myarg in CROS_ACTIVE_TIME_RANGES_ARGUMENTS:
      selectActiveTimeRanges = True
      noLists = False
    elif myarg in CROS_DEVICE_FILES_ARGUMENTS:
      selectDeviceFiles = True
      noLists = False
    elif myarg in CROS_RECENT_USERS_ARGUMENTS:
      selectRecentUsers = True
      noLists = False
    elif myarg == u'orderby':
      orderBy = getChoice(CROS_ORDERBY_CHOICE_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ASCENDING', mapChoice=True)
    elif myarg == u'nolists':
      noLists = True
      selectActiveTimeRanges = selectDeviceFiles = selectRecentUsers = False
    elif myarg == u'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg in CROS_START_ARGUMENTS:
      startDate, startTime = _getFilterDateTime()
    elif myarg in CROS_END_ARGUMENTS:
      endDate, endTime = _getFilterDateTime()
    elif myarg in PROJECTION_CHOICE_MAP:
      projection = PROJECTION_CHOICE_MAP[myarg]
      sortHeaders = True
      if projection == u'FULL':
        fieldsList = []
      else:
        fieldsList = CROS_BASIC_FIELDS_LIST[:]
    elif myarg == u'allfields':
      projection = u'FULL'
      sortHeaders = True
      fieldsList = []
    elif myarg == u'sortheaders':
      sortHeaders = getBoolean()
    elif myarg in CROS_FIELDS_CHOICE_MAP:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      addFieldToCSVfile(myarg, CROS_FIELDS_CHOICE_MAP, fieldsList, titles)
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList = [u'deviceId',]
      for field in _getFieldsList():
        if field in CROS_FIELDS_CHOICE_MAP:
          addFieldToCSVfile(field, CROS_FIELDS_CHOICE_MAP, fieldsList, titles)
          if field in CROS_ACTIVE_TIME_RANGES_ARGUMENTS:
            selectActiveTimeRanges = True
            noLists = False
          elif field in CROS_DEVICE_FILES_ARGUMENTS:
            selectDeviceFiles = True
            noLists = False
          elif field in CROS_RECENT_USERS_ARGUMENTS:
            selectRecentUsers = True
            noLists = False
        else:
          invalidChoiceExit(CROS_FIELDS_CHOICE_MAP, True)
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  if projection == u'FULL':
    if selectRecentUsers:
      addTitlesToCSVfile(CROS_FIELDS_CHOICE_MAP[u'recentusers'], titles)
    if selectActiveTimeRanges:
      addTitlesToCSVfile(CROS_FIELDS_CHOICE_MAP[u'activetimeranges'], titles)
      addTitlesToCSVfile([u'activeTimeRanges.duration', u'activeTimeRanges.minutes'], titles)
    if selectDeviceFiles:
      addTitlesToCSVfile(CROS_FIELDS_CHOICE_MAP[u'devicefiles'], titles)
  else:
    if selectRecentUsers:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      projection = u'FULL'
      addFieldToCSVfile(u'recentUsers', CROS_FIELDS_CHOICE_MAP, fieldsList, titles)
    if selectActiveTimeRanges:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      projection = u'FULL'
      addFieldToCSVfile(u'activeTimeRanges', CROS_FIELDS_CHOICE_MAP, fieldsList, titles)
      addTitlesToCSVfile([u'activeTimeRanges.duration', u'activeTimeRanges.minutes'], titles)
    if selectDeviceFiles:
      if not fieldsList:
        fieldsList = [u'deviceId',]
      projection = u'FULL'
      addFieldToCSVfile(u'deviceFiles', CROS_FIELDS_CHOICE_MAP, fieldsList, titles)
  _, _, entityList = getEntityArgument(entityList)
  if formatJSON:
    sortHeaders = False
    titles, csvRows = initializeTitlesCSVfile([u'deviceId', u'JSON'])
  if entityList is None:
    sortRows = False
    fields = u'nextPageToken,chromeosdevices({0})'.format(u','.join(fieldsList)).replace(u'.', u'/') if fieldsList else None
    for query in queries:
      printGettingAllAccountEntities(Ent.CROS_DEVICE, query)
      try:
        feed = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                             page_message=getPageMessage(),
                             throw_reasons=[GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customerId=GC.Values[GC.CUSTOMER_ID], query=query, projection=projection, orgUnitPath=orgUnitPath,
                             orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        printGotAccountEntities(len(feed))
        while feed:
          _printCrOS(feed.popleft())
      except GAPI.invalidInput:
        entityActionFailedWarning([Ent.CROS_DEVICE, None], invalidQuery(query))
        return
      except GAPI.invalidOrgunit as e:
        entityActionFailedWarning([Ent.CROS_DEVICE, None], str(e))
        return
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
  else:
    sortRows = True
    if fieldsList:
      fields = u','.join(set(fieldsList)).replace(u'.', u'/')
      selectLookup = len(fieldsList) > 1
    else:
      fields = None
      selectLookup = True
    if selectLookup:
      jcount = len(entityList)
      svcargs = dict([(u'customerId', GC.Values[GC.CUSTOMER_ID]), (u'deviceId', None), (u'projection', projection), (u'fields', fields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
      method = getattr(cd.chromeosdevices(), u'get')
      dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
      bcount = 0
      j = 0
      for deviceId in entityList:
        j += 1
        svcparms = svcargs.copy()
        svcparms[u'deviceId'] = deviceId
        dbatch.add(method(**svcparms), request_id=batchRequestID(u'', 0, 0, j, jcount, deviceId))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
          bcount = 0
      if bcount > 0:
        executeBatch(dbatch)
    else:
      for cros in entityList:
        _printCrOS({u'deviceId': cros})
  if sortRows and orderBy and orderBy in titles[u'set']:
    csvRows.sort(key=lambda k: k[orderBy], reverse=sortOrder == u'DESCENDING')
  writeCSVfile(csvRows, titles, u'CrOS', todrive, [u'deviceId',] if sortHeaders else None, quotechar)

CROS_ACTIVITY_TIME_OBJECTS = set([u'createTime',])

# gam [<CrOSTypeEntity>] print crosactivity [todrive [<ToDriveAttributes>]] [(query <QueryCrOS>)|(queries <QueryCrOSList>)|(select <CrOSTypeEntity>)] [limittoou <OrgUnitItem>]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]] [recentusers] [timeranges] [devicefiles] [both|all] [listlimit <Number>] [start <Date>] [end <Date>]
#	[delimiter <Character>] [formatjson] [quotechar <Character>]
def doPrintCrOSActivity(entityList=None):
  def _printCrOS(cros):
    row = {}
    if formatJSON:
      csvRows.append({u'deviceId': cros[u'deviceId'],
                      u'JSON': json.dumps(cleanJSON(cros, u'', timeObjects=CROS_ACTIVITY_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
      return
    for attrib in cros:
      if attrib not in [u'recentUsers', u'activeTimeRanges', u'deviceFiles']:
        row[attrib] = cros[attrib]
    if selectActiveTimeRanges:
      activeTimeRanges = _filterTimeRanges(cros.get(u'activeTimeRanges', []), startDate, endDate)
      lenATR = len(activeTimeRanges)
      for activeTimeRange in activeTimeRanges[:min(lenATR, listLimit or lenATR)]:
        new_row = row.copy()
        new_row[u'activeTimeRanges.date'] = activeTimeRange[u'date']
        new_row[u'activeTimeRanges.duration'] = formatMilliSeconds(activeTimeRange[u'activeTime'])
        new_row[u'activeTimeRanges.minutes'] = activeTimeRange[u'activeTime']//60000
        csvRows.append(new_row)
    if selectRecentUsers:
      recentUsers = cros.get(u'recentUsers', [])
      lenRU = len(recentUsers)
      row[u'recentUsers.email'] = delimiter.join([recent_user.get(u'email', [u'Unknown', u'UnmanagedUser'][recent_user[u'type'] == u'USER_TYPE_UNMANAGED']) for recent_user in recentUsers[:min(lenRU, listLimit or lenRU)]])
      csvRows.append(row)
    if selectDeviceFiles:
      deviceFiles = _filterDeviceFiles(cros.get(u'deviceFiles', []), startTime, endTime)
      lenDF = len(deviceFiles)
      for deviceFile in deviceFiles[:min(lenDF, listLimit or lenDF)]:
        new_row = row.copy()
        new_row[u'deviceFiles.type'] = deviceFile[u'type']
        new_row[u'deviceFiles.createTime'] = formatLocalTime(deviceFile[u'createTime'])
        csvRows.append(new_row)

  def _callbackPrintCrOS(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printCrOS(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN]:
        checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  cd = buildGAPIObject(API.DIRECTORY)
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  todrive = {}
  fieldsList = [u'deviceId', u'annotatedAssetId', u'annotatedLocation', u'serialNumber', u'orgUnitPath']
  titles, csvRows = initializeTitlesCSVfile(fieldsList)
  projection = u'FULL'
  orgUnitPath = orderBy = sortOrder = None
  queries = [None]
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  listLimit = 0
  startDate = endDate = startTime = endTime = None
  selectActiveTimeRanges = selectDeviceFiles = selectRecentUsers = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'limittoou':
      orgUnitPath = getOrgUnitItem()
    elif myarg in [u'query', u'queries']:
      queries = getQueries(myarg)
    elif myarg == u'select':
      _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_CROS, crosAllowed=True, userAllowed=False)
    elif myarg == u'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg in CROS_START_ARGUMENTS:
      startDate, startTime = _getFilterDateTime()
    elif myarg in CROS_END_ARGUMENTS:
      endDate, endTime = _getFilterDateTime()
    elif myarg in CROS_ACTIVE_TIME_RANGES_ARGUMENTS:
      selectActiveTimeRanges = True
    elif myarg in CROS_DEVICE_FILES_ARGUMENTS:
      selectDeviceFiles = True
    elif myarg in CROS_RECENT_USERS_ARGUMENTS:
      selectRecentUsers = True
    elif myarg == u'both':
      selectActiveTimeRanges = selectRecentUsers = True
    elif myarg == u'all':
      selectActiveTimeRanges = selectDeviceFiles = selectRecentUsers = True
    elif myarg == u'orderby':
      orderBy = getChoice(CROS_ORDERBY_CHOICE_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ASCENDING', mapChoice=True)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  if not selectActiveTimeRanges and not selectDeviceFiles and not selectRecentUsers:
    selectActiveTimeRanges = selectRecentUsers = True
  if selectRecentUsers:
    fieldsList.append(u'recentUsers')
    addTitlesToCSVfile(u'recentUsers.email', titles)
  if selectActiveTimeRanges:
    fieldsList.append(u'activeTimeRanges')
    addTitlesToCSVfile([u'activeTimeRanges.date', u'activeTimeRanges.duration', u'activeTimeRanges.minutes'], titles)
  if selectDeviceFiles:
    fieldsList.append(u'deviceFiles')
    addTitlesToCSVfile([u'deviceFiles.type', u'deviceFiles.createTime'], titles)
  _, _, entityList = getEntityArgument(entityList)
  if formatJSON:
    titles, csvRows = initializeTitlesCSVfile([u'deviceId', u'JSON'])
  if entityList is None:
    sortRows = False
    fields = u'nextPageToken,chromeosdevices({0})'.format(u','.join(fieldsList))
    for query in queries:
      printGettingAllAccountEntities(Ent.CROS_DEVICE, query)
      try:
        feed = callGAPIpages(cd.chromeosdevices(), u'list', u'chromeosdevices',
                             page_message=getPageMessage(),
                             throw_reasons=[GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customerId=GC.Values[GC.CUSTOMER_ID], query=query, projection=projection, orgUnitPath=orgUnitPath,
                             orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        printGotAccountEntities(len(feed))
        while feed:
          _printCrOS(feed.popleft())
      except GAPI.invalidInput:
        entityActionFailedWarning([Ent.CROS_DEVICE, None], invalidQuery(query))
        return
      except GAPI.invalidOrgunit as e:
        entityActionFailedWarning([Ent.CROS_DEVICE, None], str(e))
        return
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
  else:
    sortRows = True
    fields = u','.join(set(fieldsList))
    jcount = len(entityList)
    svcargs = dict([(u'customerId', GC.Values[GC.CUSTOMER_ID]), (u'deviceId', None), (u'projection', projection), (u'fields', fields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.chromeosdevices(), u'get')
    dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
    bcount = 0
    j = 0
    for deviceId in entityList:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'deviceId'] = deviceId
      dbatch.add(method(**svcparms), request_id=batchRequestID(u'', 0, 0, j, jcount, deviceId))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
  if sortRows and orderBy and orderBy in titles[u'set']:
    csvRows.sort(key=lambda k: k[orderBy], reverse=sortOrder == u'DESCENDING')
  writeCSVfile(csvRows, titles, u'CrOS Activity', todrive, None, quotechar)

# gam <CrOSTypeEntity> print
def doPrintCrOSEntity(entityList):
  if getChoice([Cmd.ARG_CROS, Cmd.ARG_CROSES, Cmd.ARG_CROSACTIVITY], defaultChoice=None) != Cmd.ARG_CROSACTIVITY:
    if not Cmd.ArgumentsRemaining():
      _, _, entityList = getEntityArgument(entityList)
      for entity in entityList:
        printLine(entity)
      return
    doPrintCrOSDevices(entityList)
  else:
    doPrintCrOSActivity(entityList)

# Mobile command utilities
MOBILE_ACTION_CHOICE_MAP = {
  u'accountwipe': u'admin_account_wipe',
  u'adminaccountwipe': u'admin_account_wipe',
  u'wipeaccount': u'admin_account_wipe',
  u'adminremotewipe': u'admin_remote_wipe',
  u'wipe': u'admin_remote_wipe',
  u'approve': u'approve',
  u'block': u'action_block',
  u'cancelremotewipethenactivate': u'cancel_remote_wipe_then_activate',
  u'cancelremotewipethenblock': u'cancel_remote_wipe_then_block',
  }

def getMobileDeviceEntity():
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent(u'query'):
    query = getString(Cmd.OB_QUERY)
  else:
    resourceId = getString(Cmd.OB_MOBILE_DEVICE_ENTITY)
    if resourceId[:6].lower() == u'query:':
      query = resourceId[6:]
    else:
      Cmd.Backup()
      query = None
  if not query:
    return (getEntityList(Cmd.OB_MOBILE_ENTITY), cd)
  try:
    devices = callGAPIpages(cd.mobiledevices(), u'list', u'mobiledevices',
                            throw_reasons=[GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=GC.Values[GC.CUSTOMER_ID], query=query,
                            fields=u'nextPageToken,mobiledevices(resourceId)')
    return ([mobile[u'resourceId'] for mobile in devices], cd)
  except GAPI.invalidInput:
    Cmd.Backup()
    usageErrorExit(Msg.INVALID_QUERY)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam update mobile|mobiles <MobileDeviceEntity> action <MobileAction>
def doUpdateMobileDevices():
  entityList, cd = getMobileDeviceEntity()
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'action':
      body[u'action'] = getChoice(MOBILE_ACTION_CHOICE_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      if body:
        callGAPI(cd.mobiledevices(), u'action',
                 bailOnInternalError=True, throw_reasons=[GAPI.INTERNAL_ERROR, GAPI.RESOURCE_ID_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                 customerId=GC.Values[GC.CUSTOMER_ID], resourceId=resourceId, body=body)
        printEntityKVList([Ent.MOBILE_DEVICE, resourceId],
                          [Msg.ACTION_APPLIED, body[u'action']],
                          i, count)
    except GAPI.internalError:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.resourceIdNotFound, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], str(e), i, count)

# gam delete mobile|mobiles <MobileDeviceEntity>
def doDeleteMobileDevices():
  entityList, cd = getMobileDeviceEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.mobiledevices(), u'delete',
               bailOnInternalError=True, throw_reasons=[GAPI.INTERNAL_ERROR, GAPI.RESOURCE_ID_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerId=GC.Values[GC.CUSTOMER_ID], resourceId=resourceId)
      entityActionPerformed([Ent.MOBILE_DEVICE, resourceId], i, count)
    except GAPI.internalError:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.resourceIdNotFound, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], str(e), i, count)

MOBILE_FIELDS_CHOICE_MAP = {
  u'adbstatus': u'adbStatus',
  u'applications': u'applications',
  u'basebandversion': u'basebandVersion',
  u'bootloaderversion': u'bootloaderVersion',
  u'brand': u'brand',
  u'buildnumber': u'buildNumber',
  u'defaultlanguage': u'defaultLanguage',
  u'developeroptionsstatus': u'developerOptionsStatus',
  u'devicecompromisedstatus': u'deviceCompromisedStatus',
  u'deviceid': u'deviceId',
  u'devicepasswordstatus': u'devicePasswordStatus',
  u'email': u'email',
  u'encryptionstatus': u'encryptionStatus',
  u'firstsync': u'firstSync',
  u'hardware': u'hardware',
  u'hardwareid': u'hardwareId',
  u'imei': u'imei',
  u'kernelversion': u'kernelVersion',
  u'lastsync': u'lastSync',
  u'managedaccountisonownerprofile': u'managedAccountIsOnOwnerProfile',
  u'manufacturer': u'manufacturer',
  u'meid': u'meid',
  u'model': u'model',
  u'name': u'name',
  u'networkoperator': u'networkOperator',
  u'os': u'os',
  u'otheraccountsinfo': u'otherAccountsInfo',
  u'privilege': u'privilege',
  u'releaseversion': u'releaseVersion',
  u'resourceid': u'resourceId',
  u'securitypatchlevel': u'securityPatchLevel',
  u'serialnumber': u'serialNumber',
  u'status': u'status',
  u'supportsworkprofile': u'supportsWorkProfile',
  u'type': u'type',
  u'unknownsourcesstatus': u'unknownSourcesStatus',
  u'useragent': u'userAgent',
  u'wifimacaddress': u'wifiMacAddress',
  }

MOBILE_TIME_OBJECTS = set([u'firstSync', u'lastSync'])

def _initMobileFieldsParameters():
  return {u'fieldsList': [], u'projection': None}

def _getMobileFieldsArguments(myarg, parameters):
  if myarg == u'allfields':
    parameters[u'projection'] = u'FULL'
    parameters[u'fieldsList'] = []
  elif myarg in PROJECTION_CHOICE_MAP:
    parameters[u'projection'] = PROJECTION_CHOICE_MAP[myarg]
    parameters[u'fieldsList'] = []
  elif getFieldsList(myarg, MOBILE_FIELDS_CHOICE_MAP, parameters[u'fieldsList'], u'resourceId'):
    pass
  else:
    unknownArgumentExit()

# gam info mobile|mobiles <MobileDeviceEntity>
#	[basic|full|allfields] <MobileFieldName>* [fields <MobileFieldNameList>]
def doInfoMobileDevices():
  entityList, cd = getMobileDeviceEntity()
  parameters = _initMobileFieldsParameters()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    _getMobileFieldsArguments(myarg, parameters)
  fields = u','.join(set(parameters[u'fieldsList'])) if parameters[u'fieldsList'] else None
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      info = callGAPI(cd.mobiledevices(), u'get',
                      bailOnInternalError=True, throw_reasons=[GAPI.INTERNAL_ERROR, GAPI.RESOURCE_ID_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      customerId=GC.Values[GC.CUSTOMER_ID], resourceId=resourceId, projection=parameters[u'projection'], fields=fields)
      printEntity([Ent.MOBILE_DEVICE, resourceId], i, count)
      Ind.Increment()
      showJSON(None, info, timeObjects=MOBILE_TIME_OBJECTS)
      Ind.Decrement()
    except GAPI.internalError:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.resourceIdNotFound, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], str(e), i, count)

MOBILE_ORDERBY_CHOICE_MAP = {
  u'deviceid': u'deviceId',
  u'email': u'email',
  u'lastsync': u'lastSync',
  u'model': u'model',
  u'name': u'name',
  u'os': u'os',
  u'status': u'status',
  u'type': u'type',
  }

# gam print mobile [todrive [<ToDriveAttributes>]] [(query <QueryMobile>)|(queries <QueryMobileList>)]
#	[orderby <MobileOrderByFieldName> [ascending|descending]] [noapps]
#	[basic|full|allfields] <MobileFieldName>* [fields <MobileFieldNameList>]
#	[delimiter <Character>] [appslimit <Number>] [listlimit <Number>]
def doPrintMobileDevices():
  cd = buildGAPIObject(API.DIRECTORY)
  todrive = {}
  parameters = _initMobileFieldsParameters()
  titles, csvRows = initializeTitlesCSVfile([u'resourceId',])
  orderBy = sortOrder = None
  queries = [None]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  listLimit = 1
  appsLimit = -1
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'query', u'queries']:
      queries = getQueries(myarg)
    elif myarg == u'orderby':
      orderBy = getChoice(MOBILE_ORDERBY_CHOICE_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ASCENDING', mapChoice=True)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'listlimit':
      listLimit = getInteger(minVal=-1)
    elif myarg == u'appslimit':
      appsLimit = getInteger(minVal=-1)
    else:
      _getMobileFieldsArguments(myarg, parameters)
  if appsLimit >= 0:
    parameters[u'projection'] = u'FULL'
  fields = u'nextPageToken,mobiledevices({0})'.format(u','.join(parameters[u'fieldsList'])) if parameters[u'fieldsList'] else None
  for query in queries:
    printGettingAllAccountEntities(Ent.MOBILE_DEVICE, query)
    try:
      feed = callGAPIpages(cd.mobiledevices(), u'list', u'mobiledevices',
                           page_message=getPageMessage(),
                           throw_reasons=[GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                           customerId=GC.Values[GC.CUSTOMER_ID], query=query, projection=parameters[u'projection'],
                           orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
      printGotAccountEntities(len(feed))
      while feed:
        mobile = feed.popleft()
        row = {}
        for attrib in mobile:
          if attrib in DEFAULT_SKIP_OBJECTS:
            pass
          elif attrib in [u'name', u'email', u'otherAccountsInfo']:
            if listLimit > 0:
              row[attrib] = delimiter.join(mobile[attrib][0:listLimit])
            elif listLimit == 0:
              row[attrib] = delimiter.join(mobile[attrib])
          elif attrib == u'applications':
            if appsLimit >= 0:
              applications = []
              j = 0
              for app in mobile[attrib]:
                j += 1
                if appsLimit and (j > appsLimit):
                  break
                appDetails = []
                for field in [u'displayName', u'packageName', u'versionName']:
                  appDetails.append(app.get(field, u'<None>'))
                appDetails.append(text_type(app.get(u'versionCode', u'<None>')))
                permissions = app.get(u'permission', [])
                if permissions:
                  appDetails.append(u'/'.join(permissions))
                else:
                  appDetails.append(u'<None>')
                applications.append(u'-'.join(appDetails))
              row[attrib] = delimiter.join(applications)
          elif attrib == u'deviceId' and GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]:
            row[attrib] = escapeCRsNLs(mobile[attrib])
          elif attrib not in MOBILE_TIME_OBJECTS:
            row[attrib] = mobile[attrib]
          else:
            row[attrib] = formatLocalTime(mobile[attrib])
        addRowTitlesToCSVfile(row, csvRows, titles)
    except GAPI.invalidInput:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, None], invalidQuery(query))
      return
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)
  writeCSVfile(csvRows, titles, u'Mobile', todrive, [u'resourceId', u'deviceId', u'serialNumber', u'name', u'email', u'status'])

COLLABORATIVE_ACL_ATTRIBUTES = [
  u'whoCanAddReferences',
  u'whoCanAssignTopics',
  u'whoCanEnterFreeFormTags',
  u'whoCanMarkDuplicate',
  u'whoCanMarkFavoriteReplyOnAnyTopic',
  u'whoCanMarkFavoriteReplyOnOwnTopic',
  u'whoCanMarkNoResponseNeeded',
  u'whoCanModifyTagsAndCategories',
  u'whoCanTakeTopics',
  u'whoCanUnassignTopic',
  u'whoCanUnmarkFavoriteReplyOnAnyTopic',
  ]
COLLABORATIVE_ACL_CHOICES = {
  u'allmembers': u'ALL_MEMBERS',
  u'members': u'ALL_MEMBERS',
  u'ownersandmanagers': u'OWNERS_AND_MANAGERS',
  u'managersonly': u'MANAGERS_ONLY',
  u'managers': u'OWNERS_AND_MANAGERS',
  u'ownersonly': u'OWNERS_ONLY',
  u'owners': u'OWNERS_ONLY',
  u'none': u'NONE',
  }
GROUP_ATTRIBUTES = {
  u'allowexternalmembers': [u'allowExternalMembers', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'allowgooglecommunication': [u'allowGoogleCommunication', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'allowwebposting': [u'allowWebPosting', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'archiveonly': [u'archiveOnly', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'customfootertext': [u'customFooterText', {GC.VAR_TYPE: GC.TYPE_STRING}],
  u'customreplyto': [u'customReplyTo', {GC.VAR_TYPE: GC.TYPE_EMAIL_OPTIONAL}],
  u'defaultmessagedenynotificationtext': [u'defaultMessageDenyNotificationText', {GC.VAR_TYPE: GC.TYPE_STRING}],
  u'description': [u'description', {GC.VAR_TYPE: GC.TYPE_STRING}],
  u'favoriterepliesontop': [u'favoriteRepliesOnTop', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'gal': [u'includeInGlobalAddressList', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'includecustomfooter': [u'includeCustomFooter', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'includeinglobaladdresslist': [u'includeInGlobalAddressList', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'isarchived': [u'isArchived', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'maxmessagebytes': [u'maxMessageBytes', {GC.VAR_TYPE: GC.TYPE_INTEGER}],
  u'memberscanpostasthegroup': [u'membersCanPostAsTheGroup', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'messagedisplayfont': [u'messageDisplayFont', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                  u'choices': {u'defaultfont': u'DEFAULT_FONT', u'fixedwidthfont': u'FIXED_WIDTH_FONT',}}],
  u'messagemoderationlevel': [u'messageModerationLevel', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                          u'choices': {u'moderateallmessages': u'MODERATE_ALL_MESSAGES', u'moderatenonmembers': u'MODERATE_NON_MEMBERS',
                                                                       u'moderatenewmembers': u'MODERATE_NEW_MEMBERS', u'moderatenone': u'MODERATE_NONE',}}],
  u'name': [u'name', {GC.VAR_TYPE: GC.TYPE_STRING}],
  u'primarylanguage': [u'primaryLanguage', {GC.VAR_TYPE: GC.TYPE_LANGUAGE}],
  u'replyto': [u'replyTo', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                            u'choices': {u'replytocustom': u'REPLY_TO_CUSTOM', u'replytosender': u'REPLY_TO_SENDER', u'replytolist': u'REPLY_TO_LIST',
                                         u'replytoowner': u'REPLY_TO_OWNER', u'replytoignore': u'REPLY_TO_IGNORE', u'replytomanagers': u'REPLY_TO_MANAGERS',}}],
  u'sendmessagedenynotification': [u'sendMessageDenyNotification', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'showingroupdirectory': [u'showInGroupDirectory', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  u'spammoderationlevel': [u'spamModerationLevel', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                    u'choices': {u'allow': u'ALLOW', u'moderate': u'MODERATE', u'silentlymoderate': u'SILENTLY_MODERATE', u'reject': u'REJECT',}}],
  u'whocanadd': [u'whoCanAdd', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                u'choices': {u'allmemberscanadd': u'ALL_MEMBERS_CAN_ADD', u'allmanagerscanadd': u'ALL_MANAGERS_CAN_ADD', u'nonecanadd': u'NONE_CAN_ADD',}}],
  u'whocanaddreferences': [u'whoCanAddReferences', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanassigntopics': [u'whoCanAssignTopics', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocancontactowner': [u'whoCanContactOwner', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                  u'choices': {u'anyonecancontact': u'ANYONE_CAN_CONTACT', u'allindomaincancontact': u'ALL_IN_DOMAIN_CAN_CONTACT',
                                                               u'allmemberscancontact': u'ALL_MEMBERS_CAN_CONTACT', u'allmanagerscancontact': u'ALL_MANAGERS_CAN_CONTACT',}}],
  u'whocanenterfreeformtags': [u'whoCanEnterFreeFormTags', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocaninvite': [u'whoCanInvite', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                      u'choices': {u'allmemberscaninvite': u'ALL_MEMBERS_CAN_INVITE', u'allmanagerscaninvite': u'ALL_MANAGERS_CAN_INVITE', u'nonecaninvite': u'NONE_CAN_INVITE',}}],
  u'whocanjoin': [u'whoCanJoin', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                  u'choices': {u'anyonecanjoin': u'ANYONE_CAN_JOIN', u'allindomaincanjoin': u'ALL_IN_DOMAIN_CAN_JOIN',
                                               u'invitedcanjoin': u'INVITED_CAN_JOIN', u'canrequesttojoin': u'CAN_REQUEST_TO_JOIN',}}],
  u'whocanleavegroup': [u'whoCanLeaveGroup', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                              u'choices': {u'allmanagerscanleave': u'ALL_MANAGERS_CAN_LEAVE', u'allmemberscanleave': u'ALL_MEMBERS_CAN_LEAVE', u'nonecanleave': u'NONE_CAN_LEAVE',}}],
  u'whocanmarkduplicate': [u'whoCanMarkDuplicate', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanmarkfavoritereplyonanytopic': [u'whoCanMarkFavoriteReplyOnAnyTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanmarkfavoritereplyonowntopic': [u'whoCanMarkFavoriteReplyOnOwnTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanmarknoresponseneeded': [u'whoCanMarkNoResponseNeeded', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanmodifytagsandcategories': [u'whoCanModifyTagsAndCategories', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocantaketopics': [u'whoCanTakeTopics', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanpostmessage': [u'whoCanPostMessage', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                u'choices': {u'nonecanpost': u'NONE_CAN_POST', u'allmanagerscanpost': u'ALL_MANAGERS_CAN_POST', u'allmemberscanpost': u'ALL_MEMBERS_CAN_POST',
                                                             u'allindomaincanpost': u'ALL_IN_DOMAIN_CAN_POST', u'anyonecanpost': u'ANYONE_CAN_POST',}}],
  u'whocanunassigntopic': [u'whoCanUnassignTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanunmarkfavoritereplyonanytopic': [u'whoCanUnmarkFavoriteReplyOnAnyTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': COLLABORATIVE_ACL_CHOICES}],
  u'whocanviewgroup': [u'whoCanViewGroup', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                            u'choices': {u'anyonecanview': u'ANYONE_CAN_VIEW', u'allindomaincanview': u'ALL_IN_DOMAIN_CAN_VIEW',
                                                         u'allmemberscanview': u'ALL_MEMBERS_CAN_VIEW', u'allmanagerscanview': u'ALL_MANAGERS_CAN_VIEW',}}],
  u'whocanviewmembership': [u'whoCanViewMembership', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                      u'choices': {u'allindomaincanview': u'ALL_IN_DOMAIN_CAN_VIEW', u'allmemberscanview': u'ALL_MEMBERS_CAN_VIEW',
                                                                   u'allmanagerscanview': u'ALL_MANAGERS_CAN_VIEW',}}],
  }

GROUP_FIELDS_WITH_CRS_NLS = [u'customFooterText', u'defaultMessageDenyNotificationText', u'description', u'groupDescription']

def getGroupAttrValue(argument, gs_body):
  if argument == u'copyfrom':
    gs_body[argument] = getEmailAddress()
    return
  attrProperties = GROUP_ATTRIBUTES.get(argument)
  if not attrProperties:
    unknownArgumentExit()
  attrName = attrProperties[0]
  attribute = attrProperties[1]
  attrType = attribute[GC.VAR_TYPE]
  if attrType == GC.TYPE_BOOLEAN:
    gs_body[attrName] = getBoolean()
  elif attrType == GC.TYPE_STRING:
    if attrName in GROUP_FIELDS_WITH_CRS_NLS:
      gs_body[attrName] = getStringWithCRsNLs()
    else:
      gs_body[attrName] = getString(Cmd.OB_STRING, minLen=0)
  elif attrType == GC.TYPE_CHOICE:
    gs_body[attrName] = getChoice(attribute[u'choices'], mapChoice=True)
  elif attrType in [GC.TYPE_EMAIL, GC.TYPE_EMAIL_OPTIONAL]:
    gs_body[attrName] = getEmailAddress(noUid=True, optional=attrType == GC.TYPE_EMAIL_OPTIONAL)
    if attrType == GC.TYPE_EMAIL_OPTIONAL and gs_body[attrName] is None:
      gs_body[attrName] = u''
  elif attrType == GC.TYPE_LANGUAGE:
    gs_body[attrName] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
  else: # GC.TYPE_INTEGER
    if attrName == u'maxMessageBytes':
      gs_body[attrName] = getMaxMessageBytes()
    else:
      gs_body[attrName] = getInteger()

def setCollaborativeAttributes(gs_body):
  choice = getChoice(COLLABORATIVE_ACL_CHOICES, mapChoice=True)
  for attrName in COLLABORATIVE_ACL_ATTRIBUTES:
    gs_body[attrName] = choice
  gs_body[u'favoriteRepliesOnTop'] = True

def GroupIsAbuseOrPostmaster(emailAddr):
  return emailAddr.startswith(u'abuse@') or emailAddr.startswith(u'postmaster@')

def getSettingsFromGroup(cd, gs, gs_body):
  if gs_body:
    copySettingsFromGroup = gs_body.pop(u'copyfrom', None)
    if copySettingsFromGroup:
      try:
        if copySettingsFromGroup.find(u'@') == -1: # group settings API won't take uid so we make sure cd API is used so that we can grab real email.
          copySettingsFromGroup = callGAPI(cd.groups(), u'get',
                                           throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                                           groupKey=copySettingsFromGroup, fields=u'email')[u'email']
        settings = callGAPI(gs.groups(), u'get',
                            throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=copySettingsFromGroup, fields=u'*')
        if settings is not None:
          for field in [u'email', u'name', u'description']:
            settings.pop(field, None)
          settings.update(gs_body)
          return settings
        else:
          entityActionNotPerformedWarning([Ent.GROUP, copySettingsFromGroup], Msg.API_ERROR_SETTINGS)
          return None
      except (GAPI.notFound, GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
              GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
              GAPI.systemError, GAPI.serviceLimit) as e:
        entityActionNotPerformedWarning([Ent.GROUP, copySettingsFromGroup], str(e))
        return None
  return gs_body

# gam create group <EmailAddress> [copyfrom <GroupItem>] <GroupAttributes>
def doCreateGroup():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {u'email': getEmailAddress(noUid=True)}
  gs_body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'collaborative':
      setCollaborativeAttributes(gs_body)
    else:
      getGroupAttrValue(myarg, gs_body)
  gs_body.setdefault(u'name', body[u'email'])
  if gs_body:
    gs = buildGAPIObject(API.GROUPSSETTINGS)
    gs_body = getSettingsFromGroup(cd, gs, gs_body)
    if not gs_body:
      return
  try:
    callGAPI(cd.groups(), u'insert',
             throw_reasons=GAPI.GROUP_CREATE_THROW_REASONS,
             body=body, fields=u'')
    if gs_body and not GroupIsAbuseOrPostmaster(body[u'email']):
      settings = callGAPI(gs.groups(), u'get',
                          throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                          groupUniqueId=body[u'email'], fields=u'*')
      settings.update(gs_body)
      callGAPI(gs.groups(), u'update',
               throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
               groupUniqueId=body[u'email'], body=settings, fields=u'')
    entityActionPerformed([Ent.GROUP, body[u'email']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.GROUP, body[u'email']])
  except (GAPI.notFound, GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
          GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
          GAPI.systemError, GAPI.serviceLimit) as e:
    entityActionFailedWarning([Ent.GROUP, body[u'email']], str(e))

def checkGroupExists(cd, group, i=0, count=0):
  group = normalizeEmailAddressOrUID(group)
  try:
    return callGAPI(cd.groups(), u'get',
                    throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                    groupKey=group, fields=u'email')[u'email']
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError):
    entityUnknownWarning(Ent.GROUP, group, i, count)
    return None

UPDATE_GROUP_SUBCMDS = [u'add', u'create', u'delete', u'remove', u'clear', u'sync', u'update']

# gam update groups <GroupEntity> [admincreated <Boolean>] [email <EmailAddress>] [copyfrom <GroupItem>] <GroupAttributes>
# gam update groups <GroupEntity> create|add [member|manager|owner] [usersonly|groupsonly] [notsuspended|suspended] <UserTypeEntity>
# gam update groups <GroupEntity> delete|remove [member|manager|owner] [usersonly|groupsonly] <UserTypeEntity>
# gam update groups <GroupEntity> sync [member|manager|owner] [usersonly|groupsonly] [addonly|removeonly] [notsuspended|suspended] <UserTypeEntity>
# gam update groups <GroupEntity> update [member|manager|owner] [usersonly|groupsonly] <UserTypeEntity>
# gam update groups <GroupEntity> clear [member] [manager] [owner] [notsuspended|suspended]
def doUpdateGroups():

# Convert foo@googlemail.com to foo@gmail.com; eliminate periods in name for foo.bar@gmail.com

  def _getRoleGroupMemberType():
    role = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
    groupMemberType = getChoice({u'usersonly': u'USER', 'groupsonly': u'GROUP'}, defaultChoice=u'ALL', mapChoice=True)
    return (role, groupMemberType)

  def _cleanConsumerAddress(emailAddress, mapCleanToOriginal):
    atLoc = emailAddress.find(u'@')
    if atLoc > 0:
      if emailAddress[atLoc+1:] in [u'gmail.com', u'googlemail.com']:
        cleanEmailAddress = emailAddress[:atLoc].replace(u'.', u'')+u'@gmail.com'
        if cleanEmailAddress != emailAddress:
          mapCleanToOriginal[cleanEmailAddress] = emailAddress
          return cleanEmailAddress
    return emailAddress

  _ADD_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI.DUPLICATE: Msg.DUPLICATE,
                                       GAPI.CONDITION_NOT_MET: Msg.DUPLICATE,
                                       GAPI.MEMBER_NOT_FOUND: Msg.DOES_NOT_EXIST,
                                       GAPI.RESOURCE_NOT_FOUND: Msg.DOES_NOT_EXIST,
                                       GAPI.INVALID_MEMBER: Msg.INVALID_MEMBER,
                                       GAPI.CYCLIC_MEMBERSHIPS_NOT_ALLOWED: Msg.WOULD_MAKE_MEMBERSHIP_CYCLE}

  def _handleDuplicateAdd(group, i, count, role, member, j, jcount):
    try:
      result = callGAPI(cd.members(), u'get',
                        throw_reasons=[GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
                        groupKey=group, memberKey=member, fields=u'role')
      entityActionFailedWarning([Ent.GROUP, group, role, member], Msg.DUPLICATE_ALREADY_A_ROLE.format(Ent.Singular(result[u'role'])), j, jcount)
      return
    except (GAPI.memberNotFound, GAPI.resourceNotFound):
      pass
    printEntityKVList([Ent.GROUP, group, role, member], [Msg.MEMBERSHIP_IS_PENDING_WILL_DELETE_ADD_TO_ACCEPT], j, jcount)
    try:
      callGAPI(cd.members(), u'delete',
               throw_reasons=[GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               groupKey=group, memberKey=member)
    except (GAPI.memberNotFound, GAPI.resourceNotFound):
      entityActionFailedWarning([Ent.GROUP, group, role, member], Msg.DUPLICATE, j, jcount)
      return
    body = {u'role': role}
    if member.find(u'@') != -1:
      body[u'email'] = member
    else:
      body[u'id'] = member
    try:
      callGAPI(cd.members(), u'insert',
               throw_reasons=[GAPI.DUPLICATE, GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND, GAPI.INVALID_MEMBER, GAPI.CYCLIC_MEMBERSHIPS_NOT_ALLOWED],
               groupKey=group, body=body, fields=u'')
      entityActionPerformed([Ent.GROUP, group, role, member], j, jcount)
    except (GAPI.duplicate, GAPI.memberNotFound, GAPI.resourceNotFound, GAPI.invalidMember, GAPI.cyclicMembershipsNotAllowed) as e:
      http_status, reason, message = checkGAPIError(e)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, group, i, count)
      else:
        errMsg = getHTTPError(_ADD_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, group, role, member], errMsg, j, jcount)

  def _callbackAddGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      elif reason in [GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET]:
        _handleDuplicateAdd(ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]), ri[RI_ROLE], ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_ADD_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchAddGroupMembers(group, i, count, addMembers, role):
    Act.Set(Act.ADD)
    jcount = len(addMembers)
    entityPerformActionNumItems([Ent.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    Ind.Increment()
    svcargs = dict([(u'groupKey', group), (u'body', {u'role': role}), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.members(), u'insert')
    dbatch = cd.new_batch_http_request(callback=_callbackAddGroupMembers)
    bcount = 0
    j = 0
    for member in addMembers:
      j += 1
      svcparms = svcargs.copy()
      member = normalizeEmailAddressOrUID(member, checkForCustomerId=True)
      if member.find(u'@') != -1:
        svcparms[u'body'][u'email'] = member
        svcparms[u'body'].pop(u'id', None)
      else:
        svcparms[u'body'][u'id'] = member
        svcparms[u'body'].pop(u'email', None)
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, member, role))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackAddGroupMembers)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

  _REMOVE_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI.MEMBER_NOT_FOUND: u'{0} {1}'.format(Msg.NOT_A, Ent.Singular(Ent.MEMBER)),
                                          GAPI.CONDITION_NOT_MET: u'{0} {1}'.format(Msg.NOT_A, Ent.Singular(Ent.MEMBER)),
                                          GAPI.INVALID_MEMBER: Msg.DOES_NOT_EXIST}

  def _callbackRemoveGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      elif reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.MEMBERS_RETRY_REASONS:
        errMsg = getHTTPError(_REMOVE_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        try:
          callGAPI(cd.members(), u'delete',
                   throw_reasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER], retry_reasons=GAPI.MEMBERS_RETRY_REASONS,
                   groupKey=ri[RI_ENTITY], memberKey=ri[RI_ITEM])
          entityActionPerformed([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.invalid, GAPI.forbidden) as e:
          entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
        except (GAPI.memberNotFound, GAPI.invalidMember) as e:
          entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchRemoveGroupMembers(group, i, count, removeMembers, role):
    Act.Set(Act.REMOVE)
    svcargs = dict([(u'groupKey', group), (u'memberKey', None)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    jcount = len(removeMembers)
    entityPerformActionNumItems([Ent.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    Ind.Increment()
    method = getattr(cd.members(), u'delete')
    dbatch = cd.new_batch_http_request(callback=_callbackRemoveGroupMembers)
    bcount = 0
    j = 0
    for member in removeMembers:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'memberKey'] = normalizeEmailAddressOrUID(member, checkForCustomerId=True)
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, svcparms[u'memberKey'], role))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackRemoveGroupMembers)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

  _UPDATE_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI.MEMBER_NOT_FOUND: u'{0} {1}'.format(Msg.NOT_A, Ent.Singular(Ent.MEMBER)),
                                          GAPI.INVALID_MEMBER: Msg.DOES_NOT_EXIST}

  def _callbackUpdateGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      else:
        errMsg = getHTTPError(_UPDATE_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchUpdateGroupMembers(group, i, count, updateMembers, role):
    Act.Set(Act.UPDATE)
    svcargs = dict([(u'groupKey', group), (u'memberKey', None), (u'body', {u'role': role}), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    jcount = len(updateMembers)
    entityPerformActionNumItems([Ent.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    Ind.Increment()
    method = getattr(cd.members(), u'update')
    dbatch = cd.new_batch_http_request(callback=_callbackUpdateGroupMembers)
    bcount = 0
    j = 0
    for member in updateMembers:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'memberKey'] = normalizeEmailAddressOrUID(member, checkForCustomerId=True)
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, svcparms[u'memberKey'], role))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackUpdateGroupMembers)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
  CL_subCommand = getChoice(UPDATE_GROUP_SUBCMDS, defaultChoice=None)
  if not CL_subCommand:
    body = {}
    gs_body = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'email':
        body[u'email'] = getEmailAddress(noUid=True)
      elif myarg == u'admincreated':
        body[u'adminCreated'] = getBoolean()
      elif myarg == u'collaborative':
        setCollaborativeAttributes(gs_body)
      else:
        getGroupAttrValue(myarg, gs_body)
    if gs_body:
      gs = buildGAPIObject(API.GROUPSSETTINGS)
      gs_body = getSettingsFromGroup(cd, gs, gs_body)
      if not gs_body:
        return
    elif not body:
      return
    Act.Set(Act.UPDATE)
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      group = normalizeEmailAddressOrUID(group)
      if gs_body and not GroupIsAbuseOrPostmaster(group):
        try:
          if group.find(u'@') == -1: # group settings API won't take uid so we make sure cd API is used so that we can grab real email.
            group = callGAPI(cd.groups(), u'get',
                             throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                             groupKey=group, fields=u'email')[u'email']
          settings = callGAPI(gs.groups(), u'get',
                              throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                              groupUniqueId=group, fields=u'*')
          settings.update(gs_body)
        except (GAPI.notFound, GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
                GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
                GAPI.systemError, GAPI.serviceLimit) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
      if body:
        try:
          group = callGAPI(cd.groups(), u'update',
                           throw_reasons=GAPI.GROUP_UPDATE_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                           groupKey=group, body=body, fields=u'email')[u'email']
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.backendError, GAPI.badRequest, GAPI.invalid, GAPI.systemError) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
      if gs_body and not GroupIsAbuseOrPostmaster(group):
        try:
          callGAPI(gs.groups(), u'update',
                   throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                   groupUniqueId=group, body=settings, fields=u'')
        except (GAPI.notFound, GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
                GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
                GAPI.systemError, GAPI.serviceLimit) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
      entityActionPerformed([Ent.GROUP, group], i, count)
  elif CL_subCommand in [u'create', u'add']:
    role, groupMemberType = _getRoleGroupMemberType()
    checkSuspended = getChoice(CHECK_SUSPENDED_CHOICE_MAP, defaultChoice=None)
    _, addMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, checkSuspended=checkSuspended, groupMemberType=groupMemberType)
    groupMemberLists = addMembers if isinstance(addMembers, dict) else None
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        addMembers = groupMemberLists[group]
      group = checkGroupExists(cd, group, i, count)
      if group:
        _batchAddGroupMembers(group, i, count, [convertUIDtoEmailAddress(member, cd=cd, emailType=u'any', checkForCustomerId=True) for member in addMembers], role)
  elif CL_subCommand in [u'delete', u'remove']:
    role, groupMemberType = _getRoleGroupMemberType()
    _, removeMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, groupMemberType=groupMemberType)
    groupMemberLists = removeMembers if isinstance(removeMembers, dict) else None
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        removeMembers = groupMemberLists[group]
      group = checkGroupExists(cd, group, i, count)
      if group:
        _batchRemoveGroupMembers(group, i, count, [convertUIDtoEmailAddress(member, cd=cd, emailType=u'any', checkForCustomerId=True) for member in removeMembers], role)
  elif CL_subCommand == u'sync':
    role, groupMemberType = _getRoleGroupMemberType()
    syncOperation = getChoice([u'addonly', 'removeonly'], defaultChoice=u'addremove')
    checkSuspended = getChoice(CHECK_SUSPENDED_CHOICE_MAP, defaultChoice=None)
    _, syncMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, checkSuspended=checkSuspended, groupMemberType=groupMemberType)
    groupMemberLists = syncMembers if isinstance(syncMembers, dict) else None
    if not groupMemberLists:
      syncMembersSet = set()
      syncMembersMap = {}
      for member in syncMembers:
        syncMembersSet.add(_cleanConsumerAddress(convertUIDtoEmailAddress(member, cd=cd, emailType=u'any', checkForCustomerId=True), syncMembersMap))
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        syncMembersSet = set()
        syncMembersMap = {}
        for member in groupMemberLists[group]:
          syncMembersSet.add(_cleanConsumerAddress(convertUIDtoEmailAddress(member, cd=cd, emailType=u'any', checkForCustomerId=True), syncMembersMap))
      group = checkGroupExists(cd, group, i, count)
      if group:
        currentMembersSet = set()
        currentMembersMap = {}
        for member in getUsersToModify(Cmd.ENTITY_GROUP, group, memberRoles=role, groupMemberType=groupMemberType):
          currentMembersSet.add(_cleanConsumerAddress(member, currentMembersMap))
        if syncOperation != u'removeonly':
          _batchAddGroupMembers(group, i, count,
                                [syncMembersMap.get(emailAddress, emailAddress) for emailAddress in syncMembersSet-currentMembersSet],
                                role)
        if syncOperation != u'addonly':
          _batchRemoveGroupMembers(group, i, count,
                                   [currentMembersMap.get(emailAddress, emailAddress) for emailAddress in currentMembersSet-syncMembersSet],
                                   role)
  elif CL_subCommand == u'update':
    role, groupMemberType = _getRoleGroupMemberType()
    _, updateMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, groupMemberType=groupMemberType)
    groupMemberLists = updateMembers if isinstance(updateMembers, dict) else None
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      if groupMemberLists:
        updateMembers = groupMemberLists[group]
      group = checkGroupExists(cd, group, i, count)
      if group:
        _batchUpdateGroupMembers(group, i, count, [convertUIDtoEmailAddress(member, cd=cd, emailType=u'any', checkForCustomerId=True) for member in updateMembers], role)
  else: #clear
    checkSuspended = None
    qualifier = u''
    fieldsList = [u'email', u'id']
    rolesSet = set()
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in GROUP_ROLES_MAP:
        rolesSet.add(GROUP_ROLES_MAP[myarg])
      elif myarg in CHECK_SUSPENDED_CHOICE_MAP:
        checkSuspended = CHECK_SUSPENDED_CHOICE_MAP[myarg]
        qualifier = [u' (Non-suspended)', u' (Suspended)'][checkSuspended]
        fieldsList.append(u'status')
      else:
        unknownArgumentExit()
    Act.Set(Act.REMOVE)
    memberRoles = u','.join(sorted(rolesSet)) if rolesSet else Ent.ROLE_MEMBER
    fields = u'nextPageToken,members({0})'.format(u','.join(set(fieldsList)))
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      group = normalizeEmailAddressOrUID(group)
      printGettingAllEntityItemsForWhom(memberRoles, group, qualifier=qualifier, entityType=Ent.GROUP)
      validRoles, listRoles, listFields = _getRoleVerification(memberRoles, fields)
      try:
        result = callGAPIpages(cd.members(), u'list', u'members',
                               page_message=getPageMessageForWhom(noNL=True),
                               throw_reasons=GAPI.MEMBERS_THROW_REASONS,
                               groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
        if checkSuspended is None:
          removeMembers = [member.get(u'email', member[u'id']) for member in result if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles]
        elif checkSuspended:
          removeMembers = [member.get(u'email', member[u'id']) for member in result if (not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles) and member[u'status'] == u'SUSPENDED']
        else: # elif not checkSuspended
          removeMembers = [member.get(u'email', member[u'id']) for member in result if (not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles) and member[u'status'] != u'SUSPENDED']
        _batchRemoveGroupMembers(group, i, count, removeMembers, Ent.ROLE_MEMBER)
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
        entityUnknownWarning(Ent.GROUP, group, i, count)

# gam delete groups <GroupEntity>
def doDeleteGroups():
  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      callGAPI(cd.groups(), u'delete',
               throw_reasons=[GAPI.GROUP_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
               groupKey=group)
      entityActionPerformed([Ent.GROUP, group], i, count)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.invalid):
      entityUnknownWarning(Ent.GROUP, group, i, count)

GROUP_FIELDS_CHOICE_MAP = {
  u'admincreated': u'adminCreated',
  u'aliases': [u'aliases', u'nonEditableAliases'],
  u'description': u'description',
  u'directmemberscount': u'directMembersCount',
  u'email': u'email',
  u'id': u'id',
  u'name': u'name',
  }

# CL argument: [API field name, CSV field title]
GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP = {
  u'admincreated': [u'adminCreated', u'Admin_Created'],
  u'aliases': [u'aliases', u'Aliases', u'nonEditableAliases', u'NonEditableAliases'],
  u'description': [u'description', u'Description'],
  u'directmemberscount': [u'directMembersCount', u'DirectMembersCount'],
  u'email': [u'email', u'Email'],
  u'id': [u'id', u'ID'],
  u'name': [u'name', u'Name'],
  }

GROUP_BASIC_FIELD_TO_GROUP_FIELD_MAP = {u'description': u'groupDescription', u'name': u'groupName'}
GROUP_BASIC_INFO_PRINT_ORDER = [u'id', u'name', u'groupName', u'description', u'groupDescription', u'directMembersCount', u'adminCreated']
INFO_GROUP_OPTIONS = [u'nousers', u'groups',]

def infoGroups(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  getAliases = getUsers = True
  getGroups = getSettings = False
  formatJSON = False
  groups = collections.deque()
  members = collections.deque()
  cdfieldsList = gsfieldsList = None
  rolesSet = set()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'quick':
      getAliases = getUsers = False
    elif myarg == u'nousers':
      getUsers = False
    elif myarg == u'noaliases':
      getAliases = False
    elif myarg in GROUP_ROLES_MAP:
      rolesSet.add(GROUP_ROLES_MAP[myarg])
      getUsers = True
    elif myarg == u'groups':
      getGroups = True
    elif myarg in GROUP_FIELDS_CHOICE_MAP:
      if not cdfieldsList:
        cdfieldsList = [u'email',]
      addFieldToFieldsList(myarg, GROUP_FIELDS_CHOICE_MAP, cdfieldsList)
      if myarg in [u'name', u'description']:
        if not gsfieldsList:
          gsfieldsList = []
        gsfieldsList.append(myarg)
    elif myarg in GROUP_ATTRIBUTES:
      if not gsfieldsList:
        gsfieldsList = []
      gsfieldsList.extend([GROUP_ATTRIBUTES[myarg][0]])
    elif myarg == u'collaborative':
      if not gsfieldsList:
        gsfieldsList = []
      gsfieldsList.extend(COLLABORATIVE_ACL_ATTRIBUTES)
    elif myarg == u'fields':
      if not cdfieldsList:
        cdfieldsList = [u'email',]
      if not gsfieldsList:
        gsfieldsList = []
      for field in _getFieldsList():
        if field in GROUP_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, GROUP_FIELDS_CHOICE_MAP, cdfieldsList)
          if field in [u'name', u'description']:
            gsfieldsList.append(field)
        elif field in GROUP_ATTRIBUTES:
          gsfieldsList.extend([GROUP_ATTRIBUTES[field][0]])
        elif field == u'collaborative':
          gsfieldsList.extend(COLLABORATIVE_ACL_ATTRIBUTES)
        else:
          invalidChoiceExit(list(GROUP_FIELDS_CHOICE_MAP)+list(GROUP_ATTRIBUTES), True)
# Ignore info user arguments that may have come from whatis
    elif myarg in INFO_USER_OPTIONS:
      if myarg == u'schemas':
        getString(Cmd.OB_SCHEMA_NAME_LIST)
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  cdfields = u','.join(set(cdfieldsList)) if cdfieldsList else None
  memberRoles = u','.join(sorted(rolesSet)) if rolesSet else None
  if gsfieldsList is None:
    getSettings = True
    gsfields = None
  elif gsfieldsList:
    getSettings = True
    gsfields = u','.join(set(gsfieldsList))
  else:
    gsfields = None
  if getSettings:
    gs = buildGAPIObject(API.GROUPSSETTINGS)
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      basic_info = callGAPI(cd.groups(), u'get',
                            throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                            groupKey=group, fields=cdfields)
      group = basic_info[u'email']
      settings = {}
      if getSettings and not GroupIsAbuseOrPostmaster(group):
        settings = callGAPI(gs.groups(), u'get',
                            throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=group, fields=gsfields) # Use email address retrieved from cd since GS API doesn't support uid
        for key in GROUP_BASIC_FIELD_TO_GROUP_FIELD_MAP:
          if key in settings and ((key not in basic_info) or (basic_info[key] != settings[key])):
            if key in basic_info:
              basic_info[GROUP_BASIC_FIELD_TO_GROUP_FIELD_MAP[key]] = basic_info.pop(key)
            basic_info[key] = settings.pop(key)
      if getGroups:
        groups = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=group, fields=u'nextPageToken,groups(name,email)')
      if getUsers:
        validRoles, listRoles, listFields = _getRoleVerification(memberRoles, u'nextPageToken,members(email,id,role,status,type)')
        members = callGAPIpages(cd.members(), u'list', u'members',
                                throw_reasons=GAPI.MEMBERS_THROW_REASONS, retry_reasons=GAPI.MEMBERS_RETRY_REASONS,
                                groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      if formatJSON:
        basic_info.update(settings)
        if getGroups:
          basic_info[u'groups'] = list(groups)
        if getUsers:
          basic_info[u'members'] = list(members)
        printLine(json.dumps(cleanJSON(basic_info, u''), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.GROUP, group], i, count)
      Ind.Increment()
      printEntity([Ent.GROUP_SETTINGS, None])
      Ind.Increment()
      for key in GROUP_BASIC_INFO_PRINT_ORDER:
        if key not in basic_info:
          continue
        value = basic_info[key]
        if isinstance(value, list):
          printKeyValueList([key, None])
          Ind.Increment()
          for val in value:
            printKeyValueList([val])
          Ind.Decrement()
        elif key not in GROUP_FIELDS_WITH_CRS_NLS:
          printKeyValueList([key, value])
        else:
          printKeyValueWithCRsNLs(key, value)
      if settings:
        for key in sorted(settings):
          if key not in set([u'kind', u'etag', u'email', u'name', u'description']):
            value = settings[key]
            if key == u'maxMessageBytes':
              printKeyValueList([key, formatMaxMessageBytes(value)])
            elif key not in GROUP_FIELDS_WITH_CRS_NLS:
              printKeyValueList([key, value])
            else:
              printKeyValueWithCRsNLs(key, value)
      Ind.Decrement()
      if getAliases:
        for up in [u'aliases', u'nonEditableAliases']:
          aliases = basic_info.get(up, [])
          if aliases:
            printEntitiesCount([Ent.NONEDITABLE_ALIAS, Ent.EMAIL_ALIAS][up == u'aliases'], aliases)
            Ind.Increment()
            for alias in aliases:
              printKeyValueList([u'alias', alias])
            Ind.Decrement()
      if getGroups:
        printEntitiesCount(Ent.GROUP, groups)
        Ind.Increment()
        for groupm in groups:
          printKeyValueList([groupm[u'name'], groupm[u'email']])
        Ind.Decrement()
      if getUsers:
        printEntitiesCount(Ent.MEMBER, members)
        Ind.Increment()
        for member in members:
          if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles:
            printKeyValueList([member.get(u'role', Ent.ROLE_MEMBER).lower(), u'{0} ({1})'.format(member.get(u'email', member[u'id']), member[u'type'].lower())])
        Ind.Decrement()
        printKeyValueList([u'Total users in group', len(members)])
      Ind.Decrement()
    except (GAPI.notFound, GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
            GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
            GAPI.systemError, GAPI.serviceLimit) as e:
      entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)

# gam info groups <GroupEntity> [members] [managers] [owners] [nousers] [quick] [noaliases] [groups] <GroupFieldName>* [fields <GroupFieldNameList>] [formatjson]
def doInfoGroups():
  infoGroups(getEntityList(Cmd.OB_GROUP_ENTITY))

def groupFilters(kwargs):
  queryTitle = ''
  if kwargs.get(u'domain'):
    queryTitle += u'{0}={1}, '.format(Ent.Singular(Ent.DOMAIN), kwargs[u'domain'])
  if kwargs.get(u'userKey'):
    queryTitle += u'{0}={1}, '.format(Ent.Singular(Ent.MEMBER), kwargs[u'userKey'])
  if kwargs.get(u'query'):
    queryTitle += u'query="{0}", '.format(kwargs[u'query'])
  if queryTitle:
    return queryTitle[:-2]
  return queryTitle

def getGroupFilters(myarg, kwargs):
  if myarg == u'domain':
    kwargs[u'domain'] = getString(Cmd.OB_DOMAIN_NAME).lower()
    kwargs.pop(u'customer', None)
  elif myarg == u'member':
    kwargs[u'userKey'] = getEmailAddress()
    kwargs.pop(u'customer', None)
  elif myarg == u'query':
    kwargs[u'query'] = getString(Cmd.OB_QUERY)
  else:
    return False
  if kwargs.get(u'userKey') and kwargs.get(u'query'):
    usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format(u'member', u'query'))
  return True

def getGroupMatchPatterns(myarg, matchPatterns):
  if myarg == u'emailmatchpattern':
    matchPatterns[u'email'] = getREPattern(re.IGNORECASE)
  elif myarg == u'namematchpattern':
    matchPatterns[u'name'] = getREPattern(re.IGNORECASE|re.UNICODE)
  elif myarg == u'descriptionmatchpattern':
    matchPatterns[u'description'] = getREPattern(re.IGNORECASE|re.UNICODE)
  else:
    return False
  return True

def updateFieldsTitlesForGroupMatchPatterns(matchPatterns, fieldsList, fieldsTitles=None, titles=None, nativeTitles=None):
  for field in [u'name', u'description']:
    if matchPatterns.get(field):
      if fieldsTitles is not None:
        addFieldTitleToCSVfile(field, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, fieldsList, fieldsTitles, titles, nativeTitles)
      else:
        fieldsList.append(field)

def clearUnneededGroupMatchPatterns(matchPatterns):
  for field in [u'name', u'description']:
    matchPatterns.pop(field, None)

def checkGroupMatchPatterns(groupEmail, group, matchPatterns):
  for field, pattern in iteritems(matchPatterns):
    if field == u'email':
      if not pattern.match(groupEmail):
        return False
    elif not pattern.match(group[field]):
      return False
  return True

PRINT_GROUPS_JSON_TITLES = [u'Email', u'JSON']

# gam print groups [todrive [<ToDriveAttributes>]] ([domain <DomainName>] ([member <UserItem>]|[query <QueryGroup>]))|[select <GroupEntity>]
#	[emailmatchpattern <RegularExpression>] [namematchpattern <RegularExpression>] [descriptionmatchpattern <RegularExpression>]
#	[maxresults <Number>] [allfields|([settings] <GroupFieldName>* [fields <GroupFieldNameList>])]
#	[members|memberscount] [managers|managerscount] [owners|ownerscount] [countsonly]
#	[convertcrnl] [delimiter <Character>] [sortheaders] [formatjson] [quotechar <Character>]
def doPrintGroups():

  def _printGroupRow(groupEntity, groupMembers, groupSettings):
    row = {}
    if formatJSON:
      row[u'Email'] = groupEntity[u'email']
      row[u'JSON'] = json.dumps(groupEntity, ensure_ascii=False, sort_keys=True)
      if memberRoles and groupMembers is not None:
        row[u'JSON-members'] = json.dumps(groupMembers, ensure_ascii=False, sort_keys=True)
      if isinstance(groupSettings, dict):
        row[u'JSON-settings'] = json.dumps(groupSettings, ensure_ascii=False, sort_keys=True)
      csvRows.append(row)
      return
    for field in cdfieldsList:
      if field in groupEntity:
        if isinstance(groupEntity[field], list):
          row[fieldsTitles[field]] = delimiter.join(groupEntity[field])
        elif convertCRNL and field in GROUP_FIELDS_WITH_CRS_NLS:
          row[fieldsTitles[field]] = escapeCRsNLs(groupEntity[field])
        else:
          row[fieldsTitles[field]] = groupEntity[field]
    if groupMembers is not None:
      if members:
        membersList = []
        membersCount = 0
      if managers:
        managersList = []
        managersCount = 0
      if owners:
        ownersList = []
        ownersCount = 0
      for member in groupMembers:
        member_email = member.get(u'email', member.get(u'id', None))
        if not member_email:
          writeStderr(u' Not sure what to do with: {0}\n'.format(member))
          continue
        role = member.get(u'role', Ent.ROLE_MEMBER)
        if role == Ent.ROLE_MEMBER:
          if members:
            membersCount += 1
            if not membersCountOnly:
              membersList.append(member_email)
        elif role == Ent.ROLE_MANAGER:
          if managers:
            managersCount += 1
            if not managersCountOnly:
              managersList.append(member_email)
        elif role == Ent.ROLE_OWNER:
          if owners:
            ownersCount += 1
            if not ownersCountOnly:
              ownersList.append(member_email)
        elif members:
          membersCount += 1
          if not membersCountOnly:
            membersList.append(member_email)
      if members:
        row[u'MembersCount'] = membersCount
        if not membersCountOnly:
          row[u'Members'] = delimiter.join(membersList)
      if managers:
        row[u'ManagersCount'] = managersCount
        if not managersCountOnly:
          row[u'Managers'] = delimiter.join(managersList)
      if owners:
        row[u'OwnersCount'] = ownersCount
        if not ownersCountOnly:
          row[u'Owners'] = delimiter.join(ownersList)
    if isinstance(groupSettings, dict):
      for key in groupSettings:
        if key not in set([u'kind', u'etag', u'email', u'name', u'description']):
          setting_value = groupSettings[key]
          if setting_value is None:
            setting_value = u''
          if key not in titles[u'set']:
            addTitleToCSVfile(key, titles)
          if convertCRNL and key in GROUP_FIELDS_WITH_CRS_NLS:
            row[key] = escapeCRsNLs(setting_value)
          else:
            row[key] = setting_value
    csvRows.append(row)

  def _callbackProcessGroupBasic(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.GROUP_GET_RETRY_REASONS:
        if reason in GAPI.GROUP_GET_THROW_REASONS:
          entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], i, int(ri[RI_COUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP, None], errMsg, i, int(ri[RI_COUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.groups(), u'get',
                            throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                            groupKey=ri[RI_ENTITY], fields=cdfields)
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP, None], str(e), i, int(ri[RI_COUNT]))
        return
    entityList.append(response)

  def _callbackProcessGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    totalItems = 0
    items = u'members'
    page_message = getPageMessageForWhom(forWhom=ri[RI_ENTITY], showTotal=False, showFirstLastItems=True)
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.MEMBERS_RETRY_REASONS:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], errMsg, i, int(ri[RI_COUNT]))
        groupData[i][u'required'] -= 1
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.members(), u'list',
                            throw_reasons=GAPI.MEMBERS_THROW_REASONS, retry_reasons=GAPI.MEMBERS_RETRY_REASONS,
                            groupKey=ri[RI_ENTITY], roles=ri[RI_ROLE], fields=u'nextPageToken,members(email,id,role)',
                            maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.invalid, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], str(e), i, int(ri[RI_COUNT]))
        groupData[i][u'required'] -= 1
        return
    while True:
      pageToken, totalItems = _processGAPIpagesResult(response, items, groupData[i][items], totalItems, page_message, u'email', ri[RI_ROLE])
      if not pageToken:
        break
      try:
        response = callGAPI(cd.members(), u'list',
                            throw_reasons=GAPI.MEMBERS_THROW_REASONS, retry_reasons=GAPI.MEMBERS_RETRY_REASONS,
                            pageToken=pageToken,
                            groupKey=ri[RI_ENTITY], roles=ri[RI_ROLE], fields=u'nextPageToken,members(email,id,role)',
                            maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.invalid, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], str(e), i, int(ri[RI_COUNT]))
        break
    groupData[i][u'required'] -= 1

  def _callbackProcessGroupSettings(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.GROUP_SETTINGS_RETRY_REASONS:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP_SETTINGS, None], errMsg, i, int(ri[RI_COUNT]))
        groupData[i][u'required'] -= 1
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(gs.groups(), u'get',
                            throw_reasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retry_reasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=ri[RI_ENTITY], fields=gsfields)
      except (GAPI.notFound, GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
              GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
              GAPI.systemError, GAPI.serviceLimit) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP_SETTINGS, None], str(e), i, int(ri[RI_COUNT]))
        response = {}
    groupData[i][u'settings'] = response
    groupData[i][u'required'] -= 1

  def _writeCompleteRows():
    complete = [k for k in groupData if groupData[k][u'required'] == 0]
    for k in complete:
      _printGroupRow(groupData[k][u'entity'], groupData[k][u'members'], groupData[k][u'settings'])
      del groupData[k]

  cd = buildGAPIObject(API.DIRECTORY)
  kwargs = {u'customer': GC.Values[GC.CUSTOMER_ID]}
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  formatJSON = getSettings = members = membersCountOnly = managers = managersCountOnly = owners = ownersCountOnly = sortHeaders = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  todrive = {}
  maxResults = None
  cdfieldsList = []
  gsfieldsList = []
  fieldsTitles = {}
  nativeTitles = []
  titles, csvRows = initializeTitlesCSVfile(None)
  addFieldTitleToCSVfile(u'email', GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles, nativeTitles)
  rolesSet = set()
  entitySelection = None
  matchPatterns = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif getGroupFilters(myarg, kwargs):
      pass
    elif getGroupMatchPatterns(myarg, matchPatterns):
      pass
    elif myarg == u'select':
      entitySelection = getEntityList(Cmd.OB_GROUP_ENTITY)
    elif myarg == u'maxresults':
      maxResults = getInteger(minVal=1)
    elif myarg in [u'convertcrnl', u'converttextnl', u'convertfooternl']:
      convertCRNL = True
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'settings':
      getSettings = sortHeaders = True
    elif myarg == u'allfields':
      getSettings = sortHeaders = True
      cdfieldsList = []
      gsfieldsList = []
      fieldsTitles = {}
      for field in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
        addFieldTitleToCSVfile(field, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles, nativeTitles)
    elif myarg == u'sortheaders':
      sortHeaders = getBoolean()
    elif myarg in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
      addFieldTitleToCSVfile(myarg, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles, nativeTitles)
    elif myarg in GROUP_ATTRIBUTES:
      addFieldTitleToCSVfile(myarg, {myarg: [GROUP_ATTRIBUTES[myarg][0], GROUP_ATTRIBUTES[myarg][0]]}, gsfieldsList, fieldsTitles, titles, nativeTitles)
    elif myarg == u'collaborative':
      for attr in COLLABORATIVE_ACL_ATTRIBUTES:
        attr = attr.lower()
        addFieldTitleToCSVfile(attr, {attr: [GROUP_ATTRIBUTES[attr][0], GROUP_ATTRIBUTES[attr][0]]}, gsfieldsList, fieldsTitles, titles, nativeTitles)
    elif myarg == u'fields':
      for field in _getFieldsList():
        if field in GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP:
          addFieldTitleToCSVfile(field, GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP, cdfieldsList, fieldsTitles, titles, nativeTitles)
        elif field in GROUP_ATTRIBUTES:
          addFieldTitleToCSVfile(field, {field: [GROUP_ATTRIBUTES[field][0], GROUP_ATTRIBUTES[field][0]]}, gsfieldsList, fieldsTitles, titles, nativeTitles)
        elif field == u'collaborative':
          for attr in COLLABORATIVE_ACL_ATTRIBUTES:
            attr = attr.lower()
            addFieldTitleToCSVfile(attr, {attr: [GROUP_ATTRIBUTES[attr][0], GROUP_ATTRIBUTES[attr][0]]}, gsfieldsList, fieldsTitles, titles, nativeTitles)
        else:
          invalidChoiceExit(list(GROUP_ARGUMENT_TO_PROPERTY_TITLE_MAP)+list(GROUP_ATTRIBUTES), True)
    elif myarg in [u'members', u'memberscount']:
      rolesSet.add(Ent.ROLE_MEMBER)
      members = True
      if myarg == u'memberscount':
        membersCountOnly = True
    elif myarg in [u'managers', u'managerscount']:
      rolesSet.add(Ent.ROLE_MANAGER)
      managers = True
      if myarg == u'managerscount':
        managersCountOnly = True
    elif myarg in [u'owners', u'ownerscount']:
      rolesSet.add(Ent.ROLE_OWNER)
      owners = True
      if myarg == u'ownerscount':
        ownersCountOnly = True
    elif myarg == u'countsonly':
      membersCountOnly = managersCountOnly = ownersCountOnly = True
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  updateFieldsTitlesForGroupMatchPatterns(matchPatterns, cdfieldsList, fieldsTitles, titles, nativeTitles)
  if cdfieldsList:
    cdfields = u','.join(set(cdfieldsList))
    cdfieldsnp = u'nextPageToken,groups({0})'.format(cdfields)
  else:
    cdfields = cdfieldsnp = None
  if gsfieldsList:
    getSettings = True
    gsfields = u','.join(set(gsfieldsList))
  else:
    gsfields = None
  if GC.Values[GC.PRINT_NATIVE_NAMES]:
    convertToNativeTitles(fieldsTitles, titles, nativeTitles)
  if getSettings:
    gs = buildGAPIObject(API.GROUPSSETTINGS)
  memberRoles = u','.join(sorted(rolesSet)) if rolesSet else None
  rolesOrSettings = memberRoles or getSettings
  if memberRoles:
    if members:
      addTitlesToCSVfile(u'MembersCount', titles)
      if not membersCountOnly:
        addTitlesToCSVfile(u'Members', titles)
    if managers:
      addTitlesToCSVfile(u'ManagersCount', titles)
      if not managersCountOnly:
        addTitlesToCSVfile(u'Managers', titles)
    if owners:
      addTitlesToCSVfile(u'OwnersCount', titles)
      if not ownersCountOnly:
        addTitlesToCSVfile(u'Owners', titles)
  if formatJSON:
    sortHeaders = False
    titles, csvRows = initializeTitlesCSVfile(PRINT_GROUPS_JSON_TITLES)
    if memberRoles:
      addTitleToCSVfile(u'JSON-members', titles)
    if getSettings:
      addTitleToCSVfile(u'JSON-settings', titles)
  if entitySelection is None:
    printGettingAllAccountEntities(Ent.GROUP, groupFilters(kwargs))
    try:
      entityList = callGAPIpages(cd.groups(), u'list', u'groups',
                                 page_message=getPageMessage(showTotal=False, showFirstLastItems=True), message_attribute=u'email',
                                 throw_reasons=[GAPI.INVALID_MEMBER, GAPI.RESOURCE_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID_INPUT],
                                 fields=cdfieldsnp, maxResults=maxResults, **kwargs)
    except GAPI.invalidMember:
      badRequestWarning(Ent.GROUP, Ent.MEMBER, kwargs[u'userKey'])
      entityList = collections.deque()
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get(u'domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs[u'domain'])
        entityList = collections.deque()
      else:
        accessErrorExit(cd)
    except GAPI.invalidInput:
      badRequestWarning(Ent.GROUP, Ent.QUERY, invalidQuery(kwargs[u'query']))
      entityList = collections.deque()
  else:
    svcargs = dict([(u'groupKey', None), (u'fields', cdfields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    cdmethod = getattr(cd.groups(), u'get')
    cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupBasic)
    cdbcount = 0
    entityList = collections.deque()
    i = 0
    count = len(entitySelection)
    for groupEntity in entitySelection:
      i += 1
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = normalizeEmailAddressOrUID(groupEntity)
      printGettingEntityItem(Ent.GROUP, svcparms[u'groupKey'], i, count)
      cdbatch.add(cdmethod(**svcparms), request_id=batchRequestID(svcparms[u'groupKey'], i, count, 0, 0, None))
      cdbcount += 1
      if cdbcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(cdbatch)
        cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupBasic)
        cdbcount = 0
    if cdbcount > 0:
      executeBatch(cdbatch)
  required = 0
  if memberRoles:
    required += 1
    svcargs = dict([(u'groupKey', None), (u'roles', memberRoles), (u'fields', u'nextPageToken,members(email,id,role)'), (u'maxResults', GC.Values[GC.MEMBER_MAX_RESULTS])]+GM.Globals[GM.EXTRA_ARGS_LIST])
  if getSettings:
    required += 1
    svcargsgs = dict([(u'groupUniqueId', None), (u'fields', gsfields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
  cdmethod = getattr(cd.members(), u'list')
  cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupMembers)
  cdbcount = 0
  if getSettings:
    gsmethod = getattr(gs.groups(), u'get')
    gsbatch = gs.new_batch_http_request(callback=_callbackProcessGroupSettings)
    gsbcount = 0
  groupData = {}
  i = 0
  count = len(entityList)
  for groupEntity in entityList:
    i += 1
    groupEmail = groupEntity[u'email']
    if not checkGroupMatchPatterns(groupEmail, groupEntity, matchPatterns):
      continue
    if not rolesOrSettings:
      _printGroupRow(groupEntity, None, None)
      continue
    groupData[i] = {u'entity': groupEntity, u'members': [], u'settings': getSettings, u'required': required}
    if memberRoles:
      printGettingEntityItemForWhom(memberRoles, groupEmail, i, count)
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = groupEmail
      cdbatch.add(cdmethod(**svcparms), request_id=batchRequestID(groupEmail, i, count, 0, 0, None, memberRoles))
      cdbcount += 1
      if cdbcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(cdbatch)
        cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupMembers)
        cdbcount = 0
        _writeCompleteRows()
    if getSettings:
      if not GroupIsAbuseOrPostmaster(groupEmail):
        printGettingEntityItemForWhom(Ent.GROUP_SETTINGS, groupEmail, i, count)
        svcparmsgs = svcargsgs.copy()
        svcparmsgs[u'groupUniqueId'] = groupEmail
        gsbatch.add(gsmethod(**svcparmsgs), request_id=batchRequestID(groupEmail, i, count, 0, 0, None))
        gsbcount += 1
        if gsbcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(gsbatch)
          gsbatch = gs.new_batch_http_request(callback=_callbackProcessGroupSettings)
          gsbcount = 0
          _writeCompleteRows()
      else:
        groupData[i][u'settings'] = False
        groupData[i][u'required'] -= 1
  if cdbcount > 0:
    executeBatch(cdbatch)
  if getSettings and gsbcount > 0:
    executeBatch(gsbatch)
  _writeCompleteRows()
  writeCSVfile(csvRows, titles, u'Groups', todrive, [fieldsTitles[u'email']] if sortHeaders else None, quotechar)

def getGroupMembers(cd, groupEmail, memberRoles, membersList, membersSet, i, count, checkSuspended, noduplicates, recursive, level):
  try:
    printGettingAllEntityItemsForWhom(memberRoles if memberRoles else Ent.ROLE_MANAGER_MEMBER_OWNER, groupEmail, i, count)
    validRoles, listRoles, listFields = _getRoleVerification(memberRoles, u'nextPageToken,members(email,id,role,status,type)')
    groupMembers = callGAPIpages(cd.members(), u'list', u'members',
                                 throw_reasons=GAPI.MEMBERS_THROW_REASONS, retry_reasons=GAPI.MEMBERS_RETRY_REASONS,
                                 groupKey=groupEmail, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
    if not recursive:
      if noduplicates:
        for member in groupMembers:
          if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles:
            if (checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED')) and member[u'id'] not in membersSet:
              membersSet.add(member[u'id'])
              membersList.append(member)
      else:
        for member in groupMembers:
          if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles:
            if checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED'):
              membersList.append(member)
    elif noduplicates:
      groupMemberList = []
      for member in groupMembers:
        if member[u'type'] == u'USER':
          if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles:
            if (checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED')) and member[u'id'] not in membersSet:
              membersSet.add(member[u'id'])
              member[u'level'] = level
              member[u'subgroup'] = groupEmail
              membersList.append(member)
        elif member[u'type'] == u'GROUP':
          if member[u'id'] not in membersSet:
            membersSet.add(member[u'id'])
            groupMemberList.append(member[u'email'])
      for member in groupMemberList:
        getGroupMembers(cd, member, memberRoles, membersList, membersSet, i, count, checkSuspended, noduplicates, recursive, level+1)
    else:
      for member in groupMembers:
        if member[u'type'] == u'USER':
          if not validRoles or member.get(u'role', Ent.ROLE_MEMBER) in validRoles:
            if checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED'):
              member[u'level'] = level
              member[u'subgroup'] = groupEmail
              membersList.append(member)
        elif member[u'type'] == u'GROUP':
          getGroupMembers(cd, member[u'email'], memberRoles, membersList, membersSet, i, count, checkSuspended, noduplicates, recursive, level+1)
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
    entityUnknownWarning(Ent.GROUP, groupEmail, i, count)

GROUPMEMBERS_FIELDS_CHOICE_MAP = {
  u'email': u'email',
  u'group': u'group',
  u'groupemail': u'group',
  u'id': u'id',
  u'name': u'name',
  u'role': u'role',
  u'status': u'status',
  u'type': u'type',
  u'useremail': u'email',
  }

GROUPMEMBERS_DEFAULT_FIELDS = [u'id', u'role', u'group', u'email', u'type', u'status']

# gam print group-members|groups-members [todrive [<ToDriveAttributes>]]
#	([domain <DomainName>] ([member <UserItem>]|[query <QueryGroup>]))|[group|group_ns|group_susp <GroupItem>]|[select <GroupEntity>] [notsuspended|suspended]
#	[emailmatchpattern <RegularExpression>] [namematchpattern <RegularExpression>] [descriptionmatchpattern <RegularExpression>]
#	[roles <GroupRoleList>] [members] [managers] [owners] [membernames] <MembersFieldName>* [fields <MembersFieldNameList>]
#	[userfields <UserFieldNameList>] [recursive [noduplicates]] [nogroupemail]
def doPrintGroupMembers():
  cd = buildGAPIObject(API.DIRECTORY)
  membernames = noduplicates = recursive = False
  groupColumn = True
  todrive = {}
  kwargs = {u'customer': GC.Values[GC.CUSTOMER_ID]}
  subTitle = u'{0} {1}'.format(Msg.ALL, Ent.Plural(Ent.GROUP))
  fieldsList = []
  titles, csvRows = initializeTitlesCSVfile([u'group',])
  entityList = None
  cdfieldsList = [u'email',]
  userFieldsList = []
  rolesSet = set()
  checkSuspended = None
  matchPatterns = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif getGroupFilters(myarg, kwargs):
      pass
    elif getGroupMatchPatterns(myarg, matchPatterns):
      pass
    elif myarg in [u'group', u'groupns', u'groususp']:
      entityList = [getEmailAddress()]
      subTitle = u'{0}={1}'.format(Ent.Singular(Ent.GROUP), entityList[0])
      if myarg == u'groupns':
        checkSuspended = False
      elif myarg == u'groupsusp':
        checkSuspended = True
    elif myarg == u'select':
      entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
      subTitle = u'{0} {1}'.format(Msg.SELECTED, Ent.Plural(Ent.GROUP))
    elif myarg in CHECK_SUSPENDED_CHOICE_MAP:
      checkSuspended = CHECK_SUSPENDED_CHOICE_MAP[myarg]
    elif myarg in [u'role', u'roles']:
      for role in getString(Cmd.OB_GROUP_ROLE_LIST).lower().replace(u',', u' ').split():
        if role in GROUP_ROLES_MAP:
          rolesSet.add(GROUP_ROLES_MAP[role])
        else:
          invalidChoiceExit(GROUP_ROLES_MAP, True)
    elif myarg in GROUP_ROLES_MAP:
      rolesSet.add(GROUP_ROLES_MAP[myarg])
    elif getFieldsListTitles(myarg, GROUPMEMBERS_FIELDS_CHOICE_MAP, fieldsList, titles):
      pass
    elif myarg == u'membernames':
      membernames = True
    elif myarg == u'userfields':
      for field in _getFieldsList():
        if field in USER_FIELDS_CHOICE_MAP:
          addFieldToCSVfile(field, USER_FIELDS_CHOICE_MAP, userFieldsList, titles)
        else:
          invalidChoiceExit(USER_FIELDS_CHOICE_MAP, True)
    elif myarg == u'noduplicates':
      noduplicates = True
    elif myarg == u'recursive':
      recursive = True
    elif myarg == u'nogroupemail':
      groupColumn = False
    else:
      unknownArgumentExit()
  if entityList is None:
    updateFieldsTitlesForGroupMatchPatterns(matchPatterns, cdfieldsList)
    subTitle = groupFilters(kwargs)
    printGettingAllAccountEntities(Ent.GROUP, subTitle)
    try:
      entityList = callGAPIpages(cd.groups(), u'list', u'groups',
                                 page_message=getPageMessage(showTotal=False, showFirstLastItems=True), message_attribute=u'email',
                                 throw_reasons=[GAPI.INVALID_MEMBER, GAPI.RESOURCE_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID_INPUT],
                                 fields=u'nextPageToken,groups({0})'.format(u','.join(set(cdfieldsList))), **kwargs)
    except GAPI.invalidMember:
      badRequestWarning(Ent.GROUP, Ent.MEMBER, kwargs[u'userKey'])
      entityList = collections.deque()
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get(u'domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs[u'domain'])
        entityList = collections.deque()
      else:
        accessErrorExit(cd)
    except GAPI.invalidInput:
      badRequestWarning(Ent.GROUP, Ent.QUERY, invalidQuery(kwargs[u'query']))
      entityList = collections.deque()
  else:
    clearUnneededGroupMatchPatterns(matchPatterns)
  if not fieldsList:
    for field in GROUPMEMBERS_DEFAULT_FIELDS:
      addFieldToCSVfile(field, {field: field}, fieldsList, titles)
  elif u'name'in fieldsList:
    membernames = True
    fieldsList.remove(u'name')
  if u'group' in fieldsList:
    fieldsList.remove(u'group')
  if not groupColumn:
    removeTitlesFromCSVfile([u'group',], titles)
  if userFieldsList:
    if not membernames and u'name.fullName' in userFieldsList:
      membernames = True
  if membernames:
    if u'name.fullName' not in userFieldsList:
      userFieldsList.append(u'name.fullName')
    addTitlesToCSVfile(u'name', titles)
    removeTitlesFromCSVfile([u'name.fullName'], titles)
  userFields = u','.join(set(userFieldsList)).replace(u'.', u'/') if userFieldsList else None
  memberRoles = u','.join(sorted(rolesSet)) if rolesSet else None
  membersSet = set()
  level = 0
  customerKey = GC.Values[GC.CUSTOMER_ID]
  setCustomerMemberEmail = u'email' in fieldsList
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    if isinstance(group, dict):
      groupEmail = group[u'email']
    else:
      groupEmail = convertUIDtoEmailAddress(group, cd, u'group')
    if not checkGroupMatchPatterns(groupEmail, group, matchPatterns):
      continue
    membersList = []
    getGroupMembers(cd, groupEmail, memberRoles, membersList, membersSet, i, count, checkSuspended, noduplicates, recursive, level)
    for member in membersList:
      memberId = member[u'id']
      row = {}
      if groupColumn:
        row[u'group'] = groupEmail
      if recursive:
        row[u'level'] = member[u'level']
        row[u'subgroup'] = member[u'subgroup']
      for title in fieldsList:
        row[title] = member.get(title, u'')
      if setCustomerMemberEmail and (memberId == customerKey):
        row[u'email'] = memberId
      if userFieldsList:
        if membernames:
          row[u'name'] = u'Unknown'
        memberType = member.get(u'type')
        if memberType == u'USER':
          try:
            mbinfo = callGAPI(cd.users(), u'get',
                              throw_reasons=GAPI.USER_GET_THROW_REASONS,
                              userKey=memberId, fields=userFields)
            if membernames:
              row[u'name'] = mbinfo[u'name'].pop(u'fullName')
            addRowTitlesToCSVfile(flattenJSON(mbinfo, flattened=row), csvRows, titles)
            continue
          except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
            pass
        elif memberType == u'GROUP':
          if membernames:
            try:
              row[u'name'] = callGAPI(cd.groups(), u'get',
                                      throw_reasons=GAPI.GROUP_GET_THROW_REASONS, retry_reasons=GAPI.GROUP_GET_RETRY_REASONS,
                                      groupKey=memberId, fields=u'name')[u'name']
            except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError):
              pass
        elif memberType == u'CUSTOMER':
          if membernames:
            try:
              row[u'name'] = callGAPI(cd.customers(), u'get',
                                      throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                      customerKey=memberId, fields=u'customerDomain')[u'customerDomain']
            except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
              pass
      csvRows.append(row)
  sortCSVTitles(GROUPMEMBERS_DEFAULT_FIELDS, titles)
  if recursive:
    removeTitlesFromCSVfile([u'level', u'subgroup'], titles)
    addTitlesToCSVfile([u'level', u'subgroup'], titles)
  writeCSVfile(csvRows, titles, u'Group Members ({0})'.format(subTitle), todrive)

# gam show group-members
#	([domain <DomainName>] ([member <UserItem>]|[query <QueryGroup>]))|[group|group_ns|group_susp <GroupItem>]|[select <GroupEntity>] [notsuspended|suspended]
#	[emailmatchpattern <RegularExpression>] [namematchpattern <RegularExpression>] [descriptionmatchpattern <RegularExpression>]
#	[roles <GroupRoleList>] [members] [managers] [owners] [depth <Number>]
def doShowGroupMembers():
  def _roleOrder(key):
    return {Ent.ROLE_OWNER: 0, Ent.ROLE_MANAGER: 1, Ent.ROLE_MEMBER: 2}.get(key, 3)

  def _typeOrder(key):
    return {u'CUSTOMER': 0, u'USER': 1, u'GROUP': 2, u'EXTERNAL': 3}.get(key, 4)

  def _statusOrder(key):
    return {u'ACTIVE': 0, U'SUSPENDED': 1, u'UNKNOWN': 2}.get(key, 3)

  def _showGroup(groupEmail, depth):
    try:
      membersList = callGAPIpages(cd.members(), u'list', u'members',
                                  throw_reasons=GAPI.MEMBERS_THROW_REASONS, retry_reasons=GAPI.MEMBERS_RETRY_REASONS,
                                  groupKey=groupEmail, fields=u'nextPageToken,members(email,id,role,status,type)', maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      if depth == 0:
        printEntity([Ent.GROUP, groupEmail], i, count)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      if depth == 0:
        entityUnknownWarning(Ent.GROUP, groupEmail, i, count)
      return
    Ind.Increment()
    for member in sorted(membersList, key=lambda k: (_roleOrder(k.get(u'role', Ent.ROLE_MEMBER)), _typeOrder(k[u'type']), _statusOrder(k['status']))):
      if checkSuspended is None or (not checkSuspended and member[u'status'] != u'SUSPENDED') or (checkSuspended and member[u'status'] == u'SUSPENDED'):
        if (member.get(u'role', Ent.ROLE_MEMBER) in rolesSet) or (member[u'type'] == u'GROUP'):
          printKeyValueList([u'{0}, {1}, {2}, {3}'.format(member.get(u'role', Ent.ROLE_MEMBER), member[u'type'], member.get(u'email', member[u'id']), member[u'status'])])
        if (member[u'type'] == u'GROUP') and (maxdepth == -1 or depth < maxdepth):
          _showGroup(member[u'email'], depth+1)
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  customerKey = GC.Values[GC.CUSTOMER_ID]
  kwargs = {u'customer': customerKey}
  entityList = None
  cdfieldsList = [u'email',]
  rolesSet = set()
  checkSuspended = None
  matchPatterns = {}
  maxdepth = -1
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if getGroupFilters(myarg, kwargs):
      pass
    elif getGroupMatchPatterns(myarg, matchPatterns):
      pass
    elif myarg in [u'group', u'groupns', u'groupsusp']:
      entityList = [getEmailAddress()]
      if myarg == u'groupns':
        checkSuspended = False
      elif myarg == u'groupsusp':
        checkSuspended = True
    elif myarg == u'select':
      entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
    elif myarg in CHECK_SUSPENDED_CHOICE_MAP:
      checkSuspended = CHECK_SUSPENDED_CHOICE_MAP[myarg]
    elif myarg in [u'role', u'roles']:
      for role in getString(Cmd.OB_GROUP_ROLE_LIST).lower().replace(u',', u' ').split():
        if role in GROUP_ROLES_MAP:
          rolesSet.add(GROUP_ROLES_MAP[role])
        else:
          invalidChoiceExit(GROUP_ROLES_MAP, True)
    elif myarg in GROUP_ROLES_MAP:
      rolesSet.add(GROUP_ROLES_MAP[myarg])
    elif myarg == u'depth':
      maxdepth = getInteger(minVal=-1)
    else:
      unknownArgumentExit()
  if not rolesSet:
    rolesSet = set([Ent.ROLE_MANAGER, Ent.ROLE_MEMBER, Ent.ROLE_OWNER])
  if entityList is None:
    updateFieldsTitlesForGroupMatchPatterns(matchPatterns, cdfieldsList)
    printGettingAllAccountEntities(Ent.GROUP, groupFilters(kwargs))
    try:
      groupsList = callGAPIpages(cd.groups(), u'list', u'groups',
                                 page_message=getPageMessage(showTotal=False, showFirstLastItems=True), message_attribute=u'email',
                                 throw_reasons=[GAPI.INVALID_MEMBER, GAPI.RESOURCE_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID_INPUT],
                                 fields=u'nextPageToken,groups({0})'.format(u','.join(set(cdfieldsList))), **kwargs)
    except GAPI.invalidMember:
      badRequestWarning(Ent.GROUP, Ent.MEMBER, kwargs[u'userKey'])
      return
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get(u'domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs[u'domain'])
        return
      accessErrorExit(cd)
    except GAPI.invalidInput:
      badRequestWarning(Ent.GROUP, Ent.QUERY, invalidQuery(kwargs[u'query']))
      return
  else:
    clearUnneededGroupMatchPatterns(matchPatterns)
    groupsList = collections.deque()
    for group in entityList:
      if isinstance(group, dict):
        groupsList.append({u'email': group[u'email']})
      else:
        groupsList.append({u'email': convertUIDtoEmailAddress(group, cd, u'group')})
  i = 0
  count = len(groupsList)
  for group in groupsList:
    i += 1
    groupEmail = group[u'email']
    if checkGroupMatchPatterns(groupEmail, group, matchPatterns):
      _showGroup(groupEmail, 0)

# gam print licenses [todrive [<ToDriveAttributes>]] [(products|product <ProductIDList>)|(skus|sku <SKUIDList>)]
def doPrintLicenses(returnFields=None, skus=None):
  lic = buildGAPIObject(API.LICENSING)
  products = []
  feed = collections.deque()
  if not returnFields:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'userId', u'productId', u'skuId', u'skuDisplay'])
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'todrive':
        todrive = getTodriveParameters()
      elif myarg in [u'products', u'product']:
        products = getGoogleProductList()
        skus = []
      elif myarg in [u'sku', u'skus']:
        skus = getGoogleSKUList()
        products = []
      else:
        unknownArgumentExit()
    fields = u'nextPageToken,items(productId,skuId,userId)'
  else:
    fields = u'nextPageToken,items({0})'.format(returnFields)
  if skus:
    for skuId in skus:
      Ent.SetGetting(Ent.LICENSE)
      try:
        productId, skuId = SKU.getProductAndSKU(skuId)
        feed += callGAPIpages(lic.licenseAssignments(), u'listForProductAndSku', u'items',
                              page_message=getPageMessageForWhom(forWhom=skuId),
                              throw_reasons=[GAPI.INVALID, GAPI.FORBIDDEN],
                              customerId=GC.Values[GC.DOMAIN], productId=productId, skuId=skuId, fields=fields)
      except (GAPI.invalid, GAPI.forbidden) as e:
        entityActionNotPerformedWarning([Ent.PRODUCT, productId, Ent.SKU, skuId], str(e))
  else:
    if not products:
      products = SKU.getSortedProductList()
    for productId in products:
      Ent.SetGetting(Ent.LICENSE)
      try:
        feed += callGAPIpages(lic.licenseAssignments(), u'listForProduct', u'items',
                              page_message=getPageMessageForWhom(forWhom=productId),
                              throw_reasons=[GAPI.INVALID, GAPI.FORBIDDEN],
                              customerId=GC.Values[GC.DOMAIN], productId=productId, fields=fields)
      except (GAPI.invalid, GAPI.forbidden) as e:
        entityActionNotPerformedWarning([Ent.PRODUCT, productId], str(e))
  if returnFields:
    if returnFields == u'userId':
      userIds = []
      while feed:
        u_license = feed.popleft()
        userId = u_license.get(u'userId', u'').lower()
        if userId:
          userIds.append(userId)
      return userIds
    else:
      userSkuIds = {}
      while feed:
        u_license = feed.popleft()
        userId = u_license.get(u'userId', u'').lower()
        skuId = u_license.get(u'skuId')
        if userId and skuId:
          userSkuIds.setdefault(userId, [])
          userSkuIds[userId].append(skuId)
      return userSkuIds
  while feed:
    u_license = feed.popleft()
    userId = u_license.get(u'userId', u'').lower()
    skuId = u_license.get(u'skuId', u'')
    csvRows.append({u'userId': userId, u'productId': u_license.get(u'productId', u''),
                    u'skuId': skuId, u'skuDisplay': SKU.skuIdToDisplayName(skuId)})
  writeCSVfile(csvRows, titles, u'Licenses', todrive)

# Notification commands utilities
READ_UNREAD_CHOICES = [u'read', u'unread',]

def getNotificationParameters(function):
  cd = buildGAPIObject(API.DIRECTORY)
  selected = False
  isUnread = None
  ids = []
  get_all = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'unreadonly', u'unread']:
      isUnread = True
      selected = True
    elif myarg == u'read':
      isUnread = False
      selected = True
    elif myarg == u'id':
      notificationId = getString(Cmd.OB_NOTIFICATION_ID)
      if notificationId.lower() == u'all':
        get_all = True
        isUnread = None
        selected = False
        ids = []
      else:
        get_all = False
        ids.append(notificationId)
    else:
      unknownArgumentExit()
  if not selected:
    if function == u'update':
      missingChoiceExit(READ_UNREAD_CHOICES)
  if get_all:
    fields = u'nextPageToken,items(notificationId,isUnread)' if function != u'info' else None
    try:
      notifications = callGAPIpages(cd.notifications(), u'list', u'items',
                                    throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                    customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
      for notification in notifications:
        if function == u'update':
          if notification[u'isUnread'] != isUnread:
            ids.append(notification[u'notificationId'])
        elif (not selected) or (notification[u'isUnread'] == isUnread):
          ids.append(notification[u'notificationId'])
    except (GAPI.domainNotFound, GAPI.badRequest, GAPI.forbidden):
      accessErrorExit(cd)
  else:
    notifications = None
  return (cd, isUnread, ids, notifications)

# gam update notification|notifications (id all)|(id <NotificationID>)* unreadonly|unread|read
def doUpdateNotification():
  cd, isUnread, notificationIds, _ = getNotificationParameters(u'update')
  printKeyValueList([u'Marking', len(notificationIds), u'Notification(s) as', u'UNREAD' if isUnread else u'READ'])
  body = {u'isUnread': isUnread}
  i = 0
  count = len(notificationIds)
  for notificationId in notificationIds:
    i += 1
    try:
      result = callGAPI(cd.notifications(), u'update',
                        throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.INTERNAL_ERROR, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                        customer=GC.Values[GC.CUSTOMER_ID], notificationId=notificationId,
                        body=body, fields=u'notificationId,isUnread')
      printEntityKVList([Ent.NOTIFICATION, result[u'notificationId']],
                        [Msg.MARKED_AS, [u'read', u'unread'][result[u'isUnread']]],
                        i, count)
    except (GAPI.domainNotFound, GAPI.internalError, GAPI.badRequest, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.NOTIFICATION, notificationId, i, count)

# gam delete notification|notifications (id all)|(id <NotificationID>)* [unreadonly|unread|read]
def doDeleteNotification():
  cd, _, notificationIds, _ = getNotificationParameters(u'delete')
  printKeyValueList([u'Deleting', len(notificationIds), u'Notification(s)'])
  i = 0
  count = len(notificationIds)
  for notificationId in notificationIds:
    i += 1
    try:
      callGAPI(cd.notifications(), u'delete',
               throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.INTERNAL_ERROR, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
               customer=GC.Values[GC.CUSTOMER_ID], notificationId=notificationId)
      entityActionPerformed([Ent.NOTIFICATION, notificationId], i, count)
    except (GAPI.domainNotFound, GAPI.internalError, GAPI.badRequest, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.NOTIFICATION, notificationId, i, count)

# gam info notification|notifications (id all)|(id <NotificationID>)* [unreadonly|unread|read]
def doInfoNotifications():
  cd, _, notificationIds, notifications = getNotificationParameters(u'info')
  i = 0
  count = len(notificationIds)
  for notificationId in notificationIds:
    i += 1
    if not notifications:
      try:
        notification = callGAPI(cd.notifications(), u'get',
                                throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.INTERNAL_ERROR, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                customer=GC.Values[GC.CUSTOMER_ID], notificationId=notificationId)
      except (GAPI.domainNotFound, GAPI.internalError, GAPI.badRequest, GAPI.forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.NOTIFICATION, notificationId, i, count)
        continue
    else:
      for notification in notifications:
        if notification[u'notificationId'] == notificationId:
          break
    printEntity([Ent.NOTIFICATION, notification[u'notificationId']], i, count)
    Ind.Increment()
    printKeyValueList([u'From', notification[u'fromAddress']])
    printKeyValueList([u'Subject', notification[u'subject']])
    printKeyValueList([u'Date', formatLocalTime(notification[u'sendTime'])])
    printKeyValueList([u'Read Status', [u'READ', u'UNREAD'][notification[u'isUnread']]])
    Ind.Decrement()
    printBlankLine()
    printKeyValueList([dehtml(notification[u'body'])])
    printBlankLine()
    printKeyValueList([u'--------------'])
    printBlankLine()

def ACLRuleDict(rule):
  if rule[u'scope'][u'type'] != u'default':
    return {u'Scope': u'{0}:{1}'.format(rule[u'scope'][u'type'], rule[u'scope'][u'value']), u'Role': rule[u'role']}
  else:
    return {u'Scope': u'{0}'.format(rule[u'scope'][u'type']), u'Role': rule[u'role']}

def ACLRuleKeyValueList(rule):
  if rule[u'scope'][u'type'] != u'default':
    return [u'Scope', u'{0}:{1}'.format(rule[u'scope'][u'type'], rule[u'scope'][u'value']), u'Role', rule[u'role']]
  else:
    return [u'Scope', u'{0}'.format(rule[u'scope'][u'type']), u'Role', rule[u'role']]

def formatACLRule(rule):
  return formatKeyValueList(u'(', ACLRuleKeyValueList(rule), u')')

def formatACLScopeRole(scope, role):
  if role:
    return formatKeyValueList(u'(', [u'Scope', scope, u'Role', role], u')')
  else:
    return formatKeyValueList(u'(', [u'Scope', scope], u')')

def normalizeRuleId(ruleId):
  ruleIdParts = ruleId.split(u':')
  if (len(ruleIdParts) == 1) or (len(ruleIdParts[1]) == 0):
    if ruleIdParts[0] == u'default':
      return ruleId
    if ruleIdParts[0] == u'domain':
      return u'{0}:{1}'.format(u'domain', GC.Values[GC.DOMAIN])
    return u'{0}:{1}'.format(u'user', normalizeEmailAddressOrUID(ruleIdParts[0], noUid=True))
  if ruleIdParts[0] in [u'user', u'group']:
    return u'{0}:{1}'.format(ruleIdParts[0], normalizeEmailAddressOrUID(ruleIdParts[1], noUid=True))
  return ruleId

def makeRoleRuleIdBody(role, ruleId):
  ruleIdParts = ruleId.split(u':')
  if len(ruleIdParts) == 1:
    if ruleIdParts[0] == u'default':
      return {u'role': role, u'scope': {u'type': ruleIdParts[0]}}
    if ruleIdParts[0] == u'domain':
      return {u'role': role, u'scope': {u'type': ruleIdParts[0], u'value': GC.Values[GC.DOMAIN]}}
    return {u'role': role, u'scope': {u'type': u'user', u'value': ruleIdParts[0]}}
  return {u'role': role, u'scope': {u'type': ruleIdParts[0], u'value': ruleIdParts[1]}}

def _getBuildingAttributes(body):
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'id':
      body[u'buildingId'] = getString(Cmd.OB_BUILDING_ID, maxLen=100)
    elif myarg == u'name':
      body[u'buildingName'] = getString(Cmd.OB_STRING, maxLen=100)
    elif myarg in [u'lat', u'latitude']:
      body.setdefault(u'coordinates', {})
      body[u'coordinates'][u'latitude'] = getFloat(minVal=-180.0, maxVal=180.0)
    elif myarg in [u'long', u'lng', u'longitude']:
      body.setdefault(u'coordinates', {})
      body[u'coordinates'][u'longitude'] = getFloat(minVal=-180.0, maxVal=180.0)
    elif myarg == u'description':
      body[u'description'] = getString(Cmd.OB_STRING)
    elif myarg == u'floors':
      body[u'floorNames'] = getString(Cmd.OB_STRING).split(u',')
    else:
      unknownArgumentExit()
  return body

# gam create|add building <Name> <BuildingAttributes>*
def doCreateBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getBuildingAttributes({u'buildingId': unicode(uuid.uuid4()),
                                 u'buildingName': getString(Cmd.OB_NAME, maxLen=100),
                                 u'floorNames': [u'1',]})
  try:
    callGAPI(cd.resources().buildings(), u'insert',
             throw_reasons=[GAPI.DUPLICATE, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body)
    entityActionPerformed([Ent.BUILDING_ID, body[u'buildingId'], Ent.BUILDING, body[u'buildingName']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.BUILDING_ID, body[u'buildingId'], Ent.BUILDING, body[u'buildingName']])
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.BUILDING_ID, body[u'buildingId'], Ent.BUILDING, body[u'buildingName']], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

def _makeBuildingIdNameMap(cd=None):
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  try:
    buildings = callGAPIpages(cd.resources().buildings(), u'list', u'buildings',
                              throw_reasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID],
                              fields=u'nextPageToken,buildings(buildingId,buildingName)')
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  GM.Globals[GM.MAP_BUILDING_ID_TO_NAME] = {}
  GM.Globals[GM.MAP_BUILDING_NAME_TO_ID] = {}
  for building in buildings:
    GM.Globals[GM.MAP_BUILDING_ID_TO_NAME][building[u'buildingId']] = building[u'buildingName']
    GM.Globals[GM.MAP_BUILDING_NAME_TO_ID][building[u'buildingName']] = building[u'buildingId']

def _getBuildingByNameOrId(cd, minLen=1):
  which_building = getString(Cmd.OB_BUILDING_ID, minLen=minLen)
  if not which_building or (minLen == 0 and which_building in [u'id:', u'uid:']):
    return u''
  cg = UID_PATTERN.match(which_building)
  if cg:
    return cg.group(1)
  if GM.Globals[GM.MAP_BUILDING_NAME_TO_ID] is None:
    _makeBuildingIdNameMap(cd)
# Exact name match, return ID
  if which_building in GM.Globals[GM.MAP_BUILDING_NAME_TO_ID]:
    return GM.Globals[GM.MAP_BUILDING_NAME_TO_ID][which_building]
# No exact name match, check for case insensitive name matches
  which_building_lower = which_building.lower()
  ci_matches = []
  for buildingName, buildingId in GM.Globals[GM.MAP_BUILDING_NAME_TO_ID].iteritems():
    if buildingName.lower() == which_building_lower:
      ci_matches.append({u'buildingName': buildingName, u'buildingId': buildingId})
# One match, return ID
  if len(ci_matches) == 1:
    return ci_matches[0][u'buildingId']
# No or multiple name matches, try ID
# Exact ID match, return ID
  if which_building in GM.Globals[GM.MAP_BUILDING_ID_TO_NAME]:
    return which_building
# No exact ID match, check for case insensitive id match
  for buildingId in GM.Globals[GM.MAP_BUILDING_ID_TO_NAME]:
# Match, return ID
    if buildingId.lower() == which_building_lower:
      return buildingId
# Multiple name  matches
  if len(ci_matches) > 1:
    printErrorMessage(1, Msg.MULTIPLE_BUILDINGS_SAME_NAME.format(len(ci_matches), Ent.Plural(Ent.BUILDING)))
    Ind.Increment()
    for building in ci_matches:
      printEntity([Ent.BUILDING, building[u'buildingName'], Ent.BUILDING_ID, building[u'buildingId']])
    Ind.Decrement()
    Cmd.Backup()
    usageErrorExit(Msg.PLEASE_SPECIFY_BUILDING_EXACT_CASE_NAME_OR_ID)
# No matches
  entityDoesNotExistExit(Ent.BUILDING, which_building)

def _getBuildingNameById(cd, buildingId):
  if GM.Globals[GM.MAP_BUILDING_ID_TO_NAME]is None:
    _makeBuildingIdNameMap(cd)
  return GM.Globals[GM.MAP_BUILDING_ID_TO_NAME].get(buildingId, u'UNKNOWN')

# gam update building <BuildIngID> <BuildingAttributes>*
def doUpdateBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  buildingId = _getBuildingByNameOrId(cd)
  body = _getBuildingAttributes({})
  try:
    callGAPI(cd.resources().buildings(), u'patch',
             throw_reasons=[GAPI.DUPLICATE, GAPI.RESOURCE_NOT_FOUND, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], buildingId=buildingId, body=body)
    entityActionPerformed([Ent.BUILDING_ID, buildingId])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.BUILDING, body[u'buildingName']])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.BUILDING_ID, buildingId)
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.BUILDING_ID, buildingId], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete building <BuildIngID>
def doDeleteBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  buildingId = _getBuildingByNameOrId(cd)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.resources().buildings(), u'delete',
             throw_reasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], buildingId=buildingId)
    entityActionPerformed([Ent.BUILDING_ID, buildingId])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.BUILDING_ID, buildingId)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

def _showBuilding(building, delimiter=u',', i=0, count=0):
  if u'buildingName' in building:
    printEntity([Ent.BUILDING, building[u'buildingName']], i, count)
    Ind.Increment()
    printKeyValueList([u'buildingId', u'id:{0}'.format(building[u'buildingId'])])
  else:
    printEntity([Ent.BUILDING_ID, u'id:{0}'.format(building[u'buildingId'])], i, count)
    Ind.Increment()
  if u'description' in building:
    printKeyValueList([u'description', building[u'description']])
  if u'floorNames' in building:
    printKeyValueList([u'floorNames', delimiter.join(building[u'floorNames'])])
  if u'coordinates' in building:
    printKeyValueList([u'coordinates', None])
    Ind.Increment()
    printKeyValueList([u'latitude', building[u'coordinates'].get(u'latitude', 0)])
    printKeyValueList([u'longitude', building[u'coordinates'].get(u'longitude', 0)])
    Ind.Decrement()
  Ind.Decrement()

# gam info building <BuildingID>
def doInfoBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  buildingId = _getBuildingByNameOrId(cd)
  checkForExtraneousArguments()
  try:
    building = callGAPI(cd.resources().buildings(), u'get',
                        throw_reasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                        customer=GC.Values[GC.CUSTOMER_ID], buildingId=buildingId)
    _showBuilding(building)
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.BUILDING_ID, buildingId)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

BUILDINGS_FIELDS_CHOICE_MAP = {
  u'buildingid': u'buildingId',
  u'buildingname': u'buildingName',
  u'coordinates': u'coordinates',
  u'description': u'description',
  u'floors': u'floorNames',
  u'floornames': u'floorNames',
  u'id': u'buildingId',
  u'name': u'buildingName',
  }

def _doPrintShowBuildings(csvFormat):
  cd = buildGAPIObject(API.DIRECTORY)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'buildingId',])
    delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  else:
    delimiter = u','
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif csvFormat and myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'allfields':
      fieldsList = []
    elif getFieldsList(myarg, BUILDINGS_FIELDS_CHOICE_MAP, fieldsList, u'buildingId'):
      pass
    else:
      unknownArgumentExit()
  fields = u'nextPageToken,buildings({0})'.format(u','.join(set(fieldsList))) if fieldsList else None
  try:
    buildings = callGAPIpages(cd.resources().buildings(), u'list', u'buildings',
                              throw_reasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
    if not csvFormat:
      jcount = len(buildings)
      performActionNumItems(jcount, Ent.BUILDING)
      Ind.Increment()
      j = 0
      for building in buildings:
        j += 1
        _showBuilding(building, delimiter, j, jcount)
      Ind.Decrement()
    else:
      for building in buildings:
        if u'buildingId' in building:
          building[u'buildingId'] = u'id:{0}'.format(building[u'buildingId'])
        if u'floorNames' in building:
          building[u'floorNames'] = delimiter.join(building[u'floorNames'])
        addRowTitlesToCSVfile(flattenJSON(building), csvRows, titles)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Buildings', todrive, [u'buildingId',])

# gam print buildings [todrive [<ToDriveAttributes>]]
def doPrintBuildings():
  _doPrintShowBuildings(True)

# gam show buildings
def doShowBuildings():
  _doPrintShowBuildings(False)

def _getFeatureAttributes(body):
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'name'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  return body

# gam create|add feature <Name>
def doCreateFeature():
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getFeatureAttributes({})
  try:
    callGAPI(cd.resources().features(), u'insert',
             throw_reasons=[GAPI.DUPLICATE, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body)
    entityActionPerformed([Ent.BUILDING, body[u'name']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.FEATURE, body[u'name']])
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.FEATURE, body[u'name']], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

#gam update feature <Name> name <Name>
def doUpdateFeature():
  # update does not work for name and name is only field to be updated
  # if additional writable fields are added to feature in the future
  # we'll add support for update as well as rename
  cd = buildGAPIObject(API.DIRECTORY)
  oldName = getString(Cmd.OB_STRING)
  getChoice([u'name'])
  body = {u'newName': getString(Cmd.OB_STRING)}
  checkForExtraneousArguments()
  try:
    callGAPI(cd.resources().features(), u'rename',
             throw_reasons=[GAPI.DUPLICATE, GAPI.RESOURCE_NOT_FOUND, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], oldName=oldName, body=body)
    entityActionPerformed([Ent.FEATURE, oldName])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.FEATURE, body[u'newName']])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.FEATURE, oldName)
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.FEATURE, oldName], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete feature <eName>
def doDeleteFeature():
  cd = buildGAPIObject(API.DIRECTORY)
  featureKey = getString(Cmd.OB_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.resources().features(), u'delete',
             throw_reasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], featureKey=featureKey)
    entityActionPerformed([Ent.FEATURE, featureKey])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.FEATURE, featureKey)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

FEATURE_FIELDS_CHOICE_MAP = {
  u'name': u'name',
  }

def _doPrintShowFeatures(csvFormat):
  cd = buildGAPIObject(API.DIRECTORY)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'name',])
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'allfields':
      fieldsList = []
    elif getFieldsList(myarg, FEATURE_FIELDS_CHOICE_MAP, fieldsList):
      pass
    else:
      unknownArgumentExit()
  fields = u'nextPageToken,features({0})'.format(u','.join(set(fieldsList))) if fieldsList else None
  try:
    features = callGAPIpages(cd.resources().features(), u'list', u'features',
                             throw_reasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                             customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
    if not csvFormat:
      jcount = len(features)
      performActionNumItems(jcount, Ent.FEATURE)
      Ind.Increment()
      j = 0
      for feature in features:
        j += 1
        printEntity([Ent.FEATURE, feature[u'name']], j, jcount)
    else:
      for feature in features:
        addRowTitlesToCSVfile(flattenJSON(feature), csvRows, titles)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Features', todrive)

# gam print features [todrive [<ToDriveAttributes>]]
def doPrintFeatures():
  _doPrintShowFeatures(True)

# gam show features
def doShowFeatures():
  _doPrintShowFeatures(False)

RESOURCE_CATEGORY_MAP = {
  u'conference': u'CONFERENCE_ROOM',
  u'conferenceroom': u'CONFERENCE_ROOM',
  u'room': u'CONFERENCE_ROOM',
  u'other': u'OTHER',
  u'categoryunknown': u'CATEGORY_UNKNOWN',
  u'unknown': u'CATEGORY_UNKNOWN',
  }

def _getResourceCalendarAttributes(cd, body):
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'resourceName'] = getString(Cmd.OB_STRING)
    elif myarg == u'description':
      body[u'resourceDescription'] = getStringWithCRsNLs()
    elif myarg == u'type':
      body[u'resourceType'] = getString(Cmd.OB_STRING)
    elif myarg in [u'building', u'buildingid']:
      body[u'buildingId'] = _getBuildingByNameOrId(cd, minLen=0)
    elif myarg in [u'capacity']:
      body[u'capacity'] = getInteger()
    elif myarg in [u'feature', u'features']:
      features = getString(Cmd.OB_STRING).split(u',')
      body[u'featureInstances'] = []
      for feature in features:
        body[u'featureInstances'].append({u'feature': {u'name': feature}})
    elif myarg in [u'floor', u'floorname']:
      body[u'floorName'] = getString(Cmd.OB_STRING)
    elif myarg in [u'floorsection']:
      body[u'floorSection'] = getString(Cmd.OB_STRING)
    elif myarg in [u'category']:
      body[u'resourceCategory'] = getChoice(RESOURCE_CATEGORY_MAP, mapChoice=True)
    elif myarg in [u'uservisibledescription', u'userdescription']:
      body[u'userVisibleDescription'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  return body

# gam create|add resource <ResourceID> <Name> <ResourceAttributes>*
def doCreateResourceCalendar():
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getResourceCalendarAttributes(cd, {u'resourceId': getString(Cmd.OB_RESOURCE_ID), u'resourceName': getString(Cmd.OB_NAME)})
  try:
    callGAPI(cd.resources().calendars(), u'insert',
             throw_reasons=[GAPI.INVALID, GAPI.REQUIRED, GAPI.DUPLICATE, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body, fields=u'')
    entityActionPerformed([Ent.RESOURCE_CALENDAR, body[u'resourceId']])
  except (GAPI.invalid, GAPI.required) as e:
    entityActionFailedWarning([Ent.RESOURCE_CALENDAR, body[u'resourceId']], str(e))
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.RESOURCE_CALENDAR, body[u'resourceId']])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)

def _doUpdateResourceCalendars(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getResourceCalendarAttributes(cd, {})
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.resources().calendars(), u'patch',
               throw_reasons=[GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.REQUIRED, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, body=body, fields=u'')
      entityActionPerformed([Ent.RESOURCE_CALENDAR, resourceId], i, count)
    except (GAPI.invalid, GAPI.invalidInput, GAPI.required)  as e:
      entityActionFailedWarning([Ent.RESOURCE_CALENDAR, resourceId], str(e), i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)

# gam update resources <ResourceEntity> <ResourceAttributes>*
def doUpdateResourceCalendars():
  _doUpdateResourceCalendars(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# gam update resource <ResourceID> <ResourceAttributes>*
def doUpdateResourceCalendar():
  _doUpdateResourceCalendars(getStringReturnInList(Cmd.OB_RESOURCE_ID))

def _doDeleteResourceCalendars(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.resources().calendars(), u'delete',
               throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId)
      entityActionPerformed([Ent.RESOURCE_CALENDAR, resourceId], i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)

# gam delete resources <ResourceEntity>
def doDeleteResourceCalendars():
  _doDeleteResourceCalendars(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# gam delete resource <ResourceID>
def doDeleteResourceCalendar():
  _doDeleteResourceCalendars(getStringReturnInList(Cmd.OB_RESOURCE_ID))

RESOURCE_DFLT_FIELDS = [u'resourceId', u'resourceName', u'resourceEmail', u'resourceDescription', u'resourceType',]
RESOURCE_ADDTL_FIELDS = [
  u'buildingId',	# buildingId must be first element
  u'capacity',
  u'featureInstances',
  u'floorName',
  u'floorSection',
  u'generatedResourceName',
  u'resourceCategory',
  u'userVisibleDescription',
  ]
RESOURCE_ALL_FIELDS = RESOURCE_DFLT_FIELDS+RESOURCE_ADDTL_FIELDS
RESOURCE_FIELDS_WITH_CRS_NLS = [u'resourceDescription',]

def _showResource(cd, resource, i, count, formatJSON, acls=None):

  def _showResourceField(title, resource, field):
    if field in resource:
      if field not in RESOURCE_FIELDS_WITH_CRS_NLS:
        printKeyValueList([title, resource[field]])
      else:
        printKeyValueWithCRsNLs(title, resource[field])

  if u'buildingId' in resource:
    resource[u'buildingName'] = _getBuildingNameById(cd, resource[u'buildingId'])
    resource[u'buildingId'] = u'id:{0}'.format(resource[u'buildingId'])
  if formatJSON:
    if acls:
      resource[u'acls'] = [{u'id': rule[u'id'], u'role': rule[u'role']} for rule in acls]
    printLine(json.dumps(cleanJSON(resource, u''), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.RESOURCE_ID, resource[u'resourceId']], i, count)
  Ind.Increment()
  _showResourceField(u'Name', resource, u'resourceName')
  _showResourceField(u'Email', resource, u'resourceEmail')
  _showResourceField(u'Type', resource, u'resourceType')
  _showResourceField(u'Description', resource, u'resourceDescription')
  if u'featureInstances' in resource:
    resource[u'featureInstances'] = u', '.join([a_feature[u'feature'][u'name'] for a_feature in resource.pop(u'featureInstances')])
  if u'buildingId' in resource:
    _showResourceField(u'buildingId', resource, u'buildingId')
    _showResourceField(u'buildingName', resource, u'buildingName')
  for field in RESOURCE_ADDTL_FIELDS[1:]:
    _showResourceField(field, resource, field)
  if acls:
    j = 0
    jcount = len(acls)
    for rule in acls:
      j += 1
      printEntity([Ent.CALENDAR_ACL, formatACLScopeRole(rule[u'id'], rule[u'role'])], j, jcount)
  Ind.Decrement()

def _doInfoResourceCalendars(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      resource = callGAPI(cd.resources().calendars(), u'get',
                          throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, fields=u','.join(RESOURCE_ALL_FIELDS))
      _showResource(cd, resource, i, count, formatJSON)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)

# gam info resources <ResourceEntity>
def doInfoResourceCalendars():
  _doInfoResourceCalendars(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# gam info resource <ResourceID>
def doInfoResourceCalendar():
  _doInfoResourceCalendars(getStringReturnInList(Cmd.OB_RESOURCE_ID))

RESOURCE_FIELDS_CHOICE_MAP = {
  u'description': u'resourceDescription',
  u'building': u'buildingId',
  u'buildingid': u'buildingId',
  u'capacity': u'capacity',
  u'category': u'resourceCategory',
  u'email': u'resourceEmail',
  u'feature': u'featureInstances',
  u'features': u'featureInstances',
  u'floor': u'floorName',
  u'floorname': u'floorName',
  u'floorsection': u'floorSection',
  u'generatedresourcename': u'generatedResourceName',
  u'id': u'resourceId',
  u'name': u'resourceName',
  u'type': u'resourceType',
  u'userdescription': u'userVisibleDescription',
  u'uservisibledescription': u'userVisibleDescription',
  }

def _doPrintShowResourceCalendars(csvFormat):
  cd = buildGAPIObject(API.DIRECTORY)
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  showPermissions = False
  acls = None
  fieldsList = []
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'allfields':
      fieldsList = RESOURCE_ALL_FIELDS[:]
    elif myarg in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
      showPermissions = True
    elif myarg in RESOURCE_FIELDS_CHOICE_MAP:
      if not fieldsList:
        fieldsList = [u'resourceId',]
      fieldsList.append(RESOURCE_FIELDS_CHOICE_MAP[myarg])
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList = [u'resourceId',]
      for field in _getFieldsList():
        if field in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
          showPermissions = True
        elif field in RESOURCE_FIELDS_CHOICE_MAP:
          fieldsList.append(RESOURCE_FIELDS_CHOICE_MAP[field])
        else:
          invalidChoiceExit(RESOURCE_FIELDS_CHOICE_MAP, True)
    elif myarg in [u'convertcrnl', u'converttextnl']:
      convertCRNL = True
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  if not fieldsList:
    fieldsList = RESOURCE_DFLT_FIELDS[:]
  if showPermissions:
    cal = buildGAPIObject(API.CALENDAR)
    fields = u'nextPageToken,items({0})'.format(u','.join(set(fieldsList+[u'resourceEmail',])))
  else:
    fields = u'nextPageToken,items({0})'.format(u','.join(set(fieldsList)))
  if u'buildingId' in fieldsList:
    fieldsList.append(u'buildingName')
  if csvFormat:
    if not formatJSON:
      addTitlesToCSVfile(fieldsList, titles)
      sortTitles = RESOURCE_DFLT_FIELDS
    else:
      if u'resourceName' in fieldsList:
        sortTitles = [u'resourceId', u'resourceName', u'JSON']
      else:
        sortTitles = [u'resourceId', u'JSON']
      addTitlesToCSVfile(sortTitles, titles)
  printGettingAllAccountEntities(Ent.RESOURCE_CALENDAR)
  try:
    resources = callGAPIpages(cd.resources().calendars(), u'list', u'items',
                              page_message=getPageMessage(showTotal=False, showFirstLastItems=True), message_attribute=u'resourceName',
                              throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
    i = 0
    count = len(resources)
    for resource in resources:
      i += 1
      if showPermissions:
        acls = callGAPIpages(cal.acl(), u'list', u'items',
                             throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                             calendarId=resource[u'resourceEmail'], fields=u'nextPageToken,items(id,role,scope)')
      if not csvFormat:
        _showResource(cd, resource, i, count, formatJSON, acls)
      else:
        if u'buildingId' in resource:
          resource[u'buildingName'] = _getBuildingNameById(cd, resource[u'buildingId'])
          resource[u'buildingId'] = u'id:{0}'.format(resource[u'buildingId'])
        if not formatJSON:
          if u'featureInstances' in resource:
            resource[u'featureInstances'] = u', '.join([a_feature[u'feature'][u'name'] for a_feature in resource.pop(u'featureInstances')])
          row = {}
          for field in fieldsList:
            if convertCRNL and field in RESOURCE_FIELDS_WITH_CRS_NLS:
              row[field] = escapeCRsNLs(resource.get(field, u''))
            else:
              row[field] = resource.get(field, u'')
          if showPermissions:
            for rule in acls:
              addRowTitlesToCSVfile(flattenJSON(rule, flattened=row.copy()), csvRows, titles)
          else:
            csvRows.append(row)
        else:
          if showPermissions:
            resource[u'acls'] = [{u'id': rule[u'id'], u'role': rule[u'role']} for rule in acls]
          row = {u'resourceId': resource[u'resourceId'], u'JSON': json.dumps(cleanJSON(resource, u''), ensure_ascii=False, sort_keys=True)}
          if u'resourceName' in resource:
            row[u'resourceName'] = resource[u'resourceName']
          csvRows.append(row)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Resources', todrive, sortTitles, quotechar)

# gam show resources [allfields|<ResourceFieldName>*|(fields <ResourceFieldNameList>)] [acls] [convertcrnl] [formatjson]
def doShowResourceCalendars():
  _doPrintShowResourceCalendars(False)

# gam print resources [todrive [<ToDriveAttributes>]] [allfields|<ResourceFieldName>*|(fields <ResourceFieldNameList>)] [acls] [convertcrnl]
#	[formatjson] [quotechar <Character>]
def doPrintResourceCalendars():
  _doPrintShowResourceCalendars(True)

# Calendar commands utilities
def normalizeCalendarId(calId, user):
  if not user or calId.lower() != u'primary':
    return normalizeEmailAddressOrUID(calId)
  return user

def checkCalendarExists(cal, calId, showMessage=False):
  if cal is None:
    cal = buildGAPIObject(API.CALENDAR)
  try:
    return callGAPI(cal.calendars(), u'get',
                    throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
                    calendarId=calId, fields=u'id')[u'id']
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.notACalendarUser, GAPI.notFound) as e:
    if showMessage:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e))
    return None

def validateCalendar(calId, i=0, count=0):
  calId, cal = buildGAPIServiceObject(API.CALENDAR, calId, i, count)
  if not cal:
    return (calId, None)
  try:
    callGAPI(cal.calendars(), u'get',
             throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
             calendarId=calId, fields=u'')
    return (calId, cal)
  except (GAPI.notACalendarUser, GAPI.notFound) as e:
    entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
  return (calId, None)

CALENDAR_ACL_ROLES_MAP = {
  u'editor': u'writer',
  u'freebusy': u'freeBusyReader',
  u'freebusyreader': u'freeBusyReader',
  u'owner': u'owner',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  u'none': u'none',
  }

ACL_SCOPE_CHOICES = [u'default', u'user', u'group', u'domain',] # default must be first element

def getACLScope():
  scopeType, scopeValue = getChoiceAndValue(Cmd.OB_ACL_SCOPE, ACL_SCOPE_CHOICES[1:], u':')
  if scopeType:
    if scopeType != u'domain':
      scopeValue = normalizeEmailAddressOrUID(scopeValue, noUid=True)
    else:
      scopeValue = scopeValue.lower()
    return (scopeType, scopeValue)
  scopeType = getChoice(ACL_SCOPE_CHOICES, defaultChoice=u'user')
  if scopeType == u'domain':
    entity = getString(Cmd.OB_DOMAIN_NAME, optional=True)
    if entity:
      scopeValue = entity.lower()
    else:
      scopeValue = GC.Values[GC.DOMAIN]
  elif scopeType != u'default':
    scopeValue = getEmailAddress(noUid=True)
  else:
    scopeValue = None
  return (scopeType, scopeValue)

def getCalendarACLScope():
  scopeType, scopeValue = getACLScope()
  if scopeType != u'default':
    return {u'list': [u'{0}:{1}'.format(scopeType, scopeValue)], u'dict': None}
  return {u'list': [scopeType], u'dict': None}

def getCalendarSiteACLScopeEntity():
  ACLScopeEntity = {u'list': getEntityList(Cmd.OB_ACL_SCOPE_ENTITY), u'dict': None}
  if isinstance(ACLScopeEntity[u'list'], dict):
    ACLScopeEntity[u'dict'] = ACLScopeEntity[u'list']
  return ACLScopeEntity

def _normalizeCalIdGetRuleIds(origUser, user, cal, calId, j, jcount, ACLScopeEntity, showAction=True):
  if ACLScopeEntity[u'dict']:
    if origUser:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        ruleIds = ACLScopeEntity[u'dict'][calId]
      else:
        ruleIds = ACLScopeEntity[u'dict'][origUser][calId]
    else:
      ruleIds = ACLScopeEntity[u'dict'][calId]
  else:
    ruleIds = ACLScopeEntity[u'list']
  calId = normalizeCalendarId(calId, user)
  kcount = len(ruleIds)
  if kcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if showAction:
    entityPerformActionNumItems([Ent.CALENDAR, calId], kcount, Ent.CALENDAR_ACL, j, jcount)
  return (calId, cal, ruleIds, kcount)

def _processCalendarACLs(cal, function, entityType, calId, j, jcount, k, kcount, ruleId, role, body):
  result = True
  kwargs = {}
  if function in [u'insert', u'patch']:
    kwargs[u'body'] = body
    kwargs[u'fields'] = u''
  if function in [u'patch', u'delete']:
    kwargs[u'ruleId'] = ruleId
  try:
    callGAPI(cal.acl(), function,
             throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.INVALID_SCOPE_VALUE,
                            GAPI.ILLEGAL_ACCESS_ROLE_FOR_DEFAULT, GAPI.CANNOT_CHANGE_OWN_ACL, GAPI.CANNOT_CHANGE_OWNER_ACL, GAPI.FORBIDDEN],
             calendarId=calId, **kwargs)
    entityActionPerformed([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], k, kcount)
  except GAPI.notFound as e:
    if not checkCalendarExists(cal, calId):
      entityUnknownWarning(entityType, calId, j, jcount)
      result = False
    else:
      entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
  except (GAPI.invalid, GAPI.invalidParameter, GAPI.invalidScopeValue,
          GAPI.illegalAccessRoleForDefault, GAPI.forbidden, GAPI.cannotChangeOwnAcl, GAPI.cannotChangeOwnerAcl) as e:
    entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
  return result

def _createCalendarACLs(cal, entityType, calId, j, jcount, role, ruleIds, kcount):
  Ind.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    if not _processCalendarACLs(cal, u'insert', entityType, calId, j, jcount, k, kcount, ruleId, role, makeRoleRuleIdBody(role, ruleId)):
      break
  Ind.Decrement()

def _doCalendarsCreateACLs(origUser, user, cal, calIds, count, role, ACLScopeEntity):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, cal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _createCalendarACLs(cal, Ent.CALENDAR, calId, i, count, role, ruleIds, jcount)

# gam calendar <CalendarEntity> create|add <CalendarACLRole> <CalendarACLScope>
def doCalendarsCreateACL(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarACLScope()
  checkForExtraneousArguments()
  _doCalendarsCreateACLs(None, None, cal, calIds, len(calIds), role, ACLScopeEntity)

# gam calendars <CalendarEntity> create|add acls <CalendarACLRole> <CalendarACLScopeEntity>
def doCalendarsCreateACLs(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doCalendarsCreateACLs(None, None, cal, calIds, len(calIds), role, ACLScopeEntity)

def _updateDeleteCalendarACLs(cal, function, entityType, calId, j, jcount, role, body, ruleIds, kcount):
  Ind.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    if not _processCalendarACLs(cal, function, entityType, calId, j, jcount, k, kcount, ruleId, role, body):
      break
  Ind.Decrement()

def _doUpdateDeleteCalendarACLs(origUser, user, cal, function, calIds, count, ACLScopeEntity, role, body):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, cal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _updateDeleteCalendarACLs(cal, function, Ent.CALENDAR, calId, i, count, role, body, ruleIds, jcount)

# gam calendar <CalendarEntity> update <CalendarACLRole> <CalendarACLScope>
def doCalendarsUpdateACL(cal, calIds):
  body = {u'role': getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)}
  ACLScopeEntity = getCalendarACLScope()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'patch', calIds, len(calIds), ACLScopeEntity, body[u'role'], body)

# gam calendars <CalendarEntity> update acls <CalendarACLRole> <CalendarACLScopeEntity>
def doCalendarsUpdateACLs(cal, calIds):
  body = {u'role': getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)}
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'patch', calIds, len(calIds), ACLScopeEntity, body[u'role'], body)

# gam calendar <CalendarEntity> del|delete [<CalendarACLRole>] <CalendarACLScope>
def doCalendarsDeleteACL(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  ACLScopeEntity = getCalendarACLScope()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'delete', calIds, len(calIds), ACLScopeEntity, role, {})

# gam calendars <CalendarEntity> del|delete acls <CalendarACLScopeEntity>
def doCalendarsDeleteACLs(cal, calIds):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  _doUpdateDeleteCalendarACLs(None, None, cal, u'delete', calIds, len(calIds), ACLScopeEntity, role, {})

def _showCalendarACL(user, entityType, calId, acl, k, kcount, formatJSON):
  if formatJSON:
    if entityType == Ent.CALENDAR:
      if user:
        printLine(json.dumps(cleanJSON({u'primaryEmail': user, u'calendarId': calId, u'acl': acl}, u''),
                             ensure_ascii=False, sort_keys=True))
      else:
        printLine(json.dumps(cleanJSON({u'calendarId': calId, u'acl': acl}, u''),
                             ensure_ascii=False, sort_keys=True))
    else:
      printLine(json.dumps(cleanJSON({u'resourceId': user, u'resourceEmail': calId, u'acl': acl}, u''),
                           ensure_ascii=False, sort_keys=True))
  else:
    printEntity([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(acl[u'id'], acl[u'role'])], k, kcount)

def _infoCalendarACLs(cal, user, entityType, calId, j, jcount, ruleIds, kcount, formatJSON):
  Ind.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    try:
      result = callGAPI(cal.acl(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.INVALID_SCOPE_VALUE, GAPI.FORBIDDEN],
                        calendarId=calId, ruleId=ruleId, fields=u'id,role,scope')
      _showCalendarACL(user, entityType, calId, result, k, kcount, formatJSON)
    except (GAPI.notFound, GAPI.invalid) as e:
      if not checkCalendarExists(cal, calId):
        entityUnknownWarning(entityType, calId, j, jcount)
        break
      else:
        entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, None)], str(e), k, kcount)
    except (GAPI.invalidScopeValue, GAPI.forbidden) as e:
      entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, None)], str(e), k, kcount)
  Ind.Decrement()

def _doInfoCalendarACLs(origUser, user, cal, calIds, count, ACLScopeEntity, formatJSON):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, cal, calId, i, count, ACLScopeEntity, showAction=not formatJSON)
    if jcount == 0:
      continue
    _infoCalendarACLs(cal, user, Ent.CALENDAR, calId, i, count, ruleIds, jcount, formatJSON)

def _getCalendarInfoACLEventOptions():
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  return formatJSON

# gam calendars <CalendarEntity> info acl|acls <CalendarACLScopeEntity> [formatjson]
def doCalendarsInfoACLs(cal, calIds):
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  formatJSON = _getCalendarInfoACLEventOptions()
  _doInfoCalendarACLs(None, None, cal, calIds, len(calIds), ACLScopeEntity, formatJSON)

def _printShowCalendarACLs(cal, user, entityType, calId, i, count, csvFormat, formatJSON, csvRows, titles):
  try:
    if csvFormat:
      printGettingEntityItemForWhom(Ent.CALENDAR_ACL, calId, i, count)
    acls = callGAPIpages(cal.acl(), u'list', u'items',
                         throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                         calendarId=calId, fields=u'nextPageToken,items(id,role,scope)')
    jcount = len(acls)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    if not csvFormat:
      if not formatJSON:
        entityPerformActionNumItems([entityType, calId], jcount, Ent.CALENDAR_ACL, i, count)
      Ind.Increment()
      j = 0
      for rule in acls:
        j += 1
        _showCalendarACL(user, entityType, calId, rule, j, jcount, formatJSON)
      Ind.Decrement()
    else:
      if entityType == Ent.CALENDAR:
        if not formatJSON:
          if acls:
            for rule in acls:
              flattened = {u'calendarId': calId}
              if user:
                flattened[u'primaryEmail'] = user
              addRowTitlesToCSVfile(flattenJSON(rule, flattened=flattened), csvRows, titles)
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and user:
            csvRows.append({u'calendarId': calId, u'primaryEmail': user})
        else:
          if acls:
            for rule in acls:
              flattened = {u'calendarId': calId, u'JSON': json.dumps(cleanJSON(rule, u''), ensure_ascii=False, sort_keys=False)}
              if user:
                flattened[u'primaryEmail'] = user
              csvRows.append(flattened)
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and user:
            csvRows.append({u'primaryEmail': user, u'calendarId': calId, u'JSON': json.dumps({})})
      else: # Ent.RESOURCE_CALENDAR
        if not formatJSON:
          for rule in acls:
            addRowTitlesToCSVfile(flattenJSON(rule, flattened={u'resourceId': user, u'resourceEmail': calId}), csvRows, titles)
        else:
          for rule in acls:
            csvRows.append({u'resourceId': user, u'resourceEmail': calId, u'JSON': json.dumps(cleanJSON(rule, u''), ensure_ascii=False, sort_keys=False)})
  except GAPI.forbidden as e:
    entityActionFailedWarning([entityType, calId], str(e), i, count)
  except GAPI.notFound:
    entityUnknownWarning(entityType, calId, i, count)

def _getCalendarPrintShowACLOptions(csvFormat, entityType):
  todrive = {}
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  sortTitles = []
  if csvFormat:
    if entityType == Ent.USER:
      sortTitles.extend([u'primaryEmail', u'calendarId'])
    elif entityType == Ent.CALENDAR:
      sortTitles.append(u'calendarId')
    else: # Ent.RESOURCE_CALENDAR
      sortTitles.extend([u'resourceId', u'resourceEmail'])
    if formatJSON:
      sortTitles.append(u'JSON')
  return (todrive, formatJSON, quotechar, sortTitles)

def _doCalendarsPrintShowACLs(cal, calIds, csvFormat):
  todrive, formatJSON, quotechar, sortTitles = _getCalendarPrintShowACLOptions(csvFormat, Ent.CALENDAR)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  else:
    titles = csvRows = None
  count = len(calIds)
  i = 0
  for calId in calIds:
    i += 1
    calId = convertUIDtoEmailAddress(calId)
    _printShowCalendarACLs(cal, None, Ent.CALENDAR, calId, i, count, csvFormat, formatJSON, csvRows, titles)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Calendar ACLs', todrive, sortTitles, quotechar)

# gam calendars <CalendarEntity> print acls [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>]
def doCalendarsPrintACLs(cal, calIds):
  _doCalendarsPrintShowACLs(cal, calIds, True)

# gam calendars <CalendarEntity> show acls [formatjson]
# gam calendar <CalendarEntity> showacl [formatjson]
def doCalendarsShowACLs(cal, calIds):
  _doCalendarsPrintShowACLs(cal, calIds, False)

LIST_EVENTS_DISPLAY_PROPERTIES = {
  u'alwaysincludeemail': (u'alwaysIncludeEmail', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  u'icaluid': (u'iCalUID', {GC.VAR_TYPE: GC.TYPE_STRING}),
  u'maxattendees': (u'maxAttendees', {GC.VAR_TYPE: GC.TYPE_INTEGER, GC.VAR_LIMITS: (1, None)}),
  u'orderby': (u'orderBy', {GC.VAR_TYPE: GC.TYPE_CHOICE, u'choices': {u'starttime': u'startTime', u'updated': u'updated'}}),
  u'timezone': (u'timeZone', {GC.VAR_TYPE: GC.TYPE_STRING}),
  }

LIST_EVENTS_SELECT_PROPERTIES = {
  u'endtime': (u'timeMax', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  u'privateextendedproperty': (u'privateExtendedProperty', {GC.VAR_TYPE: GC.TYPE_STRING}),
  u'sharedextendedproperty': (u'sharedExtendedProperty', {GC.VAR_TYPE: GC.TYPE_STRING}),
  u'showdeletedevents': (u'showDeleted', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  u'showhiddeninvitations': (u'showHiddenInvitations', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  u'singleevents': (u'singleEvents', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  u'starttime': (u'timeMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  u'timemax': (u'timeMax', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  u'timemin': (u'timeMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  u'updatedmin': (u'updatedMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  }

LIST_EVENTS_MATCH_FIELDS = {
  u'attendees': [u'attendees',],
  u'description': [u'description',],
  u'location': [u'location',],
  u'summary': [u'summary',],
  u'creatorname': [u'creator', u'displayName'],
  u'creatoremail': [u'creator', u'email'],
  u'organizername': [u'organizer', u'displayName'],
  u'organizeremail': [u'organizer', u'email'],
  }

def _getCalendarListEventsProperty(myarg, attributes, kwargs):
  attrName, attribute = attributes.get(myarg, (None, None))
  if not attrName:
    return False
  attrType = attribute[GC.VAR_TYPE]
  if attrType == GC.TYPE_BOOLEAN:
    kwargs[attrName] = True
  elif attrType == GC.TYPE_STRING:
    kwargs[attrName] = getString(Cmd.OB_STRING)
  elif attrType == GC.TYPE_CHOICE:
    kwargs[attrName] = getChoice(attribute[u'choices'], mapChoice=True)
  elif attrType == GC.TYPE_DATETIME:
    kwargs[attrName] = getTimeOrDeltaFromNow()
  else: # GC.TYPE_INTEGER
    minVal, maxVal = attribute[GC.VAR_LIMITS]
    kwargs[attrName] = getInteger(minVal=minVal, maxVal=maxVal)
  return True

def _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
  return _getCalendarListEventsProperty(myarg, LIST_EVENTS_DISPLAY_PROPERTIES, calendarEventEntity[u'kwargs'])

def initCalendarEventEntity():
  return {u'list': [], u'queries': [], u'kwargs': {}, u'dict': None, u'matches': [], u'maxinstances': -1}

def getCalendarEventEntity(noIds=False):
  calendarEventEntity = initCalendarEventEntity()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'event', u'events']:
      if noIds:
        unknownArgumentExit()
      entitySelector = getEntitySelector()
      if entitySelector:
        entityList = getEntitySelection(entitySelector, False)
        if isinstance(entityList, dict):
          calendarEventEntity[u'dict'] = entityList
        else:
          calendarEventEntity[u'list'] = entityList
      else:
        calendarEventEntity[u'list'].extend(convertEntityToList(getString(Cmd.OB_EVENT_ID)))
    elif myarg in [u'q', u'query', u'eventquery']:
      calendarEventEntity[u'queries'].append(getString(Cmd.OB_QUERY))
    elif myarg == u'matchfield':
      matchField = getChoice(LIST_EVENTS_MATCH_FIELDS, mapChoice=True)
      if matchField[0] != u'attendees':
        matchPattern = getREPattern(re.IGNORECASE)
      else:
        matchPattern = convertEntityToList(getString(Cmd.OB_EMAIL_ADDRESS, minLen=0))
      calendarEventEntity[u'matches'].append((matchField, matchPattern))
    elif myarg == u'maxinstances':
      calendarEventEntity[u'maxinstances'] = getInteger(minVal=-1)
    elif _getCalendarListEventsProperty(myarg, LIST_EVENTS_SELECT_PROPERTIES, calendarEventEntity[u'kwargs']):
      pass
    else:
      Cmd.Backup()
      break
  return calendarEventEntity

#
CALENDAR_MIN_COLOR_INDEX = 1
CALENDAR_MAX_COLOR_INDEX = 24

CALENDAR_EVENT_MIN_COLOR_INDEX = 1
CALENDAR_EVENT_MAX_COLOR_INDEX = 11

CALENDAR_EVENT_STATUS_CHOICES = [u'confirmed', u'tentative', u'cancelled',]
CALENDAR_EVENT_TRANSPARENCY_CHOICES = [u'opaque', u'transparent',]
CALENDAR_EVENT_VISIBILITY_CHOICES = [u'default', u'public', u'private', u'confedential']

def _getCalendarEventAttribute(myarg, body, parameters, function):
  if function == u'insert' and myarg in [u'id', u'eventid']:
    body[u'id'] = getEventID()
  elif function == u'import' and myarg == u'icaluid':
    body[u'iCalUID'] = getString(Cmd.OB_ICALUID)
  elif myarg == u'description':
    body[u'description'] = getStringWithCRsNLs()
  elif myarg == u'location':
    body[u'location'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg == u'source':
    body[u'source'] = {u'title': getString(Cmd.OB_STRING), u'url': getString(Cmd.OB_URL)}
  elif myarg == u'summary':
    body[u'summary'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg == u'start':
    body[u'start'] = getEventTime()
  elif myarg == u'end':
    body[u'end'] = getEventTime()
  elif myarg == u'attachment':
    body.setdefault(u'attachments', [])
    body[u'attachments'].append({u'title': getString(Cmd.OB_STRING), u'fileUrl': getString(Cmd.OB_URL)})
  elif function == u'update' and myarg == u'clearattachments':
    body[u'attachments'] = []
  elif myarg == u'recurrence':
    body.setdefault(u'recurrence', [])
    body[u'recurrence'].append(getString(Cmd.OB_RECURRENCE))
  elif myarg == u'timezone':
    parameters[u'timeZone'] = getString(Cmd.OB_STRING)
  elif myarg == u'attendee':
    body.setdefault(u'attendees', [])
    body[u'attendees'].append({u'email': getEmailAddress(noUid=True)})
  elif myarg == u'optionalattendee':
    body.setdefault(u'attendees', [])
    body[u'attendees'].append({u'email': getEmailAddress(noUid=True), u'optional': True})
  elif function != u'import' and myarg == u'sendnotifications':
    parameters[u'sendNotifications'] = getBoolean()
  elif function != u'import' and myarg == u'notifyattendees':
    parameters[u'sendNotifications'] = True
  elif myarg == u'anyonecanaddself':
    body[u'anyoneCanAddSelf'] = getBoolean()
  elif myarg == u'guestscaninviteothers':
    body[u'guestsCanInviteOthers'] = getBoolean()
  elif myarg == u'guestscantinviteothers':
    body[u'guestsCanInviteOthers'] = False
  elif myarg == u'guestscanseeotherguests':
    body[u'guestsCanSeeOtherGuests'] = getBoolean()
  elif myarg == u'guestscantseeotherguests':
    body[u'guestsCanSeeOtherGuests'] = False
  elif myarg == u'status':
    body[u'status'] = getChoice(CALENDAR_EVENT_STATUS_CHOICES)
  elif myarg == u'tentative':
    body[u'status'] = u'tentative'
  elif myarg == u'transparency':
    body[u'transparency'] = getChoice(CALENDAR_EVENT_TRANSPARENCY_CHOICES)
  elif myarg == u'available':
    body[u'transparency'] = u'transparent'
  elif myarg == u'visibility':
    body[u'visibility'] = getChoice(CALENDAR_EVENT_VISIBILITY_CHOICES)
  elif myarg in [u'colorindex', u'colorid']:
    body[u'colorId'] = str(getInteger(CALENDAR_EVENT_MIN_COLOR_INDEX, CALENDAR_EVENT_MAX_COLOR_INDEX))
  elif myarg == u'noreminders':
    body[u'reminders'] = {u'useDefault': False}
  elif myarg == u'reminder':
    body.setdefault(u'reminders', {u'overrides': [], u'useDefault': False})
    body[u'reminders'][u'overrides'].append(getCalendarReminder())
    body[u'reminders'][u'useDefault'] = False
  elif myarg == u'privateproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'private', {})
    key = getString(Cmd.OB_PROPERTY_KEY)
    body[u'extendedProperties'][u'private'][key] = getString(Cmd.OB_PROPERTY_VALUE, minLen=0)
  elif myarg == u'sharedproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'shared', {})
    key = getString(Cmd.OB_PROPERTY_KEY)
    body[u'extendedProperties'][u'shared'][key] = getString(Cmd.OB_PROPERTY_VALUE, minLen=0)
  elif function == u'update' and myarg == u'clearprivateproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'private', {})
    body[u'extendedProperties'][u'private'][getString(Cmd.OB_PROPERTY_KEY)] = None
  elif function == u'update' and myarg == u'clearsharedproperty':
    body.setdefault(u'extendedProperties', {})
    body[u'extendedProperties'].setdefault(u'shared', {})
    body[u'extendedProperties'][u'shared'][getString(Cmd.OB_PROPERTY_KEY)] = None
  elif function == u'import' and myarg == u'organizername':
    body.setdefault(u'orgainzer', {})
    body[u'orgainzer'][u'displayName'] = getString(Cmd.OB_NAME)
  elif function == u'import' and myarg == u'organizeremail':
    body.setdefault(u'orgainzer', {})
    body[u'orgainzer'][u'email'] = getEmailAddress(noUid=True)
  else:
    return False
  return True

def _eventMatches(event, match):
  eventAttr = event
  for attr in match[0]:
    eventAttr = eventAttr.get(attr)
    if not eventAttr:
      return False
  if match[0][0] != u'attendees':
    return match[1].search(eventAttr) is not None
  attendees = [attendee[u'email'] for attendee in eventAttr]
  for attendee in match[1]:
    if attendee not in attendees:
      return False
  return True

def _validateCalendarGetEventIDs(origUser, user, cal, calId, j, jcount, calendarEventEntity, doIt=True, showAction=True):
  if calendarEventEntity[u'dict']:
    if origUser:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        calEventIds = calendarEventEntity[u'dict'][calId][:]
      else:
        calEventIds = calendarEventEntity[u'dict'][origUser][calId][:]
    else:
      calEventIds = calendarEventEntity[u'dict'][calId][:]
  else:
    calEventIds = calendarEventEntity[u'list'][:]
  calId = normalizeCalendarId(calId, user)
  if not calEventIds:
    fieldList = [u'id',]
    for match in calendarEventEntity[u'matches']:
      fieldList.append(match[0][0])
    fields = u','.join(fieldList)
    try:
      eventIdsSet = set()
      calEventIds = []
      if len(calendarEventEntity[u'queries']) <= 1:
        if len(calendarEventEntity[u'queries']) == 1:
          calendarEventEntity[u'kwargs'][u'q'] = calendarEventEntity[u'queries'][0]
        events = callGAPIpages(cal.events(), u'list', u'items',
                               throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                               calendarId=calId, fields=u'nextPageToken,items({0})'.format(fields),
                               maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity[u'kwargs'])
        while events:
          event = events.popleft()
          for match in calendarEventEntity[u'matches']:
            if not _eventMatches(event, match):
              break
          else:
            calEventIds.append(event[u'id'])
      else:
        for query in calendarEventEntity[u'queries']:
          calendarEventEntity[u'kwargs'][u'q'] = query
          events = callGAPIpages(cal.events(), u'list', u'items',
                                 throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                 calendarId=calId, fields=u'nextPageToken,items({0})'.format(fields),
                                 maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity[u'kwargs'])
          while events:
            event = events.popleft()
            for match in calendarEventEntity[u'matches']:
              if not _eventMatches(event, match):
                break
            else:
              eventId = event[u'id']
              if eventId not in eventIdsSet:
                calEventIds.append(eventId)
                eventIdsSet.add(eventId)
      kcount = len(calEventIds)
      if kcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.CALENDAR, calId], Ent.EVENT, kcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(Ent.EVENT)), j, jcount)
        setSysExitRC(NO_ENTITIES_FOUND)
        return (calId, cal, None, 0)
    except GAPI.notFound:
      entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
      return (calId, cal, None, 0)
    except (GAPI.notACalendarUser, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
      return (calId, cal, None, 0)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
      return (calId, cal, None, 0)
  else:
    kcount = len(calEventIds)
  if kcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if not doIt:
    if showAction:
      entityNumEntitiesActionNotPerformedWarning([Ent.CALENDAR, calId], Ent.EVENT, kcount, Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
    return (calId, cal, None, 0)
  if showAction:
    entityPerformActionNumItems([Ent.CALENDAR, calId], kcount, Ent.EVENT, j, jcount)
  return (calId, cal, calEventIds, kcount)

def _validateCalendarGetEvents(origUser, user, cal, calId, j, jcount, calendarEventEntity, showAction):
  if calendarEventEntity[u'dict']:
    if origUser:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        calEventIds = calendarEventEntity[u'dict'][calId][:]
      else:
        calEventIds = calendarEventEntity[u'dict'][origUser][calId][:]
    else:
      calEventIds = calendarEventEntity[u'dict'][calId][:]
  else:
    calEventIds = calendarEventEntity[u'list'][:]
  calId = normalizeCalendarId(calId, user)
  eventIdsSet = set()
  eventsList = collections.deque()
  try:
    if not calEventIds:
      if len(calendarEventEntity[u'queries']) <= 1:
        if len(calendarEventEntity[u'queries']) == 1:
          calendarEventEntity[u'kwargs'][u'q'] = calendarEventEntity[u'queries'][0]
        events = callGAPIpages(cal.events(), u'list', u'items',
                               throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                               calendarId=calId, fields=u'nextPageToken,items',
                               maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity[u'kwargs'])
        while events:
          event = events.popleft()
          for match in calendarEventEntity[u'matches']:
            if not _eventMatches(event, match):
              break
          else:
            eventsList.append(event)
      else:
        for query in calendarEventEntity[u'queries']:
          calendarEventEntity[u'kwargs'][u'q'] = query
          events = callGAPIpages(cal.events(), u'list', u'items',
                                 throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                 calendarId=calId, fields=u'nextPageToken,items',
                                 maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity[u'kwargs'])
          while events:
            event = events.popleft()
            for match in calendarEventEntity[u'matches']:
              if not _eventMatches(event, match):
                break
            else:
              eventId = event[u'id']
              if eventId not in eventIdsSet:
                eventsList.append(event)
                eventIdsSet.add(eventId)
    else:
      k = 0
      for eventId in calEventIds:
        k += 1
        if eventId not in eventIdsSet:
          eventsList.append(callGAPI(cal.events(), u'get',
                                     throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                                     calendarId=calId, eventId=eventId))
          eventIdsSet.add(eventId)
    kcount = len(eventsList)
    if showAction:
      entityPerformActionNumItems([Ent.CALENDAR, calId], kcount, Ent.EVENT, j, jcount)
    if kcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    return (calId, cal, eventsList, kcount)
  except (GAPI.notFound, GAPI.deleted) as e:
    if not checkCalendarExists(cal, calId):
      entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
      return (calId, cal, [], 0)
    entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), k, kcount)
  except (GAPI.notACalendarUser, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
    return (calId, cal, [], 0)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
    return (calId, cal, [], 0)

def _checkIfEventRecurrenceTimeZoneRequired(body, parameters):
  if (u'recurrence' in body) and ((u'start' in body) or (u'end' in body)):
    timeZone = parameters.get(u'timeZone')
    if not timeZone:
      return True
    if u'start' in body:
      body[u'start'][u'timeZone'] = timeZone
    if u'end' in body:
      body[u'end'][u'timeZone'] = timeZone
  return False

def _setEventRecurrenceTimeZone(cal, calId, body, i, count):
  try:
    timeZone = callGAPI(cal.calendars(), u'get',
                        throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                        calendarId=calId, fields=u'timeZone')[u'timeZone']
    if u'start' in body:
      body[u'start'][u'timeZone'] = timeZone
    if u'end' in body:
      body[u'end'][u'timeZone'] = timeZone
    return True
  except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden, GAPI.invalid) as e:
    entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
  return False

def _createCalendarEvents(user, cal, function, calIds, count,
                          eventRecurrenceTimeZoneRequired, sendNotifications, body):
  i = 0
  for calId in calIds:
    i += 1
    calId = normalizeCalendarId(calId, user)
    if eventRecurrenceTimeZoneRequired and not _setEventRecurrenceTimeZone(cal, calId, body, i, count):
      continue
    try:
      if function == u'insert':
        event = callGAPI(cal.events(), u'insert',
                         throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.INVALID, GAPI.REQUIRED, GAPI.TIME_RANGE_EMPTY, GAPI.DUPLICATE, GAPI.FORBIDDEN],
                         calendarId=calId, sendNotifications=sendNotifications, supportsAttachments=True, body=body, fields=u'id')
      else:
        event = callGAPI(cal.events(), u'import_',
                         throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.INVALID, GAPI.REQUIRED, GAPI.TIME_RANGE_EMPTY, GAPI.DUPLICATE, GAPI.FORBIDDEN],
                         calendarId=calId, supportsAttachments=True, body=body, fields=u'id')
      entityActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, event[u'id']], i, count)
    except (GAPI.invalid, GAPI.required, GAPI.timeRangeEmpty) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, u''], str(e), i, count)
      return False
    except GAPI.duplicate as e:
      entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, u''], str(e), i, count)
    except (GAPI.forbidden, GAPI.notACalendarUser) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
      break
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
      break
  return True

def _updateDeleteCalendarEvents(origUser, user, cal, calIds, count, function, calendarEventEntity, doIt,
                                eventRecurrenceTimeZoneRequired, body, kwargs):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, cal, calId, i, count, calendarEventEntity, doIt=doIt)
    if jcount == 0:
      continue
    if eventRecurrenceTimeZoneRequired and not _setEventRecurrenceTimeZone(cal, calId, body, i, count):
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        callGAPI(cal.events(), function,
                 throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN, GAPI.INVALID, GAPI.REQUIRED, GAPI.TIME_RANGE_EMPTY],
                 calendarId=calId, eventId=eventId, **kwargs)
        entityActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, eventId], j, jcount)
      except (GAPI.notFound, GAPI.deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
          break
        else:
          entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except (GAPI.invalid, GAPI.required, GAPI.timeRangeEmpty) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
        return False
      except (GAPI.forbidden, GAPI.notACalendarUser) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()
  return True

def _wipeCalendarEvents(user, cal, calIds, count):
  i = 0
  for calId in calIds:
    i += 1
    if user:
      calId = normalizeCalendarId(calId, user)
    else:
      calId, cal = buildGAPIServiceObject(API.CALENDAR, calId, i, count)
      if not cal:
        continue
    try:
      callGAPI(cal.calendars(), u'clear',
               throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
               calendarId=calId)
      entityActionPerformed([Ent.CALENDAR, calId], i, count)
    except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)

def _moveCalendarEvents(origUser, user, cal, calIds, count, calendarEventEntity, newCalId, sendNotifications):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, cal, calId, i, count, calendarEventEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        callGAPI(cal.events(), u'move',
                 throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.CANNOT_CHANGE_ORGANIZER],
                 calendarId=calId, eventId=eventId, destination=newCalId, sendNotifications=sendNotifications, fields=u'')
        entityModifierNewValueActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, eventId], Act.MODIFIER_TO, u'{0}: {1}'.format(Ent.Singular(Ent.CALENDAR), newCalId), j, jcount)
      except GAPI.notFound as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, i, count)
          break
        else:
          entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId, Ent.CALENDAR, newCalId], Ent.TypeNameMessage(Ent.EVENT, eventId, str(e)), j, jcount)
      except (GAPI.notACalendarUser, GAPI.forbidden, GAPI.cannotChangeOrganizer) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()

EVENT_PRINT_ORDER = [u'id', u'summary', u'description', u'location',
                     u'start', u'end', u'endTimeUnspecified',
                     u'creator', u'organizer', u'status', u'created', u'updated', u'iCalUID']

EVENT_TIME_OBJECTS = set([u'created', u'updated', u'dateTime'])

def _showCalendarEvent(primaryEmail, calId, eventEntityType, event, k, kcount, formatJSON):
  if formatJSON:
    if primaryEmail:
      printLine(json.dumps(cleanJSON({u'primaryEmail': primaryEmail, u'calendarId': calId, u'event': event}, u'', timeObjects=EVENT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    else:
      printLine(json.dumps(cleanJSON({u'calendarId': calId, u'event': event}, u'', timeObjects=EVENT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([eventEntityType, event[u'id']], k, kcount)
  skipObjects = set([u'id',])
  Ind.Increment()
  for field in EVENT_PRINT_ORDER:
    if field in event:
      showJSON(field, event[field], skipObjects, EVENT_TIME_OBJECTS)
      skipObjects.add(field)
  showJSON(None, event, skipObjects)
  Ind.Decrement()

def _infoCalendarEvents(origUser, user, cal, calIds, count, calendarEventEntity, formatJSON):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, cal, calId, i, count, calendarEventEntity, showAction=not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        event = callGAPI(cal.events(), u'get',
                         throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                         calendarId=calId, eventId=eventId)
        if calendarEventEntity[u'maxinstances'] == -1 or u'recurrence' not in event:
          _showCalendarEvent(user, calId, Ent.EVENT, event, j, jcount, formatJSON)
        else:
          instances = callGAPIpages(cal.events(), u'instances', u'items',
                                    throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                                    calendarId=calId, eventId=eventId,
                                    maxItems=calendarEventEntity[u'maxinstances'], maxResults=GC.Values[GC.EVENT_MAX_RESULTS])
          lcount = len(instances)
          if not formatJSON:
            entityPerformActionNumItems([Ent.EVENT, event[u'id']], lcount, Ent.INSTANCE, j, jcount)
          Ind.Increment()
          l = 0
          for instance in instances:
            l += 1
            _showCalendarEvent(user, calId, Ent.INSTANCE, instance, l, lcount, formatJSON)
          Ind.Decrement()
      except (GAPI.notFound, GAPI.deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, i, count)
          break
        else:
          entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except (GAPI.notACalendarUser, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()

def _printShowCalendarEvents(origUser, user, cal, calIds, count, calendarEventEntity, csvFormat, formatJSON, csvRows, titles):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, events, jcount = _validateCalendarGetEvents(origUser, user, cal, calId, i, count, calendarEventEntity, not csvFormat and not formatJSON)
    if not csvFormat:
      Ind.Increment()
      j = 0
      for event in events:
        j += 1
        _showCalendarEvent(user, calId, Ent.EVENT, event, j, jcount, formatJSON)
      Ind.Decrement()
    else:
      printGettingEntityItemForWhom(Ent.EVENT, calId, i, count)
      if not formatJSON:
        if events:
          for event in events:
            flattened = {u'calendarId': calId}
            if user:
              flattened[u'primaryEmail'] = user
            addRowTitlesToCSVfile(flattenJSON(event, flattened=flattened, timeObjects=EVENT_TIME_OBJECTS), csvRows, titles)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and user:
          csvRows.append({u'calendarId': calId, u'primaryEmail': user})
      else:
        if events:
          for event in events:
            flattened = {u'calendarId': calId, u'JSON': json.dumps(cleanJSON(event, u'', timeObjects=EVENT_TIME_OBJECTS), ensure_ascii=False, sort_keys=False)}
            if user:
              flattened[u'primaryEmail'] = user
            csvRows.append(flattened)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and user:
          csvRows.append({u'primaryEmail': user, u'calendarId': calId, u'JSON': json.dumps({})})

def _getCalendarCreateImportEventOptions(function):
  body = {}
  parameters = {u'sendNotifications': None}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if not _getCalendarEventAttribute(myarg, body, parameters, function):
      unknownArgumentExit()
  if (function == u'import') and (u'iCalUID' not in body):
    missingArgumentExit(Cmd.OB_ICALUID)
  return (body, parameters)

def _doCalendarsCreateImportEvent(cal, calIds, function):
  body, parameters = _getCalendarCreateImportEventOptions(function)
  _createCalendarEvents(None, cal, function, calIds, len(calIds),
                        _checkIfEventRecurrenceTimeZoneRequired(body, parameters), parameters[u'sendNotifications'], body)

# gam calendars <CalendarEntity> create|add event [id <String>] <EventAddAttributes>+
# gam calendar <UserItem> addevent [id <String>] <EventAddAttributes>+
def doCalendarsCreateEvent(cal, calIds):
  _doCalendarsCreateImportEvent(cal, calIds, u'insert')

# gam calendars <CalendarEntity> import event icaluid <iCalUID> <EventImportAttributes>+
def doCalendarsImportEvent(cal, calIds):
  _doCalendarsCreateImportEvent(cal, calIds, u'import')

def _getCalendarUpdateEventOptions():
  body = {}
  parameters = {u'sendNotifications': None}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getCalendarEventAttribute(myarg, body, parameters, u'update'):
      pass
    else:
      unknownArgumentExit()
  return (body, parameters)

# gam calendars <CalendarEntity> update event <EventEntity> <EventUpdateAttributes>+
def doCalendarsUpdateEvents(cal, calIds):
  calendarEventEntity = getCalendarEventEntity()
  body, parameters = _getCalendarUpdateEventOptions()
  _updateDeleteCalendarEvents(None, None, cal, calIds, len(calIds), u'patch', calendarEventEntity, True,
                              _checkIfEventRecurrenceTimeZoneRequired(body, parameters), body,
                              {u'supportsAttachments': True, u'body': body, u'sendNotifications': parameters[u'sendNotifications'], u'fields': u''})

def _getCalendarDeleteEventOptions():
  doIt = sendNotifications = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notifyattendees':
      sendNotifications = True
    elif myarg == u'doit':
      doIt = True
    else:
      unknownArgumentExit()
  return (doIt, sendNotifications)

# gam calendars <CalendarEntity> delete event <EventEntity> [doit] [notifyattendees]
# gam calendar <UserItem> deleteevent <EventEntity> [doit] [notifyattendees]
def doCalendarsDeleteEvents(cal, calIds):
  calendarEventEntity = getCalendarEventEntity()
  doIt, sendNotifications = _getCalendarDeleteEventOptions()
  _updateDeleteCalendarEvents(None, None, cal, calIds, len(calIds), u'delete', calendarEventEntity, doIt,
                              False, {},
                              {u'sendNotifications': sendNotifications})

# gam calendars <CalendarEntity> wipe events
# gam calendar <UserItem> wipe
def doCalendarsWipeEvents(cal, calIds):
  checkArgumentPresent([Cmd.ARG_EVENT, Cmd.ARG_EVENTS])
  checkForExtraneousArguments()
  _wipeCalendarEvents(None, cal, calIds, len(calIds))

def _getMoveEventsOptions():
  sendNotifications = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notifyattendees':
      sendNotifications = True
    else:
      unknownArgumentExit()
  return sendNotifications

# gam calendars <CalendarEntity> move events <EventEntity> to <CalendarItem> [notifyattendees]
def doCalendarsMoveEvents(cal, calIds):
  sendNotifications = False
  calendarEventEntity = getCalendarEventEntity()
  checkArgumentPresent(u'to')
  newCalId = convertUIDtoEmailAddress(getString(Cmd.OB_CALENDAR_ITEM))
  sendNotifications = _getMoveEventsOptions()
  if not checkCalendarExists(cal, newCalId, True):
    return
  _moveCalendarEvents(None, None, cal, calIds, len(calIds), calendarEventEntity, newCalId, sendNotifications)

# gam calendars <CalendarEntity> info event <EventEntity> [formatjson]
def doCalendarsInfoEvents(cal, calIds):
  calendarEventEntity = getCalendarEventEntity()
  formatJSON = _getCalendarInfoACLEventOptions()
  _infoCalendarEvents(None, None, cal, calIds, len(calIds), calendarEventEntity, formatJSON)

def _getCalendarPrintShowEventOptions(calendarEventEntity, csvFormat, entityType):
  todrive = {}
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
      pass
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  sortTitles = []
  if csvFormat:
    if entityType == Ent.USER:
      sortTitles = [u'primaryEmail', u'calendarId']
    else: # Ent.CALENDAR:
      sortTitles = [u'calendarId',]
    if not formatJSON:
      sortTitles.extend(EVENT_PRINT_ORDER)
    else:
      sortTitles.append(u'JSON')
  return (todrive, formatJSON, quotechar, sortTitles)

def calendarsPrintShowEvents(cal, calIds, csvFormat):
  calendarEventEntity = getCalendarEventEntity(noIds=True)
  todrive, formatJSON, quotechar, sortTitles = _getCalendarPrintShowEventOptions(calendarEventEntity, csvFormat, Ent.CALENDAR)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  else:
    titles = csvRows = None
  _printShowCalendarEvents(None, None, cal, calIds, len(calIds), calendarEventEntity, csvFormat, formatJSON, csvRows, titles)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Calendar Events', todrive, sortTitles, quotechar)

# gam calendars <CalendarEntity> print events <EventSelectProperties>* <EventDisplayProperties>*
#	[formatjson] [quotechar <Character>] [todrive [<ToDriveAttributes>]]
def doCalendarsPrintEvents(cal, calIds):
  calendarsPrintShowEvents(cal, calIds, True)

# gam calendars <CalendarEntity> show events <EventSelectProperties>* <EventDisplayProperties>* [formatjson]
def doCalendarsShowEvents(cal, calIds):
  calendarsPrintShowEvents(cal, calIds, False)

# <CalendarSettings> ::==
#	[description <String>] [location <String>] [summary <String>] [timezone <String>]
def _getCalendarSettings(summaryRequired=False):
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'description':
      body[u'description'] = getStringWithCRsNLs()
    elif myarg == u'location':
      body[u'location'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == u'summary':
      body[u'summary'] = getString(Cmd.OB_STRING)
    elif myarg == u'timezone':
      body[u'timeZone'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  if summaryRequired and not body.get(u'summary', None):
    missingArgumentExit(u'summary <String>')
  return body

# gam calendars <CalendarEntity> modify <CalendarSettings>
def doCalendarsModifySettings(cal, calIds):
  body = _getCalendarSettings(summaryRequired=False)
  count = len(calIds)
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = buildGAPIServiceObject(API.CALENDAR, calId, i, count)
    if not cal:
      continue
    try:
      callGAPI(cal.calendars(), u'patch',
               throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
               calendarId=calId, body=body)
      entityActionPerformed([Ent.CALENDAR, calId], i, count)
    except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)

def _validateResourceId(resourceId, i, count):
  cd = buildGAPIObject(API.DIRECTORY)
  try:
    return callGAPI(cd.resources().calendars(), u'get',
                    throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                    customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, fields=u'resourceEmail')[u'resourceEmail']
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)
    return None

def _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity, showAction=True):
  calId = _validateResourceId(resourceId, i, count)
  if not calId:
    return (None, None, 0)
  if ACLScopeEntity[u'dict']:
    ruleIds = ACLScopeEntity[u'dict'][resourceId]
  else:
    ruleIds = ACLScopeEntity[u'list']
  jcount = len(ruleIds)
  if showAction:
    entityPerformActionNumItems([Ent.RESOURCE_CALENDAR, resourceId], jcount, Ent.CALENDAR_ACL, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (calId, ruleIds, jcount)

# gam resource <ResourceID> create|add calendaracls <CalendarACLRole> <CalendarACLScopeEntity>
# gam resources <ResourceEntity> create|add calendaracls <CalendarACLRole> <CalendarACLScopeEntity>
def doResourceCreateCalendarACLs(entityList):
  cal = buildGAPIObject(API.CALENDAR)
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _createCalendarACLs(cal, Ent.RESOURCE_CALENDAR, calId, i, count, role, ruleIds, jcount)

def _resourceUpdateDeleteCalendarACLs(entityList, function, role, body):
  cal = buildGAPIObject(API.CALENDAR)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _updateDeleteCalendarACLs(cal, function, Ent.RESOURCE_CALENDAR, calId, i, count, role, body, ruleIds, jcount)

# gam resource <ResourceID> update calendaracls <CalendarACLRole> <CalendarACLScopeEntity>
# gam resources <ResourceEntity> update calendaracls <CalendarACLRole> <CalendarACLScopeEntity>
def doResourceUpdateCalendarACLs(entityList):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  body = {u'role': role}
  _resourceUpdateDeleteCalendarACLs(entityList, u'patch', role, body)

# gam resource <ResourceID> delete calendaracls [<CalendarACLRole>] <CalendarACLScopeEntity>
# gam resources <ResourceEntity> delete calendaracls [<CalendarACLRole>] <CalendarACLScopeEntity>
def doResourceDeleteCalendarACLs(entityList):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  body = {}
  _resourceUpdateDeleteCalendarACLs(entityList, u'delete', role, body)

# gam resource <ResourceID> info calendaracls <CalendarACLScopeEntity> [formatjson]
# gam resources <ResourceEntity> info calendaracls <CalendarACLScopeEntity> [formatjson]
def doResourceInfoCalendarACLs(entityList):
  cal = buildGAPIObject(API.CALENDAR)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  formatJSON = _getCalendarInfoACLEventOptions()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity, showAction=not formatJSON)
    if jcount == 0:
      continue
    _infoCalendarACLs(cal, resourceId, Ent.RESOURCE_CALENDAR, calId, i, count, ruleIds, jcount, formatJSON)

def _doResourcePrintShowCalendarACLs(entityList, csvFormat):
  cal = buildGAPIObject(API.CALENDAR)
  todrive, formatJSON, quotechar, sortTitles = _getCalendarPrintShowACLOptions(csvFormat, Ent.RESOURCE_CALENDAR)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  else:
    titles = csvRows = None
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId = _validateResourceId(resourceId, i, count)
    if not calId:
      continue
    _printShowCalendarACLs(cal, resourceId, Ent.RESOURCE_CALENDAR, calId, i, count, csvFormat, formatJSON, csvRows, titles)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Resource Calendar ACLs', todrive, sortTitles, quotechar)

# gam resource <ResourceID> print calendaracls [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>]
# gam resources <ResourceEntity> print calendaracls [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>]
def doResourcePrintCalendarACLs(entityList):
  _doResourcePrintShowCalendarACLs(entityList, True)

# gam resource <ResourceID> show calendaracls [formatjson]
# gam resources <ResourceEntity> show calendaracls [formatjson]
def doResourceShowCalendarACLs(entityList):
  _doResourcePrintShowCalendarACLs(entityList, False)

def _showSchema(schema, i=0, count=0):
  printEntity([Ent.USER_SCHEMA, schema[u'schemaName']], i, count)
  Ind.Increment()
  for a_key in schema:
    if a_key not in set([u'kind', u'etag', u'schemaName', u'fields']):
      printKeyValueList([a_key, schema[a_key]])
  for field in schema[u'fields']:
    printKeyValueList([u'Field', field[u'fieldName']])
    Ind.Increment()
    for a_key in field:
      if a_key not in set([u'kind', u'etag', u'fieldName']):
        printKeyValueList([a_key, field[a_key]])
    Ind.Decrement()
  Ind.Decrement()

SCHEMA_FIELDTYPE_CHOICE_MAP = {
  u'bool': u'BOOL',
  u'date': u'DATE',
  u'double': u'DOUBLE',
  u'email': u'EMAIL',
  u'int64': u'INT64',
  u'phone': u'PHONE',
  u'string': u'STRING',
  }

def _doCreateUpdateUserSchemas(updateCmd, entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  addBody = {u'schemaName': u'', u'fields': []}
  deleteFields = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'field':
      a_field = {u'fieldName': getString(Cmd.OB_FIELD_NAME), u'fieldType': u'STRING'}
      while Cmd.ArgumentsRemaining():
        argument = getArgument()
        if argument == u'type':
          a_field[u'fieldType'] = getChoice(SCHEMA_FIELDTYPE_CHOICE_MAP, mapChoice=True)
        elif argument in [u'multivalued', u'multivalue']:
          a_field[u'multiValued'] = True
        elif argument == u'indexed':
          a_field[u'indexed'] = True
        elif argument == u'restricted':
          a_field[u'readAccessType'] = u'ADMINS_AND_SELF'
        elif argument == u'range':
          a_field[u'numericIndexingSpec'] = {u'minValue': getInteger(), u'maxValue': getInteger()}
        elif argument == u'endfield':
          break
        elif argument == u'field':
          Cmd.Backup()
          break
        else:
          unknownArgumentExit()
      addBody[u'fields'].append(a_field)
    elif updateCmd and myarg == u'deletefield':
      deleteFields.append(getString(Cmd.OB_FIELD_NAME))
    else:
      unknownArgumentExit()
  if not updateCmd and not addBody[u'fields']:
    missingArgumentExit(u'SchemaFieldDefinition')
  i = 0
  count = len(entityList)
  for schemaName in entityList:
    i += 1
    try:
      if updateCmd:
        oldBody = callGAPI(cd.schemas(), u'get',
                           throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                           customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaName, fields=u'schemaName,fields')
        for field in oldBody[u'fields']:
          field.pop(u'etag', None)
          field.pop(u'kind', None)
          field.pop(u'fieldId', None)
        badDelete = False
        for delField in deleteFields:
          fieldNameLower = delField.lower()
          for n, field in enumerate(oldBody[u'fields']):
            if field[u'fieldName'].lower() == fieldNameLower:
              del oldBody[u'fields'][n]
              break
          else:
            entityActionNotPerformedWarning([Ent.USER_SCHEMA, schemaName, Ent.FIELD, delField], Msg.DOES_NOT_EXIST)
            badDelete = True
        if badDelete:
          continue
        for addField in addBody[u'fields']:
          fieldNameLower = addField[u'fieldName'].lower()
          for n, field in enumerate(oldBody[u'fields']):
            if field[u'fieldName'].lower() == fieldNameLower:
              del oldBody[u'fields'][n]
              break
        oldBody[u'fields'].extend(addBody[u'fields'])
        if not oldBody[u'fields']:
          entityActionNotPerformedWarning([Ent.USER_SCHEMA, schemaName],
                                          Msg.SCHEMA_WOULD_HAVE_NO_FIELDS.format(Ent.Singular(Ent.USER_SCHEMA), Ent.Plural(Ent.FIELD)))
          continue
        result = callGAPI(cd.schemas(), u'update',
                          throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          customerId=GC.Values[GC.CUSTOMER_ID], body=oldBody, schemaKey=schemaName)
        entityActionPerformed([Ent.USER_SCHEMA, result[u'schemaName']], i, count)
      else:
        addBody[u'schemaName'] = schemaName
        result = callGAPI(cd.schemas(), u'insert',
                          throw_reasons=[GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          customerId=GC.Values[GC.CUSTOMER_ID], body=addBody, fields=u'schemaName')
        entityActionPerformed([Ent.USER_SCHEMA, result[u'schemaName']], i, count)
    except GAPI.duplicate:
      entityDuplicateWarning([Ent.USER_SCHEMA, schemaName], i, count)
    except GAPI.conditionNotMet as e:
      entityActionFailedWarning([Ent.USER_SCHEMA, schemaName], str(e), i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.USER_SCHEMA, schemaName, i, count)

# gam create schema|schemas <SchemaName> <SchemaFieldDefinition>+
def doCreateUserSchema():
  _doCreateUpdateUserSchemas(False, getStringReturnInList(Cmd.OB_SCHEMA_NAME))

# gam update schema|schemas <SchemaEntity> <SchemaFieldDefinition>+
def doUpdateUserSchemas():
  _doCreateUpdateUserSchemas(True, getEntityList(Cmd.OB_SCHEMA_ENTITY))

# gam delete schema|schemas <SchemaEntity>
def doDeleteUserSchemas():
  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_SCHEMA_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for schemaKey in entityList:
    i += 1
    try:
      callGAPI(cd.schemas(), u'delete',
               throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaKey)
      entityActionPerformed([Ent.USER_SCHEMA, schemaKey], i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.USER_SCHEMA, schemaKey, i, count)

# gam info schema|schemas <SchemaEntity>
def doInfoUserSchemas():
  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_SCHEMA_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for schemaKey in entityList:
    i += 1
    try:
      schema = callGAPI(cd.schemas(), u'get',
                        throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                        customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaKey)
      _showSchema(schema, i, count)
    except (GAPI.invalid, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.USER_SCHEMA, schemaKey, i, count)

def _doPrintShowUserSchemas(csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  cd = buildGAPIObject(API.DIRECTORY)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    result = callGAPI(cd.schemas(), u'list',
                      throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      customerId=GC.Values[GC.CUSTOMER_ID])
    jcount = len(result.get(u'schemas', [])) if (result) else 0
    if not csvFormat:
      performActionNumItems(jcount, Ent.USER_SCHEMA)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    else:
      if not csvFormat:
        Ind.Increment()
        j = 0
        for schema in result[u'schemas']:
          j += 1
          _showSchema(schema, j, jcount)
        Ind.Decrement()
      else:
        for schema in result[u'schemas']:
          addRowTitlesToCSVfile(flattenJSON(schema), csvRows, titles)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'User Schemas', todrive, [u'schemaId', u'schemaName', u'fields.Count'])

# gam print schema|schemas [todrive [<ToDriveAttributes>]]
def doPrintUserSchemas():
  _doPrintShowUserSchemas(True)

# gam show schema|schemas
def doShowUserSchemas():
  _doPrintShowUserSchemas(False)

def formatHoldNameId(holdName, holdId):
  return u'{0}({1})'.format(holdName, holdId)

def convertHoldNameToID(v, nameOrId, matterId, matterNameId):
  cg = UID_PATTERN.match(nameOrId)
  if cg:
    try:
      hold = callGAPI(v.matters().holds(), u'get',
                      throw_reasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                      matterId=matterId, holdId=cg.group(1))
      return (hold[u'holdId'], hold[u'name'], formatHoldNameId(hold[u'holdId'], hold[u'name']))
    except (GAPI.notFound, GAPI.badRequest):
      entityDoesNotHaveItemExit([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, nameOrId])
    except GAPI.forbidden:
      APIAccessDeniedExit()
  nameOrIdlower = nameOrId.lower()
  try:
    holds = callGAPIpages(v.matters().holds(), u'list', u'holds',
                          throw_reasons=[GAPI.FORBIDDEN],
                          matterId=matterId, fields=u'holds(holdId,name),nextPageToken')
    for hold in holds:
      if hold[u'name'].lower() == nameOrIdlower:
        return (hold[u'holdId'], hold[u'name'], formatHoldNameId(hold[u'holdId'], hold[u'name']))
  except GAPI.forbidden:
    APIAccessDeniedExit()
  entityDoesNotHaveItemExit([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, nameOrId])

def formatMatterNameId(matterName, matterId):
  return u'{0}({1})'.format(matterName, matterId)

def convertMatterNameToID(v, nameOrId):
  cg = UID_PATTERN.match(nameOrId)
  if cg:
    try:
      matter = callGAPI(v.matters(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                        matterId=cg.group(1), view=u'BASIC', fields=u'matterId,name')
      return (matter[u'matterId'], matter[u'name'], formatMatterNameId(matter[u'name'], matter[u'matterId']))
    except (GAPI.notFound, GAPI.forbidden):
      entityDoesNotExistExit(Ent.VAULT_MATTER, nameOrId)
  nameOrIdlower = nameOrId.lower()
  ids = []
  try:
    matters = callGAPIpages(v.matters(), u'list', u'matters',
                            throw_reasons=[GAPI.FORBIDDEN],
                            view=u'BASIC', fields=u'matters(matterId,name),nextPageToken')
    for matter in matters:
      if matter[u'name'].lower() == nameOrIdlower:
        nameOrId = matter[u'name']
        ids.append(matter[u'matterId'])
  except GAPI.forbidden:
    APIAccessDeniedExit()
  if len(ids) == 1:
    return (ids[0], nameOrId, formatMatterNameId(nameOrId, ids[0]))
  if len(ids) == 0:
    entityDoesNotExistExit(Ent.VAULT_MATTER, nameOrId)
  else:
    entityIsNotUniqueExit(Ent.VAULT_MATTER, nameOrId, Ent.VAULT_MATTER_ID, ids)

def getMatterItem(v):
  matterId, _, matterNameId = convertMatterNameToID(v, getString(Cmd.OB_MATTER_ITEM))
  return (matterId, matterNameId)

VAULT_HOLD_CORPUS_ARGUMENT_MAP = {u'drive': u'DRIVE', u'groups': u'GROUPS', u'mail': u'MAIL'}

# gam create vaulthold|hold corpus drive|groups|mail matter <MatterItem> [name <String>] [query <QueryVaultCorpus>]
#	[(accounts|groups|users <EmailItemList>) | (orgunit|ou <OrgUnit>)]
#	[starttime <Date>|<DateTime>] [endtime <Date>|<DateTime>]
def doCreateVaultHold():
  v = buildGAPIObject(API.VAULT)
  body = {u'query': {}}
  query = matterId = startTime = endTime = None
  accounts = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'matter':
      matterId, matterNameId = getMatterItem(v)
    elif myarg == u'name':
      body[u'name'] = getString(Cmd.OB_STRING)
    elif myarg == u'query':
      queryLocation = Cmd.Location()
      query = getString(Cmd.OB_QUERY)
    elif myarg == u'corpus':
      body[u'corpus'] = getChoice(VAULT_HOLD_CORPUS_ARGUMENT_MAP, mapChoice=True)
    elif myarg in [u'accounts', u'users', u'groups']:
      accountsLocation = Cmd.Location()
      accounts = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
    elif myarg in [u'orgunit', u'ou']:
      _, orgUnitId = getOrgUnitId(None)
      body[u'orgUnit'] = {u'orgUnitId': orgUnitId}
    elif myarg == u'starttime':
      startTime = getTimeOrDeltaFromNow()
    elif myarg == u'endtime':
      endTime = getTimeOrDeltaFromNow()
    else:
      unknownArgumentExit()
  if matterId is None:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  if not body.get(u'name'):
    missingArgumentExit(u'name')
  if not body.get(u'corpus'):
    missingArgumentExit(u'corpus {0}'.format(u'|'.join(VAULT_HOLD_CORPUS_ARGUMENT_MAP)))
  query_type = u'{0}Query'.format(body[u'corpus'].lower())
  body[u'query'][query_type] = {}
  if body[u'corpus'] == u'DRIVE':
    if query:
      try:
        body[u'query'][query_type] = json.loads(query)
      except ValueError as e:
        Cmd.SetLocation(queryLocation)
        usageErrorExit(str(e))
  elif body[u'corpus'] in [u'GROUPS', u'MAIL']:
    if query:
      body[u'query'][query_type] = {u'terms': query}
    if startTime:
      body[u'query'][query_type][u'startTime'] = startTime
    if endTime:
      body[u'query'][query_type][u'endTime'] = endTime
  if accounts:
    body[u'accounts'] = []
    cd = buildGAPIObject(API.DIRECTORY)
    accountType = u'group' if body[u'corpus'] == u'GROUPS' else u'user'
    for account in accounts:
      body[u'accounts'].append({u'accountId': convertEmailAddressToUID(account, cd, accountType, accountsLocation)})
  try:
    result = callGAPI(v.matters().holds(), u'create',
                      throw_reasons=[GAPI.ALREADY_EXISTS, GAPI.BAD_REQUEST, GAPI.BACKEND_ERROR, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                      matterId=matterId, body=body, fields=u'holdId,name')
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, formatHoldNameId(result[u'name'], result[u'holdId'])])
  except (GAPI.alreadyExists, GAPI.badRequest, GAPI.backendError, GAPI.failedPrecondition, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, None], str(e))

# gam update vaulthold|hold <HoldItem> matter <MatterItem> [query <QueryVaultCorpus>]
#	[([addaccounts|addgroups|addusers <EmailItemList>] [removeaccounts|removegroups|removeusers <EmailItemList>]) | (orgunit|ou <OrgUnit>)]
#	[starttime <Date>|<DateTime>] [endtime <Date>|<DateTime>]
def doUpdateVaultHold():
  v = buildGAPIObject(API.VAULT)
  holdName = getString(Cmd.OB_HOLD_ITEM)
  matterId = None
  body = {}
  addAccounts = []
  addAccountIds = []
  removeAccounts = []
  removeAccountIds = []
  cd = query = startTime = endTime = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'matter':
      matterId, matterNameId = getMatterItem(v)
      holdId, holdName, holdNameId = convertHoldNameToID(v, holdName, matterId, matterNameId)
    elif myarg == u'query':
      queryLocation = Cmd.Location()
      query = getString(Cmd.OB_QUERY)
    elif myarg in [u'orgunit', u'ou']:
      _, orgUnitId = getOrgUnitId(None)
      body[u'orgUnit'] = {u'orgUnitId': orgUnitId}
    elif myarg == u'starttime':
      startTime = getTimeOrDeltaFromNow()
    elif myarg == u'endtime':
      endTime = getTimeOrDeltaFromNow()
    elif myarg in [u'addusers', u'addaccounts', u'addgroups']:
      addAccountsLocation = Cmd.Location()
      addAccounts = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
    elif myarg in [u'removeusers', u'removeaccounts', u'removegroups']:
      removeAccountsLocation = Cmd.Location()
      removeAccounts = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
    else:
      unknownArgumentExit()
  if matterId is None:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  try:
    old_body = callGAPI(v.matters().holds(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                        matterId=matterId, holdId=holdId, fields=u'name,corpus,query,orgUnit')
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))
    return
  accountType = u'group' if old_body[u'corpus'] == u'GROUPS' else u'user'
  if addAccounts:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    addAccountIds = []
    for account in addAccounts:
      addAccountIds.append({u'email': account, u'id': convertEmailAddressToUID(account, cd, accountType, addAccountsLocation)})
  if removeAccounts:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    removeAccountIds = []
    for account in removeAccounts:
      removeAccountIds.append({u'email': account, u'id': convertEmailAddressToUID(account, cd, accountType, removeAccountsLocation)})
  if query or startTime or endTime or body.get(u'orgUnit'):
    body[u'query'] = old_body[u'query']
    body[u'corpus'] = old_body[u'corpus']
    if u'orgUnit' in old_body and u'orgUnit' not in body:
      # bah, API requires this to be sent on update even when it's not changing
      body[u'orgUnit'] = old_body[u'orgUnit']
    query_type = '{0}Query'.format(body[u'corpus'].lower())
    if body[u'corpus'] == u'DRIVE':
      if query:
        try:
          body[u'query'][query_type] = json.loads(query)
        except ValueError as e:
          Cmd.SetLocation(queryLocation)
          usageErrorExit(str(e))
    elif body[u'corpus'] in [u'GROUPS', u'MAIL']:
      if  query:
        body[u'query'][query_type][u'terms'] = query
      if startTime:
        body[u'query'][query_type][u'startTime'] = startTime
      if endTime:
        body[u'query'][query_type][u'endTime'] = endTime
  if body:
    try:
      callGAPI(v.matters().holds(), u'update',
               throw_reasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
               matterId=matterId, holdId=holdId, body=body)
      entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId])
    except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))
      return
  jcount = len(addAccountIds)
  if jcount > 0:
    Act.Set(Act.ADD)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], jcount, Ent.ACCOUNT)
    Ind.Increment()
    j = 0
    for account in addAccountIds:
      j += 1
      try:
        callGAPI(v.matters().holds().accounts(), u'create',
                 throw_reasons=[GAPI.ALREADY_EXISTS, GAPI.BACKEND_ERROR, GAPI.FORBIDDEN],
                 matterId=matterId, holdId=holdId, body={u'accountId': account[u'id']})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account[u'email']], j, jcount)
      except (GAPI.alreadyExists, GAPI.backendError) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account[u'email']], str(e), j, jcount)
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, None], str(e))
        return
    Ind.Decrement()
  jcount = len(removeAccountIds)
  if jcount > 0:
    Act.Set(Act.REMOVE)
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], jcount, Ent.ACCOUNT)
    Ind.Increment()
    j = 0
    for account in removeAccountIds:
      j += 1
      try:
        callGAPI(v.matters().holds().accounts(), u'delete',
                 throw_reasons=[GAPI.NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.FORBIDDEN],
                 matterId=matterId, holdId=holdId, accountId=account[u'id'])
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account[u'email']], j, jcount)
      except (GAPI.alreadyExists, GAPI.backendError) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account[u'email']], str(e), j, jcount)
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, None], str(e))
        return
    Ind.Decrement()

# gam delete vaulthold|hold <HoldItem> matter <MatterItem>
def doDeleteVaultHold():
  v = buildGAPIObject(API.VAULT)
  holdName = getString(Cmd.OB_HOLD_ITEM)
  matterId = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'matter':
      matterId, matterNameId = getMatterItem(v)
      holdId, holdName, holdNameId = convertHoldNameToID(v, holdName, matterId, matterNameId)
    else:
      unknownArgumentExit()
  if matterId is None:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  try:
    callGAPI(v.matters().holds(), u'delete',
             throw_reasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
             matterId=matterId, holdId=holdId)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId])
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))

VAULT_HOLD_TIME_OBJECTS = set([u'holdTime', u'updateTime', u'startTime', u'endTime'])

def _getHoldEmailAddressesOrgUnitName(hold, cd):
  if u'accounts' in hold:
    accountType = u'group' if hold[u'corpus'] == u'GROUPS' else u'user'
    for i in range(0, len(hold[u'accounts'])):
      hold[u'accounts'][i][u'email'] = convertUIDtoEmailAddress(u'uid:{0}'.format(hold[u'accounts'][i][u'accountId']), cd, accountType)
  if u'orgUnit' in hold:
    hold[u'orgUnit'][u'orgUnitPath'] = convertOrgUnitIDtoPath(hold[u'orgUnit'][u'orgUnitId'], cd)

def _showVaultHold(hold, cd):
  if cd is not None:
    _getHoldEmailAddressesOrgUnitName(hold, cd)
  Ind.Increment()
  showJSON(None, hold, timeObjects=VAULT_HOLD_TIME_OBJECTS)
  Ind.Decrement()

# gam info vaulthold|hold <HoldItem> matter <MatterItem> [shownames]
def doInfoVaultHold():
  v = buildGAPIObject(API.VAULT)
  holdName = getString(Cmd.OB_HOLD_ITEM)
  cd = matterId = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'matter':
      matterId, matterNameId = getMatterItem(v)
      holdId, holdName, holdNameId = convertHoldNameToID(v, holdName, matterId, matterNameId)
    elif myarg == u'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
    else:
      unknownArgumentExit()
  if matterId is None:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  try:
    hold = callGAPI(v.matters().holds(), u'get',
                    throw_reasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                    matterId=matterId, holdId=holdId)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, formatHoldNameId(hold[u'name'], hold[u'holdId'])])
    _showVaultHold(hold, cd)
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))

PRINT_VAULT_HOLDS_TITLES = [u'matterId', u'matterName', u'holdId', u'name', u'corpus', u'updateTime']

def _doPrintShowVaultHolds(csvFormat):
  def _warnMatterNotOpen(matterNameId, j, jcount):
    printWarningMessage(DATA_NOT_AVALIABLE_RC, formatKeyValueList(u'',
                                                                  Ent.FormatEntityValueList([Ent.VAULT_MATTER, matterNameId])+[u'state is not OPEN',],
                                                                  currentCount(j, jcount)))
  v = buildGAPIObject(API.VAULT)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(PRINT_VAULT_HOLDS_TITLES)
    todrive = {}
  matters = []
  cd = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'matter', u'matters']:
      matters = getString(Cmd.OB_MATTER_ITEM_LIST).split(u',')
    elif myarg == u'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
    else:
      unknownArgumentExit()
  if not matters:
    printGettingAllAccountEntities(Ent.VAULT_MATTER)
    try:
      results = callGAPIpages(v.matters(), u'list', u'matters',
                              page_message=getPageMessage(),
                              throw_reasons=[GAPI.FORBIDDEN],
                              view=u'BASIC', fields=u'matters(matterId,name,state),nextPageToken')
    except GAPI.forbidden as e:
      entityActionFailedWarning([Ent.VAULT_HOLD, None], str(e))
      return
  else:
    results = collections.deque()
    for matter in matters:
      matterId, matterName, _ = convertMatterNameToID(v, matter)
      results.append({u'matterId': matterId, u'name': matterName, u'state': u'OPEN'})
  jcount = len(results)
  if not csvFormat:
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
  j = 0
  for matter in results:
    j += 1
    matterId = matter[u'matterId']
    matterName = matter[u'name']
    matterNameId = formatMatterNameId(matterName, matterId)
    if csvFormat:
      printGettingAllEntityItemsForWhom(Ent.VAULT_HOLD, u'{0}: {1}'.format(Ent.Singular(Ent.VAULT_MATTER), matterNameId), j, jcount)
      page_message = getPageMessageForWhom(noNL=True)
    else:
      page_message = None
    if matter[u'state'] == u'OPEN':
      try:
        holds = callGAPIpages(v.matters().holds(), u'list', u'holds',
                              page_message=page_message,
                              throw_reasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                              matterId=matterId)
      except GAPI.failedPrecondition as e:
        _warnMatterNotOpen(matterNameId, j, jcount)
        continue
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_HOLD, None], str(e))
        break
    else:
      _warnMatterNotOpen(matterNameId, j, jcount)
      continue
    kcount = len(holds)
    if not csvFormat:
      entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], kcount, Ent.VAULT_HOLD, j, jcount)
      Ind.Increment()
      k = 0
      for hold in holds:
        k += 1
        printEntity([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, formatHoldNameId(hold[u'name'], hold[u'holdId'])], k, kcount)
        _showVaultHold(hold, cd)
      Ind.Decrement()
    else:
      for hold in holds:
        if cd is not None:
          _getHoldEmailAddressesOrgUnitName(hold, cd)
        addRowTitlesToCSVfile(flattenJSON(hold, flattened={u'matterId': matterId, u'matterName': matterName}, timeObjects=VAULT_HOLD_TIME_OBJECTS), csvRows, titles)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Vault Holds', todrive, PRINT_VAULT_HOLDS_TITLES)

# gam print vaultholds|holds [todrive [<ToDriveAttributes>]] [matters <MatterItemList>] [shownames]
def doPrintVaultHolds():
  _doPrintShowVaultHolds(True)

# gam show vaultholds|holds [matters <MatterItemList>] [shownames]
def doShowVaultHolds():
  _doPrintShowVaultHolds(False)

def validateCollaborators(cd):
  collaborators = []
  for collaborator in getEntityList(Cmd.OB_COLLABORATOR_ENTITY):
    collaborators.append({u'email': collaborator, u'id': convertEmailAddressToUID(collaborator, cd)})
  return collaborators

# gam create vaultmatter|matter [name <String>] [description <string>]
#	[collaborator|collaborators <CollaboratorItemList>]
def doCreateVaultMatter():
  v = buildGAPIObject(API.VAULT)
  body = {u'name': u'New Matter - {0}'.format(GM.Globals[GM.DATETIME_NOW].strftime(YYYYMMDD_HHMMSS_FORMAT))}
  collaborators = []
  cd = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'name'] = getString(Cmd.OB_STRING)
    elif myarg == u'description':
      body[u'description'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in [u'collaborator', u'collaborators']:
      if not cd:
        cd = buildGAPIObject(API.DIRECTORY)
      collaborators.extend(validateCollaborators(cd))
    else:
      unknownArgumentExit()
  try:
    result = callGAPI(v.matters(), u'create',
                      throw_reasons=[GAPI.ALREADY_EXISTS, GAPI.FORBIDDEN],
                      body=body, fields=u'matterId,name')
    matterId = result[u'matterId']
    matterNameId = formatMatterNameId(result[u'name'], matterId)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
  except (GAPI.alreadyExists, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, body[u'name']], str(e))
    return
  jcount = len(collaborators)
  if jcount > 0:
    Act.Set(Act.ADD)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], jcount, Ent.COLLABORATOR)
    Ind.Increment()
    j = 0
    for collaborator in collaborators:
      j += 1
      try:
        callGAPI(v.matters(), u'addPermissions',
                 throw_reasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 matterId=matterId, body={u'matterPermission': {u'role': u'COLLABORATOR', u'accountId': collaborator[u'id']}})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.COLLABORATOR, collaborator[u'email']], j, jcount)
      except (GAPI.failedPrecondition, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
        break
    Ind.Decrement()

VAULT_MATTER_ACTIONS = {
  u'close': Act.CLOSE,
  u'reopen': Act.REOPEN,
  u'delete': Act.DELETE,
  u'undelete': Act.UNDELETE,
  }

def doActionVaultMatter(action, matterId=None, matterNameId=None, v=None):
  if v is None:
    v = buildGAPIObject(API.VAULT)
    matterId, matterNameId = getMatterItem(v)
  else:
    Act.Set(VAULT_MATTER_ACTIONS[action])
  checkForExtraneousArguments()
  action_kwargs = {} if action == u'delete' else {u'body': {}}
  try:
    callGAPI(v.matters(), action,
             throw_reasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
             matterId=matterId, **action_kwargs)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
  except (GAPI.notFound, GAPI.failedPrecondition, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))

# gam close vaultmatter|matter <MatterItem>
def doCloseVaultMatter():
  doActionVaultMatter(u'close')

# gam reopen vaultmatter|matter <MatterItem>
def doReopenVaultMatter():
  doActionVaultMatter(u'reopen')

# gam delete vaultmatter|matter <MatterItem>
def doDeleteVaultMatter():
  doActionVaultMatter(u'delete')

# gam undelete vaultmatter|matter <MatterItem>
def doUndeleteVaultMatter():
  doActionVaultMatter(u'undelete')

# gam update vaultmatter|matter <MatterItem> [name <String>] [description <string>]
#	[addcollaborator|addcollaborators <CollaboratorItemList>] [removecollaborator|removecollaborators <CollaboratorItemList>]
def doUpdateVaultMatter():
  v = buildGAPIObject(API.VAULT)
  matterId, matterNameId = getMatterItem(v)
  body = {}
  addCollaborators = []
  removeCollaborators = []
  cd = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'action':
      action = getChoice(VAULT_MATTER_ACTIONS)
      doActionVaultMatter(action, matterId, matterNameId, v)
      return
    if myarg == u'name':
      body[u'name'] = getString(Cmd.OB_STRING)
    elif myarg == u'description':
      body[u'description'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in [u'addcollaborator', u'addcollaborators']:
      if not cd:
        cd = buildGAPIObject(API.DIRECTORY)
      addCollaborators.extend(validateCollaborators(cd))
    elif myarg in [u'removecollaborator', u'removecollaborators']:
      if not cd:
        cd = buildGAPIObject(API.DIRECTORY)
      removeCollaborators.extend(validateCollaborators(cd))
    else:
      unknownArgumentExit()
  if body:
    try:
      if u'name' not in body or u'description' not in body:
        # bah, API requires name/description to be sent on update even when it's not changing
        result = callGAPI(v.matters(), u'get',
                          throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                          matterId=matterId, view=u'BASIC')
        body.setdefault(u'name', result[u'name'])
        body.setdefault(u'description', result.get(u'description'))
      callGAPI(v.matters(), u'update',
               throw_reasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
               matterId=matterId, body=body)
      entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
    except (GAPI.notFound, GAPI.failedPrecondition, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
      return
  jcount = len(addCollaborators)
  if jcount > 0:
    Act.Set(Act.ADD)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], jcount, Ent.COLLABORATOR)
    Ind.Increment()
    j = 0
    for collaborator in addCollaborators:
      j += 1
      try:
        callGAPI(v.matters(), u'addPermissions',
                 throw_reasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 matterId=matterId, body={u'matterPermission': {u'role': u'COLLABORATOR', u'accountId': collaborator[u'id']}})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.COLLABORATOR, collaborator[u'email']], j, jcount)
      except (GAPI.failedPrecondition, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
        break
    Ind.Decrement()
  jcount = len(removeCollaborators)
  if jcount > 0:
    Act.Set(Act.REMOVE)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], jcount, Ent.COLLABORATOR)
    Ind.Increment()
    j = 0
    for collaborator in removeCollaborators:
      j += 1
      try:
        callGAPI(v.matters(), u'removePermissions',
                 throw_reasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 matterId=matterId, body={u'accountId': collaborator[u'id']})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.COLLABORATOR, collaborator[u'email']], j, jcount)
      except (GAPI.failedPrecondition, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
        break
    Ind.Decrement()

def _showVaultMatter(matter, cd):
  if u'matterPermissions' in matter:
    for i in range(0, len(matter[u'matterPermissions'])):
      matter[u'matterPermissions'][i][u'email'] = convertUIDtoEmailAddress(u'uid:{0}'.format(matter[u'matterPermissions'][i][u'accountId']), cd)
  Ind.Increment()
  showJSON(None, matter)
  Ind.Decrement()

# gam info vaultmatter|matter <MatterItem>
def doInfoVaultMatter():
  v = buildGAPIObject(API.VAULT)
  matterId, matterNameId = getMatterItem(v)
  checkForExtraneousArguments()
  try:
    matter = callGAPI(v.matters(), u'get',
                      throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      matterId=matterId, view=u'FULL')
    cd = buildGAPIObject(API.DIRECTORY) if u'matterPermissions' in matter else None
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
    _showVaultMatter(matter, cd)
  except (GAPI.notFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))

PRINT_VAULT_MATTERS_TITLES = [u'matterId', u'name', u'description', u'state']

def _doPrintShowVaultMatters(csvFormat):
  v = buildGAPIObject(API.VAULT)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(PRINT_VAULT_MATTERS_TITLES)
    todrive = {}
  view = u'FULL'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in PROJECTION_CHOICE_MAP:
      view = PROJECTION_CHOICE_MAP[myarg]
    else:
      unknownArgumentExit()
  printGettingAllAccountEntities(Ent.VAULT_MATTER)
  try:
    matters = callGAPIpages(v.matters(), u'list', u'matters',
                            page_message=getPageMessage(),
                            throw_reasons=[GAPI.FORBIDDEN],
                            view=view)
    jcount = len(matters)
    if not csvFormat:
      performActionNumItems(jcount, Ent.VAULT_MATTER)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        return
      cd = buildGAPIObject(API.DIRECTORY) if view == u'FULL' else None
      Ind.Increment()
      j = 0
      for matter in matters:
        j += 1
        printEntity([Ent.VAULT_MATTER, formatMatterNameId(matter[u'name'], matter[u'matterId'])], j, jcount)
        _showVaultMatter(matter, cd)
      Ind.Decrement()
    else:
      for matter in matters:
        addRowTitlesToCSVfile(flattenJSON(matter), csvRows, titles)
  except GAPI.forbidden as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, None], str(e))
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Vault Matters', todrive, PRINT_VAULT_MATTERS_TITLES)

# gam print vaultmatters|matters [todrive [<ToDriveAttributes>]] [basic|full]
def doPrintVaultMatters():
  _doPrintShowVaultMatters(True)

# gam show vaultmatters|matters [basic|full]
def doShowVaultMatters():
  _doPrintShowVaultMatters(False)

def checkSiteExists(sitesObject, domain, site):
  try:
    callGData(sitesObject, u'GetSite',
              throw_errors=[GDATA.NOT_FOUND],
              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
              domain=domain, site=site)
    return True
  except GDATA.notFound:
    return None

SITE_ACLS = u'ACLs'
SITE_CATEGORIES = u'Categories'
SITE_LINK = u'Link'
SITE_NAME = u'Name'
SITE_SITE = u'Site'
SITE_SOURCELINK = u'SourceLink'
SITE_SUMMARY = u'Summary'
SITE_THEME = u'Theme'
SITE_UPDATED = u'Updated'
SITE_WEB_ADDRESS_MAPPINGS = u'WebAddressMappings'

SITE_DATA_DOMAIN = u'domain'
SITE_DATA_SITE = u'site'
SITE_DATA_DOMAIN_SITE = u'domainSite'
SITE_DATA_FIELDS = u'fields'

class SitesManager(object):

  SITE_ARGUMENT_TO_PROPERTY_MAP = {
    u'categories': SITE_CATEGORIES,
    u'name': SITE_NAME,
    u'sourcelink': SITE_SOURCELINK,
    u'summary': SITE_SUMMARY,
    u'theme': SITE_THEME,
    }

  @staticmethod
  def AclEntryToFields(acl_entry):

    def GetAclAttr(attrlist):
      objAttr = acl_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return None
      return objAttr

    fields = {}
    fields[u'role'] = GetAclAttr([u'role', u'value'])
    if not fields[u'role']:
      fields[u'role'] = GetAclAttr([u'withKey', u'role', u'value'])+u' (with link)'
    fields[u'scope'] = {u'type': GetAclAttr([u'scope', u'type']),
                        u'value': GetAclAttr([u'scope', u'value'])}
    link = acl_entry.FindInviteLink()
    if link:
      fields[u'inviteLink'] = link
    return fields

  @staticmethod
  def FieldsToAclEntry(fields):
    import gdata.apps.sites

    acl_entry = gdata.apps.sites.AclEntry()
    acl_entry.role = gdata.apps.sites.AclRole(value=fields[u'role'])
    acl_entry.scope = gdata.apps.sites.AclScope(stype=fields[u'scope'][u'type'], value=fields[u'scope'].get(u'value'))
    return acl_entry

  @staticmethod
  def ActivityEntryToFields(activity_entry):
    fields = {}

    def GetActivityField(fieldName, attrlist):
      objAttr = activity_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def GetActivityFieldData(objAttr, attrlist, default):
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return default
      return  objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)


    GetActivityField(u'Summary', [u'title', u'text'])
    GetActivityField(u'Updated', [u'updated', u'text'])
    for author in activity_entry.author:
      AppendItemToFieldsList(u'Authors', u'{0}/{1}'.format(GetActivityFieldData(author, [u'name', u'text'], u'Unknown Name'), GetActivityFieldData(author, [u'email', u'text'], u'Unknown Email')))
    fields[u'Operation'] = activity_entry.Kind()
    return fields

  @staticmethod
  def SiteToFields(site_entry):
    fields = {}

    def GetSiteField(fieldName, attrlist):
      objAttr = site_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)

    GetSiteField(SITE_SITE, [u'siteName', u'text'])
    GetSiteField(SITE_NAME, [u'title', u'text'])
    GetSiteField(SITE_SUMMARY, [u'summary', u'text'])
    GetSiteField(SITE_THEME, [u'theme', u'text'])
    GetSiteField(SITE_UPDATED, [u'updated', u'text'])
    if len(site_entry.category) > 0:
      for category in site_entry.category:
        AppendItemToFieldsList(SITE_CATEGORIES, category.term)
    link = site_entry.FindAlternateLink()
    if link:
      fields[SITE_LINK] = link
    link = site_entry.FindSourceLink()
    if link:
      fields[SITE_SOURCELINK] = link
    for link in site_entry.FindWebAddressMappings():
      AppendItemToFieldsList(SITE_WEB_ADDRESS_MAPPINGS, link)
    return fields

  @staticmethod
  def GetSiteFields():

    fields = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in SitesManager.SITE_ARGUMENT_TO_PROPERTY_MAP:
        fieldName = SitesManager.SITE_ARGUMENT_TO_PROPERTY_MAP[myarg]
        if fieldName == SITE_NAME:
          fields[fieldName] = getString(Cmd.OB_STRING)
        elif fieldName == SITE_SOURCELINK:
          fields[fieldName] = getString(Cmd.OB_URI)
        elif fieldName == SITE_SUMMARY:
          fields[fieldName] = getStringWithCRsNLs()
        elif fieldName == SITE_THEME:
          fields[fieldName] = getString(Cmd.OB_STRING)
        elif fieldName == SITE_CATEGORIES:
          fields[fieldName] = getString(Cmd.OB_STRING, minLen=0).split(u',')
      else:
        unknownArgumentExit()
    return fields

  @staticmethod
  def FieldsToSite(fields):
    import atom
    import gdata.apps.sites

    def GetField(fieldName):
      return fields.get(fieldName)

    def GetSiteField(fieldName, fieldClass):
      value = fields.get(fieldName)
      if value:
        return fieldClass(text=value)
      return None

    site_entry = gdata.apps.sites.SiteEntry(sourceSite=GetField(SITE_SOURCELINK))
    site_entry.siteName = GetSiteField(SITE_SITE, gdata.apps.sites.SiteName)
    site_entry.title = GetSiteField(SITE_NAME, atom.Title)
    site_entry.summary = GetSiteField(SITE_SUMMARY, atom.Summary)
    site_entry.theme = GetSiteField(SITE_THEME, gdata.apps.sites.Theme)
    value = GetField(SITE_CATEGORIES)
    if value:
      for category in value:
        site_entry.category.append(atom.Category(term=category, scheme=gdata.apps.sites.TAG_KIND_TERM))
    return site_entry

def getSiteEntity():
  siteEntity = {u'list': getEntityList(Cmd.OB_SITE_ENTITY), u'dict': None}
  if isinstance(siteEntity[u'list'], dict):
    siteEntity[u'dict'] = siteEntity[u'list']
  return siteEntity

def _validateUserGetSites(entityType, user, i, count, siteEntity, itemType=None, modifier=None):
  if siteEntity[u'dict']:
    sites = siteEntity[u'dict'][user]
  else:
    sites = siteEntity[u'list']
  user, sitesObject = getSitesObject(entityType, user, i, count)
  if not sitesObject:
    return (user, None, None, 0)
  jcount = len(sites)
  if not itemType:
    entityPerformActionNumItems([entityType, user], jcount, Ent.SITE, i, count)
  else:
    entityPerformActionSubItemModifierNumItems([entityType, user], itemType, modifier, jcount, Ent.SITE, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (user, sitesObject, sites, jcount)

def _validateSite(fullSite, i, count):
  domain, site, domainSite = validateSplitSiteName(fullSite)
  if domainSite:
    return (domain, site, domainSite)
  entityActionNotPerformedWarning([Ent.SITE, site], Msg.INVALID_SITE.format(site, SITENAME_FORMAT_REQUIRED), i, count)
  return (domain, site, None)

def _validateSiteGetRuleIds(origUser, fullSite, j, jcount, ACLScopeEntity, showAction=True):
  domain, site, domainSite = _validateSite(fullSite, j, jcount)
  if not domainSite:
    return (domain, site, None, None, 0)
  if ACLScopeEntity:
    if ACLScopeEntity[u'dict']:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        ruleIds = ACLScopeEntity[u'dict'][fullSite]
      else:
        ruleIds = ACLScopeEntity[u'dict'][origUser][fullSite]
    else:
      ruleIds = ACLScopeEntity[u'list']
    kcount = len(ruleIds)
    if kcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
  else:
    ruleIds = []
    kcount = 0
  if showAction:
    entityPerformActionNumItems([Ent.SITE, domainSite], kcount, Ent.SITE_ACL, j, jcount)
  return (domain, site, domainSite, ruleIds, kcount)

def _createSite(users, entityType):
  sitesManager = SitesManager()
  domain, site, domainSite = getSiteName()
  fields = sitesManager.GetSiteFields()
  if not fields.get(SITE_NAME):
    fields[SITE_NAME] = site
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject = getSitesObject(entityType, user, i, count)
    if not sitesObject:
      continue
    try:
      siteEntry = sitesManager.FieldsToSite(fields)
      callGData(sitesObject, u'CreateSite',
                throw_errors=[GDATA.NOT_FOUND, GDATA.ENTITY_EXISTS, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                siteentry=siteEntry, domain=domain, site=None)
      entityActionPerformed([Ent.SITE, domainSite])
    except GDATA.notFound as e:
      entityActionFailedWarning([Ent.DOMAIN, domain], str(e))
    except (GDATA.entityExists, GDATA.badRequest, GDATA.forbidden) as e:
      entityActionFailedWarning([Ent.SITE, domainSite], str(e))

# gam [<UserTypeEntity>] create site <SiteName> <SiteAttributes>*
def createUserSite(users):
  _createSite(users, Ent.USER)

def doCreateDomainSite():
  _createSite([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _updateSites(users, entityType):
  sitesManager = SitesManager()
  siteEntity = getSiteEntity()
  updateFields = sitesManager.GetSiteFields()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      try:
        siteEntry = callGData(sitesObject, u'GetSite',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site)
        fields = sitesManager.SiteToFields(siteEntry)
        for field in updateFields:
          if field != SITE_SOURCELINK:
            fields[field] = updateFields[field]
        newSiteEntry = sitesManager.FieldsToSite(fields)
        callGData(sitesObject, u'UpdateSite',
                  throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                  retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                  siteentry=newSiteEntry, domain=domain, site=site, extra_headers={u'If-Match': siteEntry.etag})
        entityActionPerformed([Ent.SITE, domainSite])
      except (GDATA.notFound, GDATA.badRequest, GDATA.forbidden) as e:
        entityActionFailedWarning([Ent.SITE, domainSite], str(e))

# gam [<UserTypeEntity>] update site <SiteEntity> <SiteAttributes>+
def updateUserSites(users):
  _updateSites(users, Ent.USER)

def doUpdateDomainSites():
  _updateSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

SITE_FIELD_PRINT_ORDER = [
  SITE_UPDATED,
  SITE_NAME,
  SITE_SUMMARY,
  SITE_THEME,
  SITE_SOURCELINK,
  SITE_CATEGORIES,
  SITE_LINK,
  ]

def _showSite(sitesManager, sitesObject, domain, site, roles, j, jcount):
  fields = sitesManager.SiteToFields(site)
  domainSite = u'{0}/{1}'.format(domain, fields[SITE_SITE])
  printKeyValueListWithCount([SITE_SITE, domainSite], j, jcount)
  Ind.Increment()
  for field in SITE_FIELD_PRINT_ORDER:
    if field in fields:
      if not isinstance(fields[field], list):
        if field != SITE_SUMMARY:
          printKeyValueList([field, fields[field]])
        else:
          printKeyValueWithCRsNLs(field, fields[field])
      else:
        printKeyValueList([field, u','.join(fields[field])])
  if fields.get(SITE_WEB_ADDRESS_MAPPINGS):
    printKeyValueList([SITE_WEB_ADDRESS_MAPPINGS, None])
    Ind.Increment()
    for link in fields[SITE_WEB_ADDRESS_MAPPINGS]:
      printKeyValueList([link, None])
    Ind.Decrement()
  if roles:
    try:
      acls = callGDataPages(sitesObject, u'GetAclFeed',
                            throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                            retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                            domain=domain, site=fields[SITE_SITE])
      printKeyValueList([SITE_ACLS, None])
      Ind.Increment()
      for acl in acls:
        fields = sitesManager.AclEntryToFields(acl)
        if fields[u'role'] in roles:
          printKeyValueList([formatACLRule(fields)])
      Ind.Decrement()
    except (GDATA.notFound, GDATA.forbidden) as e:
      entityActionFailedWarning([Ent.SITE, domainSite], str(e))
  Ind.Decrement()

SITE_ACL_ROLES_MAP = {
  u'editor': u'writer',
  u'invite': u'invite',
  u'owner': u'owner',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  }

def getACLRoles(aclRolesMap):
  roles = []
  for role in getString(Cmd.OB_ROLE_LIST, minLen=0).strip().lower().replace(u',', u' ').split():
    if role == u'all':
      for role in aclRolesMap:
        roles.append(aclRolesMap[role])
    elif role in aclRolesMap:
      roles.append(aclRolesMap[role])
    else:
      invalidChoiceExit(aclRolesMap, True)
  return list(set(roles))

def _infoSites(users, entityType):
  siteEntity = getSiteEntity()
  url_params = {}
  roles = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'withmappings':
      url_params[u'with-mappings'] = u'true'
    elif myarg in [u'role', u'roles']:
      roles = getACLRoles(SITE_ACL_ROLES_MAP)
    else:
      unknownArgumentExit()
  sitesManager = SitesManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      try:
        result = callGData(sitesObject, u'GetSite',
                           throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                           retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                           domain=domain, site=site, url_params=url_params)
        if result:
          _showSite(sitesManager, sitesObject, domain, result, roles, j, jcount)
      except (GDATA.notFound, GDATA.forbidden) as e:
        entityActionFailedWarning([Ent.SITE, domainSite], str(e))
    Ind.Decrement()

# gam [<UserTypeEntity>] info site <SiteEntity> [withmappings] [role|roles all|<SiteACLRoleList>]
def infoUserSites(users):
  _infoSites(users, Ent.USER)

def doInfoDomainSites():
  _infoSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _printShowSites(entityList, entityType, csvFormat):
  def _getSites(domain, i, count):
    try:
      return callGDataPages(sitesObject, u'GetSiteFeed',
                            page_message=getPageMessage(),
                            throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                            retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                            domain=domain, url_params=url_params)
    except (GDATA.notFound, GDATA.forbidden) as e:
      entityActionFailedWarning([Ent.DOMAIN, domain], str(e), i, count)
    return []

  def _printSites(entity, i, count, domain, sites):
    for site in sites:
      fields = sitesManager.SiteToFields(site)
      if fields[SITE_SITE] in sitesSet:
        continue
      sitesSet.add(fields[SITE_SITE])
      domainSite = u'{0}/{1}'.format(domain, fields[SITE_SITE])
      siteRow = {Ent.Singular(entityType): entity, SITE_SITE: domainSite}
      for field in fields:
        if field != SITE_SITE:
          if not isinstance(fields[field], list):
            if field != SITE_SUMMARY or not convertCRNL:
              siteRow[field] = fields[field]
            else:
              siteRow[field] = escapeCRsNLs(fields[field])
          else:
            siteRow[field] = delimiter.join(fields[field])
      rowShown = False
      if roles:
        try:
          acls = callGDataPages(sitesObject, u'GetAclFeed',
                                throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                                retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                                domain=domain, site=fields[SITE_SITE])
          for acl in acls:
            fields = sitesManager.AclEntryToFields(acl)
            if fields[u'role'] in roles:
              siteACLRow = siteRow.copy()
              siteACLRow.update(ACLRuleDict(fields))
              addRowTitlesToCSVfile(siteACLRow, csvRows, titles)
              rowShown = True
        except (GDATA.notFound, GDATA.forbidden) as e:
          entityActionFailedWarning([Ent.SITE, domainSite], str(e), i, count)
      if not rowShown:
        addRowTitlesToCSVfile(siteRow, csvRows, titles)

  def _showSites(entity, i, count, domain, sites):
    jcount = len(sites)
    if entityType == Ent.USER:
      entityPerformActionNumItems([entityType, entity, Ent.DOMAIN, domain], jcount, Ent.SITE, i, count)
    else:
      entityPerformActionNumItems([entityType, entity], jcount, Ent.SITE, i, count)
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      _showSite(sitesManager, sitesObject, domain, site, roles, j, jcount)
    Ind.Decrement()

  domains = []
  domainLists = []
  url_params = {}
  includeAllSites = [u'false', u'true'][entityType == Ent.DOMAIN]
  roles = None
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Ent.Singular(entityType), SITE_SITE, SITE_NAME])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'domain', u'domains']:
      if entityType == Ent.DOMAIN:
        entityList = getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY)
      else:
        domains = getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY)
        domainLists = domains if isinstance(domains, dict) else None
    elif myarg == u'includeallsites':
      includeAllSites = u'true'
    elif myarg == u'maxresults':
      url_params[u'max-results'] = getInteger(minVal=1)
    elif myarg == u'withmappings':
      url_params[u'with-mappings'] = u'true'
    elif myarg in [u'role', u'roles']:
      roles = getACLRoles(SITE_ACL_ROLES_MAP)
    elif myarg in [u'convertcrnl', u'converttextnl', u'convertsummarynl']:
      convertCRNL = True
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  sitesManager = SitesManager()
  sitesSet = set()
  i, count, entityList = getEntityArgument(entityList)
  if entityType == Ent.USER:
    for user in entityList:
      i += 1
      if domainLists:
        domainList = domainLists[user]
      elif domains:
        domainList = domains
      else:
        _, domain = splitEmailAddress(user)
        domainList = [domain]
      user, sitesObject = getSitesObject(entityType, user, i, count)
      if not sitesObject:
        continue
      jcount = len(domainList)
      j = 0
      for domain in domainList:
        j += 1
        if domain != u'site':
          url_params[u'include-all-sites'] = includeAllSites
        else:
          url_params.pop(u'include-all-sites', None)
        printGettingAllEntityItemsForWhom(Ent.SITE, u'{0}: {1}, {2}: {3}'.format(Ent.Singular(Ent.USER), user, Ent.Singular(Ent.DOMAIN), domain))
        sites = _getSites(domain, i, count)
        if not csvFormat:
          _showSites(domain, j, jcount, domain, sites)
        else:
          _printSites(user, j, jcount, domain, sites)
  else:
    for domain in entityList:
      i += 1
      domain, sitesObject = getSitesObject(entityType, domain, i, count)
      if not sitesObject:
        continue
      if domain != u'site':
        url_params[u'include-all-sites'] = includeAllSites
      else:
        url_params.pop(u'include-all-sites', None)
      printGettingAllEntityItemsForWhom(Ent.SITE, u'{0}: {1}'.format(Ent.Singular(Ent.DOMAIN), domain))
      sites = _getSites(domain, i, count)
      if not csvFormat:
        _showSites(domain, i, count, domain, sites)
      else:
        _printSites(domain, i, count, domain, sites)
  if csvFormat:
    if roles:
      removeTitlesFromCSVfile([u'Scope', u'Role'], titles)
      addTitlesToCSVfile([u'Scope', u'Role'], titles)
    writeCSVfile(csvRows, titles, u'Sites', todrive)

# gam [<UserTypeEntity>] print sites [todrive [<ToDriveAttributes>]] [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl] [delimiter <Character>]
def printUserSites(users):
  _printShowSites(users, Ent.USER, True)

# gam [<UserTypeEntity>] show sites [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl]
def showUserSites(users):
  _printShowSites(users, Ent.USER, False)

# gam print sites [todrive [<ToDriveAttributes>]] [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl] [delimiter <Character>]
def doPrintDomainSites():
  _printShowSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN, True)

# gam show sites [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [maxresults <Number>] [convertcrnl]
def doShowDomainSites():
  _printShowSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False)

SITE_ACTION_TO_MODIFIER_MAP = {
  Act.ADD: Act.MODIFIER_TO,
  Act.UPDATE: Act.MODIFIER_IN,
  Act.DELETE: Act.MODIFIER_FROM,
  Act.INFO: Act.MODIFIER_FROM,
  Act.PRINT: Act.MODIFIER_FROM,
  Act.SHOW: Act.MODIFIER_FROM,
  }

def _processSiteACLs(users, entityType):
  action = Act.Get()
  siteEntity = getSiteEntity()
  csvFormat = False
  if action in [Act.ADD, Act.UPDATE]:
    role = getChoice(SITE_ACL_ROLES_MAP, mapChoice=True)
  elif action == Act.PRINT:
    csvFormat = True
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([Ent.Singular(entityType), SITE_SITE, u'Scope', u'Role'])
  else:
    role = None
  actionPrintShow = action in [Act.PRINT, Act.SHOW]
  ACLScopeEntity = getCalendarSiteACLScopeEntity() if not actionPrintShow else {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  modifier = SITE_ACTION_TO_MODIFIER_MAP[action]
  sitesManager = SitesManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity, Ent.SITE_ACL, modifier)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite, ruleIds, kcount = _validateSiteGetRuleIds(origUser, site, j, jcount, ACLScopeEntity, showAction=not actionPrintShow)
      if not domainSite:
        continue
      if not actionPrintShow:
        Ind.Increment()
        k = 0
        for ruleId in ruleIds:
          k += 1
          ruleId = normalizeRuleId(ruleId)
          try:
            if action in [Act.CREATE, Act.ADD]:
              acl = callGData(sitesObject, u'CreateAclEntry',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.ENTITY_EXISTS, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              aclentry=sitesManager.FieldsToAclEntry(makeRoleRuleIdBody(role, ruleId)), domain=domain, site=site)
              fields = sitesManager.AclEntryToFields(acl)
              if not fields.get(u'inviteLink'):
                entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
              else:
                entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, u'{0} (Link: {1})'.format(formatACLRule(fields), fields[u'inviteLink'])], k, kcount)
            elif action == Act.UPDATE:
              acl = callGData(sitesObject, u'GetAclEntry',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              acl.role.value = role
              acl = callGData(sitesObject, u'UpdateAclEntry',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              aclentry=acl, domain=domain, site=site, ruleId=ruleId, extra_headers={u'If-Match': acl.etag})
              fields = sitesManager.AclEntryToFields(acl)
              entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
            elif action == Act.DELETE:
              acl = callGData(sitesObject, u'GetAclEntry',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              callGData(sitesObject, u'DeleteAclEntry',
                        throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                        retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                        domain=domain, site=site, ruleId=ruleId, extra_headers={u'If-Match': acl.etag})
              entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLScopeRole(ruleId, None)], k, kcount)
            elif action == Act.INFO:
              acl = callGData(sitesObject, u'GetAclEntry',
                              throw_errors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              fields = sitesManager.AclEntryToFields(acl)
              printEntity([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
          except GDATA.notFound as e:
            if not checkSiteExists(sitesObject, domain, site):
              entityUnknownWarning(Ent.SITE, domainSite, j, jcount)
              break
            entityActionFailedWarning([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
          except (GDATA.entityExists, GDATA.badRequest, GDATA.forbidden) as e:
            entityActionFailedWarning([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
        Ind.Decrement()
      else:
        try:
          acls = callGDataPages(sitesObject, u'GetAclFeed',
                                throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                                retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                                domain=domain, site=site)
          if not csvFormat:
            kcount = len(acls)
            entityPerformActionNumItems([Ent.SITE, domainSite], kcount, Ent.SITE_ACL, j, jcount)
            if kcount == 0:
              continue
            Ind.Increment()
            k = 0
            for acl in acls:
              k += 1
              fields = sitesManager.AclEntryToFields(acl)
              printEntity([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
            Ind.Decrement()
          else:
            siteRow = {Ent.Singular(entityType): user, SITE_SITE: domainSite}
            for acl in acls:
              fields = sitesManager.AclEntryToFields(acl)
              siteACLRow = siteRow.copy()
              siteACLRow.update(ACLRuleDict(fields))
              addRowTitlesToCSVfile(siteACLRow, csvRows, titles)
        except GDATA.notFound:
          entityUnknownWarning(Ent.SITE, domainSite, j, jcount)
        except GDATA.forbidden as e:
          entityActionFailedWarning([Ent.SITE, domainSite], str(e), j, jcount)
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Site ACLs', todrive)

# gam [<UserTypeEntity>] create|add siteacls <SiteEntity> <SiteACLRole> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] update siteacls <SiteEntity> <SiteACLRole> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] delete siteacls <SiteEntity> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] info siteacls <SiteEntity> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] show siteacls <SiteEntity>
# gam [<UserTypeEntity>] print siteacls <SiteEntity> [todrive [<ToDriveAttributes>]]
def processUserSiteACLs(users):
  _processSiteACLs(users, Ent.USER)

def doProcessDomainSiteACLs():
  _processSiteACLs([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _printSiteActivity(users, entityType):
  sitesManager = SitesManager()
  todrive = {}
  url_params = {}
  titles, csvRows = initializeTitlesCSVfile([SITE_SITE])
  sites = getEntityList(Cmd.OB_SITE_ENTITY)
  siteLists = sites if isinstance(sites, dict) else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'maxresults':
      url_params[u'max-results'] = getInteger(minVal=1)
    elif myarg == u'updatedmin':
      url_params[u'updated-min'] = getYYYYMMDD()
    elif myarg == u'updatedmax':
      url_params[u'updated-max'] = getYYYYMMDD()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if siteLists:
      sites = siteLists[user]
    user, sitesObject = getSitesObject(entityType, user, i, count)
    if not sitesObject:
      continue
    jcount = len(sites)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      printGettingAllEntityItemsForWhom(Ent.ACTIVITY, domainSite)
      try:
        activities = callGDataPages(sitesObject, u'GetActivityFeed',
                                    page_message=getPageMessage(),
                                    throw_errors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                                    retry_errors=[GDATA.INTERNAL_SERVER_ERROR],
                                    domain=domain, site=site, url_params=url_params)
        for activity in activities:
          fields = sitesManager.ActivityEntryToFields(activity)
          activityRow = {SITE_SITE: domainSite}
          for key in fields:
            if not isinstance(fields[key], list):
              activityRow[key] = fields[key]
            else:
              activityRow[key] = u','.join(fields[key])
          addRowTitlesToCSVfile(activityRow, csvRows, titles)
      except GDATA.notFound:
        entityUnknownWarning(Ent.SITE, domainSite, j, jcount)
      except GDATA.forbidden as e:
        entityActionFailedWarning([Ent.SITE, domainSite], str(e), j, jcount)
  writeCSVfile(csvRows, titles, u'Site Activities', todrive)

# gam [<UserTypeEntity>] print siteactivity <SiteEntity> [todrive [<ToDriveAttributes>]] [maxresults <Number>] [updated_min <Date>] [updated_max <Date>]
def printUserSiteActivity(users):
  _printSiteActivity(users, Ent.USER)

def doPrintDomainSiteActivity():
  _printSiteActivity([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP = {
  u'address': u'addresses',
  u'addresses': u'addresses',
  u'agreed2terms': u'agreedToTerms',
  u'agreedtoterms': u'agreedToTerms',
  u'changepassword': u'changePasswordAtNextLogin',
  u'changepasswordatnextlogin': u'changePasswordAtNextLogin',
  u'crypt': u'hashFunction',
  u'customerid': u'customerId',
  u'email': u'primaryEmail',
  u'emails': u'emails',
  u'externalid': u'externalIds',
  u'externalids': u'externalIds',
  u'familyname': u'familyName',
  u'firstname': u'givenName',
  u'gal': u'includeInGlobalAddressList',
  u'gender': u'gender',
  u'givenname': u'givenName',
  u'im': u'ims',
  u'ims': u'ims',
  u'includeinglobaladdresslist': u'includeInGlobalAddressList',
  u'ipwhitelisted': u'ipWhitelisted',
  u'keyword': u'keywords',
  u'keywords': u'keywords',
  u'language': u'languages',
  u'languages': u'languages',
  u'lastname': u'familyName',
  u'location': u'locations',
  u'locations': u'locations',
  u'md5': u'hashFunction',
  u'note': u'notes',
  u'notes': u'notes',
  u'org': u'orgUnitPath',
  u'organization': u'organizations',
  u'organizations': u'organizations',
  u'orgunitpath': u'orgUnitPath',
  u'otheremail': u'emails',
  u'otheremails': u'emails',
  u'ou': u'orgUnitPath',
  u'password': u'password',
  u'phone': u'phones',
  u'phones': u'phones',
  u'posix': u'posixAccounts',
  u'posixaccounts': u'posixAccounts',
  u'primaryemail': u'primaryEmail',
  u'relation': u'relations',
  u'relations': u'relations',
  u'sha': u'hashFunction',
  u'sha-1': u'hashFunction',
  u'sha1': u'hashFunction',
  u'ssh': u'sshPublicKeys',
  u'sshkeys': u'sshPublicKeys',
  u'sshpublickeys': u'sshPublicKeys',
  u'suspended': u'suspended',
  u'username': u'primaryEmail',
  u'website': u'websites',
  u'websites': u'websites',
  }

HASH_FUNCTION_MAP = {
  u'sha': u'SHA-1',
  u'sha1': u'SHA-1',
  u'sha-1': u'SHA-1',
  u'md5': u'MD5',
  u'crypt': u'crypt',
  }

ADDRESS_ARGUMENT_TO_FIELD_MAP = {
  u'country': u'country',
  u'countrycode': u'countryCode',
  u'extendedaddress': u'extendedAddress',
  u'locality': u'locality',
  u'pobox': u'poBox',
  u'postalcode': u'postalCode',
  u'region': u'region',
  u'streetaddress': u'streetAddress',
  }

ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
  u'costcenter': u'costCenter',
  u'department': u'department',
  u'description': u'description',
  u'domain': u'domain',
  u'fulltimeequivalent': u'fullTimeEquivalent',
  u'location': u'location',
  u'name': u'name',
  u'symbol': u'symbol',
  u'title': u'title',
  }

def getUserAttributes(cd, updateCmd, noUid=False):
  from gamlib import gluprop as UProp

  def getKeywordAttribute(UProp, keywords, attrdict, **opts):
    if Cmd.ArgumentsRemaining():
      keyword = Cmd.Current().strip().lower()
      if keyword in keywords[UProp.PTKW_KEYWORD_LIST]:
        Cmd.Advance()
        if keyword != keywords[UProp.PTKW_CL_CUSTOM_KEYWORD]:
          attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keyword
          attrdict.pop(keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD], None)
          return
        if Cmd.ArgumentsRemaining():
          customType = Cmd.Current().strip()
          if customType:
            Cmd.Advance()
            if keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]:
              attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
            else:
              attrdict.pop(keywords[UProp.PTKW_ATTR_TYPE_KEYWORD], None)
            attrdict[keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = customType
            return
        missingArgumentExit(u'custom attribute type')
      elif DEFAULT_CHOICE in opts:
        attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = opts[DEFAULT_CHOICE]
        return
      elif keywords[UProp.PTKW_CL_CUSTOM_KEYWORD]:
        if keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]:
          attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
        else:
          attrdict.pop(keywords[UProp.PTKW_ATTR_TYPE_KEYWORD], None)
        attrdict[keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = Cmd.Current()
        Cmd.Advance()
        return
      invalidChoiceExit(keywords[UProp.PTKW_KEYWORD_LIST], False)
    elif DEFAULT_CHOICE in opts:
      attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = opts[DEFAULT_CHOICE]
      return
    missingChoiceExit(keywords[UProp.PTKW_KEYWORD_LIST])

  def primaryNotPrimary(pnp, entry):
    if pnp == u'notprimary':
      return True
    if pnp == u'primary':
      entry[u'primary'] = True
      primary[u'location'] = Cmd.Location()
      return True
    return False

  def getPrimaryNotPrimaryChoice(entry, defaultChoice):
    if getChoice({u'primary': True, u'notprimary': False}, defaultChoice=defaultChoice, mapChoice=True):
      entry[u'primary'] = True
      primary[u'location'] = Cmd.Location()

  def checkClearBodyList(body, itemName):
    if checkArgumentPresent(Cmd.CLEAR_NONE_ARGUMENT):
      body.pop(itemName, None)
      body[itemName] = None
      return True
    return False

  def appendItemToBodyList(body, itemName, itemValue, checkBlankField=None, checkSystemId=False):
    if (itemName in body) and (body[itemName] is None):
      del body[itemName]
    body.setdefault(itemName, [])
    if checkBlankField is None or itemValue[checkBlankField]:
# Throw an error if multiple items are marked primary
      if itemValue.get(u'primary', False):
        for citem in body[itemName]:
          if citem.get(u'primary', False):
            if not checkSystemId or itemValue.get(u'systemId') == citem.get(u'systemId'):
              Cmd.SetLocation(primary[u'location']-1)
              usageErrorExit(Msg.MULTIPLE_ITEMS_MARKED_PRIMARY.format(itemName))
      body[itemName].append(itemValue)

  def gen_sha512_hash(password):
    from passlib.handlers.sha2_crypt import sha512_crypt
    return sha512_crypt.encrypt(password, rounds=5000)

  def _splitSchemaNameDotFieldName(sn_fn, fnRequired=True):
    if sn_fn.find(u'.') != -1:
      schemaName, fieldName = sn_fn.split(u'.', 1)
      schemaName = schemaName.strip()
      fieldName = fieldName.strip()
      if schemaName and fieldName:
        return (schemaName, fieldName)
    elif not fnRequired:
      schemaName = sn_fn.strip()
      if schemaName:
        return (schemaName, None)
    invalidArgumentExit(Cmd.OB_SCHEMA_NAME_FIELD_NAME)

  createIfNotFound = False
  if updateCmd:
    body = {}
    need_password = False
  else:
    body = {u'name': {u'givenName': u'Unknown', u'familyName': u'Unknown'}}
    body[u'primaryEmail'] = getEmailAddress(noUid=noUid)
    need_password = True
  need_to_hash_password = True
  admin_body = {}
  notify = {u'html': False, u'charset': u'utf-8'}
  primary = {}
  updatePrimaryEmail = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'notify':
      notify[u'emailAddress'] = getEmailAddress(noUid=True)
    elif myarg == u'subject':
      notify[u'subject'] = getString(Cmd.OB_STRING)
    elif myarg == u'message':
      if checkArgumentPresent(u'file'):
        filename = getString(Cmd.OB_FILE_NAME)
        notify[u'charset'] = getCharSet()
        notify[u'message'] = readFile(filename, encoding=notify[u'charset'])
      else:
        notify[u'message'] = getString(Cmd.OB_STRING)
    elif myarg == u'html':
      notify[u'html'] = getBoolean()
    elif myarg == u'admin':
      admin_body[u'status'] = getBoolean()
    elif myarg == u'nohash':
      need_to_hash_password = False
    elif updateCmd and myarg == u'updateprimaryemail':
      search = getString(Cmd.OB_RE_PATTERN)
      pattern = validateREPattern(search, re.IGNORECASE)
      replace = getString(Cmd.OB_EMAIL_REPLACEMENT)
      patternGroups = pattern.groups
      replSubs = REPLACE_GROUP_PATTERN.findall(replace)
      for replSub in replSubs:
        if int(replSub) > patternGroups:
          Cmd.Backup()
          usageErrorExit(Msg.MISMATCH_RE_SEARCH_REPLACE_SUBFIELDS.format(pattern.groups, search, int(replSub), replace))
      updatePrimaryEmail[u'search'] = search
      updatePrimaryEmail[u'pattern'] = pattern
      updatePrimaryEmail[u'replace'] = replace
    elif myarg in UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP:
      up = UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP[myarg]
      userProperty = UProp.PROPERTIES[up]
      propertyClass = userProperty[UProp.CLASS]
      if UProp.TYPE_KEYWORDS in userProperty:
        typeKeywords = userProperty[UProp.TYPE_KEYWORDS]
        clTypeKeyword = typeKeywords[UProp.PTKW_CL_TYPE_KEYWORD]
      if up == u'givenName':
        body.setdefault(u'name', {})
        body[u'name'][up] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
      elif up == u'familyName':
        body.setdefault(u'name', {})
        body[u'name'][up] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
      elif up == u'password':
        need_password = False
        body[up] = getString(Cmd.OB_PASSWORD, maxLen=100)
        if body[up].lower() == u'random':
          need_password = True
      elif propertyClass == UProp.PC_BOOLEAN:
        body[up] = getBoolean()
      elif up == u'hashFunction':
        body[up] = HASH_FUNCTION_MAP[myarg]
        need_to_hash_password = False
      elif up == u'primaryEmail' and updateCmd:
        body[up] = getEmailAddress(noUid=True)
      elif up == u'customerId' and updateCmd:
        body[up] = getString(Cmd.OB_STRING)
      elif up == u'orgUnitPath':
        body[up] = getOrgUnitItem(pathOnly=True)
      elif up == u'languages':
        if checkClearBodyList(body, up):
          continue
        for language in getString(Cmd.OB_LANGUAGE_LIST).replace(u',', u' ').split():
          if language.lower() in LANGUAGE_CODES_MAP:
            appendItemToBodyList(body, up, {u'languageCode': LANGUAGE_CODES_MAP[language.lower()]})
          else:
            appendItemToBodyList(body, up, {u'customLanguage': language})
      elif up == u'gender':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        if checkArgumentPresent(u'addressmeas'):
          entry[u'addressMeAs'] = getString(Cmd.OB_STRING, minLen=0)
        body[up] = entry
      elif up == u'addresses':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        if checkArgumentPresent([u'unstructured', u'formatted']):
          entry[u'sourceIsStructured'] = False
          entry[u'formatted'] = getStringWithCRsNLs()
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in ADDRESS_ARGUMENT_TO_FIELD_MAP:
            value = getString(Cmd.OB_STRING, minLen=0)
            if value:
              entry[ADDRESS_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif primaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry)
      elif up == u'ims':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        getChoice([UProp.IM_PROTOCOLS[UProp.PTKW_CL_TYPE_KEYWORD]])
        getKeywordAttribute(UProp, UProp.IM_PROTOCOLS, entry)
        # Backwards compatability: notprimary|primary on either side of IM address
        getPrimaryNotPrimaryChoice(entry, False)
        entry[u'im'] = getString(Cmd.OB_STRING, minLen=0)
        getPrimaryNotPrimaryChoice(entry, entry.get(u'primary', False))
        appendItemToBodyList(body, up, entry, u'im')
      elif up == u'keywords':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'locations':
        if checkClearBodyList(body, up):
          continue
        entry = {u'type': u'desk', u'area': u''}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(UProp, typeKeywords, entry)
          elif argument == u'area':
            entry[u'area'] = getString(Cmd.OB_STRING)
          elif argument in [u'building', u'buildingid']:
            entry[u'buildingId'] = _getBuildingByNameOrId(cd)
          elif argument in [u'floor', u'floorname']:
            entry[u'floorName'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in [u'section', u'floorsection']:
            entry[u'floorSection'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in [u'desk', u'deskcode']:
            entry[u'deskCode'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument == u'endlocation':
            break
          else:
            unknownArgumentExit()
        if u'area' not in entry:
          missingArgumentExit(u'area <String>')
        appendItemToBodyList(body, up, entry)
      elif up == u'notes':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getKeywordAttribute(UProp, typeKeywords, entry, defaultChoice=u'text_plain')
        if checkArgumentPresent(u'file'):
          filename = getString(Cmd.OB_FILE_NAME)
          encoding = getCharSet()
          entry[u'value'] = readFile(filename, encoding=encoding)
        else:
          entry[u'value'] = getStringWithCRsNLs()
        body[up] = entry
      elif up == u'organizations':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(UProp, typeKeywords, entry)
          elif argument == typeKeywords[UProp.PTKW_CL_CUSTOMTYPE_KEYWORD]:
            entry[typeKeywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = getString(Cmd.OB_STRING)
            entry.pop(typeKeywords[UProp.PTKW_ATTR_TYPE_KEYWORD], None)
          elif argument in ORGANIZATION_ARGUMENT_TO_FIELD_MAP:
            argument = ORGANIZATION_ARGUMENT_TO_FIELD_MAP[argument]
            if argument != u'fullTimeEquivalent':
              value = getString(Cmd.OB_STRING, minLen=0)
              if value:
                entry[argument] = value
            else:
              entry[argument] = getInteger(minVal=0, maxVal=100000)
          elif primaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry)
      elif up == u'phones':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(UProp, typeKeywords, entry)
          elif argument == u'value':
            entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
          elif primaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'posixAccounts':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in [u'username', u'name']:
            entry[u'username'] = getString(Cmd.OB_STRING)
          elif argument == u'uid':
            entry[u'uid'] = getInteger(minVal=1000)
          elif argument == u'gid':
            entry[u'gid'] = getInteger(minVal=0)
          elif argument in [u'system', u'systemid']:
            entry[u'systemId'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in [u'home', u'homedirectory']:
            entry[u'homeDirectory'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in [u'shell']:
            entry[u'shell'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument == u'gecos':
            entry[u'gecos'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in [u'primary']:
            primary[u'location'] = Cmd.Location()
            entry[u'primary'] = getBoolean()
          elif argument == u'endposix':
            break
          else:
            unknownArgumentExit()
        if u'username' not in entry:
          missingArgumentExit(u'username <String>')
        if u'uid' not in entry:
          missingArgumentExit(u'uid <Integer>')
        appendItemToBodyList(body, up, entry, checkSystemId=True)
      elif up == u'relations':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'emails':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'address'] = getEmailAddress(noUid=True, minLen=0)
        appendItemToBodyList(body, up, entry, u'address')
      elif up == u'sshPublicKeys':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == u'expires':
            entry[u'expirationTimeUsec'] = getInteger(minVal=0)
          elif argument == u'key':
            entry[u'key'] = getString(Cmd.OB_STRING)
          elif argument == u'endssh':
            break
          else:
            unknownArgumentExit()
        if u'key' not in entry:
          missingArgumentExit(u'key <String>')
        appendItemToBodyList(body, up, entry)
      elif up == u'externalIds':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, u'value')
      elif up == u'websites':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(UProp, typeKeywords, entry)
        entry[u'value'] = getString(Cmd.OB_URL, minLen=0)
        getPrimaryNotPrimaryChoice(entry, False)
        appendItemToBodyList(body, up, entry, u'value')
    elif myarg == u'clearschema':
      if not updateCmd:
        unknownArgumentExit()
      schemaName, fieldName = _splitSchemaNameDotFieldName(getString(Cmd.OB_SCHEMA_NAME_FIELD_NAME), False)
      up = u'customSchemas'
      body.setdefault(up, {})
      body[up].setdefault(schemaName, {})
      if fieldName is None:
        try:
          schema = callGAPI(cd.schemas(), u'get',
                            throw_reasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaName, fields=u'fields(fieldName)')
          for field in schema[u'fields']:
            body[up][schemaName][field[u'fieldName']] = None
        except (GAPI.invalid, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          entityDoesNotExistWarning(Ent.USER_SCHEMA, schemaName)
          unknownArgumentExit()
      else:
        body[up][schemaName][fieldName] = None
    elif myarg.find(u'.') >= 0:
      schemaName, fieldName = _splitSchemaNameDotFieldName(Cmd.Previous())
      up = u'customSchemas'
      body.setdefault(up, {})
      body[up].setdefault(schemaName, {})
      multivalue = getChoice([u'multivalued', u'multivalue', u'value', u'multinonempty'], defaultChoice=None)
      if multivalue is not None:
        body[up][schemaName].setdefault(fieldName, [])
        typeKeywords = UProp.PROPERTIES[up][UProp.TYPE_KEYWORDS]
        clTypeKeyword = typeKeywords[UProp.PTKW_CL_TYPE_KEYWORD]
        schemaValue = {}
        if checkArgumentPresent(clTypeKeyword):
          getKeywordAttribute(UProp, typeKeywords, schemaValue)
        schemaValue[u'value'] = getString(Cmd.OB_STRING, minLen=0)
        if schemaValue[u'value'] or multivalue != u'multinonempty':
          body[up][schemaName][fieldName].append(schemaValue)
      else:
        body[up][schemaName][fieldName] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == u'createifnotfound' and updateCmd:
      createIfNotFound = True
    else:
      unknownArgumentExit()
  if need_password:
    body[u'password'] = u''.join(random.sample(u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~`!@#$%^&*()-=_+:;"\'{}[]\\|', 25))
  if notify:
    notify[u'password'] = body.get(u'password')
  if u'password' in body and need_to_hash_password:
    body[u'password'] = gen_sha512_hash(body[u'password'])
    body[u'hashFunction'] = u'crypt'
  return (body, admin_body, notify, updatePrimaryEmail, createIfNotFound)

def changeAdminStatus(cd, user, admin_body, i=0, count=0):
  try:
    callGAPI(cd.users(), u'makeAdmin',
             throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
             userKey=user, body=admin_body)
    printEntityKVList([Ent.USER, user], [Msg.ADMIN_STATUS_CHANGED_TO, admin_body[u'status']], i, count)
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
    entityUnknownWarning(Ent.USER, user, i, count)

# gam create user <EmailAddress> <UserAttributes> [notify <EmailAddress>] [subject <String>] [message <String>|(file <FileName> [charset <CharSet>])] [html [<Boolean>]]
def doCreateUser():
  cd = buildGAPIObject(API.DIRECTORY)
  body, admin_body, notify, _, _ = getUserAttributes(cd, False, noUid=True)
  user = body[u'primaryEmail']
  try:
    callGAPI(cd.users(), u'insert',
             throw_reasons=[GAPI.DUPLICATE, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN,
                            GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.INVALID_SCHEMA_VALUE],
             body=body, fields=u'')
    entityActionPerformed([Ent.USER, user])
    if admin_body:
      changeAdminStatus(cd, user, admin_body)
    if notify.get(u'emailAddress'):
      sendCreateUpdateUserNotification(notify, body)
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.USER, user])
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.USER, user], str(e))
  except GAPI.invalidSchemaValue:
    entityActionFailedWarning([Ent.USER, user], Msg.INVALID_SCHEMA_VALUE)
  except (GAPI.invalid, GAPI.invalidInput) as e:
    entityActionFailedWarning([Ent.USER, user], str(e))
  except GAPI.invalidOrgunit:
    entityActionFailedWarning([Ent.USER, user], Msg.INVALID_ORGUNIT)

# gam <UserTypeEntity> update user <UserAttributes> [updateprimaryemail <RegularExpression> <EmailReplacement>]
#	[clearschema <SchemaName>] [clearschema <SchemaName>.<FieldName>]
#	[createifnotfound] [notify <EmailAddress>] [subject <String>] [message <String>|(file <FileName> [charset <CharSet>])] [html [<Boolean>]]
def updateUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  body, admin_body, notify, updatePrimaryEmail, createIfNotFound = getUserAttributes(cd, True)
  vfe = u'primaryEmail' in body and body[u'primaryEmail'][:4].lower() == u'vfe@'
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = userKey = normalizeEmailAddressOrUID(user)
    try:
      if vfe:
        result = callGAPI(cd.users(), u'get',
                          throw_reasons=GAPI.USER_GET_THROW_REASONS,
                          userKey=userKey, fields=u'primaryEmail,id')
        userKey = result[u'id']
        userPrimary = result[u'primaryEmail']
        userName, userDomain = splitEmailAddress(userPrimary)
        body[u'primaryEmail'] = u'vfe.{0}.{1:05}@{2}'.format(userName, random.randint(1, 99999), userDomain)
        body[u'emails'] = [{u'type': u'custom',
                            u'customType': u'former_employee',
                            u'primary': False, u'address': userPrimary}]
      elif updatePrimaryEmail:
        if updatePrimaryEmail[u'pattern'].search(user) is not None:
          body[u'primaryEmail'] = updatePrimaryEmail[u'pattern'].sub(updatePrimaryEmail[u'replace'], user)
        else:
          body.pop(u'primaryEmail', None)
          if not body:
            entityActionNotPerformedWarning([Ent.USER, user], Msg.PRIMARY_EMAIL_DID_NOT_MATCH_PATTERN.format(updatePrimaryEmail[u'search']), i, count)
      if body:
        try:
          result = callGAPI(cd.users(), u'update',
                            throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN,
                                           GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.INVALID_SCHEMA_VALUE],
                            userKey=userKey, body=body, fields=u'primaryEmail,name')
          entityActionPerformed([Ent.USER, user], i, count)
          if notify.get(u'emailAddress') and notify.get(u'password'):
            sendCreateUpdateUserNotification(notify, result, i, count, False)
        except GAPI.userNotFound:
          if createIfNotFound and (count == 1) and not vfe and (u'password' in body) and (u'name' in body) and (u'givenName' in body[u'name']) and (u'familyName' in body[u'name']):
            if u'primaryEmail' not in body:
              body[u'primaryEmail'] = user
            try:
              callGAPI(cd.users(), u'insert',
                       throw_reasons=[GAPI.DUPLICATE, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN,
                                      GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.INVALID_SCHEMA_VALUE],
                       body=body, fields=u'')
              Act.Set(Act.CREATE)
              entityActionPerformed([Ent.USER, user], i, count)
              if notify.get(u'emailAddress'):
                sendCreateUpdateUserNotification(notify, body, i, count)
            except GAPI.duplicate:
              entityDuplicateWarning([Ent.USER, user], i, count)
          else:
            entityUnknownWarning(Ent.USER, user, i, count)
            continue
      if admin_body:
        changeAdminStatus(cd, user, admin_body, i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER, user, i, count)
    except GAPI.invalidSchemaValue:
      entityActionFailedWarning([Ent.USER, user], Msg.INVALID_SCHEMA_VALUE, i, count)
    except (GAPI.invalid, GAPI.invalidInput) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except GAPI.invalidOrgunit:
      entityActionFailedWarning([Ent.USER, user], Msg.INVALID_ORGUNIT, i, count)

# gam update users <UserTypeEntity> <UserAttributes> [updateprimaryemail <RegularExpression> <EmailReplacement>]
#	[clearschema <SchemaName>] [clearschema <SchemaName>.<FieldName>]
#	[createifnotfound] [notify <EmailAddress>] [subject <String>] [message <String>|(file <FileName> [charset <CharSet>])] [html [<Boolean>]]
def doUpdateUsers():
  updateUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1])

# gam update user <UserItem> <UserAttributes> [updateprimaryemail <RegularExpression> <EmailReplacement>]
#	[clearschema <SchemaName>] [clearschema <SchemaName>.<FieldName>]
#	[createifnotfound] [notify <EmailAddress>] [subject <String>] [message <String>|(file <FileName> [charset <CharSet>])] [html [<Boolean>]]
def doUpdateUser():
  updateUsers(getStringReturnInList(Cmd.OB_USER_ITEM))

# gam <UserTypeEntity> delete users
def deleteUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.users(), u'delete',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
               userKey=user)
      entityActionPerformed([Ent.USER, user], i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam delete users <UserTypeEntity>
def doDeleteUsers():
  deleteUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1])

# gam delete user <UserItem>
def doDeleteUser():
  deleteUsers(getStringReturnInList(Cmd.OB_USER_ITEM))

# gam <UserEntity> undelete users [org|ou <OrgUnitPath>]
def undeleteUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent([u'org', u'ou']):
    orgUnitPaths = getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True)
    userOrgUnitLists = orgUnitPaths if isinstance(orgUnitPaths, dict) else None
  else:
    orgUnitPaths = [u'/']
    userOrgUnitLists = None
  checkForExtraneousArguments()
  body = {u'orgUnitPath': u''}
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    user_uid = user if user.find(u'@') == -1 else None
    if not user_uid:
      printEntityKVList([Ent.DELETED_USER, user],
                        [Msg.LOOKING_UP_GOOGLE_UNIQUE_ID, None],
                        i, count)
      try:
        deleted_users = callGAPIpages(cd.users(), u'list', u'users',
                                      throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                      customer=GC.Values[GC.CUSTOMER_ID], showDeleted=True, maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
      matching_users = []
      for deleted_user in deleted_users:
        if str(deleted_user[u'primaryEmail']).lower() == user:
          matching_users.append(deleted_user)
      jcount = len(matching_users)
      if jcount == 0:
        entityUnknownWarning(Ent.DELETED_USER, user, i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if jcount > 1:
        entityActionNotPerformedWarning([Ent.DELETED_USER, user],
                                        Msg.PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Ent.Plural(Ent.DELETED_USER), u'undelete', u'uid:<String>'),
                                        i, count)
        Ind.Increment()
        j = 0
        for matching_user in matching_users:
          printEntity([Ent.UNIQUE_ID, matching_user[u'id']], j, jcount)
          Ind.Increment()
          for attr_name in [u'creationTime', u'lastLoginTime', u'deletionTime']:
            if attr_name in matching_user:
              printKeyValueList([attr_name, formatLocalTime(matching_user[attr_name])])
          Ind.Decrement()
        Ind.Decrement()
        setSysExitRC(MULTIPLE_DELETED_USERS_FOUND_RC)
        continue
      user_uid = matching_users[0][u'id']
    if userOrgUnitLists:
      orgUnitPaths = userOrgUnitLists[user]
    body[u'orgUnitPath'] = makeOrgUnitPathAbsolute(orgUnitPaths[0])
    try:
      callGAPI(cd.users(), u'undelete',
               throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.INVALID_ORGUNIT, GAPI.DELETED_USER_NOT_FOUND],
               userKey=user_uid, body=body)
      entityActionPerformed([Ent.DELETED_USER, user], i, count)
    except (GAPI.badRequest, GAPI.invalid, GAPI.deletedUserNotFound):
      entityUnknownWarning(Ent.DELETED_USER, user, i, count)
    except GAPI.invalidOrgunit:
      entityActionFailedWarning([Ent.USER, user], Msg.INVALID_ORGUNIT, i, count)

# gam undelete users <UserEntity> [org|ou <OrgUnitPath>]
def doUndeleteUsers():
  undeleteUsers(getEntityList(Cmd.OB_USER_ENTITY))

# gam undelete user <UserItem> [org|ou <OrgUnitPath>]
def doUndeleteUser():
  undeleteUsers(getStringReturnInList(Cmd.OB_USER_ITEM))

def suspendUnsuspendUsers(entityList, suspended):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  body = {u'suspended': suspended}
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.users(), u'update',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
               userKey=user, body=body)
      entityActionPerformed([Ent.USER, user], i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> suspend users
def suspendUsers(entityList):
  suspendUnsuspendUsers(entityList, True)

# gam suspend users <UserTypeEntity>
def doSuspendUsers():
  suspendUnsuspendUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1], True)

# gam suspend user <UserItem>
def doSuspendUser():
  suspendUnsuspendUsers(getStringReturnInList(Cmd.OB_USER_ITEM), True)

# gam <UserTypeEntity> unsuspend users
def unsuspendUsers(entityList):
  suspendUnsuspendUsers(entityList, False)

# gam unsuspend users <UserTypeEntity>
def doUnsuspendUsers():
  suspendUnsuspendUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1], False)

# gam unsuspend user <UserItem>
def doUnsuspendUser():
  suspendUnsuspendUsers(getStringReturnInList(Cmd.OB_USER_ITEM), False)

USER_NAME_PROPERTY_PRINT_ORDER = [
  u'givenName',
  u'familyName',
  u'fullName',
  ]
USER_LANGUAGE_PROPERTY_PRINT_ORDER = [
  u'languageCode',
  u'customLanguage',
  ]
USER_SCALAR_PROPERTY_PRINT_ORDER = [
  u'isAdmin',
  u'isDelegatedAdmin',
  u'isEnrolledIn2Sv',
  u'isEnforcedIn2Sv',
  u'agreedToTerms',
  u'ipWhitelisted',
  u'suspended',
  u'suspensionReason',
  u'changePasswordAtNextLogin',
  u'id',
  u'customerId',
  u'isMailboxSetup',
  u'includeInGlobalAddressList',
  u'creationTime',
  u'lastLoginTime',
  u'deletionTime',
  u'orgUnitPath',
  u'thumbnailPhotoUrl',
  ]
USER_ARRAY_PROPERTY_PRINT_ORDER = [
  u'gender',
  u'keywords',
  u'notes',
  u'addresses',
  u'locations',
  u'organizations',
  u'relations',
  u'emails',
  u'ims',
  u'phones',
  u'posixAccounts',
  u'sshPublicKeys',
  u'externalIds',
  u'websites',
  ]

USER_ADDRESSES_PROPERTY_PRINT_ORDER = [
  u'primary',
  u'sourceIsStructured',
  u'formatted',
  u'extendedAddress',
  u'streetAddress',
  u'poBox',
  u'locality',
  u'region',
  u'postalCode',
  u'country',
  u'countryCode',
  ]

USER_LOCATIONS_PROPERTY_PRINT_ORDER = [
  u'area',
  u'buildingId',
  u'buildingName',
  u'floorName',
  u'floorSection',
  u'deskCode',
  ]

USER_POSIX_PROPERTY_PRINT_ORDER = [
  u'uid',
  u'gid',
  u'systemId',
  u'homeDirectory',
  u'shell',
  u'gecos',
  u'primary',
  ]

USER_SSH_PROPERTY_PRINT_ORDER = [
  u'expirationTimeUsec',
  u'fingerprint',
  ]

USER_FIELDS_CHOICE_MAP = {
  u'address': u'addresses',
  u'addresses': u'addresses',
  u'admin': [u'isAdmin', u'isDelegatedAdmin'],
  u'agreed2terms': u'agreedToTerms',
  u'agreedtoterms': u'agreedToTerms',
  u'aliases': [u'aliases', u'nonEditableAliases'],
  u'changepassword': u'changePasswordAtNextLogin',
  u'changepasswordatnextlogin': u'changePasswordAtNextLogin',
  u'creationtime': u'creationTime',
  u'deletiontime': u'deletionTime',
  u'email': u'emails',
  u'emails': u'emails',
  u'externalid': u'externalIds',
  u'externalids': u'externalIds',
  u'familyname': u'name.familyName',
  u'firstname': u'name.givenName',
  u'fullname': u'name.fullName',
  u'gal': u'includeInGlobalAddressList',
  u'givenname': u'name.givenName',
  u'gender': [u'gender.type', u'gender.customGender', u'gender.addressMeAs'],
  u'id': u'id',
  u'im': u'ims',
  u'ims': u'ims',
  u'includeinglobaladdresslist': u'includeInGlobalAddressList',
  u'ipwhitelisted': u'ipWhitelisted',
  u'isadmin': [u'isAdmin', u'isDelegatedAdmin'],
  u'isdelegatedadmin': [u'isAdmin', u'isDelegatedAdmin'],
  u'isenforcedin2sv': u'isEnforcedIn2Sv',
  u'isenrolledin2sv': u'isEnrolledIn2Sv',
  u'is2svenforced': u'isEnforcedIn2Sv',
  u'is2svenrolled': u'isEnrolledIn2Sv',
  u'ismailboxsetup': u'isMailboxSetup',
  u'keyword': u'keywords',
  u'keywords': u'keywords',
  u'language': u'languages',
  u'languages': u'languages',
  u'lastlogintime': u'lastLoginTime',
  u'lastname': u'name.familyName',
  u'location': u'locations',
  u'locations': u'locations',
  u'name': [u'name.givenName', u'name.familyName', u'name.fullName'],
  u'nicknames': [u'aliases', u'nonEditableAliases'],
  u'noneditablealiases': [u'aliases', u'nonEditableAliases'],
  u'note': u'notes',
  u'notes': u'notes',
  u'org': u'orgUnitPath',
  u'organization': u'organizations',
  u'organizations': u'organizations',
  u'orgunitpath': u'orgUnitPath',
  u'otheremail': u'emails',
  u'otheremails': u'emails',
  u'ou': u'orgUnitPath',
  u'phone': u'phones',
  u'phones': u'phones',
  u'photo': u'thumbnailPhotoUrl',
  u'photourl': u'thumbnailPhotoUrl',
  u'posix': u'posixAccounts',
  u'posixaccounts': u'posixAccounts',
  u'primaryemail': u'primaryEmail',
  u'relation': u'relations',
  u'relations': u'relations',
  u'ssh': u'sshPublicKeys',
  u'sshkeys': u'sshPublicKeys',
  u'sshpublickeys': u'sshPublicKeys',
  u'suspended': [u'suspended', u'suspensionReason'],
  u'thumbnailphotourl': u'thumbnailPhotoUrl',
  u'username': u'primaryEmail',
  u'website': u'websites',
  u'websites': u'websites',
  }

INFO_USER_OPTIONS = [u'noaliases', u'nobuildingnames', u'nogroups', u'nolicenses', u'nolicences', u'noschemas', u'schemas', u'userview',]
USER_SKIP_OBJECTS = set([u'thumbnailPhotoEtag',])
USER_TIME_OBJECTS = set([u'creationTime', u'deletionTime', u'lastLoginTime'])

def infoUsers(entityList):
  from gamlib import gluprop as UProp

  def _showType(row, typeKey, typeCustomValue, customTypeKey):
    if typeKey in row:
      if row[typeKey] != typeCustomValue or not row.get(customTypeKey):
        printKeyValueList([typeKey, row[typeKey]])
      else:
        printKeyValueList([typeKey, row[typeKey]])
        Ind.Increment()
        printKeyValueList([customTypeKey, row[customTypeKey]])
        Ind.Decrement()
      return True
    elif customTypeKey in row:
      printKeyValueList([customTypeKey, row[customTypeKey]])
      return True
    return False

  def _callbackGetLicense(request_id, response, exception):
    if exception is None:
      if response and u'skuId' in response:
        licenses.append(response[u'skuId'])

  cd = buildGAPIObject(API.DIRECTORY)
  getAliases = getBuildingNames = getGroups = getLicenses = getSchemas = True
  formatJSON = False
  projection = u'full'
  customFieldMask = viewType = None
  fieldsList = []
  groups = collections.deque()
  licenses = []
  skus = SKU.getSortedSKUList()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'quick':
      getAliases = getBuildingNames = getGroups = getLicenses = getSchemas = False
    elif myarg == u'noaliases':
      getAliases = False
    elif myarg == u'nobuildingnames':
      getBuildingNames = False
    elif myarg == u'nogroups':
      getGroups = False
    elif myarg in [u'nolicenses', u'nolicences']:
      getLicenses = False
    elif myarg == u'noschemas':
      getSchemas = False
      projection = u'basic'
    elif myarg in [u'custom', u'schemas']:
      getSchemas = True
      projection = u'custom'
      customFieldMask = getString(Cmd.OB_SCHEMA_NAME_LIST)
    elif myarg in [u'products', u'product']:
      skus = SKU.convertProductListToSKUList(getGoogleProductList())
    elif myarg in [u'sku', u'skus']:
      skus = getGoogleSKUList()
    elif myarg == u'userview':
      viewType = u'domain_public'
      getGroups = getLicenses = False
    elif myarg in USER_FIELDS_CHOICE_MAP:
      if not fieldsList:
        fieldsList = [u'primaryEmail',]
      addFieldToFieldsList(myarg, USER_FIELDS_CHOICE_MAP, fieldsList)
    elif myarg == u'fields':
      if not fieldsList:
        fieldsList.append(u'primaryEmail')
      for field in _getFieldsList():
        if field in USER_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, USER_FIELDS_CHOICE_MAP, fieldsList)
        else:
          invalidChoiceExit(USER_FIELDS_CHOICE_MAP, True)
# Ignore info group arguments that may have come from whatis
    elif myarg in INFO_GROUP_OPTIONS:
      pass
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  fields = u','.join(set(fieldsList)).replace(u'.', u'/') if fieldsList else None
  if getLicenses:
    lic = buildGAPIObject(API.LICENSING)
  if isinstance(entityList, dict):
    entityList[u'includeSuspendedInAll'] = True
  i, count, entityList = getEntityArgument(entityList)
  for userEmail in entityList:
    i += 1
    userEmail = normalizeEmailAddressOrUID(userEmail)
    try:
      user = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI.USER_GET_THROW_REASONS+[GAPI.INVALID_INPUT],
                      userKey=userEmail, projection=projection, customFieldMask=customFieldMask, viewType=viewType, fields=fields)
      if getGroups:
        groups = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=user[u'primaryEmail'], fields=u'nextPageToken,groups(name,email)')
      if getLicenses:
        svcargs = dict([(u'userId', None), (u'productId', None), (u'skuId', None), (u'fields', u'skuId')]+GM.Globals[GM.EXTRA_ARGS_LIST])
        method = getattr(lic.licenseAssignments(), u'get')
        dbatch = lic.new_batch_http_request(callback=_callbackGetLicense)
        for skuId in skus:
          svcparms = svcargs.copy()
          svcparms[u'userId'] = user[u'primaryEmail']
          svcparms[u'productId'], svcparms[u'skuId'] = SKU.getProductAndSKU(skuId)
          dbatch.add(method(**svcparms))
        executeBatch(dbatch)
      if formatJSON:
        if getGroups:
          user[u'groups'] = list(groups)
        if getLicenses:
          user[u'licenses'] = [SKU.formatSKUIdDisplayName(u_license) for u_license in licenses]
        printLine(json.dumps(cleanJSON(user, u'', skipObjects=USER_SKIP_OBJECTS, timeObjects=USER_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.USER, user[u'primaryEmail']], i, count)
      Ind.Increment()
      printKeyValueList([u'Settings', None])
      Ind.Increment()
      if u'name' in user:
        for up in USER_NAME_PROPERTY_PRINT_ORDER:
          if up in user[u'name']:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], user[u'name'][up]])
      up = u'languages'
      if up in user:
        propertyValue = user[up]
        if len(propertyValue) > 0:
          for up in USER_LANGUAGE_PROPERTY_PRINT_ORDER:
            languages = [row[up] for row in propertyValue if up in row]
            if languages:
              printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], u','.join(languages)])
      for up in USER_SCALAR_PROPERTY_PRINT_ORDER:
        if up in user:
          if up not in USER_TIME_OBJECTS:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], user[up]])
          else:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], formatLocalTime(user[up])])
      Ind.Decrement()
      for up in USER_ARRAY_PROPERTY_PRINT_ORDER:
        if up not in user:
          continue
        propertyValue = user[up]
        userProperty = UProp.PROPERTIES[up]
        propertyClass = userProperty[UProp.CLASS]
        propertyTitle = userProperty[UProp.TITLE]
        if UProp.TYPE_KEYWORDS in userProperty:
          typeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_KEYWORD]
          typeCustomValue = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
          customTypeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
        if propertyClass == UProp.PC_ARRAY:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              for key in row:
                if key in [typeKey, customTypeKey]:
                  continue
                printKeyValueList([key, row[key]])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_GENDER:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            _showType(propertyValue, typeKey, typeCustomValue, customTypeKey)
            if u'addressMeAs' in propertyValue:
              printKeyValueList([u'addressMeAs', propertyValue[u'addressMeAs']])
            Ind.Decrement()
        elif propertyClass == UProp.PC_ADDRESSES:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              for key in USER_ADDRESSES_PROPERTY_PRINT_ORDER:
                if key in row:
                  if key != u'formatted':
                    printKeyValueList([key, row[key]])
                  else:
                    printKeyValueWithCRsNLs(key, row[key])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_EMAILS:
          if len(propertyValue) > 0:
            needTitle = True
            for row in propertyValue:
              if row[u'address'].lower() == user[u'primaryEmail'].lower():
                continue
              if needTitle:
                needTitle = False
                printKeyValueList([propertyTitle, None])
                Ind.Increment()
              if not _showType(row, typeKey, typeCustomValue, customTypeKey):
                if not getAliases:
                  continue
                printKeyValueList([typeKey, u'alias'])
              Ind.Increment()
              for key in row:
                if key in [typeKey, customTypeKey]:
                  continue
                printKeyValueList([key, row[key]])
              Ind.Decrement()
            if not needTitle:
              Ind.Decrement()
        elif propertyClass == UProp.PC_IMS:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            protocolKey = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_TYPE_KEYWORD]
            protocolCustomValue = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
            customProtocolKey = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              _showType(row, protocolKey, protocolCustomValue, customProtocolKey)
              for key in row:
                if key in [typeKey, customTypeKey, protocolKey, customProtocolKey]:
                  continue
                printKeyValueList([key, row[key]])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_NOTES:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, dict):
              typeVal = propertyValue.get(typeKey, u'text_plain')
              printKeyValueList([typeKey, typeVal])
              Ind.Increment()
              if typeVal == u'text_html':
                printKeyValueWithCRsNLs(u'value', dehtml(propertyValue[u'value']))
              else:
                printKeyValueWithCRsNLs(u'value', propertyValue[u'value'])
              Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
        elif propertyClass == UProp.PC_LOCATIONS:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                _showType(row, typeKey, typeCustomValue, customTypeKey)
                Ind.Increment()
                if getBuildingNames:
                  row[u'buildingName'] = _getBuildingNameById(cd, row.get(u'buildingId', u''))
                for key in USER_LOCATIONS_PROPERTY_PRINT_ORDER:
                  if key in row:
                    printKeyValueList([key, row[key]])
                Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
        elif propertyClass == UProp.PC_POSIX:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                printKeyValueList([u'username', row.get(u'username')])
                Ind.Increment()
                for key in USER_POSIX_PROPERTY_PRINT_ORDER:
                  if key in row:
                    printKeyValueList([key, row[key]])
                Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
        elif propertyClass == UProp.PC_SSH:
          if len(propertyValue) > 0:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                printKeyValueList([u'key', row[u'key']])
                Ind.Increment()
                for key in USER_SSH_PROPERTY_PRINT_ORDER:
                  if key in row:
                    printKeyValueList([key, row[key]])
                Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
      if getSchemas:
        up = u'customSchemas'
        if up in user:
          propertyValue = user[up]
          userProperty = UProp.PROPERTIES[up]
          propertyTitle = userProperty[UProp.TITLE]
          typeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_KEYWORD]
          typeCustomValue = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
          customTypeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
          printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], None])
          Ind.Increment()
          for schema in propertyValue:
            printKeyValueList([u'Schema', schema])
            Ind.Increment()
            for field in propertyValue[schema]:
              if isinstance(propertyValue[schema][field], list):
                printKeyValueList([field])
                Ind.Increment()
                for an_item in propertyValue[schema][field]:
                  _showType(an_item, typeKey, typeCustomValue, customTypeKey)
                  Ind.Increment()
                  printKeyValueList([u'value', an_item[u'value']])
                  Ind.Decrement()
                Ind.Decrement()
              else:
                printKeyValueList([field, propertyValue[schema][field]])
            Ind.Decrement()
          Ind.Decrement()
      if getAliases:
        for up in [u'aliases', u'nonEditableAliases']:
          propertyValue = user.get(up, [])
          if propertyValue:
            printEntitiesCount([Ent.NONEDITABLE_ALIAS, Ent.EMAIL_ALIAS][up == u'aliases'], propertyValue)
            Ind.Increment()
            for alias in propertyValue:
              printKeyValueList([u'alias', alias])
            Ind.Decrement()
      if groups:
        printEntitiesCount(Ent.GROUP, groups)
        Ind.Increment()
        for group in groups:
          printKeyValueList([group[u'name'], group[u'email']])
        Ind.Decrement()
      if licenses:
        printEntitiesCount(Ent.LICENSE, licenses)
        Ind.Increment()
        for u_license in licenses:
          printKeyValueList([SKU.formatSKUIdDisplayName(u_license)])
        Ind.Decrement()
      Ind.Decrement()
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER, userEmail, i, count)
    except GAPI.invalidInput as e:
      if customFieldMask:
        entityActionFailedWarning([Ent.USER, userEmail], invalidUserSchema(customFieldMask), i, count)
      else:
        entityActionFailedWarning([Ent.USER, userEmail], str(e), i, count)

# gam info users <UserTypeEntity> [quick] [noaliases] [nogroups] [nolicenses|nolicences] [noschemas] [schemas|custom <SchemaNameList>]
#	[userview] [fields <UserFieldNameList>] [products|product <ProductIDList>] [skus|sku <SKUIDList>] [formatjson]
def doInfoUsers():
  infoUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, delayGet=True)[1])

# gam info user <UserItem> [quick] [noaliases] [nogroups] [nolicenses|nolicences] [noschemas] [schemas|custom <SchemaNameList>]
#	[userview] [fields <UserFieldNameList>] [products|product <ProductIDList>] [skus|sku <SKUIDList>] [formatjson]
# gam info user
def doInfoUser():
  if Cmd.ArgumentsRemaining():
    infoUsers(getStringReturnInList(Cmd.OB_USER_ITEM))
  else:
    infoUsers([_getValueFromOAuth(u'email')])

USERS_ORDERBY_CHOICE_MAP = {
  u'familyname': u'familyName',
  u'lastname': u'familyName',
  u'givenname': u'givenName',
  u'firstname': u'givenName',
  u'email': u'email',
  }

# gam [<UserTypeEntity>] print users [todrive [<ToDriveAttributes>]]
#	([domain <DomainName>] [(query <QueryUser>)|(queries <QueryUserList>)] [deleted_only|only_deleted])|[select <UserTypeEntity>]
#	[groups] [license|licenses|licence|licences] [emailpart|emailparts|username] [schemas|custom all|<SchemaNameList>]
#	[orderby <UserOrderByFieldName> [ascending|descending]]
#	[userview] [basic|full|allfields | <UserFieldName>* | fields <UserFieldNameList>]
#	[delimiter <Character>] [sortheaders] [formatjson] [quotechar <Character>]
#
# gam print users countonly [domain <DomainName>] [(query <QueryUser>)|(queries <QueryUserList>)] [deleted_only|only_deleted]
def doPrintUsers(entityList=None):
  def _printUser(userEntity):
    if email_parts and (u'primaryEmail' in userEntity):
      userEmail = userEntity[u'primaryEmail']
      if userEmail.find(u'@') != -1:
        userEntity[u'primaryEmailLocal'], userEntity[u'primaryEmailDomain'] = splitEmailAddress(userEmail)
    for location in userEntity.get(u'locations', []):
      location[u'buildingName'] = _getBuildingNameById(cd, location.get(u'buildingId', u''))
    if not formatJSON:
      addRowTitlesToCSVfile(flattenJSON(userEntity, skipObjects=USER_SKIP_OBJECTS, timeObjects=USER_TIME_OBJECTS), csvRows, titles)
    else:
      csvRows.append({u'primaryEmail': userEntity[u'primaryEmail'],
                      u'JSON': json.dumps(cleanJSON(userEntity, u'', skipObjects=USER_SKIP_OBJECTS, timeObjects=USER_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})

  _PRINT_USER_REASON_TO_MESSAGE_MAP = {GAPI.RESOURCE_NOT_FOUND: Msg.DOES_NOT_EXIST}
  def _callbackPrintUser(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printUser(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.USER_GET_THROW_REASONS:
        entityUnknownWarning(Ent.USER, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      elif (reason == GAPI.INVALID_INPUT) and customFieldMask:
        entityActionFailedWarning([Ent.USER, ri[RI_ITEM]], invalidUserSchema(customFieldMask), int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_PRINT_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        printKeyValueList([ERROR, errMsg])

  cd = buildGAPIObject(API.DIRECTORY)
  todrive = {}
  fieldsList = []
  titles, csvRows = initializeTitlesCSVfile(None)
  addFieldToCSVfile(u'primaryEmail', USER_FIELDS_CHOICE_MAP, fieldsList, titles)
  countOnly = sortHeaders = getGroupFeed = getLicenseFeed = email_parts = False
  customer = GC.Values[GC.CUSTOMER_ID]
  domain = None
  queries = [None]
  projection = u'basic'
  customFieldMask = None
  viewType = deleted_only = orderBy = sortOrder = None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  formatJSON = selectLookup = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'domain':
      domain = getString(Cmd.OB_DOMAIN_NAME).lower()
      customer = None
    elif myarg in [u'query', u'queries']:
      queries = getQueries(myarg)
    elif myarg in [u'deletedonly', u'onlydeleted']:
      deleted_only = True
    elif myarg == u'select':
      _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    elif myarg == u'orderby':
      orderBy = getChoice(USERS_ORDERBY_CHOICE_MAP, mapChoice=True)
      sortOrder = getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ASCENDING', mapChoice=True)
    elif myarg == u'userview':
      viewType = u'domain_public'
    elif myarg in [u'custom', u'schemas']:
      if not fieldsList:
        fieldsList = [u'primaryEmail',]
      fieldsList.append(u'customSchemas')
      customFieldMask = getString(Cmd.OB_SCHEMA_NAME_LIST).replace(u' ', u',')
      if customFieldMask.lower() == u'all':
        customFieldMask = None
        projection = u'full'
      else:
        projection = u'custom'
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg in PROJECTION_CHOICE_MAP:
      projection = myarg
      sortHeaders = True
      fieldsList = []
    elif myarg == u'allfields':
      projection = u'basic'
      sortHeaders = True
      fieldsList = []
    elif myarg == u'sortheaders':
      sortHeaders = getBoolean()
    elif getFieldsListTitles(myarg, USER_FIELDS_CHOICE_MAP, fieldsList, titles, u'primaryEmail'):
      pass
    elif myarg == u'groups':
      getGroupFeed = True
    elif myarg in [u'license', u'licenses', u'licence', u'licences']:
      getLicenseFeed = True
    elif myarg in [u'emailpart', u'emailparts', u'username']:
      email_parts = True
    elif myarg == "formatjson":
      formatJSON = True
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif myarg == u'countonly':
      countOnly = True
    else:
      unknownArgumentExit()
  _, _, entityList = getEntityArgument(entityList)
  if countOnly:
    fieldsList = [u'primaryEmail',]
    domainCounts = {}
    if not formatJSON:
      titles, csvRows = initializeTitlesCSVfile([u'domain', u'count'])
    else:
      titles, csvRows = initializeTitlesCSVfile([u'JSON',])
  elif formatJSON:
    sortHeaders = False
    titles, csvRows = initializeTitlesCSVfile([u'primaryEmail', u'JSON'])
  if entityList is None:
    sortRows = False
    fields = u'nextPageToken,users({0})'.format(u','.join(set(fieldsList))).replace(u'.', u'/') if fieldsList else None
    for query in queries:
      printGettingAllAccountEntities(Ent.USER, query)
      try:
        feed = callGAPIpages(cd.users(), u'list', u'users',
                             page_message=getPageMessage(showFirstLastItems=True), message_attribute=u'primaryEmail',
                             throw_reasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.INVALID_ORGUNIT, GAPI.INVALID_INPUT,
                                            GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customer=customer, domain=domain, fields=fields, query=query,
                             showDeleted=deleted_only, orderBy=orderBy, sortOrder=sortOrder, viewType=viewType,
                             projection=projection, customFieldMask=customFieldMask, maxResults=GC.Values[GC.USER_MAX_RESULTS])
        if not countOnly:
          while feed:
            _printUser(feed.popleft())
        else:
          for user in feed:
            _, domain = splitEmailAddress(user[u'primaryEmail'])
            domainCounts.setdefault(domain, 0)
            domainCounts[domain] += 1
      except GAPI.domainNotFound:
        entityActionFailedWarning([Ent.USER, None, Ent.DOMAIN, domain], Msg.NOT_FOUND)
        return
      except (GAPI.invalidOrgunit, GAPI.invalidInput) as e:
        if query and not customFieldMask:
          entityActionFailedWarning([Ent.USER, None], invalidQuery(query))
        elif customFieldMask and not query:
          entityActionFailedWarning([Ent.USER, None], invalidUserSchema(customFieldMask))
        elif query and customFieldMask:
          entityActionFailedWarning([Ent.USER, None], u'{0} or {1}'.format(invalidQuery(query), invalidUserSchema(customFieldMask)))
        else:
          entityActionFailedWarning([Ent.USER, None], str(e))
        return
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
  else:
    sortRows = True
    if fieldsList:
      fields = u','.join(set(fieldsList)).replace(u'.', u'/')
      selectLookup = len(fieldsList) > 1
    else:
      fields = None
      selectLookup = True
    if selectLookup:
      jcount = len(entityList)
      svcargs = dict([(u'userKey', None), (u'fields', fields), (u'projection', projection), (u'customFieldMask', customFieldMask), (u'viewType', viewType)]+GM.Globals[GM.EXTRA_ARGS_LIST])
      method = getattr(cd.users(), u'get')
      dbatch = cd.new_batch_http_request(callback=_callbackPrintUser)
      bcount = 0
      j = 0
      for userEntity in entityList:
        j += 1
        svcparms = svcargs.copy()
        svcparms[u'userKey'] = normalizeEmailAddressOrUID(userEntity)
        dbatch.add(method(**svcparms), request_id=batchRequestID(u'', 0, 0, j, jcount, svcparms[u'userKey']))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = cd.new_batch_http_request(callback=_callbackPrintUser)
          bcount = 0
      if bcount > 0:
        executeBatch(dbatch)
    elif not countOnly:
      for userEntity in entityList:
        _printUser({u'primaryEmail': normalizeEmailAddressOrUID(userEntity)})
    else:
      for userEntity in entityList:
        userEntity = normalizeEmailAddressOrUID(userEntity)
        if userEntity.find(u'@') != -1:
          _, domain = splitEmailAddress(userEntity)
        else:
          domain = u'Unknown'
        domainCounts.setdefault(domain, 0)
        domainCounts[domain] += 1
  if not countOnly:
    if sortHeaders:
      sortCSVTitles([u'primaryEmail',], titles)
    if sortRows and orderBy:
      orderBy = [u'name.{0}'.format(orderBy), u'primaryEmail'][orderBy == u'email']
      if orderBy in titles[u'set']:
        csvRows.sort(key=lambda k: k[orderBy], reverse=sortOrder == u'DESCENDING')
    if getGroupFeed:
      addTitlesToCSVfile([u'GroupsCount', u'Groups'], titles)
      i = 0
      count = len(csvRows)
      for user in csvRows:
        i += 1
        userEmail = user[u'primaryEmail']
        printGettingAllEntityItemsForWhom(Ent.GROUP_MEMBERSHIP, userEmail, i, count)
        groups = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=userEmail, fields=u'nextPageToken,groups(email)')
        user[u'GroupsCount'] = len(groups)
        user[u'Groups'] = delimiter.join([groupname[u'email'] for groupname in groups])
    if getLicenseFeed:
      addTitlesToCSVfile([u'LicensesCount', u'Licenses', u'LicensesDisplay'], titles)
      licenses = doPrintLicenses(returnFields=u'userId,skuId')
      if licenses:
        for user in csvRows:
          u_licenses = licenses.get(user[u'primaryEmail'].lower())
          if u_licenses:
            user[u'LicensesCount'] = len(u_licenses)
            user[u'Licenses'] = delimiter.join(u_licenses)
            user[u'LicensesDisplay'] = delimiter.join([SKU.skuIdToDisplayName(skuId) for skuId in u_licenses])
  elif not formatJSON:
    for domain, count in sorted(iteritems(domainCounts)):
      csvRows.append({u'domain': domain, u'count': count})
  else:
    csvRows.append({u'JSON': json.dumps(cleanJSON(domainCounts, u''), ensure_ascii=False, sort_keys=True)})
  writeCSVfile(csvRows, titles, u'Users', todrive, quotechar=quotechar)

# gam <UserTypeEntity> print
def doPrintUserEntity(entityList):
  if not Cmd.ArgumentsRemaining():
    _, _, entityList = getEntityArgument(entityList)
    for entity in entityList:
      printLine(normalizeEmailAddressOrUID(entity))
    return
  doPrintUsers(entityList)

SITEVERIFICATION_METHOD_CHOICE_MAP = {
  u'cname': u'DNS_CNAME',
  u'txt': u'DNS_TXT',
  u'text': u'DNS_TXT',
  u'file': u'FILE',
  u'site': u'FILE',
  }

# gam create verify|verification <DomainName>
def doCreateSiteVerification():
  verif = buildGAPIObject(API.SITEVERIFICATION)
  a_domain = getString(Cmd.OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  txt_record = callGAPI(verif.webResource(), u'getToken',
                        body={u'site': {u'type': u'INET_DOMAIN', u'identifier': a_domain},
                              u'verificationMethod': u'DNS_TXT'})
  printKeyValueList([u'TXT Record Name ', a_domain])
  printKeyValueList([u'TXT Record Value', txt_record[u'token']])
  printBlankLine()
  cname_record = callGAPI(verif.webResource(), u'getToken',
                          body={u'site': {u'type': u'INET_DOMAIN', u'identifier': a_domain},
                                u'verificationMethod': u'DNS_CNAME'})
  cname_token = cname_record[u'token']
  cname_list = cname_token.split(u' ')
  cname_subdomain = cname_list[0]
  cname_value = cname_list[1]
  printKeyValueList([u'CNAME Record Name ', u'{0}.{1}'.format(cname_subdomain, a_domain)])
  printKeyValueList([u'CNAME Record Value', cname_value])
  printBlankLine()
  webserver_file_record = callGAPI(verif.webResource(), u'getToken',
                                   body={u'site': {u'type': u'SITE', u'identifier': u'http://{0}/'.format(a_domain)},
                                         u'verificationMethod': u'FILE'})
  webserver_file_token = webserver_file_record[u'token']
  printKeyValueList([u'Saving web server verification file to', webserver_file_token])
  writeFile(webserver_file_token, u'google-site-verification: {0}'.format(webserver_file_token), continueOnError=True)
  printKeyValueList([u'Verification File URL', u'http://{0}/{1}'.format(a_domain, webserver_file_token)])
  printBlankLine()
  webserver_meta_record = callGAPI(verif.webResource(), u'getToken',
                                   body={u'site': {u'type': u'SITE', u'identifier': u'http://{0}/'.format(a_domain)},
                                         u'verificationMethod': u'META'})
  printKeyValueList([u'Meta URL', u'//{0}/'.format(a_domain)])
  printKeyValueList([u'Meta HTML Header Data', webserver_meta_record[u'token']])
  printBlankLine()

def _showSiteVerificationInfo(site):
  import urllib.parse
  printKeyValueList([u'Site', site[u'site'][u'identifier']])
  Ind.Increment()
  printKeyValueList([u'ID', urllib.parse.unquote(site[u'id'])])
  printKeyValueList([u'Type', site[u'site'][u'type']])
  printKeyValueList([u'All Owners', None])
  if u'owners' in site:
    Ind.Increment()
    for owner in sorted(site[u'owners']):
      printKeyValueList([owner])
    Ind.Decrement()
  Ind.Decrement()

# gam update verify|verification <DomainName> cname|txt|text|file|site
def doUpdateSiteVerification():
  verif = buildGAPIObject(API.SITEVERIFICATION)
  a_domain = getString(Cmd.OB_DOMAIN_NAME)
  verificationMethod = getChoice(SITEVERIFICATION_METHOD_CHOICE_MAP, mapChoice=True)
  if verificationMethod in [u'DNS_TXT', u'DNS_CNAME']:
    verify_type = u'INET_DOMAIN'
    identifier = a_domain
  else:
    verify_type = u'SITE'
    identifier = u'http://{0}/'.format(a_domain)
  checkForExtraneousArguments()
  body = {u'site': {u'type': verify_type, u'identifier': identifier},
          u'verificationMethod': verificationMethod}
  try:
    verify_result = callGAPI(verif.webResource(), u'insert',
                             throw_reasons=[GAPI.BAD_REQUEST],
                             verificationMethod=verificationMethod, body=body)
  except GAPI.badRequest as e:
    printKeyValueList([ERROR, str(e)])
    verify_data = callGAPI(verif.webResource(), u'getToken',
                           body=body)
    printKeyValueList([u'Method', verify_data[u'method']])
    printKeyValueList([u'Token', verify_data[u'token']])
    if verify_data[u'method'] == u'DNS_CNAME':
      try:
        import dns.resolver
        resolver = dns.resolver.Resolver()
        resolver.nameservers = GOOGLE_NAMESERVERS
        cname_token = verify_data[u'token']
        cname_list = cname_token.split(u' ')
        cname_subdomain = cname_list[0]
        try:
          answers = resolver.query(u'{0},{1}'.format(cname_subdomain, a_domain), u'A')
          for answer in answers:
            printKeyValueList([u'DNS Record', answer])
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
          printKeyValueList([ERROR, u'No such domain found in DNS!'])
      except ImportError:
        pass
    elif verify_data[u'method'] == u'DNS_TXT':
      try:
        import dns.resolver
        resolver = dns.resolver.Resolver()
        resolver.nameservers = GOOGLE_NAMESERVERS
        try:
          answers = resolver.query(a_domain, u'TXT')
          for answer in answers:
            printKeyValueList([u'DNS Record', answer.replace(u'"', u'')])
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
          printKeyValueList([ERROR, u'Domain not found in DNS!'])
      except ImportError:
        printKeyValueList([u'!!!No DNS'])
    return
  printKeyValueList([u'Verified!'])
  _showSiteVerificationInfo(verify_result)
  printKeyValueList([u'You can now add', a_domain, u'or it\'s subdomains as secondary or domain aliases of the G Suite Account', GC.Values[GC.DOMAIN]])

# gam info verify|verification
def doInfoSiteVerification():
  verif = buildGAPIObject(API.SITEVERIFICATION)
  checkForExtraneousArguments()
  sites = callGAPIitems(verif.webResource(), u'list', u'items')
  if sites:
    for site in sorted(sites, key=lambda k: (k[u'site'][u'type'], k[u'site'][u'identifier'])):
      _showSiteVerificationInfo(site)
  else:
    printKeyValueList([u'No Sites Verified.'])

# gam create guardian|guardianinvite|inviteguardian <EmailAddress> <StudentItem>
def doInviteGuardian():
  croom = buildGAPIObject(API.CLASSROOM)
  body = {u'invitedEmailAddress': getEmailAddress()}
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_STUDENT_ITEM))
  checkForExtraneousArguments()
  try:
    result = callGAPI(croom.userProfiles().guardianInvitations(), u'create',
                      throw_reasons=[GAPI.NOT_FOUND, GAPI.ALREADY_EXISTS,
                                     GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED, GAPI.RESOURCE_EXHAUSTED],
                      studentId=studentId, body=body, fields=u'invitationId')
    entityActionPerformed([Ent.STUDENT, studentId, Ent.GUARDIAN, body[u'invitedEmailAddress'], Ent.GUARDIAN_INVITATION, result[u'invitationId']])
  except GAPI.notFound:
    entityUnknownWarning(Ent.STUDENT, studentId)
  except GAPI.alreadyExists:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN, body[u'invitedEmailAddress']], Msg.DUPLICATE)
  except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied, GAPI.resourceExhausted) as e:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN, body[u'invitedEmailAddress']], str(e))

def _cancelGuardianInvitation(croom, studentId, invitationId):
  try:
    result = callGAPI(croom.userProfiles().guardianInvitations(), u'patch',
                      throw_reasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.NOT_FOUND],
                      studentId=studentId, invitationId=invitationId, updateMask=u'state', body={u'state': u'COMPLETE'}, fields=u'invitedEmailAddress')
    entityActionPerformed([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, result[u'invitedEmailAddress']])
    return True
  except GAPI.failedPrecondition:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, invitationId], Msg.GUARDIAN_INVITATION_STATUS_NOT_PENDING)
    return True
  except GAPI.forbidden:
    entityUnknownWarning(Ent.STUDENT, studentId)
    systemErrorExit(GM.Globals[GM.SYSEXITRC], None)
  except GAPI.notFound:
    return False

# gam cancel guardianinvitation|guardianinvitations <GuardianInvitationID> <StudentItem>
def doCancelGuardianInvitation():
  croom = buildGAPIObject(API.CLASSROOM)
  invitationId = getString(Cmd.OB_GUARDIAN_INVITATION_ID)
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_STUDENT_ITEM))
  checkForExtraneousArguments()
  if not _cancelGuardianInvitation(croom, studentId, invitationId):
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, invitationId], Msg.NOT_FOUND)

def _deleteGuardian(croom, studentId, guardianId, guardianEmail):
  try:
    callGAPI(croom.userProfiles().guardians(), u'delete',
             throw_reasons=[GAPI.FORBIDDEN, GAPI.NOT_FOUND],
             studentId=studentId, guardianId=guardianId)
    entityActionPerformed([Ent.STUDENT, studentId, Ent.GUARDIAN, guardianEmail])
    return True
  except GAPI.forbidden:
    entityUnknownWarning(Ent.STUDENT, studentId)
    systemErrorExit(GM.Globals[GM.SYSEXITRC], None)
  except GAPI.notFound:
    return False

# gam delete guardian|guardians <GuardianItem> <StudentItem> [invitation]
def doDeleteGuardian():
  croom = buildGAPIObject(API.CLASSROOM)
  guardianId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_GUARDIAN_ITEM))
  guardianIdIsEmail = guardianId.find(u'@') != -1
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_STUDENT_ITEM))
  invitationsOnly = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'invitation', u'invitations']:
      invitationsOnly = True
    else:
      unknownArgumentExit()
  if not invitationsOnly:
    if guardianIdIsEmail:
      try:
        results = callGAPIpages(croom.userProfiles().guardians(), u'list', u'guardians',
                                throw_reasons=[GAPI.FORBIDDEN],
                                studentId=studentId, invitedEmailAddress=guardianId)
        if len(results) > 0:
          for result in results:
            _deleteGuardian(croom, studentId, result[u'guardianId'], guardianId)
          return
      except GAPI.forbidden:
        entityUnknownWarning(Ent.STUDENT, studentId)
        systemErrorExit(GM.Globals[GM.SYSEXITRC], None)
    else:
      if _deleteGuardian(croom, studentId, guardianId, guardianId):
        return
  Act.Set(Act.CANCEL)
  if guardianIdIsEmail:
    try:
      results = callGAPIpages(croom.userProfiles().guardianInvitations(), u'list', u'guardianInvitations',
                              throw_reasons=[GAPI.FORBIDDEN],
                              studentId=studentId, invitedEmailAddress=guardianId, states=[u'PENDING',])
      if len(results) > 0:
        for result in results:
          _cancelGuardianInvitation(croom, studentId, result[u'invitationId'])
        return
    except GAPI.forbidden:
      entityUnknownWarning(Ent.STUDENT, studentId)
      systemErrorExit(GM.Globals[GM.SYSEXITRC], None)
  else:
    if _cancelGuardianInvitation(croom, studentId, guardianId):
      return
  Act.Set(Act.DELETE)
  entityActionFailedWarning([Ent.STUDENT, studentId, [Ent.GUARDIAN, Ent.GUARDIAN_INVITATION][invitationsOnly], guardianId], Msg.NOT_FOUND)

GUARDIAN_STATES = [u'complete', u'pending']

def printShowGuardians(csvFormat):
  def _getStudentEmail(guardian, studentId):
    if studentId.find(u'@') != -1:
      return studentId
    studentEmail = studentEmails.get(guardian[u'studentId'])
    if studentEmail is not None:
      return studentEmail
    try:
      studentEmail = callGAPI(croom.userProfiles(), u'get',
                              throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                              userId=guardian[u'studentId'], fields=u'emailAddress')[u'emailAddress']
    except (GAPI.notFound, GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied):
      studentEmail = guardian[u'studentId']
    studentEmails[guardian[u'studentId']] = studentEmail
    return studentEmail

  croom = buildGAPIObject(API.CLASSROOM)
  invitedEmailAddress = None
  studentIds = [u'-',]
  allStudents = True
  showStudentEmails = False
  studentEmails = {}
  states = []
  service = croom.userProfiles().guardians()
  items = u'guardians'
  entityType = Ent.GUARDIAN
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'studentEmail', u'studentId', u'invitedEmailAddress', u'guardianId'])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'invitedguardian':
      invitedEmailAddress = getEmailAddress()
    elif myarg == u'student':
      studentIds = [getString(Cmd.OB_STUDENT_ITEM)]
      allStudents = False
    elif myarg == u'invitations':
      service = croom.userProfiles().guardianInvitations()
      items = u'guardianInvitations'
      entityType = Ent.GUARDIAN_INVITATION
      titles, csvRows = initializeTitlesCSVfile([u'studentEmail', u'studentId', u'invitedEmailAddress', u'invitationId'])
      if not states:
        states = [state.upper() for state in GUARDIAN_STATES]
    elif myarg == u'states':
      statesList = getString(Cmd.OB_GUARDIAN_STATE_LIST).lower().split(u',')
      states = []
      for state in statesList:
        if state in GUARDIAN_STATES:
          states.append(state.upper())
        else:
          invalidChoiceExit(GUARDIAN_STATES, True)
    elif myarg == u'showstudentemails':
      showStudentEmails = True
    else:
      Cmd.Backup()
      _, studentIds = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
      allStudents = False
  i = 0
  count = len(studentIds)
  for studentId in studentIds:
    i += 1
    studentId = normalizeStudentGuardianEmailAddressOrUID(studentId)
    kwargs = {u'invitedEmailAddress': invitedEmailAddress, u'studentId': studentId}
    if items == u'guardianInvitations':
      kwargs[u'states'] = states
    if not allStudents:
      if csvFormat:
        printGettingAllEntityItemsForWhom(entityType, studentId, i, count)
    try:
      result = callGAPIpages(service, u'list', items,
                             throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                             **kwargs)
      jcount = len(result)
      if not csvFormat:
        entityPerformActionNumItems([Ent.STUDENT, studentId if not allStudents else u'All'], jcount, entityType, i, count)
        Ind.Increment()
        j = 0
        for guardian in result:
          j += 1
          printKeyValueListWithCount([u'invitedEmailAddress', guardian[u'invitedEmailAddress']], j, jcount)
          Ind.Increment()
          if showStudentEmails:
            guardian[u'studentEmail'] = _getStudentEmail(guardian, studentId)
          showJSON(None, guardian, [u'invitedEmailAddress',], COURSE_TIME_OBJECTS)
          Ind.Decrement()
        Ind.Decrement()
      else:
        for guardian in result:
          if showStudentEmails:
            guardian[u'studentEmail'] = _getStudentEmail(guardian, studentId)
          else:
            guardian[u'studentEmail'] = studentId
          addRowTitlesToCSVfile(flattenJSON(guardian, timeObjects=COURSE_TIME_OBJECTS), csvRows, titles)
    except (GAPI.notFound, GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden):
      entityUnknownWarning(Ent.STUDENT, studentId, i, count)
    except GAPI.permissionDenied as e:
      entityActionFailedWarning([Ent.STUDENT, studentId], str(e), i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Guardians', todrive)

# gam show guardian|guardians [showstudentemails] [invitations [states <GuardianStateList>]] [invitedguardian <EmailAddress>] [student <StudentItem>] [<UserTypeEntity>]
def doShowGuardians():
  printShowGuardians(False)

# gam print guardian|guardians [todrive [<ToDriveAttributes>]] [showstudentemails] [invitations [states <GuardianStateList>]] [invitedguardian <EmailAddress>] [student <StudentItem>] [<UserTypeEntity>]
def doPrintGuardians():
  printShowGuardians(True)

def getClassroomOauth2Credentials(filename):
  if not os.path.isfile(filename):
    invalidClassroomOauth2TxtExit(filename)
  try:
    storage = oauth2client.file.Storage(filename)
    return storage.get()
  except (KeyError, ValueError):
    invalidClassroomOauth2TxtExit(filename)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def getClassroomOauth2Filename(userId):
  return os.path.join(GC.Values[GC.CONFIG_DIR], u'classroom-{0}-oauth2.txt'.format(userId))

# gam <UserTypeEntity> create classroomoauth2
def createClassroomOauth2(users, checkArguments=True):
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArguments:
    checkForExtraneousArguments()
  client_id, client_secret = getOAuthClientIDAndSecret()
  flags = cmd_flags(noLocalWebserver=GC.Values[GC.NO_BROWSER])
  httpObj = getHttpObj()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if user.find(u'@') == -1:
      userId = user
      login_hint = convertUIDtoEmailAddress(user, cd=cd)
    else:
      userId = convertEmailAddressToUID(user, cd=cd)
      login_hint = user
    flow = oauth2client.client.OAuth2WebServerFlow(client_id=client_id,
                                                   client_secret=client_secret, scope=API.CLASSROOM_OAUTH_SCOPES, redirect_uri=oauth2client.client.OOB_CALLBACK_URN,
                                                   user_agent=GAM_INFO, response_type=u'code', login_hint=login_hint)
    classroomOauth2File = getClassroomOauth2Filename(userId)
    storage = oauth2client.file.Storage(classroomOauth2File)
    try:
      oauth2client.tools.run_flow(flow=flow, storage=storage, flags=flags, http=httpObj)
      time.sleep(2)
      action = Act.Get()
      Act.Set(Act.CREATE)
      entityActionPerformed([Ent.USER, user, Ent.CLASSROOM_OAUTH2_TXT_FILE, classroomOauth2File], i, count)
      Act.Set(action)
    except httplib2.CertificateValidationUnsupported:
      noPythonSSLExit()

# gam <UserTypeEntity> delete classroomoauth2
def deleteClassroomOauth2(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  httpObj = getHttpObj()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if user.find(u'@') == -1:
      userId = user
    else:
      userId = convertEmailAddressToUID(user, cd=cd)
    classroomOauth2File = getClassroomOauth2Filename(userId)
    if os.path.isfile(classroomOauth2File):
      credentials = getClassroomOauth2Credentials(classroomOauth2File)
      if credentials and not credentials.invalid:
        credentials.revoke_uri = oauth2client.GOOGLE_REVOKE_URI
        try:
          credentials.revoke(httpObj)
        except oauth2client.client.TokenRevokeError as e:
          printErrorMessage(INVALID_TOKEN_RC, str(e))
      deleteFile(classroomOauth2File, continueOnError=True)
      entityActionPerformed([Ent.USER, user, Ent.CLASSROOM_OAUTH2_TXT_FILE, classroomOauth2File], i, count)
    else:
      entityDoesNotHaveItemWarning([Ent.USER, user, Ent.CLASSROOM_OAUTH2_TXT_FILE, classroomOauth2File], i, count)

# gam <UserTypeEntity> info classroomoauth2
def infoClassroomOauth2(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if user.find(u'@') == -1:
      userId = user
    else:
      userId = convertEmailAddressToUID(user, cd=cd)
    classroomOauth2File = getClassroomOauth2Filename(userId)
    if os.path.isfile(classroomOauth2File):
      credentials = getClassroomOauth2Credentials(classroomOauth2File)
      if credentials and not credentials.invalid:
        printEntity([Ent.USER, user, Ent.CLASSROOM_OAUTH2_TXT_FILE, classroomOauth2File], i, count)
        Ind.Increment()
        printKeyValueList([u'Client ID', credentials.client_id])
        scopes = sorted(credentials.scopes)
        for scope in [API.EMAIL_SCOPE, API.PROFILE_SCOPE]:
          if scope in scopes:
            scopes.remove(scope)
        printKeyValueList([u'Scopes', len(scopes)])
        Ind.Increment()
        for scope in scopes:
          printKeyValueList([scope])
        Ind.Decrement()
        Ind.Decrement()
      else:
        entityActionFailedWarning([Ent.USER, user],
                                  Msg.HAS_INVALID_FORMAT.format(Ent.Singular(Ent.CLASSROOM_OAUTH2_TXT_FILE), classroomOauth2File), i, count)
    else:
      entityDoesNotHaveItemWarning([Ent.USER, user, Ent.CLASSROOM_OAUTH2_TXT_FILE, classroomOauth2File], i, count)

def buildClassroomGAPIObject(classroomOauth2File):
  api = API.CLASSROOM
  _, httpObj, service, _ = getAPIversionHttpService(api)
  credentials = getClassroomOauth2Credentials(classroomOauth2File)
  GM.Globals[GM.CURRENT_CLIENT_API] = api
  GM.Globals[GM.CURRENT_CLIENT_API_SCOPES] = credentials.scopes
  try:
    service._http = credentials.authorize(httpObj)
  except (httplib2.ServerNotFoundError, google.auth.exceptions.TransportError) as e:
    systemErrorExit(NETWORK_ERROR_RC, str(e))
  except oauth2client.client.AccessTokenRefreshError as e:
    handleOAuthTokenError(e, False)
  GM.Globals[GM.OAUTH2_CLIENT_ID] = credentials.client_id
  return service

COURSE_STATE_MAPS = {
  Cmd.OB_COURSE_STATE_LIST: {
    u'active': u'ACTIVE',
    u'archived': u'ARCHIVED',
    u'provisioned': u'PROVISIONED',
    u'declined': u'DECLINED',
    },
  Cmd.OB_COURSE_ANNOUNCEMENT_STATE_LIST: {
    u'draft': u'DRAFT',
    u'published': u'PUBLISHED',
    u'deleted': u'DELETED',
    },
  Cmd.OB_COURSE_WORK_STATE_LIST: {
    u'draft': u'DRAFT',
    u'published': u'PUBLISHED',
    u'deleted': u'DELETED',
    },
  Cmd.OB_COURSE_SUBMISSION_STATE_LIST: {
    u'new': u'NEW',
    u'created': u'CREATED',
    u'turnedin': u'TURNED_IN',
    u'returned': u'RETURNED',
    u'reclaimedbystudent': u'RECLAIMED_BY_STUDENT',
    },
  }

def _getCourseStates(item, states):
  stateMap = COURSE_STATE_MAPS[item]
  for state in getString(item).lower().replace(u',', u' ').split():
    if state == u'all':
      states.extend([stateMap[state] for state in stateMap])
    elif state in stateMap:
      states.append(stateMap[state])
    else:
      invalidChoiceExit(stateMap, True)

def _initCourseAttributesFrom():
  return {u'courseId': None, u'members': u'none', u'announcementStates': [], u'workStates': []}

def _getCourseAttribute(myarg, body, courseAttributesFrom):
  if myarg == u'name':
    body[u'name'] = getString(Cmd.OB_STRING)
  elif myarg == u'section':
    body[u'section'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg == u'heading':
    body[u'descriptionHeading'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg == u'description':
    body[u'description'] = getStringWithCRsNLs()
  elif myarg == u'room':
    body[u'room'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg in [u'owner', u'ownerid', u'teacher']:
    body[u'ownerId'] = getEmailAddress()
  elif myarg in [u'state', u'status']:
    body[u'courseState'] = getChoice(COURSE_STATE_MAPS[Cmd.OB_COURSE_STATE_LIST], mapChoice=True)
  elif myarg == u'copyfrom':
    courseAttributesFrom[u'courseId'] = getString(Cmd.OB_COURSE_ID)
  elif myarg in [u'announcementstate', u'announcementstates']:
    _getCourseStates(Cmd.OB_COURSE_ANNOUNCEMENT_STATE_LIST, courseAttributesFrom[u'announcementStates'])
  elif myarg in [u'workstate', u'workstates', u'courseworkstate', u'courseworkstates']:
    _getCourseStates(Cmd.OB_COURSE_WORK_STATE_LIST, courseAttributesFrom[u'workStates'])
  elif myarg == u'members':
    courseAttributesFrom[u'members'] = getChoice(COURSE_MEMBER_ARGUMENTS)
  else:
    unknownArgumentExit()

def _checkCourseAttributesFrom(croom, courseAttributesFrom):
  if courseAttributesFrom[u'courseId']:
    courseAttributesFrom[u'courseId'] = checkCourseExists(croom, courseAttributesFrom[u'courseId'])
    if courseAttributesFrom[u'courseId'] is None:
      return False
  elif courseAttributesFrom[u'members'] != u'none' or courseAttributesFrom[u'announcementStates'] or courseAttributesFrom[u'workStates']:
    missingArgumentExit(u'copyfrom <CourseId>)')
  return True

COURSE_ANNOUNCEMENT_REACDONLY_FIELDS = [
  u'alternateLink',
  u'courseId',
  u'creationTime',
  u'creatorUserId',
  u'id',
  u'updateTime',
  ]
COURSE_COURSEWORK_READONLY_FIELDS = [
  u'alternateLink',
  u'assignment',
  u'associatedWithDeveloper',
  u'courseId',
  u'creationTime',
  u'creatorUserId',
  u'id',
  u'updateTime',
  ]

def copyCourseAttributes(croom, newCourseId, ownerId, courseAttributesFrom, i, count):
  courseId = courseAttributesFrom[u'courseId']
  if courseAttributesFrom[u'announcementStates'] or courseAttributesFrom[u'workStates']:
    classroomOauth2File = getClassroomOauth2Filename(ownerId)
    if not os.path.isfile(classroomOauth2File):
      createClassroomOauth2([u'uid:{0}'.format(ownerId)], False)
  _, teachers, students = _getCourseAliasesMembers(croom, courseId, courseAttributesFrom,
                                                   u'nextPageToken,teachers(profile(emailAddress,id))',
                                                   u'nextPageToken,students(profile(emailAddress))')
  if courseAttributesFrom[u'announcementStates']:
    printGettingAllEntityItemsForWhom(Ent.COURSE_ANNOUNCEMENT_ID, Ent.TypeName(Ent.COURSE, courseId), i, count,
                                      _gettingCourseAnnouncementQuery(courseAttributesFrom[u'announcementStates']))
    try:
      courseAnnouncements = callGAPIpages(croom.courses().announcements(), u'list', u'announcements',
                                          page_message=getPageMessage(),
                                          throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                          courseId=courseId, announcementStates=courseAttributesFrom[u'announcementStates'],
                                          pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
    except GAPI.forbidden:
      APIAccessDeniedExit()
  else:
    courseAnnouncements = collections.deque()
  if courseAttributesFrom[u'workStates']:
    printGettingAllEntityItemsForWhom(Ent.COURSE_WORK_ID, Ent.TypeName(Ent.COURSE, courseId), i, count,
                                      _gettingCourseWorkQuery(courseAttributesFrom[u'workStates']))
    try:
      courseWorks = callGAPIpages(croom.courses().courseWork(), u'list', u'courseWork',
                                  page_message=getPageMessage(),
                                  throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                  courseId=courseId, courseWorkStates=courseAttributesFrom[u'workStates'],
                                  pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
    except GAPI.forbidden:
      APIAccessDeniedExit()
    else:
      courseWorks = collections.deque()
  if courseAttributesFrom[u'members'] in [u'all', u'students']:
    addParticipants = [student[u'profile'][u'emailAddress'] for student in students]
    _batchAddParticipantsToCourse(croom, newCourseId, i, count, addParticipants, Ent.STUDENT)
  if courseAttributesFrom[u'members'] in [u'all', u'teachers']:
    addParticipants = [teacher[u'profile'][u'emailAddress'] for teacher in teachers if teacher[u'profile'][u'id'] != ownerId]
    _batchAddParticipantsToCourse(croom, newCourseId, i, count, addParticipants, Ent.TEACHER)
  if courseAnnouncements or courseWorks:
    croom = buildClassroomGAPIObject(classroomOauth2File)
    if courseAnnouncements:
      jcount = len(courseAnnouncements)
      j = 0
      for body in courseAnnouncements:
        j += 1
        courseAnnouncementId = body[u'id']
        for field in COURSE_ANNOUNCEMENT_REACDONLY_FIELDS:
          body.pop(field, None)
        try:
          callGAPI(croom.courses().announcements(), u'create',
                   throw_reasons=[GAPI.FORBIDDEN],
                   courseId=newCourseId, body=body)
          entityActionPerformed([Ent.COURSE, newCourseId, Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], j, jcount)
        except GAPI.forbidden:
          APIAccessDeniedExit()
    if courseWorks:
      jcount = len(courseWorks)
      j = 0
      for body in courseWorks:
        j += 1
        courseWorkId = body[u'id']
        for field in COURSE_COURSEWORK_READONLY_FIELDS:
          body.pop(field, None)
        try:
          callGAPI(croom.courses().courseWork(), u'create',
                   throw_reasons=[GAPI.FORBIDDEN],
                   courseId=newCourseId, body=body)
          entityActionPerformed([Ent.COURSE, newCourseId, Ent.COURSE_WORK_ID, courseWorkId], j, jcount)
        except GAPI.forbidden:
          APIAccessDeniedExit()

# gam create course [id|alias <CourseAlias>] <CourseAttributes>*
#	 [copyfrom <CourseID> [announcementstates <CourseAnnouncementStateList>] [workstates <CourseWorkStateList>] [members none|all|students|teachers]]
def doCreateCourse():
  croom = buildGAPIObject(API.CLASSROOM)
  body = {}
  courseAttributesFrom = _initCourseAttributesFrom()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'alias', u'id']:
      body[u'id'] = getCourseAlias()
    else:
      _getCourseAttribute(myarg, body, courseAttributesFrom)
  if u'ownerId' not in body:
    missingArgumentExit(u'teacher <UserItem>)')
  if u'name' not in body:
    missingArgumentExit(u'name <String>)')
  if not _checkCourseAttributesFrom(croom, courseAttributesFrom):
    return
  try:
    result = callGAPI(croom.courses(), u'create',
                      throw_reasons=[GAPI.ALREADY_EXISTS, GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                      body=body, fields=u'id,name,ownerId')
    entityActionPerformed([Ent.COURSE_NAME, result[u'name'], Ent.COURSE, result[u'id']])
    if courseAttributesFrom[u'courseId']:
      copyCourseAttributes(croom, result[u'id'], result[u'ownerId'], courseAttributesFrom, 0, 0)
  except (GAPI.alreadyExists, GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition, GAPI.forbidden, GAPI.badRequest) as e:
    entityActionFailedWarning([Ent.COURSE_NAME, body[u'name'], Ent.TEACHER, body[u'ownerId']], str(e))

def _doUpdateCourses(entityList):
  croom = buildGAPIObject(API.CLASSROOM)
  body = {}
  courseAttributesFrom = _initCourseAttributesFrom()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    _getCourseAttribute(myarg, body, courseAttributesFrom)
  if not _checkCourseAttributesFrom(croom, courseAttributesFrom):
    return
  updateMask = u','.join(list(body))
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      if body:
        result = callGAPI(croom.courses(), u'patch',
                          throw_reasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                          id=courseId, body=body, updateMask=updateMask, fields=u'id,name,ownerId')
        entityActionPerformed([Ent.COURSE_NAME, result[u'name'], Ent.COURSE, result[u'id']], i, count)
      else:
        result = callGAPI(croom.courses(), u'get',
                          throw_reasons=[GAPI.NOT_FOUND],
                          id=courseId, fields=u'id,name,ownerId')
      if courseAttributesFrom[u'courseId']:
        copyCourseAttributes(croom, result[u'id'], result[u'ownerId'], courseAttributesFrom, i, count)
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition, GAPI.forbidden, GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)

# gam update courses <CourseEntity> <CourseAttributes>+
#	 [copyfrom <CourseID> [announcementstates <CourseAnnouncementStateList>] [workstates <CourseWorkStateList>] [members none|all|students|teachers]]
def doUpdateCourses():
  _doUpdateCourses(getEntityList(Cmd.OB_COURSE_ENTITY))

# gam update course <CourseID> <CourseAttributes>+
#	 [copyfrom <CourseID> [announcementstates <CourseAnnouncementStateList>] [workstates <CourseWorkStateList>] [members none|all|students|teachers]]
def doUpdateCourse():
  _doUpdateCourses(getStringReturnInList(Cmd.OB_COURSE_ID))

def _doDeleteCourses(entityList):
  croom = buildGAPIObject(API.CLASSROOM)
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'archive', u'archived']:
      body[u'courseState'] = u'ARCHIVED'
      updateMask = u'courseState'
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      if body:
        callGAPI(croom.courses(), u'patch',
                 throw_reasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                 id=courseId, body=body, updateMask=updateMask, fields=u'')
      callGAPI(croom.courses(), u'delete',
               throw_reasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION],
               id=courseId)
      entityActionPerformed([Ent.COURSE, removeCourseIdScope(courseId)], i, count)
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition, GAPI.forbidden, GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)

# gam delete courses <CourseEntity> [archive|archived]
def doDeleteCourses():
  _doDeleteCourses(getEntityList(Cmd.OB_COURSE_ENTITY))

# gam delete course <CourseID> [archive|archived]
def doDeleteCourse():
  _doDeleteCourses(getStringReturnInList(Cmd.OB_COURSE_ID))

COURSE_FIELDS_CHOICE_MAP = {
  u'alternatelink': u'alternateLink',
  u'calendarid': u'calendarId',
  u'coursegroupemail': u'courseGroupEmail',
  u'coursematerialsets': u'courseMaterialSets',
  u'coursestate': u'courseState',
  u'creationtime': u'creationTime',
  u'description': u'description',
  u'descriptionheading': u'descriptionHeading',
  u'enrollmentcode': u'enrollmentCode',
  u'guardiansenabled': u'guardiansEnabled',
  u'id': u'id',
  u'name': u'name',
  u'owneremail': u'ownerId',
  u'ownerid': u'ownerId',
  u'room': u'room',
  u'section': u'section',
  u'teacherfolder': u'teacherFolder',
  u'teachergroupemail': u'teacherGroupEmail',
  u'updatetime': u'updateTime',
  }
COURSE_MEMBER_ARGUMENTS = [u'none', u'all', u'students', u'teachers']
COURSE_TIME_OBJECTS = set([u'creationTime', u'updateTime'])
COURSE_NOLEN_OBJECTS = set([u'materials',])
COURSE_PROPERTY_PRINT_ORDER = [
  u'id',
  u'name',
  u'Aliases',
  u'courseState',
  u'descriptionHeading',
  u'description',
  u'section',
  u'room',
  u'enrollmentCode',
  u'guardiansEnabled',
  u'alternateLink',
  u'ownerEmail',
  u'ownerId',
  u'creationTime',
  u'updateTime',
  u'calendarId',
  u'courseGroupEmail',
  u'teacherGroupEmail',
  u'teacherFolder.id',
  u'teacherFolder.title',
  u'teacherFolder.alternateLink',
  ]

def _initCourseShowProperties(fields=None):
  return {u'aliases': False, u'ownerEmail': False, u'ownerEmailMatchPattern': None, u'members': u'none', u'countsOnly': False,
          u'fields': fields if fields is not None else [], u'skips': []}

def _getCourseShowProperties(myarg, courseShowProperties):
  if myarg in [u'alias', u'aliases']:
    courseShowProperties[u'aliases'] = True
  elif myarg == u'owneremail':
    courseShowProperties[u'ownerEmail'] = True
  elif myarg == u'owneremailmatchpattern':
    courseShowProperties[u'ownerEmail'] = True
    courseShowProperties[u'ownerEmailMatchPattern'] = getREPattern(re.IGNORECASE)
  elif myarg == u'show':
    courseShowProperties[u'members'] = getChoice(COURSE_MEMBER_ARGUMENTS)
  elif myarg == u'countsonly':
    courseShowProperties[u'countsOnly'] = True
  elif myarg == u'fields':
    for field in _getFieldsList():
      if field in [u'alias', u'aliases']:
        courseShowProperties[u'aliases'] = True
      elif field == u'owneremail':
        courseShowProperties[u'ownerEmail'] = True
        courseShowProperties[u'fields'].append(COURSE_FIELDS_CHOICE_MAP[field])
      elif field == u'teachers':
        if courseShowProperties[u'members'] == u'none':
          courseShowProperties[u'members'] = field
        elif courseShowProperties[u'members'] == u'students':
          courseShowProperties[u'members'] = u'all'
      elif field == u'students':
        if courseShowProperties[u'members'] == u'none':
          courseShowProperties[u'members'] = field
        elif courseShowProperties[u'members'] == u'teachers':
          courseShowProperties[u'members'] = u'all'
      elif field in COURSE_FIELDS_CHOICE_MAP:
        courseShowProperties[u'fields'].append(COURSE_FIELDS_CHOICE_MAP[field])
      else:
        invalidChoiceExit(COURSE_FIELDS_CHOICE_MAP, True)
  elif myarg == u'skipfields':
    for field in _getFieldsList():
      if field in [u'alias', u'aliases']:
        courseShowProperties[u'aliases'] = False
      elif field == u'teachers':
        if courseShowProperties[u'members'] == u'all':
          courseShowProperties[u'members'] = u'students'
        elif courseShowProperties[u'members'] == field:
          courseShowProperties[u'members'] = u'none'
      elif field == u'students':
        if courseShowProperties[u'members'] == u'all':
          courseShowProperties[u'members'] = u'teachers'
        elif courseShowProperties[u'members'] == field:
          courseShowProperties[u'members'] = u'none'
      elif field in COURSE_FIELDS_CHOICE_MAP:
        if field != u'id':
          courseShowProperties[u'skips'].append(COURSE_FIELDS_CHOICE_MAP[field])
      else:
        invalidChoiceExit(COURSE_FIELDS_CHOICE_MAP, True)
  else:
    unknownArgumentExit()

def _setCourseFields(courseShowProperties, pagesMode):
  if not courseShowProperties[u'fields']:
    return None
  courseShowProperties[u'fields'].append(u'id')
  if courseShowProperties[u'ownerEmail']:
    courseShowProperties[u'fields'].append(u'ownerId')
  if not pagesMode:
    return u','.join(set(courseShowProperties[u'fields']))
  return u'nextPageToken,courses({0})'.format(u','.join(set(courseShowProperties[u'fields'])))

def _convertCourseUserIdToEmail(croom, userId, emails, entityValueList, i, count):
  if userId not in emails:
    try:
      emails[userId] = callGAPI(croom.userProfiles(), u'get',
                                throw_reasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                userId=userId, fields=u'emailAddress')[u'emailAddress']
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.badRequest, GAPI.forbidden):
      entityDoesNotHaveItemWarning(entityValueList, i, count)
      emails[userId] = u'Unknown user'
  return emails[userId]

def _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields, showGettings=False, i=0, count=0):
  aliases = collections.deque()
  teachers = collections.deque()
  students = collections.deque()
  if showGettings:
    page_message = getPageMessageForWhom(forWhom=formatKeyValueList(u'',
                                                                    [Ent.Singular(Ent.COURSE), courseId],
                                                                    currentCount(i, count)))
  else:
    page_message = None
  try:
    if courseShowProperties.get(u'aliases'):
      if showGettings:
        Ent.SetGetting(Ent.ALIAS)
      try:
        aliases = callGAPIpages(croom.courses().aliases(), u'list', u'aliases',
                                page_message=page_message,
                                throw_reasons=[GAPI.NOT_IMPLEMENTED],
                                courseId=courseId, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
      except GAPI.notImplemented:
        pass
    if courseShowProperties[u'members'] != u'none':
      if courseShowProperties[u'members'] != u'students':
        if showGettings:
          Ent.SetGetting(Ent.TEACHER)
        try:
          teachers = callGAPIpages(croom.courses().teachers(), u'list', u'teachers',
                                   page_message=page_message,
                                   throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                   courseId=courseId, fields=teachersFields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        except GAPI.notFound:
          pass
      if courseShowProperties[u'members'] != u'teachers':
        if showGettings:
          Ent.SetGetting(Ent.STUDENT)
        try:
          students = callGAPIpages(croom.courses().students(), u'list', u'students',
                                   page_message=page_message,
                                   throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                   courseId=courseId, fields=studentsFields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        except GAPI.notFound:
          pass
  except GAPI.forbidden:
    APIAccessDeniedExit()
  return (aliases, teachers, students)

def _doInfoCourses(entityList):
  croom = buildGAPIObject(API.CLASSROOM)
  courseShowProperties = _initCourseShowProperties()
  courseShowProperties[u'ownerEmail'] = True
  ownerEmails = {}
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'formatjson':
      formatJSON = True
    else:
      _getCourseShowProperties(myarg, courseShowProperties)
  fields = _setCourseFields(courseShowProperties, False)
  if courseShowProperties[u'members'] != u'none':
    if courseShowProperties[u'countsOnly']:
      teachersFields = u'nextPageToken,teachers(profile(id))'
      studentsFields = u'nextPageToken,students(profile(id))'
    else:
      teachersFields = u'nextPageToken,teachers(profile)'
      studentsFields = u'nextPageToken,students(profile)'
  else:
    teachersFields = studentsFields = None
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      course = callGAPI(croom.courses(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND],
                        id=courseId, fields=fields)
      if courseShowProperties[u'ownerEmail']:
        course['ownerEmail'] = _convertCourseUserIdToEmail(croom, course['ownerId'], ownerEmails,
                                                           [Ent.COURSE, course[u'id'], Ent.OWNER_ID, course['ownerId']], i, count)
      aliases, teachers, students = _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields)
      if formatJSON:
        if courseShowProperties[u'aliases']:
          course.update({u'aliases': list(aliases)})
        if courseShowProperties[u'members'] != u'none':
          if courseShowProperties[u'members'] != u'students':
            if not courseShowProperties[u'countsOnly']:
              course.update({u'teachers': list(teachers)})
            else:
              course.update({u'teachers': len(teachers)})
          if courseShowProperties[u'members'] != u'teachers':
            if not courseShowProperties[u'countsOnly']:
              course.update({u'students': list(students)})
            else:
              course.update({u'students': len(students)})
        printLine(json.dumps(cleanJSON(course, u'', skipObjects=courseShowProperties[u'skips'], timeObjects=COURSE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.COURSE, course[u'id']], i, count)
      Ind.Increment()
      showJSON(None, course, courseShowProperties[u'skips'], COURSE_TIME_OBJECTS)
      if courseShowProperties[u'aliases']:
        printKeyValueList([u'Aliases', len(aliases)])
        Ind.Increment()
        for alias in aliases:
          printKeyValueList([removeCourseIdScope(alias[u'alias'])])
        Ind.Decrement()
      if courseShowProperties[u'members'] != u'none':
        printKeyValueList([u'Participants', None])
        Ind.Increment()
        if courseShowProperties[u'members'] != u'students':
          if teachers:
            printKeyValueList([u'Teachers', len(teachers)])
            if not courseShowProperties[u'countsOnly']:
              Ind.Increment()
              for teacher in teachers:
                if u'emailAddress' in teacher[u'profile']:
                  printKeyValueList([u'{0} - {1}'.format(teacher[u'profile'][u'name'][u'fullName'], teacher[u'profile'][u'emailAddress'])])
                else:
                  printKeyValueList([teacher[u'profile'][u'name'][u'fullName']])
              Ind.Decrement()
        if courseShowProperties[u'members'] != u'teachers':
          if students:
            printKeyValueList([u'Students', len(students)])
            if not courseShowProperties[u'countsOnly']:
              Ind.Increment()
              for student in students:
                if u'emailAddress' in student[u'profile']:
                  printKeyValueList([u'{0} - {1}'.format(student[u'profile'][u'name'][u'fullName'], student[u'profile'][u'emailAddress'])])
                else:
                  printKeyValueList([student[u'profile'][u'name'][u'fullName']])
              Ind.Decrement()
          Ind.Decrement()
        Ind.Decrement()
    except GAPI.notFound:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], Msg.DOES_NOT_EXIST, i, count)
    except GAPI.forbidden:
      APIAccessDeniedExit()

# gam info courses <CourseEntity> [owneremail] [alias|aliases] [show none|all|students|teachers] [countsonly]
#	[fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>] [formatjson]
def doInfoCourses():
  _doInfoCourses(getEntityList(Cmd.OB_COURSE_ENTITY))

# gam info course <CourseID> [owneremail] [alias|aliases] [show none|all|students|teachers] [countsonly]
#	[fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>] [formatjson]
def doInfoCourse():
  _doInfoCourses(getStringReturnInList(Cmd.OB_COURSE_ID))

def _initCourseSelectionParameters():
  return {u'courseIds': [], u'teacherId': None, u'studentId': None, u'courseStates': []}

def _getCourseSelectionParameters(myarg, courseSelectionParameters):
  if myarg in [u'course', u'courses', u'class', u'classes']:
    courseSelectionParameters[u'courseIds'].extend(getEntityList(Cmd.OB_COURSE_ENTITY))
  elif myarg == u'teacher':
    courseSelectionParameters[u'teacherId'] = getEmailAddress()
  elif myarg == u'student':
    courseSelectionParameters[u'studentId'] = getEmailAddress()
  elif myarg in [u'state', u'states', u'status']:
    _getCourseStates(Cmd.OB_COURSE_STATE_LIST, courseSelectionParameters[u'courseStates'])
  else:
    return False
  return True

def _gettingCoursesQuery(courseSelectionParameters):
  query = u''
  if courseSelectionParameters[u'teacherId']:
    query += u'{0}: {1}, '.format(Ent.Singular(Ent.TEACHER), courseSelectionParameters[u'teacherId'])
  if courseSelectionParameters[u'studentId']:
    query += u'{0}: {1}, '.format(Ent.Singular(Ent.STUDENT), courseSelectionParameters[u'studentId'])
  if courseSelectionParameters[u'courseStates']:
    query += u'{0}: {1}, '.format(Ent.Choose(Ent.COURSE_STATE, len(courseSelectionParameters[u'courseStates'])), u','.join(courseSelectionParameters[u'courseStates']))
  if query:
    query = query[:-2]
  return query

def _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties):
  if not courseSelectionParameters[u'courseIds']:
    fields = _setCourseFields(courseShowProperties, True)
    printGettingAllAccountEntities(Ent.COURSE, _gettingCoursesQuery(courseSelectionParameters))
    try:
      return callGAPIpages(croom.courses(), u'list', u'courses',
                           page_message=getPageMessage(),
                           throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                           teacherId=courseSelectionParameters[u'teacherId'],
                           studentId=courseSelectionParameters[u'studentId'],
                           courseStates=courseSelectionParameters[u'courseStates'],
                           fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
    except GAPI.notFound:
      if (not courseSelectionParameters[u'studentId']) and courseSelectionParameters[u'teacherId']:
        entityUnknownWarning(Ent.TEACHER, courseSelectionParameters[u'teacherId'])
      elif (not courseSelectionParameters[u'teacherId']) and courseSelectionParameters[u'studentId']:
        entityUnknownWarning(Ent.STUDENT, courseSelectionParameters[u'studentId'])
      elif courseSelectionParameters[u'studentId'] and courseSelectionParameters[u'teacherId']:
        entityOrEntityUnknownWarning(Ent.TEACHER, courseSelectionParameters[u'teacherId'], Ent.STUDENT, courseSelectionParameters[u'studentId'])
    except GAPI.badRequest as e:
      entityActionFailedWarning([Ent.COURSE, None], str(e))
    except GAPI.forbidden:
      APIAccessDeniedExit()
    return None
  else:
    fields = _setCourseFields(courseShowProperties, False)
    coursesInfo = collections.deque()
    for courseId in courseSelectionParameters[u'courseIds']:
      courseId = addCourseIdScope(courseId)
      try:
        info = callGAPI(croom.courses(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                        id=courseId, fields=fields)
        coursesInfo.append(info)
      except GAPI.notFound:
        entityDoesNotExistWarning(Ent.COURSE, courseId)
      except GAPI.forbidden:
        APIAccessDeniedExit()
  return coursesInfo

# gam print courses [todrive [<ToDriveAttributes>]] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] [states <CourseStateList>])
#	[owneremail] [owneremailmatchpattern <RegularExpression>] [alias|aliases] [delimiter <Character>] [show none|all|students|teachers] [countsonly]
#	[fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>] [formatjson] [quotechar <Character>]
def doPrintCourses():
  def _saveParticipants(course, participants, role, rtitles):
    jcount = len(participants)
    course[role] = jcount
    if courseShowProperties[u'countsOnly']:
      return
    j = 0
    for member in participants:
      memberTitles = []
      prefix = u'{0}.{1}.'.format(role, j)
      profile = member[u'profile']
      emailAddress = profile.get(u'emailAddress')
      if emailAddress:
        memberTitle = prefix+u'emailAddress'
        course[memberTitle] = emailAddress
        memberTitles.append(memberTitle)
      memberId = profile.get(u'id')
      if memberId:
        memberTitle = prefix+u'id'
        course[memberTitle] = memberId
        memberTitles.append(memberTitle)
      fullName = profile.get(u'name', {}).get(u'fullName')
      if fullName:
        memberTitle = prefix+u'name.fullName'
        course[memberTitle] = fullName
        memberTitles.append(memberTitle)
      addTitlesToCSVfile(memberTitles, rtitles)
      j += 1

  croom = buildGAPIObject(API.CLASSROOM)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'id',])
  courseSelectionParameters = _initCourseSelectionParameters()
  courseShowProperties = _initCourseShowProperties()
  ownerEmails = {}
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'formatjson':
      formatJSON = True
      addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      _getCourseShowProperties(myarg, courseShowProperties)
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  if courseShowProperties[u'aliases']:
    if formatJSON:
      addTitlesToCSVfile(u'JSON-aliases', titles)
  if courseShowProperties[u'members'] != u'none':
    ttitles = {u'set': set(), u'list': []}
    stitles = {u'set': set(), u'list': []}
    if courseShowProperties[u'members'] != u'students':
      addTitlesToCSVfile(u'teachers', ttitles)
      if formatJSON:
        addTitlesToCSVfile(u'JSON-teachers', titles)
    if courseShowProperties[u'members'] != u'teachers':
      addTitlesToCSVfile(u'students', stitles)
      if formatJSON:
        addTitlesToCSVfile(u'JSON-students', titles)
    if courseShowProperties[u'countsOnly']:
      teachersFields = u'nextPageToken,teachers(profile(id))'
      studentsFields = u'nextPageToken,students(profile(id))'
    else:
      teachersFields = u'nextPageToken,teachers(profile)'
      studentsFields = u'nextPageToken,students(profile)'
  else:
    teachersFields = studentsFields = None
  count = len(coursesInfo)
  i = 0
  for course in coursesInfo:
    i += 1
    for field in courseShowProperties[u'skips']:
      course.pop(field, None)
    courseId = course[u'id']
    if courseShowProperties[u'ownerEmail']:
      course['ownerEmail'] = _convertCourseUserIdToEmail(croom, course['ownerId'], ownerEmails,
                                                         [Ent.COURSE, courseId, Ent.OWNER_ID, course['ownerId']], i, count)
      if courseShowProperties[u'ownerEmailMatchPattern'] and not courseShowProperties[u'ownerEmailMatchPattern'].match(course['ownerEmail']):
        continue
    aliases, teachers, students = _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields, True, i, count)
    if formatJSON:
      row = {u'id': courseId, u'JSON': json.dumps(cleanJSON(course, u'', timeObjects=COURSE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)}
      if courseShowProperties[u'aliases']:
        row[u'JSON-aliases'] = json.dumps(list(aliases))
      if courseShowProperties[u'members'] != u'none':
        if courseShowProperties[u'members'] != u'students':
          if not courseShowProperties[u'countsOnly']:
            row[u'JSON-teachers'] = json.dumps(list(teachers))
          else:
            row[u'JSON-teachers'] = json.dumps(len(teachers))
        if courseShowProperties[u'members'] != u'teachers':
          if not courseShowProperties[u'countsOnly']:
            row[u'JSON-students'] = json.dumps(list(students))
          else:
            row[u'JSON-students'] = json.dumps(len(students))
      csvRows.append(row)
    else:
      if courseShowProperties[u'aliases']:
        course[u'Aliases'] = delimiter.join([removeCourseIdScope(alias[u'alias']) for alias in aliases])
      if courseShowProperties[u'members'] != u'none':
        if courseShowProperties[u'members'] != u'students':
          _saveParticipants(course, teachers, u'teachers', ttitles)
        if courseShowProperties[u'members'] != u'teachers':
          _saveParticipants(course, students, u'students', stitles)
      addRowTitlesToCSVfile(flattenJSON(course, timeObjects=COURSE_TIME_OBJECTS, noLenObjects=COURSE_NOLEN_OBJECTS), csvRows, titles)
  if not formatJSON:
    if courseShowProperties[u'aliases']:
      addTitleToCSVfile(u'Aliases', titles)
    sortCSVTitles(COURSE_PROPERTY_PRINT_ORDER, titles)
    if courseShowProperties[u'members'] != u'none':
      ttitles[u'list'].sort()
      stitles[u'list'].sort()
      try:
        cmsIndex = titles[u'list'].index(u'courseMaterialSets')
        titles[u'list'] = titles[u'list'][:cmsIndex]+ttitles[u'list']+stitles[u'list']+titles[u'list'][cmsIndex:]
      except ValueError:
        titles[u'list'].extend(ttitles[u'list'])
        titles[u'list'].extend(stitles[u'list'])
  writeCSVfile(csvRows, titles, u'Courses', todrive, quotechar=quotechar)

COURSE_ANNOUNCEMENTS_FIELDS_CHOICE_MAP = {
  u'alternatelink': u'alternateLink',
  u'announcementid': u'id',
  u'assigneemode': u'assigneeMode',
  u'courseid': u'courseId',
  u'courseannouncementid': u'id',
  u'creationtime': u'creationTime',
  u'creator': u'creatorUserId',
  u'creatoruserid': u'creatorUserId',
  u'id': u'id',
  u'materials': u'materials',
  u'scheduledtime': u'scheduledTime',
  u'state': u'state',
  u'text': u'text',
  u'updatetime': u'updateTime',
  }

COURSE_ANNOUNCEMENTS_ORDERBY_CHOICE_MAP = {
  u'updatetime': u'updateTime',
  u'updatedate': u'updateTime',
  }


COURSE_ANNOUNCEMENTS_TIME_OBJECTS = set([u'creationTime', u'scheduledTime', u'updateTime'])

def _gettingCourseAnnouncementQuery(courseAnnouncementStates):
  query = u''
  if courseAnnouncementStates:
    query += u'{0}: {1}, '.format(Ent.Choose(Ent.COURSE_ANNOUNCEMENT_STATE, len(courseAnnouncementStates)), u','.join(courseAnnouncementStates))
  if query:
    query = query[:-2]
  return query

# gam print course-announcements [todrive [<ToDriveAttributes>]] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	(announcementids <CourseAnnouncementIDEntity>)|((announcementstates <CourseAnnouncementStateList>)* (orderby <CourseAnnouncementOrderByFieldName> [ascending|descending])*)
#	[creatoremail] [fields <CourseAnnouncementFieldNameList>] [formatjson] [quotechar <Character>]
def doPrintCourseAnnouncements():
  def _printCourseAnnouncement(course, courseAnnouncement, i, count):
    if showCreatorEmail:
      courseAnnouncement[u'creatorUserEmail'] = _convertCourseUserIdToEmail(croom, courseAnnouncement[u'creatorUserId'], creatorEmails,
                                                                            [Ent.COURSE, course[u'id'], Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncement[u'id'],
                                                                             Ent.CREATOR_ID, courseAnnouncement[u'creatorUserId']], i, count)
    if formatJSON:
      csvRows.append({u'courseId': course[u'id'], u'courseName': course[u'name'],
                      u'JSON': json.dumps(cleanJSON(courseAnnouncement, u'', timeObjects=COURSE_ANNOUNCEMENTS_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
    else:
      addRowTitlesToCSVfile(flattenJSON(courseAnnouncement, flattened={u'courseId': course[u'id'], u'courseName': course[u'name']}, timeObjects=COURSE_ANNOUNCEMENTS_TIME_OBJECTS),
                            csvRows, titles)

  croom = buildGAPIObject(API.CLASSROOM)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'courseId', u'courseName'])
  fieldsList = []
  courseSelectionParameters = _initCourseSelectionParameters()
  courseShowProperties = _initCourseShowProperties([u'name',])
  courseAnnouncementIds = []
  courseAnnouncementStates = []
  orderByList = []
  creatorEmails = {}
  formatJSON = showCreatorEmail = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif myarg in [u'announcementid', u'announcementids']:
      courseAnnouncementIds = getEntityList(Cmd.OB_COURSE_ANNOUNCEMENT_ID_ENTITY)
    elif myarg in [u'announcementstate', u'announcementstates']:
      _getCourseStates(Cmd.OB_COURSE_ANNOUNCEMENT_STATE_LIST, courseAnnouncementStates)
    elif myarg == u'orderby':
      fieldName = getChoice(COURSE_ANNOUNCEMENTS_ORDERBY_CHOICE_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICE_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg == u'creatoremail':
      showCreatorEmail = True
    elif myarg == u'formatjson':
      formatJSON = True
      addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif getFieldsList(myarg, COURSE_ANNOUNCEMENTS_FIELDS_CHOICE_MAP, fieldsList, u'id'):
      pass
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  if showCreatorEmail and fieldsList:
    fieldsList.append(u'creatorUserId')
  courseAnnouncementIdsLists = courseAnnouncementIds if isinstance(courseAnnouncementIds, dict) else None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course[u'id']
    if courseAnnouncementIdsLists:
      courseAnnouncementIds = courseAnnouncementIdsLists[courseId]
    if not courseAnnouncementIds:
      fields = u'nextPageToken,announcements({0})'.format(u','.join(set(fieldsList))) if fieldsList else None
      printGettingAllEntityItemsForWhom(Ent.COURSE_ANNOUNCEMENT_ID, Ent.TypeName(Ent.COURSE, courseId), i, count, _gettingCourseAnnouncementQuery(courseAnnouncementStates))
      try:
        results = callGAPIpages(croom.courses().announcements(), u'list', u'announcements',
                                page_message=getPageMessage(),
                                throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                courseId=courseId, announcementStates=courseAnnouncementStates, orderBy=orderBy,
                                fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseAnnouncement in results:
          _printCourseAnnouncement(course, courseAnnouncement, i, count)
      except GAPI.forbidden:
        APIAccessDeniedExit()
    else:
      jcount = len(courseAnnouncementIds)
      if jcount == 0:
        continue
      fields = u'{0}'.format(u','.join(set(fieldsList))) if fieldsList else None
      j = 0
      for courseAnnouncementId in courseAnnouncementIds:
        j += 1
        try:
          courseAnnouncement = callGAPI(croom.courses().announcements(), u'get',
                                        throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                        courseId=courseId, id=courseAnnouncementId, fields=fields)
          _printCourseAnnouncement(course, courseAnnouncement, i, count)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course[u'name'], Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], j, jcount)
        except GAPI.forbidden:
          APIAccessDeniedExit()
  writeCSVfile(csvRows, titles, u'Course Announcements', todrive, [u'courseId', u'courseName', u'id', u'text', u'state'], quotechar)

COURSE_WORK_FIELDS_CHOICE_MAP = {
  u'alternatelink': u'alternateLink',
  u'assigneemode': u'assigneeMode',
  u'courseid': u'courseId',
  u'courseworkid': u'id',
  u'courseworktype': u'workType',
  u'creationtime': u'creationTime',
  u'creator': u'creatorUserId',
  u'creatoruserid': u'creatorUserId',
  u'description': u'description',
  u'duedate': u'dueDate',
  u'id': u'id',
  u'materials': u'materials',
  u'maxpoints': u'maxPoints',
  u'scheduledtime': u'scheduledTime',
  u'state': u'state',
  u'submissionmodificationmode': u'submissionModificationMode',
  u'title': u'title',
  u'updatetime': u'updateTime',
  u'workid': u'id',
  u'worktype': u'workType',
  }

COURSE_WORK_ORDERBY_CHOICE_MAP = {
  u'duedate': u'dueDate',
  u'updatetime': u'updateTime',
  u'updatedate': u'updateTime',
  }

COURSE_WORK_TIME_OBJECTS = set([u'creationTime', u'scheduledTime', u'updateTime'])

def _initCourseWorkSelectionParameters():
  return {u'courseWorkIds': [], u'courseWorkStates': []}

def _getCourseWorkSelectionParameters(myarg, courseWorkSelectionParameters):
  if myarg in [u'workid', u'workids', u'courseworkid', u'courseworkids']:
    courseWorkSelectionParameters[u'courseWorkIds'] = getEntityList(Cmd.OB_COURSE_WORK_ID_ENTITY)
  elif myarg in [u'workstate', u'workstates', u'courseworkstate', u'courseworkstates']:
    _getCourseStates(Cmd.OB_COURSE_WORK_STATE_LIST, courseWorkSelectionParameters[u'courseWorkStates'])
  else:
    return False
  return True

def _gettingCourseWorkQuery(courseWorkStates):
  query = u''
  if courseWorkStates:
    query += u'{0}: {1}, '.format(Ent.Choose(Ent.COURSE_WORK_STATE, len(courseWorkStates)), u','.join(courseWorkStates))
  if query:
    query = query[:-2]
  return query

# gam print course-work [todrive [<ToDriveAttributes>]] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	(workids <CourseWorkIDEntity>)|((workstates <CourseWorkStateList>)*  (orderby <CourseWorkOrderByFieldName> [ascending|descending])*)
#	[creatoremail] [fields <CourseWorkFieldNameList>] [formatjson] [quotechar <Character>]
def doPrintCourseWork():
  def _printCourseWork(course, courseWork, i, count):
    if showCreatorEmail:
      courseWork[u'creatorUserEmail'] = _convertCourseUserIdToEmail(croom, courseWork[u'creatorUserId'], creatorEmails,
                                                                    [Ent.COURSE, course[u'id'], Ent.COURSE_WORK_ID, courseWork[u'id'],
                                                                     Ent.CREATOR_ID, courseWork[u'creatorUserId']], i, count)
    if formatJSON:
      csvRows.append({u'courseId': course[u'id'], u'courseName': course[u'name'],
                      u'JSON': json.dumps(cleanJSON(courseWork, u'', timeObjects=COURSE_WORK_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
    else:
      addRowTitlesToCSVfile(flattenJSON(courseWork, flattened={u'courseId': course[u'id'], u'courseName': course[u'name']}, timeObjects=COURSE_WORK_TIME_OBJECTS),
                            csvRows, titles)

  croom = buildGAPIObject(API.CLASSROOM)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'courseId', u'courseName'])
  fieldsList = []
  courseSelectionParameters = _initCourseSelectionParameters()
  courseWorkSelectionParameters = _initCourseWorkSelectionParameters()
  courseShowProperties = _initCourseShowProperties([u'name',])
  orderByList = []
  creatorEmails = {}
  formatJSON = showCreatorEmail = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseWorkSelectionParameters(myarg, courseWorkSelectionParameters):
      pass
    elif myarg == u'orderby':
      fieldName = getChoice(COURSE_WORK_ORDERBY_CHOICE_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICE_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg == u'creatoremail':
      showCreatorEmail = True
    elif myarg == u'formatjson':
      formatJSON = True
      addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif getFieldsList(myarg, COURSE_WORK_FIELDS_CHOICE_MAP, fieldsList, u'id'):
      pass
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  if showCreatorEmail and fieldsList:
    fieldsList.append(u'creatorUserId')
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  courseWorkIds = courseWorkSelectionParameters[u'courseWorkIds']
  courseWorkIdsLists = courseWorkIds if isinstance(courseWorkIds, dict) else None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course[u'id']
    if courseWorkIdsLists:
      courseWorkIds = courseWorkIdsLists[courseId]
    if not courseWorkIds:
      fields = u'nextPageToken,courseWork({0})'.format(u','.join(set(fieldsList))) if fieldsList else None
      printGettingAllEntityItemsForWhom(Ent.COURSE_WORK_ID, Ent.TypeName(Ent.COURSE, courseId), i, count, _gettingCourseWorkQuery(courseWorkSelectionParameters[u'courseWorkStates']))
      try:
        results = callGAPIpages(croom.courses().courseWork(), u'list', u'courseWork',
                                page_message=getPageMessage(),
                                throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                courseId=courseId, courseWorkStates=courseWorkSelectionParameters[u'courseWorkStates'], orderBy=orderBy,
                                fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseWork in results:
          _printCourseWork(course, courseWork, i, count)
      except GAPI.forbidden:
        APIAccessDeniedExit()
    else:
      jcount = len(courseWorkIds)
      if jcount == 0:
        continue
      fields = u'{0}'.format(u','.join(set(fieldsList))) if fieldsList else None
      j = 0
      for courseWorkId in courseWorkIds:
        j += 1
        try:
          courseWork = callGAPI(croom.courses().courseWork(), u'get',
                                throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                courseId=courseId, id=courseWorkId, fields=fields)
          _printCourseWork(course, courseWork, i, count)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course[u'name'], Ent.COURSE_WORK_ID, courseWorkId], j, jcount)
        except GAPI.forbidden:
          APIAccessDeniedExit()
  writeCSVfile(csvRows, titles, u'Course Work', todrive, [u'courseId', u'courseName', u'id', u'title', u'description', u'state'], quotechar)

COURSE_SUBMISSION_FIELDS_CHOICE_MAP = {
  u'alternatelink': u'alternateLink',
  u'assignedgrade': u'assignedGrade',
  u'courseid': u'courseId',
  u'coursesubmissionid': u'id',
  u'courseworkid': u'courseWorkId',
  u'courseworktype': u'courseWorkType',
  u'creationtime': u'creationTime',
  u'draftgrade': u'draftGrade',
  u'id': u'id',
  u'late': u'late',
  u'state': u'state',
  u'submissionhistory': u'submissionHistory',
  u'submissionid': u'id',
  u'updatetime': u'updateTime',
  u'userid': u'userId',
  u'workid': u'courseWorkId',
  u'worktype': u'courseWorkType',
  }

COURSE_SUBMISSION_TIME_OBJECTS = set([u'creationTime', u'updateTime', u'gradeTimestamp', u'stateTimestamp'])

def _gettingCourseSubmissionQuery(courseSubmissionStates, late, userId):
  query = u''
  if courseSubmissionStates:
    query += u'{0}: {1}, '.format(Ent.Choose(Ent.COURSE_SUBMISSION_STATE, len(courseSubmissionStates)), u','.join(courseSubmissionStates))
  if late:
    query += u'{0}, '.format(late)
  if userId:
    query += u'{0}: {1}, '.format(Ent.Singular(Ent.USER), userId)
  if query:
    query = query[:-2]
  return query

# gam print course-submissions [todrive [<ToDriveAttributes>]] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	(workids <CourseWorkIDEntity>)|((workstates <CourseWorkStateList>)*  (orderby <CourseWorkOrderByFieldName> [ascending|descending])*)
#	(submissionids <CourseSubmissionIDEntity>)|((submissionstates <CourseSubmissionStateList>)*) [late|notlate]
#	[fields <CourseSubmissionFieldNameList>] [formatjson] [quotechar <Character>] [showuserprofile]
def doPrintCourseSubmissions():
  def _printCourseSubmission(course, courseSubmission):
    if showUserProfile:
      userId = courseSubmission.get(u'userId')
      if userId:
        if userId not in userProfiles:
          try:
            userProfile = callGAPI(croom.userProfiles(), u'get',
                                   throw_reasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                                   userId=userId, fields=u'emailAddress,name')
            userProfiles[userId] = {u'profile': {u'emailAddress': userProfile[u'emailAddress'], u'name': userProfile[u'name']}}
          except (GAPI.notFound, GAPI.permissionDenied):
            userProfiles[userId] = {u'profile': {u'emailAddress', u'', u'name', {u'givenName': u'', u'familyName': u'', u'fullName': u''}}}
        courseSubmission.update(userProfiles[userId])
    if formatJSON:
      csvRows.append({u'courseId': course[u'id'], u'courseName': course[u'name'],
                      u'JSON': json.dumps(cleanJSON(courseSubmission, u'', timeObjects=COURSE_SUBMISSION_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
    else:
      addRowTitlesToCSVfile(flattenJSON(courseSubmission, flattened={u'courseId': course[u'id'], u'courseName': course[u'name']}, timeObjects=COURSE_SUBMISSION_TIME_OBJECTS),
                            csvRows, titles)

  croom = buildGAPIObject(API.CLASSROOM)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'courseId', u'courseName'])
  fieldsList = []
  courseSelectionParameters = _initCourseSelectionParameters()
  courseWorkSelectionParameters = _initCourseWorkSelectionParameters()
  courseShowProperties = _initCourseShowProperties([u'name',])
  courseSubmissionStates = []
  courseSubmissionIds = []
  orderByList = []
  late = None
  userProfiles = {}
  formatJSON = showUserProfile = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseWorkSelectionParameters(myarg, courseWorkSelectionParameters):
      pass
    elif myarg == u'orderby':
      fieldName = getChoice(COURSE_WORK_ORDERBY_CHOICE_MAP, mapChoice=True)
      if getChoice(SORTORDER_CHOICE_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
        orderByList.append(fieldName)
      else:
        orderByList.append(u'{0} desc'.format(fieldName))
    elif myarg in [u'submissionid', u'submissionids', u'coursesubmissionid', u'coursesubmissionids']:
      courseSubmissionIds = getEntityList(Cmd.OB_COURSE_SUBMISSION_ID_ENTITY)
    elif myarg in [u'submissionstate', u'submissionstates', u'coursesubmissionstate', u'coursesubmissionstates']:
      _getCourseStates(Cmd.OB_COURSE_SUBMISSION_STATE_LIST, courseSubmissionStates)
    elif myarg == u'late':
      late = u'LATE_ONLY'
    elif myarg == u'notlate':
      late = u'NOT_LATE_ONLY'
    elif myarg == u'formatjson':
      formatJSON = True
      addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif myarg == u'showuserprofile':
      showUserProfile = True
    elif getFieldsList(myarg, COURSE_SUBMISSION_FIELDS_CHOICE_MAP, fieldsList, u'id'):
      pass
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  courseWorkIds = courseWorkSelectionParameters[u'courseWorkIds']
  courseWorkIdsLists = courseWorkIds if isinstance(courseWorkIds, dict) else None
  courseSubmissionIdsLists = courseSubmissionIds if isinstance(courseSubmissionIds, dict) else None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course[u'id']
    if courseWorkIdsLists:
      courseWorkIds = courseWorkIdsLists[courseId]
    if not courseWorkIds:
      printGettingAllEntityItemsForWhom(Ent.COURSE_WORK_ID, Ent.TypeName(Ent.COURSE, courseId), i, count, _gettingCourseWorkQuery(courseWorkSelectionParameters[u'courseWorkStates']))
      try:
        results = callGAPIpages(croom.courses().courseWork(), u'list', u'courseWork',
                                page_message=getPageMessage(),
                                throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                courseId=courseId, courseWorkStates=courseWorkSelectionParameters[u'courseWorkStates'], orderBy=orderBy,
                                fields=u'nextPageToken,courseWork(id)', pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        courseWorkIdsForCourse = [courseWork[u'id'] for courseWork in results]
      except GAPI.notFound:
        continue
      except GAPI.forbidden:
        APIAccessDeniedExit()
    else:
      courseWorkIdsForCourse = courseWorkIds
    jcount = len(courseWorkIdsForCourse)
    if jcount == 0:
      continue
    j = 0
    for courseWorkId in courseWorkIdsForCourse:
      j += 1
      if not courseSubmissionIds:
        fields = u'nextPageToken,studentSubmissions({0})'.format(u','.join(set(fieldsList))) if fieldsList else None
        printGettingAllEntityItemsForWhom(Ent.COURSE_SUBMISSION_ID, Ent.TypeName(Ent.COURSE_WORK_ID, courseWorkId), j, jcount,
                                          _gettingCourseSubmissionQuery(courseSubmissionStates, late, courseSelectionParameters[u'studentId']))
        try:
          results = callGAPIpages(croom.courses().courseWork().studentSubmissions(), u'list', u'studentSubmissions',
                                  page_message=getPageMessage(),
                                  throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                  courseId=courseId, courseWorkId=courseWorkId, states=courseSubmissionStates, late=late, userId=courseSelectionParameters[u'studentId'],
                                  fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
          for submission in results:
            _printCourseSubmission(course, submission)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course[u'name'], Ent.COURSE_WORK_ID, courseWorkId], j, jcount)
        except GAPI.forbidden:
          APIAccessDeniedExit()
      else:
        if courseSubmissionIdsLists:
          if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
            courseSubmissionIds = courseSubmissionIdsLists[courseWorkId]
          else:
            courseSubmissionIds = courseSubmissionIdsLists[courseId][courseWorkId]
        kcount = len(courseSubmissionIds)
        if kcount == 0:
          continue
        fields = u'{0}'.format(u','.join(set(fieldsList))) if fieldsList else None
        k = 0
        for courseSubmissionId in courseSubmissionIds:
          k += 1
          try:
            submission = callGAPI(croom.courses().courseWork().studentSubmissions(), u'get',
                                  throw_reasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                  courseId=courseId, courseWorkId=courseWorkId, id=courseSubmissionId,
                                  fields=fields)
            _printCourseSubmission(course, submission)
          except GAPI.notFound:
            entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course[u'name'], Ent.COURSE_WORK_ID, courseWorkId, Ent.COURSE_SUBMISSION_ID, courseSubmissionId], k, kcount)
          except GAPI.forbidden:
            APIAccessDeniedExit()
  writeCSVfile(csvRows, titles, u'Course Submissions', todrive, [u'courseId', u'courseName', u'courseWorkId', u'id', u'userId',
                                                                 u'profile.emailAddress', u'profile.name.givenName', u'profile.name.familyName', u'profile.name.fullName',
                                                                 u'state'], quotechar)

# gam print course-participants [todrive [<ToDriveAttributes>]] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] [states <CourseStateList>])
#	[show all|students|teachers] [formatjson] [quotechar <Character>]
def doPrintCourseParticipants():
  croom = buildGAPIObject(API.CLASSROOM)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'courseId', u'courseName'])
  courseSelectionParameters = _initCourseSelectionParameters()
  courseShowProperties = _initCourseShowProperties([u'name',])
  courseShowProperties[u'members'] = u'all'
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif myarg == u'show':
      courseShowProperties[u'members'] = getChoice(COURSE_MEMBER_ARGUMENTS)
    elif myarg == u'formatjson':
      formatJSON = True
    else:
      unknownArgumentExit()
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  if courseShowProperties[u'members'] != u'none':
    if courseShowProperties[u'members'] != u'students':
      if formatJSON:
        addTitlesToCSVfile(u'JSON-teachers', titles)
    if courseShowProperties[u'members'] != u'teachers':
      if formatJSON:
        addTitlesToCSVfile(u'JSON-students', titles)
    teachersFields = u'nextPageToken,teachers(userId,profile)'
    studentsFields = u'nextPageToken,students(userId,profile)'
  else:
    teachersFields = studentsFields = None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course[u'id']
    _, teachers, students = _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields, True, i, count)
    if formatJSON:
      row = {u'courseId': courseId, u'courseName': course[u'name']}
      if courseShowProperties[u'members'] != u'none':
        if courseShowProperties[u'members'] != u'students':
          row[u'JSON-teachers'] = json.dumps(list(teachers))
        if courseShowProperties[u'members'] != u'teachers':
          row[u'JSON-students'] = json.dumps(list(students))
      csvRows.append(row)
    else:
      if courseShowProperties[u'members'] != u'none':
        if courseShowProperties[u'members'] != u'students':
          for member in teachers:
            addRowTitlesToCSVfile(flattenJSON(member, flattened={u'courseId': courseId, u'courseName': course[u'name'], u'userRole': u'TEACHER'}), csvRows, titles)
        if courseShowProperties[u'members'] != u'teachers':
          for member in students:
            addRowTitlesToCSVfile(flattenJSON(member, flattened={u'courseId': courseId, u'courseName': course[u'name'], u'userRole': u'STUDENT'}), csvRows, titles)
  if formatJSON:
    writeCSVfile(csvRows, titles, u'Course Participants', todrive, quotechar=quotechar)
  else:
    writeCSVfile(csvRows, titles, u'Course Participants', todrive, [u'courseId', u'courseName', u'userRole', u'userId'], quotechar=quotechar)

def checkCourseExists(croom, courseId, i=0, count=0):
  courseId = addCourseIdScope(courseId)
  try:
    return callGAPI(croom.courses(), u'get',
                    throw_reasons=[GAPI.NOT_FOUND],
                    id=courseId, fields=u'id')[u'id']
  except GAPI.notFound:
    entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], Msg.DOES_NOT_EXIST, i, count)
    return None

def _batchAddParticipantsToCourse(croom, courseId, i, count, addParticipants, role):
  _ADD_PART_REASON_TO_MESSAGE_MAP = {GAPI.ALREADY_EXISTS: Msg.DUPLICATE, GAPI.FAILED_PRECONDITION: Msg.NOT_ALLOWED}
  def _callbackAddParticipantsToCourse(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BACKEND_ERROR]:
        errMsg = getPhraseDNEorSNA(ri[RI_ITEM])
      else:
        errMsg = getHTTPError(_ADD_PART_REASON_TO_MESSAGE_MAP, http_status, reason, message)
      entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  if role == Ent.STUDENT:
    method = getattr(croom.courses().students(), u'create')
    attribute = u'userId'
  elif role == Ent.TEACHER:
    method = getattr(croom.courses().teachers(), u'create')
    attribute = u'userId'
  else:
    method = getattr(croom.courses().aliases(), u'create')
    attribute = u'alias'
  Act.Set(Act.ADD)
  jcount = len(addParticipants)
  noScopeCourseId = removeCourseIdScope(courseId)
  entityPerformActionNumItems([Ent.COURSE, noScopeCourseId], jcount, role, i, count)
  Ind.Increment()
  svcargs = dict([(u'courseId', courseId), (u'body', {attribute: None}), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
  dbatch = croom.new_batch_http_request(callback=_callbackAddParticipantsToCourse)
  bcount = 0
  j = 0
  for participant in addParticipants:
    j += 1
    svcparms = svcargs.copy()
    if role != Ent.COURSE_ALIAS:
      svcparms[u'body'][attribute] = cleanItem = normalizeEmailAddressOrUID(participant)
    else:
      svcparms[u'body'][attribute] = addCourseIdScope(participant)
      cleanItem = removeCourseIdScope(svcparms[u'body'][attribute])
    dbatch.add(method(**svcparms), request_id=batchRequestID(noScopeCourseId, 0, 0, j, jcount, cleanItem, role))
    bcount += 1
    if bcount >= GC.Values[GC.BATCH_SIZE]:
      executeBatch(dbatch)
      dbatch = croom.new_batch_http_request(callback=_callbackAddParticipantsToCourse)
      bcount = 0
  if bcount > 0:
    executeBatch(dbatch)
  Ind.Decrement()

def _batchRemoveParticipantsFromCourse(croom, courseId, i, count, removeParticipants, role):
  _REMOVE_PART_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.FORBIDDEN: Msg.FORBIDDEN}
  def _callbackRemoveParticipantsFromCourse(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason == GAPI.NOT_FOUND and ri[RI_ROLE] != Ent.COURSE_ALIAS:
        errMsg = u'{0} {1}'.format(Msg.NOT_A, Ent.Singular(ri[RI_ROLE]))
      else:
        errMsg = getHTTPError(_REMOVE_PART_REASON_TO_MESSAGE_MAP, http_status, reason, message)
      entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  if role == Ent.STUDENT:
    method = getattr(croom.courses().students(), u'delete')
    attribute = u'userId'
  elif role == Ent.TEACHER:
    method = getattr(croom.courses().teachers(), u'delete')
    attribute = u'userId'
  else:
    method = getattr(croom.courses().aliases(), u'delete')
    attribute = u'alias'
  Act.Set(Act.REMOVE)
  jcount = len(removeParticipants)
  noScopeCourseId = removeCourseIdScope(courseId)
  entityPerformActionNumItems([Ent.COURSE, noScopeCourseId], jcount, role, i, count)
  Ind.Increment()
  svcargs = dict([(u'courseId', courseId), (u'fields', u''), (attribute, None)]+GM.Globals[GM.EXTRA_ARGS_LIST])
  dbatch = croom.new_batch_http_request(callback=_callbackRemoveParticipantsFromCourse)
  bcount = 0
  j = 0
  for participant in removeParticipants:
    j += 1
    svcparms = svcargs.copy()
    if role != Ent.COURSE_ALIAS:
      svcparms[attribute] = cleanItem = normalizeEmailAddressOrUID(participant)
    else:
      svcparms[attribute] = addCourseIdScope(participant)
      cleanItem = removeCourseIdScope(svcparms[attribute])
    dbatch.add(method(**svcparms), request_id=batchRequestID(noScopeCourseId, 0, 0, j, jcount, cleanItem, role))
    bcount += 1
    if bcount >= GC.Values[GC.BATCH_SIZE]:
      executeBatch(dbatch)
      dbatch = croom.new_batch_http_request(callback=_callbackRemoveParticipantsFromCourse)
      bcount = 0
  if bcount > 0:
    executeBatch(dbatch)
  Ind.Decrement()

ADD_REMOVE_PARTICIPANT_TYPES_MAP = {
  u'alias': Ent.COURSE_ALIAS,
  u'student': Ent.STUDENT,
  u'students': Ent.STUDENT,
  u'teacher': Ent.TEACHER,
  u'teachers': Ent.TEACHER,
  }
SYNC_PARTICIPANT_TYPES_MAP = {
  u'student': Ent.STUDENT,
  u'students': Ent.STUDENT,
  u'teacher': Ent.TEACHER,
  u'teachers': Ent.TEACHER,
  }
PARTICIPANT_EN_MAP = {
  Ent.STUDENT: Cmd.ENTITY_STUDENTS,
  Ent.TEACHER: Cmd.ENTITY_TEACHERS,
  }

# gam courses <CourseEntity> create|add alias <CourseAliasEntity>
# gam course <CourseID> create|add alias <CourseAlias>
# gam courses <CourseEntity> create|add teachers|students <UserTypeEntity>
# gam course <CourseID> create|add teacher|student <EmailAddress>
def doCourseAddParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(ADD_REMOVE_PARTICIPANT_TYPES_MAP, mapChoice=True)
  if not getEntityListArg:
    if role != Ent.COURSE_ALIAS:
      addParticipants = getStringReturnInList(Cmd.OB_EMAIL_ADDRESS)
    else:
      addParticipants = getStringReturnInList(Cmd.OB_COURSE_ALIAS)
    courseParticipantLists = None
  else:
    if role != Ent.COURSE_ALIAS:
      _, addParticipants = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS,
                                             typeMap={Cmd.ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]},
                                             checkSuspended=False)
    else:
      addParticipants = getEntityList(Cmd.OB_COURSE_ALIAS_ENTITY)
    courseParticipantLists = addParticipants if isinstance(addParticipants, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      addParticipants = courseParticipantLists[courseId]
    courseId = checkCourseExists(croom, courseId, i, count)
    if courseId:
      _batchAddParticipantsToCourse(croom, courseId, i, count, addParticipants, role)

# gam courses <CourseEntity> remove alias <CourseAliasEntity>
# gam course <CourseID> remove alias <CourseAlias>
# gam courses <CourseEntity> remove teachers|students <UserTypeEntity>
# gam course <CourseID> remove teacher|student <EmailAddress>
def doCourseRemoveParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(ADD_REMOVE_PARTICIPANT_TYPES_MAP, mapChoice=True)
  if not getEntityListArg:
    if role != Ent.COURSE_ALIAS:
      removeParticipants = getStringReturnInList(Cmd.OB_EMAIL_ADDRESS)
    else:
      removeParticipants = getStringReturnInList(Cmd.OB_COURSE_ALIAS)
    courseParticipantLists = None
  else:
    if role != Ent.COURSE_ALIAS:
      _, removeParticipants = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS,
                                                typeMap={Cmd.ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]})
    else:
      removeParticipants = getEntityList(Cmd.OB_COURSE_ALIAS_ENTITY)
    courseParticipantLists = removeParticipants if isinstance(removeParticipants, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      removeParticipants = courseParticipantLists[courseId]
    courseId = checkCourseExists(croom, courseId, i, count)
    if courseId:
      _batchRemoveParticipantsFromCourse(croom, courseId, i, count, removeParticipants, role)

# gam courses <CourseEntity> sync teachers|students [addonly|removeonly] <UserTypeEntity>
# gam course <CourseID> sync teachers|students [addonly|removeonly] <UserTypeEntity>
def doCourseSyncParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(SYNC_PARTICIPANT_TYPES_MAP, mapChoice=True)
  syncOperation = getChoice([u'addonly', 'removeonly'], defaultChoice=u'addremove')
  _, syncParticipants = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS,
                                          typeMap={Cmd.ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]}, checkSuspended=False)
  checkForExtraneousArguments()
  courseParticipantLists = syncParticipants if isinstance(syncParticipants, dict) else None
  if not courseParticipantLists:
    syncParticipantsSet = set()
    for user in syncParticipants:
      syncParticipantsSet.add(normalizeEmailAddressOrUID(user))
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      syncParticipantsSet = set()
      for user in courseParticipantLists[courseId]:
        syncParticipantsSet.add(normalizeEmailAddressOrUID(user))
    courseId = checkCourseExists(croom, courseId, i, count)
    if courseId:
      currentParticipantsSet = set()
      for user in getUsersToModify(PARTICIPANT_EN_MAP[role], courseId):
        currentParticipantsSet.add(normalizeEmailAddressOrUID(user))
      if syncOperation != u'removeonly':
        _batchAddParticipantsToCourse(croom, courseId, i, count, list(syncParticipantsSet-currentParticipantsSet), role)
      if syncOperation != u'addonly':
        _batchRemoveParticipantsFromCourse(croom, courseId, i, count, list(currentParticipantsSet-syncParticipantsSet), role)

def encode_multipart(fields, files, boundary=None):
  def escape_quote(s):
    return s.replace('"', '\\"')

  def getFormDataLine(name, value, boundary):
    return '--{0}'.format(boundary), 'Content-Disposition: form-data; name="{0}"'.format(escape_quote(name)), '', str(value)

  if boundary is None:
    boundary = ''.join(random.choice(string.digits+string.ascii_letters) for i in range(30))
  lines = []
  for name, value in iteritems(fields):
    if name == u'tags':
      for tag in value:
        lines.extend(getFormDataLine('tag', tag, boundary))
    else:
      lines.extend(getFormDataLine(name, value, boundary))
  for name, value in iteritems(files):
    filename = value[u'filename']
    mimetype = value[u'mimetype']
    lines.extend((
      '--{0}'.format(boundary),
      'Content-Disposition: form-data; name="{0}"; filename="{1}"'.format(escape_quote(name), escape_quote(filename)),
      'Content-Type: {0}'.format(mimetype),
      '',
      value[u'content'],
    ))
  lines.extend((
    '--{0}--'.format(boundary),
    '',
  ))
  body = '\r\n'.join(lines)
  headers = {
    'Content-Type': 'multipart/form-data; boundary={0}'.format(boundary),
    'Content-Length': str(len(body)),
  }
  return (body, headers)

# gam printer register
def doPrinterRegister():
  cp = buildGAPIObject(API.CLOUDPRINT)
  checkForExtraneousArguments()
  form_fields = {u'name': u'GAM',
                 u'proxy': u'GAM',
                 u'uuid': _getValueFromOAuth(u'sub'),
                 u'manufacturer': __author__,
                 u'model': u'cp1',
                 u'gcp_version': u'2.0',
                 u'setup_url': GAM_URL,
                 u'support_url': u'https://groups.google.com/forum/#!forum/google-apps-manager',
                 u'update_url': GAM_RELEASES,
                 u'firmware': __version__,
                 u'semantic_state': {"version": "1.0", "printer": {"state": "IDLE",}},
                 u'use_cdd': True,
                 u'capabilities': {"version": "1.0",
                                   "printer": {"supported_content_type": [{"content_type": "application/pdf", "min_version": "1.5"},
                                                                          {"content_type": "image/jpeg"},
                                                                          {"content_type": "text/plain"},
                                                                         ],
                                               "copies": {"default": 1, "max": 100},
                                               "media_size": {"option": [{"name": "ISO_A4", "width_microns": 210000, "height_microns": 297000},
                                                                         {"name": "NA_LEGAL", "width_microns": 215900, "height_microns": 355600},
                                                                         {"name": "NA_LETTER", "width_microns": 215900, "height_microns": 279400, "is_default": True},
                                                                        ],
                                                             },
                                              },
                                  },
                 u'tags': [u'GAM', GAM_URL],
                }
  body, headers = encode_multipart(form_fields, {})
  #Get the printer first to make sure our OAuth access token is fresh
  callGAPI(cp.printers(), u'list')
  _, result = cp._http.request(uri='https://www.google.com/cloudprint/register', method='POST', body=body, headers=headers)
  result = checkCloudPrintResult(result)
  entityActionPerformed([Ent.PRINTER, result[u'printers'][0][u'id']])
#
PRINTER_UPDATE_ITEMS_CHOICE_MAP = {
  u'currentquota': u'currentQuota',
  u'dailyquota': u'dailyQuota',
  u'defaultdisplayname': u'defaultDisplayName',
  u'description': u'description',
  u'displayname': u'displayName',
  u'firmware': u'firmware',
  u'gcpversion': u'gcpVersion',
  u'istosaccepted': u'isTosAccepted',
  u'manufacturer': u'manufacturer',
  u'model': u'model',
  u'name': u'name',
  u'ownerid': u'ownerId',
  u'proxy': u'proxy',
  u'public': u'public',
  u'quotaenabled': u'quotaEnabled',
  u'setupurl': u'setupUrl',
  u'status': u'status',
  u'supporturl': u'supportUrl',
  u'type': u'type',
  u'updateurl': u'updateUrl',
  u'uuid': u'uuid',
  }

# gam update printer|printers <PrinterIDEntity> <PrinterAttributes>
def doUpdatePrinters():
  cp = buildGAPIObject(API.CLOUDPRINT)
  entityList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  kwargs = {}
  while Cmd.ArgumentsRemaining():
    item = getChoice(PRINTER_UPDATE_ITEMS_CHOICE_MAP, mapChoice=True)
    if item in [u'isTosAccepted', u'public', u'quotaEnabled']:
      kwargs[item] = getBoolean()
    elif item in [u'currentQuota', u'dailyQuota', u'status']:
      kwargs[item] = getInteger(minVal=0)
    elif item in [u'displayName', u'defaultDisplayName']:
      kwargs[item] = getString(Cmd.OB_STRING, minLen=0)
    else:
      kwargs[item] = getString(Cmd.OB_STRING)
  i = 0
  count = len(entityList)
  for printerId in entityList:
    i += 1
    try:
      callGCP(cp.printers(), u'update',
              throw_messages=[GCP.UNKNOWN_PRINTER],
              printerid=printerId, **kwargs)
      entityActionPerformed([Ent.PRINTER, printerId], i, count)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)

# gam delete printer|printers <PrinterIDEntity>
def doDeletePrinters():
  cp = buildGAPIObject(API.CLOUDPRINT)
  entityList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for printerId in entityList:
    i += 1
    try:
      callGCP(cp.printers(), u'delete',
              throw_messages=[GCP.UNKNOWN_PRINTER],
              printerid=printerId)
      entityActionPerformed([Ent.PRINTER, printerId], i, count)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)

# gam info printers <PrinterIDEntity> [everything]
def doInfoPrinters():
  cp = buildGAPIObject(API.CLOUDPRINT)
  entityList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  everything = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'everything':
      everything = True
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for printerId in entityList:
    i += 1
    try:
      result = callGCP(cp.printers(), u'get',
                       throw_messages=[GCP.UNKNOWN_PRINTER],
                       printerid=printerId)
      printEntity([Ent.PRINTER, printerId], i, count)
      Ind.Increment()
      printer_info = result[u'printers'][0]
      printer_info[u'createTime'] = formatLocalTimestamp(printer_info[u'createTime'])
      printer_info[u'accessTime'] = formatLocalTimestamp(printer_info[u'accessTime'])
      printer_info[u'updateTime'] = formatLocalTimestamp(printer_info[u'updateTime'])
      printer_info[u'tags'] = u' '.join(printer_info[u'tags'])
      if not everything:
        del printer_info[u'capabilities']
        del printer_info[u'access']
      showJSON(None, printer_info)
      Ind.Decrement()
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)

# gam print printers [todrive [<ToDriveAttributes>]] [(query <QueryPrinter>)|(queries <QueryPrinterList>)] [type <String>] [status <String>] [extrafields <String>] [delimiter <Character>]
def doPrintPrinters():
  cp = buildGAPIObject(API.CLOUDPRINT)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'id',])
  queries = [None]
  printer_type = None
  connection_status = None
  extra_fields = None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'query', u'queries']:
      queries = getQueries(myarg)
    elif myarg == u'type':
      printer_type = getString(Cmd.OB_STRING)
    elif myarg == u'status':
      connection_status = getString(Cmd.OB_STRING)
    elif myarg == u'extrafields':
      extra_fields = getString(Cmd.OB_STRING)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  for query in queries:
    printers = callGCP(cp.printers(), u'list',
                       q=query, type=printer_type, connection_status=connection_status, extra_fields=extra_fields)
    for printer in printers[u'printers']:
      printer[u'createTime'] = formatLocalTimestamp(printer[u'createTime'])
      printer[u'accessTime'] = formatLocalTimestamp(printer[u'accessTime'])
      printer[u'updateTime'] = formatLocalTimestamp(printer[u'updateTime'])
      printer[u'tags'] = delimiter.join(printer[u'tags'])
      addRowTitlesToCSVfile(flattenJSON(printer), csvRows, titles)
  writeCSVfile(csvRows, titles, u'Printers', todrive, [u'id', u'name', u'displayName', u'description', u'createTime', u'updateTime', u'accessTime'])

def normalizePrinterScopeList(rawScopeList):
  scopeList = []
  for scope in rawScopeList:
    scope = scope.lower()
    if scope != u'public':
      if scope == u'domain':
        scope = u'/hd/domain/{0}'.format(GC.Values[GC.DOMAIN])
      elif scope.startswith(u'domain:'):
        scope = u'/hd/domain/{0}'.format(scope[7:])
      elif scope.startswith(u'user:'):
        scope = normalizeEmailAddressOrUID(scope[5:], noUid=True)
      elif scope.startswith(u'group:'):
        scope = normalizeEmailAddressOrUID(scope[6:], noUid=True)
      else:
        scope = normalizeEmailAddressOrUID(scope, noUid=True)
    scopeList.append(scope)
  return scopeList

def getPrinterACLScopeEntity():
  groupMemberType = getChoice({u'usersonly': u'USER', 'groupsonly': u'GROUP'}, defaultChoice=u'ALL', mapChoice=True)
  _, scopeList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, groupMemberType=groupMemberType)
  printerScopeLists = scopeList if isinstance(scopeList, dict) else None
  if not printerScopeLists:
    scopeList = normalizePrinterScopeList(scopeList)
  return scopeList, printerScopeLists

def _batchCreatePrinterACLs(cp, printerId, i, count, scopeList, role, notify):
  Act.Set(Act.ADD)
  jcount = len(scopeList)
  entityPerformActionNumItems([Ent.PRINTER, printerId], jcount, role, i, count)
  Ind.Increment()
  j = 0
  for scope in scopeList:
    j += 1
    if scope.lower() == u'public':
      public = True
      scope = None
      roleForScope = None
      skip_notification = None
    else:
      public = None
      roleForScope = role
      skip_notification = not notify if scope.find(u'@') != -1 else True
    try:
      callGCP(cp.printers(), u'share',
              throw_messages=[GCP.UNKNOWN_PRINTER, GCP.FAILED_TO_SHARE_THE_PRINTER, GCP.USER_IS_NOT_AUTHORIZED],
              printerid=printerId, role=roleForScope, scope=scope, public=public, skip_notification=skip_notification)
      if scope is None:
        scope = u'public'
        roleForScope = Ent.ROLE_USER
      entityActionPerformed([Ent.PRINTER, printerId, roleForScope, scope], j, jcount)
    except GCP.userIsNotAuthorized:
      entityActionFailedWarning([Ent.PRINTER, printerId, roleForScope, scope], Msg.ONLY_ONE_OWNER_ALLOWED, j, jcount)
    except GCP.failedToShareThePrinter:
      entityActionFailedWarning([Ent.PRINTER, printerId, roleForScope, scope], Msg.INVALID_SCOPE, j, jcount)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
      break
  Ind.Decrement()

PRINTER_ROLE_MAP = {u'manager': Ent.ROLE_MANAGER, u'owner': Ent.ROLE_OWNER, u'user': Ent.ROLE_USER,}

# gam printer|printers <PrinterIDEntity> create|add user|manager|owner <PrinterACLScopeEntity> [notify]
def doPrinterCreateACL(printerIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  notify = checkArgumentPresent(u'notify')
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    if printerScopeLists:
      scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
    _batchCreatePrinterACLs(cp, printerId, i, count, scopeList, role, notify)

def _batchDeletePrinterACLs(cp, printerId, i, count, scopeList, role):
  Act.Set(Act.DELETE)
  jcount = len(scopeList)
  entityPerformActionNumItems([Ent.PRINTER, printerId], jcount, role, i, count)
  Ind.Increment()
  j = 0
  for scope in scopeList:
    j += 1
    if scope.lower() == u'public':
      public = True
      scope = None
    else:
      public = None
    try:
      callGCP(cp.printers(), u'unshare',
              throw_messages=[GCP.UNKNOWN_PRINTER],
              printerid=printerId, scope=scope, public=public)
      if scope is None:
        scope = u'public'
      entityActionPerformed([Ent.PRINTER, printerId, Ent.SCOPE, scope], j, jcount)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
      break
  Ind.Decrement()

# gam printer|printers <PrinterIDEntity> delete [user|manager|owner] <PrinterACLScopeEntity>
def doPrinterDeleteACLs(printerIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  getChoice(PRINTER_ROLE_MAP, defaultChoice=None, mapChoice=True)
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    if printerScopeLists:
      scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
    _batchDeletePrinterACLs(cp, printerId, i, count, scopeList, Ent.SCOPE)

def getPrinterScopeListsForRole(cp, printerId, i, count, role):
  try:
    result = callGCP(cp.printers(), u'get',
                     throw_messages=[GCP.UNKNOWN_PRINTER],
                     printerid=printerId)
    try:
      jcount = len(result[u'printers'][0][u'access'])
    except KeyError:
      jcount = 0
    scopeList = []
    if jcount > 0:
      for acl in result[u'printers'][0][u'access']:
        if acl.get(u'role') == role:
          scopeList.append(acl[u'scope'].lower())
    return scopeList
  except GCP.unknownPrinter as e:
    entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
    return None

# gam printer|printers <PrinterIDEntity> sync user|manager|owner [addonly|removeonly] <PrinterACLScopeEntity> [notify]
def doPrinterSyncACLs(printerIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  syncOperation = getChoice([u'addonly', 'removeonly'], defaultChoice=u'addremove')
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  notify = checkArgumentPresent(u'notify')
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    if printerScopeLists:
      scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
    currentScopeList = getPrinterScopeListsForRole(cp, printerId, i, count, role)
    if currentScopeList is not None:
      if syncOperation != u'removeonly':
        _batchCreatePrinterACLs(cp, printerId, i, count, list(set(scopeList)-set(currentScopeList)), role, notify)
      if syncOperation != u'addonly':
        _batchDeletePrinterACLs(cp, printerId, i, count, list(set(currentScopeList)-set(scopeList)), role)

# gam printer|printers <PrinterIDEntity> wipe user|manager|owner
def doPrinterWipeACLs(printerIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  checkForExtraneousArguments()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    currentScopeList = getPrinterScopeListsForRole(cp, printerId, i, count, role)
    if currentScopeList is not None:
      _batchDeletePrinterACLs(cp, printerId, i, count, currentScopeList, role)

def _doPrinterPrintShowACLs(printerIdList, csvFormat):
  cp = buildGAPIObject(API.CLOUDPRINT)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'id',])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i = 0
  count = len(printerIdList)
  for printerId in printerIdList:
    i += 1
    try:
      if csvFormat:
        printGettingEntityItemForWhom(Ent.PRINTER_ACL, printerId, i, count)
      result = callGCP(cp.printers(), u'get',
                       throw_messages=[GCP.UNKNOWN_PRINTER],
                       printerid=printerId)
      try:
        jcount = len(result[u'printers'][0][u'access'])
      except KeyError:
        jcount = 0
      if not csvFormat:
        entityPerformActionNumItems([Ent.PRINTER, printerId], jcount, Ent.PRINTER_ACL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        Ind.Increment()
        for acl in result[u'printers'][0][u'access']:
          if u'key' in acl:
            acl[u'accessURL'] = CLOUDPRINT_ACCESS_URL.format(printerId, acl[u'key'])
          showJSON(None, acl)
          printBlankLine()
        Ind.Decrement()
      else:
        for acl in result[u'printers'][0][u'access']:
          if u'key' in acl:
            acl[u'accessURL'] = CLOUDPRINT_ACCESS_URL.format(printerId, acl[u'key'])
          addRowTitlesToCSVfile(flattenJSON(acl, flattened={u'id': printerId}), csvRows, titles)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'PrinterACLs', todrive)

# gam printer|printers <PrinterIDEntity> printacls [todrive [<ToDriveAttributes>]]
def doPrinterPrintACLs(printerIdList):
  _doPrinterPrintShowACLs(printerIdList, True)

# gam printer|printers <PrinterIDEntity> showacls
def doPrinterShowACLs(printerIdList):
  _doPrinterPrintShowACLs(printerIdList, False)

# gam printjob|printjobs <PrintJobEntity> cancel
def doPrintJobCancel(jobIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  checkForExtraneousArguments()
  ssd = u'{"state": {"type": "ABORTED", "user_action_cause": {"action_code": "CANCELLED"}}}'
  i = 0
  count = len(jobIdList)
  for jobId in jobIdList:
    i += 1
    try:
      callGCP(cp.jobs(), u'update',
              throw_messages=[GCP.UNKNOWN_JOB_ID],
              jobid=jobId, semantic_state_diff=ssd)
      entityActionPerformed([Ent.PRINTJOB, jobId], i, count)
    except GCP.unknownJobId as e:
      entityActionFailedWarning([Ent.PRINTJOB, jobId], str(e), i, count)

# gam printjob|printjobs <PrintJobEntity> delete
def doPrintJobDelete(jobIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  checkForExtraneousArguments()
  i = 0
  count = len(jobIdList)
  for jobId in jobIdList:
    i += 1
    try:
      callGCP(cp.jobs(), u'delete',
              throw_messages=[GCP.UNKNOWN_JOB_ID],
              jobid=jobId)
      entityActionPerformed([Ent.PRINTJOB, jobId], i, count)
    except GCP.unknownJobId as e:
      entityActionFailedWarning([Ent.PRINTJOB, jobId], str(e), i, count)

# gam printjob|printjobs <PrintJobEntity> resubmit <PrinterID>
def doPrintJobResubmit(jobIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  printerId = getString(Cmd.OB_PRINTER_ID)
  ssd = u'{"state": {"type": "HELD"}}'
  i = 0
  count = len(jobIdList)
  for jobId in jobIdList:
    i += 1
    try:
      result = callGCP(cp.jobs(), u'update',
                       throw_messages=[GCP.UNKNOWN_JOB_ID, GCP.CANT_MODIFY_FINISHED_JOB],
                       jobid=jobId, semantic_state_diff=ssd)
      ticket = callGCP(cp.jobs(), u'getticket',
                       throw_messages=[GCP.UNKNOWN_JOB_ID, GCP.CANT_MODIFY_FINISHED_JOB],
                       jobid=jobId, use_cjt=True)
      result = callGCP(cp.jobs(), u'resubmit',
                       throw_messages=[GCP.UNKNOWN_PRINTER, GCP.UNKNOWN_JOB_ID, GCP.CANT_MODIFY_FINISHED_JOB],
                       printerid=printerId, jobid=jobId, ticket=ticket)
      entityActionPerformed([Ent.PRINTJOB, result[u'job'][u'id'], Ent.PRINTER, printerId], i, count)
    except GCP.unknownJobId as e:
      entityActionFailedWarning([Ent.PRINTJOB, jobId], str(e), count)
    except (GCP.cantModifyFinishedJob, GCP.unknownPrinter) as e:
      entityActionFailedWarning([Ent.PRINTJOB, jobId, Ent.PRINTER, printerId], str(e), i, count)
#
PRINTJOB_STATUS_MAP = {
  u'done': u'DONE',
  u'error': u'ERROR',
  u'held': u'HELD',
  u'inprogress': u'IN_PROGRESS',
  u'queued': u'QUEUED',
  u'submitted': u'SUBMITTED',
  }
# Map argument to API value
PRINTJOB_ASCENDINGORDER_MAP = {
  u'createtime': u'CREATE_TIME',
  u'status': u'STATUS',
  u'title': u'TITLE',
  }
# Map API value from ascending to descending
PRINTJOB_DESCENDINGORDER_MAP = {
  u'CREATE_TIME': u'CREATE_TIME_DESC',
  u'STATUS': u'STATUS_DESC',
  u'TITLE': u'TITLE_DESC',
  }

PRINTJOBS_DEFAULT_JOB_LIMIT = 0
PRINTJOBS_DEFAULT_MAX_RESULTS = 100

def initPrintjobListParameters():
  return {u'older_or_newer': 0,
          u'age': None,
          u'sortorder': None,
          u'owner': None,
          u'queries': [None],
          u'status': None,
          u'jobLimit': PRINTJOBS_DEFAULT_JOB_LIMIT,
         }

def getPrintjobListParameters(myarg, parameters):
  if myarg == u'olderthan':
    parameters[u'older_or_newer'] = 1
    parameters[u'age'] = getAgeTime()
  elif myarg == u'newerthan':
    parameters[u'older_or_newer'] = -1
    parameters[u'age'] = getAgeTime()
  elif myarg in [u'query', u'queries']:
    parameters[u'queries'] = getQueries(myarg)
  elif myarg == u'status':
    parameters[u'status'] = getChoice(PRINTJOB_STATUS_MAP, mapChoice=True)
  elif myarg == u'orderby':
    parameters[u'sortorder'] = getChoice(PRINTJOB_ASCENDINGORDER_MAP, mapChoice=True)
    if getChoice(SORTORDER_CHOICE_MAP, defaultChoice=u'ASCENDING', mapChoice=True) == u'DESCENDING':
      parameters[u'sortorder'] = PRINTJOB_DESCENDINGORDER_MAP[parameters[u'sortorder']]
  elif myarg in [u'owner', u'user']:
    parameters[u'owner'] = getEmailAddress(noUid=True)
  elif myarg == u'limit':
    parameters[u'jobLimit'] = getInteger(minVal=0)
  else:
    unknownArgumentExit()

# gam printjob <PrinterID>|any fetch
#	[olderthan|newerthan <PrintJobAge>] [(query <QueryPrintJob>)|(queries <QueryPrintJobList>)]
#	[status done|error|held|in_progress|queued|submitted]
#	[orderby <PrintJobOrderByFieldName> [ascending|descending]]
#	[owner|user <EmailAddress>]
#	[limit <Number>] [drivedir|(targetfolder <FilePath>)]
def doPrintJobFetch(printerIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  printerId = printerIdList[0]
  if printerId.lower() == u'any':
    printerId = None
  parameters = initPrintjobListParameters()
  targetFolder = os.getcwd()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'drivedir':
      targetFolder = GC.Values[GC.DRIVE_DIR]
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      getPrintjobListParameters(myarg, parameters)
  if printerId:
    try:
      callGCP(cp.printers(), u'get',
              throw_messages=[GCP.UNKNOWN_PRINTER],
              printerid=printerId)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e))
      return
  ssd = u'{"state": {"type": "DONE"}}'
  if ((not parameters[u'sortorder']) or (parameters[u'sortorder'] == u'CREATE_TIME_DESC')) and (parameters[u'older_or_newer'] < 0):
    timeExit = True
  elif (parameters[u'sortorder'] == u'CREATE_TIME') and (parameters[u'older_or_newer'] > 0):
    timeExit = True
  else:
    timeExit = False
  for query in parameters[u'queries']:
    jobCount = offset = 0
    exitLoop = False
    while not exitLoop:
      if parameters[u'jobLimit'] == 0:
        limit = PRINTJOBS_DEFAULT_MAX_RESULTS
      else:
        limit = min(PRINTJOBS_DEFAULT_MAX_RESULTS, parameters[u'jobLimit']-jobCount)
        if limit == 0:
          break
      result = callGCP(cp.jobs(), u'list',
                       throw_messages=[GCP.UNKNOWN_PRINTER, GCP.NO_PRINT_JOBS],
                       printerid=printerId, q=query, status=parameters[u'status'], sortorder=parameters[u'sortorder'],
                       owner=parameters[u'owner'], offset=offset, limit=limit)
      newJobs = result[u'range'][u'jobsCount']
      if newJobs == 0:
        break
      jobCount += newJobs
      offset += newJobs
      for job in result[u'jobs']:
        createTime = int(job[u'createTime'])
        if parameters[u'older_or_newer'] > 0:
          if createTime > parameters[u'age']:
            if timeExit:
              exitLoop = True
              break
            continue
        elif parameters[u'older_or_newer'] < 0:
          if createTime < parameters[u'age']:
            if timeExit:
              exitLoop = True
              break
            continue
        jobId = job[u'id']
        fileName = os.path.join(targetFolder, u'{0}-{1}'.format(cleanFilename(job[u'title']), jobId))
        _, content = cp._http.request(job[u'fileUrl'], method='GET')
        if writeFile(fileName, content, mode=u'wb', continueOnError=True):
#          ticket = callGCP(cp.jobs(), u'getticket',
#                           jobid=jobId, use_cjt=True)
          result = callGCP(cp.jobs(), u'update',
                           jobid=jobId, semantic_state_diff=ssd)
          entityModifierNewValueActionPerformed([Ent.PRINTER, printerId, Ent.PRINTJOB, jobId], Act.MODIFIER_TO, fileName)
    if jobCount == 0:
      entityActionFailedWarning([Ent.PRINTER, printerId, Ent.PRINTJOB, u''], Msg.NO_PRINT_JOBS)

# gam print printjobs [todrive [<ToDriveAttributes>]] [printer|printerid <PrinterID>]
#	[olderthan|newerthan <PrintJobAge>] [(query <QueryPrintJob>)|(queries <QueryPrintJobList>)]
#	[status <PrintJobStatus>]
#	[orderby <PrintJobOrderByFieldName> [ascending|descending]]
#	[owner|user <EmailAddress>]
#	[limit <Number>] [delimiter <Character>]
def doPrintPrintJobs():
  cp = buildGAPIObject(API.CLOUDPRINT)
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'printerid', u'id'])
  printerId = None
  parameters = initPrintjobListParameters()
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'printer', u'printerid']:
      printerId = getString(Cmd.OB_PRINTER_ID)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    else:
      getPrintjobListParameters(myarg, parameters)
  if printerId:
    try:
      callGCP(cp.printers(), u'get',
              throw_messages=[GCP.UNKNOWN_PRINTER],
              printerid=printerId)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e))
      return
  if ((not parameters[u'sortorder']) or (parameters[u'sortorder'] == u'CREATE_TIME_DESC')) and (parameters[u'older_or_newer'] < 0):
    timeExit = True
  elif (parameters[u'sortorder'] == u'CREATE_TIME') and (parameters[u'older_or_newer'] > 0):
    timeExit = True
  else:
    timeExit = False
  for query in parameters[u'queries']:
    jobCount = offset = 0
    exitLoop = False
    while not exitLoop:
      if parameters[u'jobLimit'] == 0:
        limit = PRINTJOBS_DEFAULT_MAX_RESULTS
      else:
        limit = min(PRINTJOBS_DEFAULT_MAX_RESULTS, parameters[u'jobLimit']-jobCount)
        if limit == 0:
          break
      result = callGCP(cp.jobs(), u'list',
                       printerid=printerId, q=query, status=parameters[u'status'], sortorder=parameters[u'sortorder'],
                       owner=parameters[u'owner'], offset=offset, limit=limit)
      newJobs = result[u'range'][u'jobsCount']
      if GC.Values[GC.DEBUG_LEVEL] > 0:
        sys.stderr.write(u'Debug: jobCount: {0}, jobLimit: {1}, jobsCount: {2}, jobsTotal: {3}\n'.format(jobCount, parameters[u'jobLimit'], newJobs, int(result[u'range'][u'jobsTotal'])))
      if newJobs == 0:
        break
      jobCount += newJobs
      offset += newJobs
      for job in result[u'jobs']:
        createTime = int(job[u'createTime'])
        if parameters[u'older_or_newer'] > 0:
          if createTime > parameters[u'age']:
            if timeExit:
              exitLoop = True
              break
            continue
        elif parameters[u'older_or_newer'] < 0:
          if createTime < parameters[u'age']:
            if timeExit:
              exitLoop = True
              break
            continue
        job[u'createTime'] = formatLocalTimestamp(job[u'createTime'])
        job[u'updateTime'] = formatLocalTimestamp(job[u'updateTime'])
        job[u'tags'] = delimiter.join(job[u'tags'])
        addRowTitlesToCSVfile(flattenJSON(job), csvRows, titles)
  writeCSVfile(csvRows, titles, u'Print Jobs', todrive, [u'printerid', u'id', u'printerName', u'title', u'ownerId', u'createTime', u'updateTime'])

# gam printjob <PrinterID> submit <FileName>|<URL> [name|title <String>] (tag <String>)*
def doPrintJobSubmit(printerIdList):
  cp = buildGAPIObject(API.CLOUDPRINT)
  printerId = printerIdList[0]
  content = getString(Cmd.OB_FILE_NAME_OR_URL)
  form_fields = {u'printerid': printerId,
                 u'title': content,
                 u'ticket': u'{"version": "1.0"}',
                 u'tags': [u'GAM', GAM_URL]}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'tag':
      form_fields[u'tags'].append(getString(Cmd.OB_STRING))
    elif myarg in [u'name', u'title']:
      form_fields[u'title'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  form_files = {}
  if content[:4] == u'http':
    form_fields[u'content'] = content
    form_fields[u'contentType'] = u'url'
  else:
    filepath = content
    content = os.path.basename(content)
    mimetype = mimetypes.guess_type(filepath)[0]
    if mimetype is None:
      mimetype = u'application/octet-stream'
    filecontent = readFile(filepath, mode=u'rb')
    form_files[u'content'] = {u'filename': content, u'content': filecontent, u'mimetype': mimetype}
#  result = callGCP(cp.printers(), u'submit',
#                   body=body)
  body, headers = encode_multipart(form_fields, form_files)
  try:
    #Get the printer first to make sure our OAuth access token is fresh
    callGCP(cp.printers(), u'get',
            throw_messages=[GCP.UNKNOWN_PRINTER],
            printerid=printerId)
    _, result = cp._http.request(uri='https://www.google.com/cloudprint/submit', method='POST', body=body, headers=headers)
    result = checkCloudPrintResult(result)
    entityActionPerformed([Ent.PRINTER, printerId, Ent.PRINTJOB, result[u'job'][u'id']])
  except GCP.unknownPrinter as e:
    entityActionFailedWarning([Ent.PRINTER, printerId], str(e))

def _showASPs(user, asps, i=0, count=0):
  Act.Set(Act.SHOW)
  jcount = len(asps)
  entityPerformActionNumItems([Ent.USER, user], jcount, Ent.APPLICATION_SPECIFIC_PASSWORD, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Ind.Increment()
  for asp in asps:
    if asp[u'creationTime'] == u'0':
      created_date = u'Unknown'
    else:
      created_date = formatLocalTimestamp(asp[u'creationTime'])
    if asp[u'lastTimeUsed'] == u'0':
      used_date = GC.NEVER
    else:
      used_date = formatLocalTimestamp(asp[u'lastTimeUsed'])
    printKeyValueList([u'ID', asp[u'codeId']])
    Ind.Increment()
    printKeyValueList([u'Name', asp[u'name']])
    printKeyValueList([u'Created', created_date])
    printKeyValueList([u'Last Used', used_date])
    Ind.Decrement()
  Ind.Decrement()

# gam <UserTypeEntity> delete asps|applicationspecificpasswords all|<AspIDList>
def deleteASP(users):
  cd = buildGAPIObject(API.DIRECTORY)
  codeIdList = getString(Cmd.OB_ASP_ID_LIST).lower()
  if codeIdList == u'all':
    allCodeIds = True
  else:
    allCodeIds = False
    codeIds = codeIdList.replace(u',', u' ').split()
    for codeId in codeIds:
      if not codeId.isdigit():
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_ENTITY_MESSAGE.format(Ent.Singular(Ent.APPLICATION_SPECIFIC_PASSWORD), Msg.MUST_BE_NUMERIC))
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if allCodeIds:
      try:
        asps = callGAPIitems(cd.asps(), u'list', u'items',
                             throw_reasons=[GAPI.USER_NOT_FOUND],
                             userKey=user, fields=u'items(codeId)')
        codeIds = [asp[u'codeId'] for asp in asps]
      except GAPI.userNotFound:
        entityUnknownWarning(Ent.USER, user, i, count)
        continue
    jcount = len(codeIds)
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.APPLICATION_SPECIFIC_PASSWORD, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    j = 0
    for codeId in codeIds:
      j += 1
      try:
        callGAPI(cd.asps(), u'delete',
                 throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.FORBIDDEN],
                 userKey=user, codeId=codeId)
        entityActionPerformed([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], j, jcount)
      except (GAPI.invalid, GAPI.invalidParameter, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], str(e), j, jcount)
      except GAPI.userNotFound:
        entityUnknownWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> show asps|applicationspecificpasswords
def showASPs(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      asps = callGAPIitems(cd.asps(), u'list', u'items',
                           throw_reasons=[GAPI.USER_NOT_FOUND],
                           userKey=user)
      _showASPs(user, asps, i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)

def _showBackupCodes(user, codes, i, count):
  Act.Set(Act.SHOW)
  jcount = 0
  for code in codes:
    if code.get(u'verificationCode'):
      jcount += 1
  entityPerformActionNumItems([Ent.USER, user], jcount, Ent.BACKUP_VERIFICATION_CODES, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Ind.Increment()
  j = 0
  for code in codes:
    j += 1
    printKeyValueList([u'{0:2}'.format(j), code.get(u'verificationCode')])
  Ind.Decrement()

# gam <UserTypeEntity> update backupcodes|verificationcodes
def updateBackupCodes(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.verificationCodes(), u'generate',
               throw_reasons=[GAPI.USER_NOT_FOUND],
               userKey=user)
      codes = callGAPIitems(cd.verificationCodes(), u'list', u'items',
                            throw_reasons=[GAPI.USER_NOT_FOUND],
                            userKey=user, fields=u'items(verificationCode)')
      _showBackupCodes(user, codes, i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete backupcodes|verificationcodes
def deleteBackupCodes(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.verificationCodes(), u'invalidate',
               throw_reasons=[GAPI.USER_NOT_FOUND],
               userKey=user)
      printEntityKVList([Ent.USER, user], [Ent.Plural(Ent.BACKUP_VERIFICATION_CODES), u'', u'Invalidated'], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> show backupcodes|verificationcodes
def showBackupCodes(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      codes = callGAPIitems(cd.verificationCodes(), u'list', u'items',
                            throw_reasons=[GAPI.USER_NOT_FOUND],
                            userKey=user, fields=u'items(verificationCode)')
      _showBackupCodes(user, codes, i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)

def _getCalendarSelectProperty(myarg, kwargs):
  if myarg == u'minaccessrole':
    kwargs[u'minAccessRole'] = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  elif myarg == u'showdeleted':
    kwargs[u'showDeleted'] = True
  elif myarg == u'showhidden':
    kwargs[u'showHidden'] = True
  else:
    return False
  return True

def initCalendarEntity():
  return {u'list': [], u'kwargs': {}, u'dict': None, u'all': False, u'primary': False, u'resourceIds': []}

def getCalendarEntity(default=u'primary', noSelectionKwargs=None):

  def _noSelectionMade():
    return (not calendarEntity[u'list'] and not calendarEntity[u'kwargs'] and calendarEntity[u'dict'] is None and
            not calendarEntity[u'all'] and not calendarEntity[u'primary'] and not calendarEntity[u'resourceIds'])

  calendarEntity = initCalendarEntity()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'calendar', u'calendars']:
      entitySelector = getEntitySelector()
      if entitySelector:
        entityList = getEntitySelection(entitySelector, False)
        if isinstance(entityList, dict):
          calendarEntity[u'dict'] = entityList
        else:
          calendarEntity[u'list'] = entityList
      else:
        calendarEntity[u'list'].extend(convertEntityToList(getString(Cmd.OB_EMAIL_ADDRESS)))
    elif myarg == u'allcalendars':
      calendarEntity[u'all'] = True
    elif myarg == u'primary':
      calendarEntity[u'primary'] = True
    elif _getCalendarSelectProperty(myarg, calendarEntity[u'kwargs']):
      pass
    elif myarg == u'resource':
      calendarEntity[u'resourceIds'].append(getString(Cmd.OB_RESOURCE_ID))
    elif myarg == u'resources':
      calendarEntity[u'resourceIds'].extend(convertEntityToList(getString(Cmd.OB_RESOURCE_ID, minLen=0), shlexSplit=True))
    elif _noSelectionMade() and myarg.find(u'@') != -1:
      calendarEntity[u'list'].extend(convertEntityToList(Cmd.Previous().lower()))
    else:
      Cmd.Backup()
      break
  if _noSelectionMade():
    if not noSelectionKwargs:
      calendarEntity[default] = True
    else:
      calendarEntity[u'all'] = True
      calendarEntity[u'kwargs'].update(noSelectionKwargs)
  return calendarEntity

def _validateUserGetCalendarIds(user, i, count, calendarEntity, itemType=None, modifier=None, showAction=True, setRC=True, newCalId=None):
  if calendarEntity[u'dict']:
    calIds = calendarEntity[u'dict'][user][:]
  else:
    calIds = calendarEntity[u'list'][:]
  user, cal = validateCalendar(user, i, count)
  if not cal:
    return (user, None, None, 0)
  if calendarEntity[u'resourceIds']:
    cd = buildGAPIObject(API.DIRECTORY)
    for resourceId in calendarEntity[u'resourceIds']:
      try:
        calIds.append(callGAPI(cd.resources().calendars(), u'get',
                               throw_reasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, fields=u'resourceEmail')[u'resourceEmail'])
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)
        return (user, None, None, 0)
  if calendarEntity[u'primary']:
    calIds.append(user)
  try:
    if calendarEntity[u'kwargs'] or calendarEntity[u'all']:
      result = callGAPIpages(cal.calendarList(), u'list', u'items',
                             throw_reasons=GAPI.CALENDAR_THROW_REASONS,
                             fields=u'nextPageToken,items/id', **calendarEntity[u'kwargs'])
      calIds.extend([calId[u'id'] for calId in result])
    else:
      callGAPI(cal.calendars(), u'get',
               throw_reasons=GAPI.CALENDAR_THROW_REASONS,
               calendarId=u'primary', fields=u'')
  except GAPI.notACalendarUser as e:
    entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    return (user, None, None, 0)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return (user, None, None, 0)
  if newCalId:
    newcal = buildGAPIObject(API.CALENDAR)
    if not checkCalendarExists(newcal, newCalId):
      entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, newCalId], Msg.DOES_NOT_EXIST, i, count)
      return (user, None, None, 0)
  jcount = len(calIds)
  if setRC and jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if showAction:
    if not itemType:
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.CALENDAR, i, count)
    elif not newCalId:
      entityPerformActionSubItemModifierNumItems([Ent.USER, user], itemType, modifier, jcount, Ent.CALENDAR, i, count)
    else:
      entityPerformActionSubItemModifierNumItemsModifierNewValue([Ent.USER, user], itemType, modifier, jcount, Ent.CALENDAR, Act.MODIFIER_TO, newCalId, i, count)
  return (user, cal, calIds, jcount)

CALENDAR_NOTIFICATION_METHODS = [u'email', u'sms',]
CALENDAR_NOTIFICATION_TYPES_MAP = {
  u'eventcreation': u'eventCreation',
  u'eventchange': u'eventChange',
  u'eventcancellation': u'eventCancellation',
  u'eventresponse': u'eventResponse',
  u'agenda': u'agenda',
  }

def _getCalendarAttributes(body):
  colorRgbFormat = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'selected':
      body[u'selected'] = getBoolean()
    elif myarg == u'hidden':
      body[u'hidden'] = getBoolean()
    elif myarg == u'summary':
      body[u'summaryOverride'] = getString(Cmd.OB_STRING)
    elif myarg in [u'colorindex', u'colorid']:
      body[u'colorId'] = str(getInteger(minVal=CALENDAR_MIN_COLOR_INDEX, maxVal=CALENDAR_MAX_COLOR_INDEX))
    elif myarg == u'backgroundcolor':
      body[u'backgroundColor'] = getColor()
      body.setdefault(u'foregroundColor', u'#000000')
      colorRgbFormat = True
    elif myarg == u'foregroundcolor':
      body[u'foregroundColor'] = getColor()
      colorRgbFormat = True
    elif myarg == u'reminder':
      body.setdefault(u'defaultReminders', [])
      if not checkArgumentPresent(Cmd.CLEAR_NONE_ARGUMENT):
        body[u'defaultReminders'].append(getCalendarReminder(True))
    elif myarg == u'notification':
      body.setdefault(u'notificationSettings', {u'notifications': []})
      method = getChoice(CALENDAR_NOTIFICATION_METHODS+Cmd.CLEAR_NONE_ARGUMENT)
      if method not in Cmd.CLEAR_NONE_ARGUMENT:
        body[u'notificationSettings'][u'notifications'].append({u'method': method,
                                                                u'type': getChoice(CALENDAR_NOTIFICATION_TYPES_MAP, mapChoice=True)})
    else:
      unknownArgumentExit()
  return colorRgbFormat

def _showCalendar(userCalendar, j, jcount, formatJSON, acls=None):
  if formatJSON:
    if acls:
      userCalendar[u'acls'] = [{u'id': rule[u'id'], u'role': rule[u'role']} for rule in acls]
    printLine(json.dumps(cleanJSON(userCalendar, u''), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.CALENDAR, userCalendar[u'id']], j, jcount)
  Ind.Increment()
  printKeyValueList([u'Summary', userCalendar.get(u'summaryOverride', userCalendar[u'summary'])])
  printKeyValueWithCRsNLs(u'Description', userCalendar.get(u'description', u''))
  printKeyValueList([u'Location', userCalendar.get(u'location', u'')])
  printKeyValueList([u'Timezone', userCalendar[u'timeZone']])
  printKeyValueList([u'Primary', userCalendar.get(u'primary', FALSE)])
  printKeyValueList([u'Access Level', userCalendar[u'accessRole']])
  printKeyValueList([u'Hidden', userCalendar.get(u'hidden', FALSE)])
  printKeyValueList([u'Selected', userCalendar.get(u'selected', FALSE)])
  printKeyValueList([u'Color ID', userCalendar[u'colorId'], u'Background Color', userCalendar[u'backgroundColor'], u'Foreground Color', userCalendar[u'foregroundColor']])
  printKeyValueList([u'ConferenceProperties', None])
  Ind.Increment()
  printKeyValueList([u'AllowedConferenceSolutionTypes', u','.join(userCalendar.get(u'conferenceProperties', {}).get(u'allowedConferenceSolutionTypes', []))])
  Ind.Decrement()
  printKeyValueList([u'Default Reminders', None])
  Ind.Increment()
  for reminder in userCalendar.get(u'defaultReminders', []):
    printKeyValueList([u'Method', reminder[u'method'], u'Minutes', reminder[u'minutes']])
  Ind.Decrement()
  printKeyValueList([u'Notifications', None])
  Ind.Increment()
  if u'notificationSettings' in userCalendar:
    for notification in userCalendar[u'notificationSettings'].get(u'notifications', []):
      printKeyValueList([u'Method', notification[u'method'], u'Type', notification[u'type']])
  Ind.Decrement()
  if acls:
    printKeyValueList([u'ACLs', None])
    Ind.Increment()
    for rule in acls:
      printKeyValueList(ACLRuleKeyValueList(rule))
    Ind.Decrement()
  Ind.Decrement()

# Process CalendarList functions
def _processCalendarList(user, calId, j, jcount, cal, function, **kwargs):
  try:
    callGAPI(cal.calendarList(), function,
             throw_reasons=[GAPI.NOT_FOUND, GAPI.DUPLICATE, GAPI.CANNOT_CHANGE_OWN_ACL],
             **kwargs)
    entityActionPerformed([Ent.USER, user, Ent.CALENDAR, calId], j, jcount)
  except (GAPI.notFound, GAPI.duplicate, GAPI.cannotChangeOwnAcl) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, calId], str(e), j, jcount)

# gam <UserTypeEntity> add calendars <CalendarAddEntity> <CalendarAttributes>
def addCalendars(users):
  calendarEntity = getCalendarEntity()
  body = {u'selected': True, u'hidden': False}
  colorRgbFormat = _getCalendarAttributes(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      body[u'id'] = calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, u'insert',
                           body=body, colorRgbFormat=colorRgbFormat, fields=u'')
    Ind.Decrement()

def _updateDeleteCalendars(users, calendarEntity, function, **kwargs):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, function,
                           calendarId=calId, **kwargs)
    Ind.Decrement()

# gam <UserTypeEntity> update calendars <CalendarEntity> <CalendarAttributes>
def updateCalendars(users):
  calendarEntity = getCalendarEntity()
  body = {}
  colorRgbFormat = _getCalendarAttributes(body)
  _updateDeleteCalendars(users, calendarEntity, u'patch', body=body, colorRgbFormat=colorRgbFormat, fields=u'')

# gam <UserTypeEntity> delete calendars <CalendarEntity>
def deleteCalendars(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  _updateDeleteCalendars(users, calendarEntity, u'delete')

# gam <UserTypeEntity> info calendars <CalendarEntity> [formatjson]
def infoCalendars(users):
  calendarEntity = getCalendarEntity()
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, showAction=not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      try:
        result = callGAPI(cal.calendarList(), u'get',
                          throw_reasons=[GAPI.NOT_FOUND, GAPI.DUPLICATE, GAPI.CANNOT_CHANGE_OWN_ACL],
                          calendarId=calId)
        _showCalendar(result, j, jcount, formatJSON)
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, calId], str(e), j, jcount)
    Ind.Decrement()

# gam <UserTypeEntity> create calendars <CalendarSettings>
def createCalendar(users):
  calendarEntity = initCalendarEntity()
  body = _getCalendarSettings(summaryRequired=True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, _, _ = _validateUserGetCalendarIds(user, i, count, calendarEntity, showAction=False, setRC=False)
    if not cal:
      continue
    try:
      calId = callGAPI(cal.calendars(), u'insert',
                       throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.FORBIDDEN],
                       body=body, fields=u'id')[u'id']
      entityActionPerformed([Ent.USER, user, Ent.CALENDAR, calId], i, count)
    except (GAPI.notACalendarUser, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def addCreateCalendars(users):
  if Act.Get() == Act.ADD:
    addCalendars(users)
  else:
    createCalendar(users)

def _modifyRemoveCalendars(users, calendarEntity, function, **kwargs):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      try:
        callGAPI(cal.calendars(), function,
                 throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.CANNOT_DELETE_PRIMARY_CALENDAR, GAPI.FORBIDDEN],
                 calendarId=calId, **kwargs)
        entityActionPerformed([Ent.USER, user, Ent.CALENDAR, calId], j, jcount)
      except (GAPI.notFound, GAPI.cannotDeletePrimaryCalendar, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, calId], str(e), j, jcount)
      except GAPI.notACalendarUser as e:
        entityActionFailedWarning([Ent.USER, user], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> modify calendars <CalendarEntity> <CalendarSettings>
def modifyCalendars(users):
  calendarEntity = getCalendarEntity()
  body = _getCalendarSettings(summaryRequired=False)
  _modifyRemoveCalendars(users, calendarEntity, u'patch', body=body)

# gam <UserTypeEntity> remove calendars <CalendarEntity>
def removeCalendars(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  _modifyRemoveCalendars(users, calendarEntity, u'delete')

CALENDAR_SIMPLE_LISTS = set([u'allowedConferenceSolutionTypes',])

def _printShowCalendars(users, csvFormat):

  def _getPermissions(cal, userCalendar):
    if userCalendar[u'accessRole'] == u'owner':
      try:
        return callGAPIpages(cal.acl(), u'list', u'items',
                             throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
                             calendarId=userCalendar[u'id'], fields=u'nextPageToken,items(id,role,scope)')
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.notACalendarUser, GAPI.notFound):
        pass
    return collections.deque()

  acls = collections.deque()
  primary = showPermissions = False
  sortTitles = [u'primaryEmail', u'calendarId']
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  kwargs = {}
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
      showPermissions = True
    elif myarg == u'allcalendars':
      pass
    elif myarg == u'primary':
      primary = True
    elif _getCalendarSelectProperty(myarg, kwargs):
      pass
    elif myarg == "formatjson":
      formatJSON = True
      if csvFormat:
        addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal = validateCalendar(user, i, count)
    if not cal:
      continue
    try:
      calendars = callGAPIpages(cal.calendarList(), u'list', u'items',
                                throw_reasons=GAPI.CALENDAR_THROW_REASONS,
                                **kwargs)
      if primary:
        for calendar in calendars:
          if calendar.get(u'primary', False):
            calendars = collections.deque([calendar])
            break
        else:
          calendars = collections.deque()
      jcount = len(calendars)
      if not csvFormat:
        if not formatJSON:
          entityPerformActionNumItems([Ent.USER, user], jcount, Ent.CALENDAR, i, count)
        Ind.Increment()
        j = 0
        for calendar in calendars:
          j += 1
          if showPermissions:
            acls = _getPermissions(cal, calendar)
          _showCalendar(calendar, j, jcount, formatJSON, acls)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.CALENDAR, user, i, count)
        if not formatJSON:
          if calendars:
            for calendar in calendars:
              row = {u'primaryEmail': user, u'calendarId': calendar.pop(u'id')}
              if showPermissions:
                flattenJSON(_getPermissions(cal, calendar), key=u'permissions', flattened=row)
              addRowTitlesToCSVfile(flattenJSON(calendar, flattened=row, simpleLists=CALENDAR_SIMPLE_LISTS), csvRows, titles)
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
            csvRows.append({u'primaryEmail': user})
        else:
          if calendars:
            for calendar in calendars:
              if showPermissions:
                calendar[u'acls'] = [{u'id': rule[u'id'], u'role': rule[u'role']} for rule in _getPermissions(cal, calendar)]
              csvRows.append({u'primaryEmail': user, u'calendarId': calendar[u'id'],
                              u'JSON': json.dumps(cleanJSON(calendar, u''), ensure_ascii=False, sort_keys=True)})
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
            csvRows.append({u'primaryEmail': user})
    except GAPI.notACalendarUser as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Calendars', todrive, sortTitles, quotechar)

# gam <UserTypeEntity> print calendars <CalendarPrintShowEntity> [todrive [<ToDriveAttributes>]] [permissions]
#	[formatjson] [quotechar <Character>}
def printCalendars(users):
  _printShowCalendars(users, True)

# gam <UserTypeEntity> show calendars <CalendarPrintShowEntity> [permissions] [formatjson]
def showCalendars(users):
  _printShowCalendars(users, False)

def _printShowCalSettings(users, csvFormat):
  if csvFormat:
    todrive = {}
    sortTitles = [u'User',]
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == "formatjson":
      formatJSON = True
      if csvFormat:
        addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal = validateCalendar(user, i, count)
    if not cal:
      continue
    try:
      feed = callGAPIpages(cal.settings(), u'list', u'items',
                           throw_reasons=GAPI.CALENDAR_THROW_REASONS)
      settings = {}
      for setting in feed:
        settings[setting[u'id']] = setting[u'value']
      if not csvFormat:
        if not formatJSON:
          printEntityKVList([Ent.USER, user], [Ent.Plural(Ent.CALENDAR_SETTINGS), None], i, count)
          Ind.Increment()
          for attr in sorted(settings):
            printKeyValueList([attr, settings[attr]])
          Ind.Decrement()
        else:
          printLine(json.dumps({u'User': user, u'settings': settings}, ensure_ascii=False, sort_keys=True))
      else:
        if not formatJSON:
          addRowTitlesToCSVfile(flattenJSON(settings, flattened={u'User': user}), csvRows, titles)
        else:
          csvRows.append({u'User': user, u'JSON': json.dumps(settings, ensure_ascii=False, sort_keys=True)})
    except GAPI.notACalendarUser as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Calendar Settings', todrive, sortTitles, quotechar)

# gam <UserTypeEntity> print calsettings  [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>}
def printCalSettings(users):
  _printShowCalSettings(users, True)

# gam <UserTypeEntity> show calsettings [formatjson]
def showCalSettings(users):
  _printShowCalSettings(users, False)

# gam <UserTypeEntity> create|add calendaracls <CalendarEntity> <CalendarACLRole> <CalendarACLScopeEntity>
def createCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, Act.MODIFIER_TO)
    if jcount == 0:
      continue
    Ind.Increment()
    _doCalendarsCreateACLs(origUser, user, cal, calIds, jcount, role, ACLScopeEntity)
    Ind.Decrement()

def updateDeleteCalendarACLs(users, calendarEntity, function, modifier, role, body):
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, modifier)
    if jcount == 0:
      continue
    Ind.Increment()
    _doUpdateDeleteCalendarACLs(origUser, user, cal, function, calIds, jcount, ACLScopeEntity, role, body)
    Ind.Decrement()

# gam <UserTypeEntity> update calendaracls <CalendarEntity> <CalendarACLRole> <CalendarACLScopeEntity>
def updateCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  body = {u'role': role}
  updateDeleteCalendarACLs(users, calendarEntity, u'patch', Act.MODIFIER_IN, role, body)

# gam <UserTypeEntity> delete calendaracls <CalendarEntity> [<CalendarACLRole>] <CalendarACLScopeEntity>
def deleteCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  role = getChoice(CALENDAR_ACL_ROLES_MAP, defaultChoice=None, mapChoice=True)
  body = {}
  updateDeleteCalendarACLs(users, calendarEntity, u'delete', Act.MODIFIER_FROM, role, body)

# gam <UserTypeEntity> info calendaracls <CalendarEntity> <CalendarACLScopeEntity> [formatjson]
def infoCalendarACLs(users):
  calendarEntity = getCalendarEntity()
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  formatJSON = _getCalendarInfoACLEventOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, Act.MODIFIER_FROM, showAction=not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    _doInfoCalendarACLs(origUser, user, cal, calIds, jcount, ACLScopeEntity, formatJSON)
    Ind.Decrement()

def printShowCalendarACLs(users, csvFormat):
  calendarEntity = getCalendarEntity(default=u'all')
  todrive, formatJSON, quotechar, sortTitles = _getCalendarPrintShowACLOptions(csvFormat, Ent.USER)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  else:
    titles = csvRows = None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, Act.MODIFIER_FROM, showAction=not csvFormat and not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = convertUIDtoEmailAddress(calId)
      _printShowCalendarACLs(cal, user, Ent.CALENDAR, calId, j, jcount, csvFormat, formatJSON, csvRows, titles)
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Calendar ACLs', todrive, sortTitles, quotechar)

# gam <UserTypeEntity> print calendaracls <CalendarEntity> [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>]
def printCalendarACLs(users):
  printShowCalendarACLs(users, True)

# gam <UserTypeEntity> show calendaracls <CalendarEntity> [formatjson]
def showCalendarACLs(users):
  printShowCalendarACLs(users, False)

# gam <UserTypeEntity> transfer calendars <UserItem> <CalendarEntity> [keepuser | (retainrole <CalendarACLRole>)] [noretentionmessages]
def transferCalendars(users):
  targetUser = getEmailAddress()
  calendarEntity = getCalendarEntity(noSelectionKwargs={u'minAccessRole': u'owner', u'showHidden': True})
  giveForbiddenWarnings = not calendarEntity[u'all']
  retainRoleBody = {u'role': u'none'}
  showRetentionMessages = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'keepuser':
      retainRoleBody[u'role'] = u'owner'
    elif myarg == u'retainrole':
      retainRoleBody[u'role'] = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
    elif myarg == u'noretentionmessages':
      showRetentionMessages = False
    else:
      unknownArgumentExit()
  targetUser, targetCal = validateCalendar(targetUser)
  if not targetCal:
    return
  targetRoleBody = {u'role': u'owner', u'scope': {u'type': u'user', u'value': targetUser}}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    Act.Set(Act.TRANSFER_OWNERSHIP)
    user, sourceCal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    sourceRuleId = u'{0}:{1}'.format(u'user', user)
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      Act.Set(Act.TRANSFER_OWNERSHIP)
      if calId.find(u'@group.calendar.google.com') == -1:
        entityActionNotPerformedWarning([Ent.CALENDAR, calId], [None, Msg.FORBIDDEN][giveForbiddenWarnings], j, jcount)
        continue
      try:
        callGAPI(sourceCal.acl(), u'insert',
                 throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.FORBIDDEN],
                 calendarId=calId, body=targetRoleBody, fields=u'')
        entityModifierNewValueItemValueListActionPerformed([Ent.CALENDAR, calId], Act.MODIFIER_TO, None, [Ent.USER, targetUser], j, jcount)
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
        continue
      except (GAPI.notFound, GAPI.invalid):
        entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
        continue
      Act.Set(Act.RETAIN)
      if retainRoleBody[u'role'] != u'none':
        try:
          callGAPI(targetCal.acl(), u'patch',
                   throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.INVALID_SCOPE_VALUE, GAPI.ILLEGAL_ACCESS_ROLE_FOR_DEFAULT,
                                  GAPI.CANNOT_CHANGE_OWN_ACL, GAPI.CANNOT_CHANGE_OWNER_ACL, GAPI.FORBIDDEN],
                   calendarId=calId, ruleId=sourceRuleId, body=retainRoleBody, fields=u'')
          if showRetentionMessages:
            entityActionPerformed([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody[u'role'])], j, jcount)
        except GAPI.notFound as e:
          if not checkCalendarExists(targetCal, calId):
            entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
          else:
            entityActionFailedWarning([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody[u'role'])], str(e), j, jcount)
        except (GAPI.invalid, GAPI.invalidParameter, GAPI.invalidScopeValue, GAPI.illegalAccessRoleForDefault, GAPI.forbidden, GAPI.cannotChangeOwnAcl, GAPI.cannotChangeOwnerAcl) as e:
          entityActionFailedWarning([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody[u'role'])], str(e), j, jcount)
      else:
        try:
          callGAPI(targetCal.acl(), u'delete',
                   throw_reasons=[GAPI.NOT_FOUND, GAPI.INVALID],
                   calendarId=calId, ruleId=sourceRuleId)
          if showRetentionMessages:
            entityActionPerformed([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody[u'role'])], j, jcount)
        except (GAPI.notFound, GAPI.invalid):
          entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
    Ind.Decrement()

def _createImportCalendarEvent(users, function):
  calendarEntity = getCalendarEntity()
  body, parameters = _getCalendarCreateImportEventOptions(function)
  eventRecurrenceTimeZoneRequired = _checkIfEventRecurrenceTimeZoneRequired(body, parameters)
  sendNotifications = parameters[u'sendNotifications']
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_TO)
    if jcount == 0:
      continue
    Ind.Increment()
    status = _createCalendarEvents(user, cal, function, calIds, jcount,
                                   eventRecurrenceTimeZoneRequired, sendNotifications, body)
    Ind.Decrement()
    if not status:
      return

# gam <UserTypeEntity> create|add event <CalendarEntity> [id <String>] <EventAddAttributes>+
def createCalendarEvent(users):
  _createImportCalendarEvent(users, u'insert')

# gam <UserTypeEntity> import event <CalendarEntity> icaluid <iCalUID> <EventImportAttributes>+
def importCalendarEvent(users):
  _createImportCalendarEvent(users, u'import')

# gam <UserTypeEntity> update events <CalendarEntity> <EventEntity> <EventUpdateAttributes>+
def updateCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  body, parameters = _getCalendarUpdateEventOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_IN)
    if jcount == 0:
      continue
    Ind.Increment()
    status = _updateDeleteCalendarEvents(origUser, user, cal, calIds, jcount, u'patch', calendarEventEntity, True,
                                         _checkIfEventRecurrenceTimeZoneRequired(body, parameters), body,
                                         {u'supportsAttachments': True, u'body': body, u'sendNotifications': parameters[u'sendNotifications'], u'fields': u''})
    Ind.Decrement()
    if not status:
      return

# gam <UserTypeEntity> delete events <CalendarEntity> <EventEntity> [doit] [notifyattendees]
def deleteCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  doIt, sendNotifications = _getCalendarDeleteEventOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM)
    if jcount == 0:
      continue
    Ind.Increment()
    _updateDeleteCalendarEvents(origUser, user, cal, calIds, jcount, u'delete', calendarEventEntity, doIt,
                                False, {}, {u'sendNotifications': sendNotifications})
    Ind.Decrement()

# gam <UserTypeEntity> wipe events <CalendarEntity>
def wipeCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM)
    if jcount == 0:
      continue
    Ind.Increment()
    _wipeCalendarEvents(user, cal, calIds, jcount)
    Ind.Decrement()

# gam <UserTypeEntity> move events <CalendarEntity> <EventEntity> to <CalendarItem> [notifyattendees]
def moveCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  checkArgumentPresent(u'to')
  newCalId = convertUIDtoEmailAddress(getString(Cmd.OB_CALENDAR_ITEM))
  sendNotifications = _getMoveEventsOptions()
  if not checkCalendarExists(None, newCalId, True):
    return
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM, newCalId=newCalId)
    if jcount == 0:
      continue
    Ind.Increment()
    _moveCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, newCalId, sendNotifications)
    Ind.Decrement()

# gam <UserTypeEntity> update calattendees <CalendarEntity> <EventEntity> [anyorganizer]
#	[csv <FileName>] (replace <EmailAddress> <EmailAddress>)* (delete <EmailAddress>)* [doit]
def updateCalendarAttendees(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  csv_file = None
  anyOrganizer = doIt = False
  attendee_map = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'csv':
      csv_file = getString(Cmd.OB_FILE_NAME)
    elif myarg == u'replace':
      origAttendee = getEmailAddress(noUid=True)
      attendee_map[origAttendee] = getEmailAddress(noUid=True)
    elif myarg == u'delete':
      origAttendee = getEmailAddress(noUid=True)
      attendee_map[origAttendee] = u'delete'
    elif myarg == u'doit':
      doIt = True
    elif myarg in [u'anyorganizer', u'allevents']:
      anyOrganizer = True
    else:
      unknownArgumentExit()
  if not attendee_map:
    missingChoiceExit([u'(csv <FileName>)', u'(replace <EmailAddress> <EmailAddress>)', u'(delete <EmailAddress>)'])
  if csv_file:
    f = openFile(csv_file)
    csvFile = csv.reader(f)
    for row in csvFile:
      if len(row) >= 2:
        attendee_map[row[0].lower()] = row[1].lower()
    closeFile(f)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      Act.Set(Act.UPDATE)
      calId, cal, events, kcount = _validateCalendarGetEvents(origUser, user, cal, calId, j, jcount, calendarEventEntity, True)
      if kcount == 0:
        continue
      Ind.Increment()
      k = 0
      for event in events:
        k += 1
        Act.Set(Act.REPLACE)
        if event[u'status'] == u'cancelled':
          continue
        event_summary = convertUTF8(event.get(u'summary', event[u'id']))
        if not anyOrganizer and not event.get(u'organizer', {}).get(u'self'):
          continue
        needs_update = False
        for attendee in event.get(u'attendees', []):
          if u'email' in attendee:
            old_email = attendee[u'email'].lower()
            new_email = attendee_map.get(old_email)
            if new_email:
              event[u'attendees'].remove(attendee)
              if new_email != u'delete':
                event[u'attendees'].append({u'email': new_email})
                entityModifierNewValueActionPerformed([Ent.EVENT, event_summary, Ent.ATTENDEE, old_email], Act.MODIFIER_WITH, new_email, k, kcount)
              else:
                Act.Set(Act.DELETE)
                entityActionPerformed([Ent.EVENT, event_summary, Ent.ATTENDEE, old_email], k, kcount)
                Act.Set(Act.UPDATE)
              needs_update = True
        if needs_update:
          Act.Set(Act.UPDATE)
          if doIt:
            try:
              callGAPI(cal.events(), u'patch',
                       throw_reasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                       calendarId=calId, eventId=event[u'id'], sendNotifications=False, body={u'attendees': event[u'attendees']}, fields=u'')
              entityActionPerformed([Ent.EVENT, event_summary], j, jcount)
            except GAPI.notFound as e:
              if not checkCalendarExists(cal, calId):
                entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
                break
              else:
                entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, event_summary], str(e), k, kcount)
            except (GAPI.notACalendarUser, GAPI.forbidden) as e:
              entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
              break
            except (GAPI.serviceNotAvailable, GAPI.authError):
              entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
              break
          else:
            entityActionNotPerformedWarning([Ent.EVENT, event_summary], Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> info events <CalendarEntity> <EventEntity> [formatjson]
def infoCalendarEvents(users):
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  formatJSON = _getCalendarInfoACLEventOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_IN, showAction=not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    _infoCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, formatJSON)
    Ind.Decrement()

def printShowCalendarEvents(users, csvFormat):
  todrive = {}
  calendarEntity = getCalendarEntity()
  calendarEventEntity = getCalendarEventEntity(noIds=True)
  todrive, formatJSON, quotechar, sortTitles = _getCalendarPrintShowEventOptions(calendarEventEntity, csvFormat, Ent.USER)
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  else:
    titles = csvRows = None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM, showAction=not csvFormat and not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    _printShowCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, csvFormat, formatJSON, csvRows, titles)
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Calendar Events', todrive, sortTitles, quotechar)

# gam <UserTypeEntity> print events <CalendarPrintShowEntity> <EventSelectProperties>* <EventDisplayProperties>*
#	[formatjson] [quotechar <Character>] [todrive [<ToDriveAttributes>]]
def printCalendarEvents(users):
  printShowCalendarEvents(users, True)

# gam <UserTypeEntity> show events <CalendarPrintShowEntity> <EventSelectProperties>* <EventDisplayProperties>* [formatjson]
def showCalendarEvents(users):
  printShowCalendarEvents(users, False)

def _getEntityMimeType(fileEntry):
  return [Ent.DRIVE_FILE, Ent.DRIVE_FOLDER][fileEntry[u'mimeType'] == MIMETYPE_GA_FOLDER]

CORPORA_CHOICE_MAP = {
  u'allteamdrives': u'allTeamDrives,user',
  u'domain': u'domain',
  u'onlyteamdrives': u'allTeamDrives,user',
  u'user': u'user',
  }

def _getCorpora(kwargs):
  corpora = getChoice(CORPORA_CHOICE_MAP)
  kwargs[u'corpora'] = CORPORA_CHOICE_MAP[corpora]
  kwargs[u'includeTeamDriveItems'] = kwargs[u'supportsTeamDrives'] = True
  return corpora == u'onlyteamdrives'

QUERY_SHORTCUTS_MAP = {
  u'allfiles': u"mimeType != '{0}'".format(MIMETYPE_GA_FOLDER),
  u'allfolders': u"mimeType = '{0}'".format(MIMETYPE_GA_FOLDER),
  u'allgooglefiles': u"mimeType != '{0}' and mimeType contains 'vnd.google'".format(MIMETYPE_GA_FOLDER),
  u'allnongooglefiles': u"not mimeType contains 'vnd.google'",
  u'allitems': u'',
  u'myfiles': ME_IN_OWNERS_AND+u"mimeType != '{0}'".format(MIMETYPE_GA_FOLDER),
  u'myfolders': ME_IN_OWNERS_AND+u"mimeType = '{0}'".format(MIMETYPE_GA_FOLDER),
  u'mygooglefiles': ME_IN_OWNERS_AND+u"mimeType != '{0}' and mimeType contains 'vnd.google'".format(MIMETYPE_GA_FOLDER),
  u'mynongooglefiles': ME_IN_OWNERS_AND+u"not mimeType contains 'vnd.google'",
  u'myitems': ME_IN_OWNERS,
  u'othersfiles': NOT_ME_IN_OWNERS_AND+u"mimeType != '{0}'".format(MIMETYPE_GA_FOLDER),
  u'othersfolders': NOT_ME_IN_OWNERS_AND+u"mimeType = '{0}'".format(MIMETYPE_GA_FOLDER),
  u'othersgooglefiles': NOT_ME_IN_OWNERS_AND+u"mimeType != '{0}' and mimeType contains 'vnd.google'".format(MIMETYPE_GA_FOLDER),
  u'othersnongooglefiles': NOT_ME_IN_OWNERS_AND+u"not mimeType contains 'vnd.google'",
  u'othersitems': NOT_ME_IN_OWNERS,
  u'writablefiles': u"'me' in writers and mimeType != '{0}'".format(MIMETYPE_GA_FOLDER),
  }
TEAMDRIVE_QUERY_SHORTCUTS_MAP = {
  u'allfiles': u"mimeType != '{0}'".format(MIMETYPE_GA_FOLDER),
  u'allfolders': u"mimeType = '{0}'".format(MIMETYPE_GA_FOLDER),
  u'allgooglefiles': u"mimeType != '{0}' and mimeType contains 'vnd.google'".format(MIMETYPE_GA_FOLDER),
  u'allnongooglefiles': u"not mimeType contains 'vnd.google'",
  u'allitems': u'',
  }

def doDriveSearch(drive, user, i, count, query=None, parentQuery=False, orderBy=None, teamDriveOnly=False, **kwargs):
  if GC.Values[GC.SHOW_GETTINGS]:
    printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
  try:
    files = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                          page_message=getPageMessageForWhom(),
                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.FILE_NOT_FOUND, GAPI.TEAMDRIVE_NOT_FOUND],
                          q=query, orderBy=orderBy, fields=u'nextPageToken,files(id,teamDriveId)', pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **kwargs)
    if files or not parentQuery:
      return [f_file[u'id'] for f_file in files if not teamDriveOnly or f_file.get(u'teamDriveId')]
    entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], emptyQuery(query, Ent.DRIVE_FOLDER), i, count)
  except (GAPI.invalidQuery, GAPI.invalid):
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(query), i, count)
  except GAPI.fileNotFound:
    printGotEntityItemsForWhom(0)
  except GAPI.teamDriveNotFound as e:
    entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, kwargs[u'teamDriveId']], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return None

def doTeamDriveSearch(drive, user, i, count, query, useDomainAdminAccess):
  if GC.Values[GC.SHOW_GETTINGS]:
    printGettingAllEntityItemsForWhom(Ent.TEAMDRIVE, user, i, count, query=query)
  try:
    files = callGAPIpages(drive.teamdrives(), u'list', u'teamDrives',
                          page_message=getPageMessageForWhom(),
                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.QUERY_REQUIRES_ADMIN_CREDENTIALS, GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                          q=query, useDomainAdminAccess=useDomainAdminAccess,
                          fields=u'nextPageToken,teamDrives(id)', pageSize=100)
    if files:
      return [f_file[u'id'] for f_file in files]
    entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], emptyQuery(query, Ent.TEAMDRIVE), i, count)
  except (GAPI.invalidQuery, GAPI.invalid):
    entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], invalidQuery(query), i, count)
  except (GAPI.queryRequiresAdminCredentials, GAPI.noListTeamDrivesAdministratorPrivilege) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return None

def cleanFileIDsList(fileIdEntity, fileIds):
  fileIdEntity[u'list'] = []
  fileIdEntity[u'root'] = []
  i = 0
  for fileId in fileIds:
    if fileId[:8].lower() == u'https://' or fileId[:7].lower() == u'http://':
      loc = fileId.find(u'/d/')
      if loc > 0:
        fileId = fileId[loc+3:]
        loc = fileId.find(u'/')
        if loc != -1:
          fileId = fileId[:loc]
      else:
        loc = fileId.find(u'/folderview?id=')
        if loc > 0:
          fileId = fileId[loc+15:]
          loc = fileId.find(u'&')
          if loc != -1:
            fileId = fileId[:loc]
        else:
          continue
    elif fileId.lower() == u'root':
      fileIdEntity[u'root'].append(i)
      fileId = fileId.lower()
    fileIdEntity[u'list'].append(fileId)
    i += 1

TITLE_QUERY_PATTERN = re.compile(r'title((?: *!?=)|(?: +contains))', flags=re.IGNORECASE)

def _mapDrive2QueryToDrive3(query):
  if query:
    query = TITLE_QUERY_PATTERN.sub(r'name\1', query).replace(u'modifiedDate', VX_MODIFIED_TIME).replace(u'lastViewedByMeDate', VX_VIEWED_BY_ME_TIME)
  return query

def escapeDriveFileName(filename):
  if filename.find(u"'") == -1 and filename.find(u'\\') == -1:
    return filename
  encfilename = u''
  for c in filename:
    if c == u"'":
      encfilename += u"\\'"
    elif c == u'\\':
      encfilename += u'\\\\'
    else:
      encfilename += c
  return encfilename

def getEscapedDriveFileName():
  return escapeDriveFileName(getString(Cmd.OB_DRIVE_FILE_NAME))

def getEscapedDriveFolderName():
  return escapeDriveFileName(getString(Cmd.OB_DRIVE_FOLDER_NAME))

def initDriveFileEntity():
  return {u'list': [], u'teamdrivename': None, u'teamdriveadminquery': None, u'query': None, u'teamdrivefilequery': None, u'dict': None, u'root': [], u'teamdrive': {}}

def getDriveFileEntity(orphansOK=False, queryShortcutsOK=True):
  def _getKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(u':', 1)
    kw = kw.lower().replace(u'_', u'').replace(u'-', u'')
    if kw == u'id':
      cleanFileIDsList(fileIdEntity, [value])
    elif kw == u'ids':
      cleanFileIDsList(fileIdEntity, value.replace(u',', u' ').split())
    elif kw == u'query':
      fileIdEntity[u'query'] = _mapDrive2QueryToDrive3(value)
    elif kw == u'drivefilename':
      fileIdEntity[u'query'] = VX_WITH_MY_FILE_NAME.format(escapeDriveFileName(value))
    elif kw in [u'anydrivefilename', u'anyownerdrivefilename', u'shareddrivefilename']:
      fileIdEntity[u'query'] = VX_WITH_ANY_FILE_NAME.format(escapeDriveFileName(value))
    else:
      return False
    return True

  def _getTDKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(u':', 1)
    kw = kw.lower().replace(u'_', u'').replace(u'-', u'')
    if kw == u'teamdriveid':
      fileIdEntity[u'teamdrive'][u'teamDriveId'] = value
    elif kw == u'teamdrive':
      fileIdEntity[u'teamdrivename'] = value
    elif kw == u'teamdriveadminquery':
      fileIdEntity[u'teamdriveadminquery'] = value
    elif kw == u'teamdrivefilename':
      fileIdEntity[u'teamdrivefilequery'] = VX_WITH_ANY_FILE_NAME.format(escapeDriveFileName(value))
    elif kw == u'teamdrivequery':
      fileIdEntity[u'teamdrivefilequery'] = _mapDrive2QueryToDrive3(value)
    else:
      return False
    return True

  fileIdEntity = initDriveFileEntity()
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      fileIdEntity[u'dict'] = entityList
    else:
      cleanFileIDsList(fileIdEntity, entityList)
  else:
    myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
    mycmd = myarg.lower().replace(u'_', u'').replace(u'-', u'')
    if mycmd == u'id':
      cleanFileIDsList(fileIdEntity, getStringReturnInList(Cmd.OB_DRIVE_FILE_ID))
    elif mycmd == u'ids':
      cleanFileIDsList(fileIdEntity, getString(Cmd.OB_DRIVE_FILE_ID).replace(u',', u' ').split())
    elif mycmd == u'drivefilename':
      fileIdEntity[u'query'] = VX_WITH_MY_FILE_NAME.format(getEscapedDriveFileName())
    elif mycmd in [u'anydrivefilename', u'anyownerdrivefilename', u'shareddrivefilename']:
      fileIdEntity[u'query'] = VX_WITH_ANY_FILE_NAME.format(getEscapedDriveFileName())
    elif mycmd == u'query':
      fileIdEntity[u'query'] = _mapDrive2QueryToDrive3(getString(Cmd.OB_QUERY))
    elif queryShortcutsOK and mycmd in QUERY_SHORTCUTS_MAP:
      fileIdEntity[u'query'] = QUERY_SHORTCUTS_MAP[mycmd]
    elif mycmd in [u'root', u'mydrive']:
      cleanFileIDsList(fileIdEntity, [u'root',])
    elif orphansOK and mycmd == u'orphans':
      cleanFileIDsList(fileIdEntity, [u'Orphans',])
    elif mycmd.startswith(u'teamdrive'):
      fileIdEntity[u'teamdrive'] = {u'teamDriveId': None,
                                    u'corpora': u'teamDrive', u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
      while True:
        if mycmd == u'teamdriveid':
          fileIdEntity[u'teamdrive'][u'teamDriveId'] = getString(Cmd.OB_TEAMDRIVE_ID)
        elif mycmd == u'teamdrive':
          fileIdEntity[u'teamdrivename'] = getString(Cmd.OB_TEAMDRIVE_NAME)
        elif mycmd == u'teamdriveadminquery':
          fileIdEntity[u'teamdriveadminquery'] = getString(Cmd.OB_QUERY)
        elif mycmd == u'teamdrivefilename':
          fileIdEntity[u'teamdrivefilequery'] = VX_WITH_ANY_FILE_NAME.format(getEscapedDriveFileName())
        elif mycmd == u'teamdrivequery':
          fileIdEntity[u'teamdrivefilequery'] = _mapDrive2QueryToDrive3(getString(Cmd.OB_QUERY))
        elif queryShortcutsOK and mycmd in TEAMDRIVE_QUERY_SHORTCUTS_MAP:
          fileIdEntity[u'teamdrivefilequery'] = TEAMDRIVE_QUERY_SHORTCUTS_MAP[mycmd]
        elif (mycmd.find(u':') > 0) and _getTDKeywordColonValue(myarg):
          pass
        else:
          unknownArgumentExit()
        if Cmd.ArgumentsRemaining():
          myarg = getString(Cmd.OB_STRING)
          mycmd = myarg.lower().replace(u'_', u'').replace(u'-', u'')
          if (mycmd.startswith(u'teamdriveparent') or
              (not mycmd.startswith(u'teamdrive')) and (not (queryShortcutsOK and mycmd in TEAMDRIVE_QUERY_SHORTCUTS_MAP))):
            Cmd.Backup()
            break
        else:
          break
      if not fileIdEntity[u'teamdrive'].get(u'teamDriveId'):
        fileIdEntity[u'teamdrive'][u'corpora'] = u'allTeamDrives,user'
    elif (mycmd.find(u':') > 0) and _getKeywordColonValue(myarg):
      pass
    else:
      cleanFileIDsList(fileIdEntity, [myarg])
  return fileIdEntity

def getTeamDriveEntity():
  def _getTDKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(u':', 1)
    kw = kw.lower().replace(u'_', u'').replace(u'-', u'')
    if kw == u'teamdriveid':
      fileIdEntity[u'teamdrive'][u'teamDriveId'] = value
    elif kw == u'teamdrive':
      fileIdEntity[u'teamdrivename'] = value
    else:
      return False
    return True

  fileIdEntity = initDriveFileEntity()
  myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  mycmd = myarg.lower().replace(u'_', u'').replace(u'-', u'')
  fileIdEntity[u'teamdrive'] = {u'teamDriveId': None,
                                u'corpora': u'teamDrive', u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
  if mycmd == u'teamdriveid':
    fileIdEntity[u'teamdrive'][u'teamDriveId'] = getString(Cmd.OB_TEAMDRIVE_ID)
  elif mycmd == u'teamdrive':
    fileIdEntity[u'teamdrivename'] = getString(Cmd.OB_TEAMDRIVE_NAME)
  elif (mycmd.find(u':') > 0) and _getTDKeywordColonValue(myarg):
    pass
  else:
    fileIdEntity[u'teamdrive'][u'teamDriveId'] = myarg
  return fileIdEntity

def _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity, useDomainAdminAccess=False):
  try:
    feed = callGAPIpages(drive.teamdrives(), u'list', u'teamDrives',
                         throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                         useDomainAdminAccess=useDomainAdminAccess,
                         fields=u'nextPageToken,teamDrives(id,name)', pageSize=100)
    tddrivenamelower = fileIdEntity[u'teamdrivename'].lower()
    for td in feed:
      if td[u'name'].lower() == tddrivenamelower:
        fileIdEntity[u'teamdrive'][u'teamDriveId'] = td[u'id']
#        fileIdEntity[u'teamdrivename'] = None
        return True
  except (GAPI.notFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
    pass
  entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_NAME, fileIdEntity[u'teamdrivename']], Msg.DOES_NOT_EXIST, i, count)
  return False

def _getTeamDriveNameFromId(drive, teamDriveId):
  try:
    return callGAPI(drive.teamdrives(), u'get',
                    throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND],
                    teamDriveId=teamDriveId, fields=u'name')[u'name']
  except (GAPI.teamDriveNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
    return TEAM_DRIVE

def _getDriveFileNameFromId(drive, fileId, combineTitleId=True):
  try:
    result = callGAPI(drive.files(), u'get',
                      throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                      fileId=fileId, fields=VX_FILENAME_MIMETYPE_TEAMDRIVEID, supportsTeamDrives=True)
    if result:
      fileName = result[VX_FILENAME]
      if (result[u'mimeType'] == MIMETYPE_GA_FOLDER) and (result[VX_FILENAME] == TEAM_DRIVE) and result.get(u'teamDriveId'):
        fileName = _getTeamDriveNameFromId(drive, result[u'teamDriveId'])
      if combineTitleId:
        fileName += u'('+fileId+u')'
      return (fileName, _getEntityMimeType(result))
  except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.internalError,
          GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
    pass
  return (fileId, Ent.DRIVE_FILE_OR_FOLDER_ID)

def _validateUserGetFileIDs(user, i, count, fileIdEntity, drive=None, entityType=None, orderBy=None, useDomainAdminAccess=False):
  if fileIdEntity[u'dict']:
    cleanFileIDsList(fileIdEntity, fileIdEntity[u'dict'][user])
  if not drive:
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      return (user, None, 0)
  else:
    user = convertUIDtoEmailAddress(user)
  if fileIdEntity[u'teamdrivename'] and u'teamDriveId' not in fileIdEntity:
    if not _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity):
      return (user, None, 0)
    if not fileIdEntity[u'teamdrivefilequery']:
      fileIdEntity[u'list'] = [fileIdEntity[u'teamdrive'][u'teamDriveId']]
    fileIdEntity[u'teamdrive'][u'corpora'] = u'teamDrive'
  elif fileIdEntity[u'teamdrive'].get(u'teamDriveId'):
    if not fileIdEntity[u'teamdrivefilequery']:
      fileIdEntity[u'list'] = [fileIdEntity[u'teamdrive'][u'teamDriveId']]
    fileIdEntity[u'teamdrive'][u'corpora'] = u'teamDrive'
  if fileIdEntity[u'query']:
    fileIdEntity[u'list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity[u'query'], orderBy=orderBy)
    if fileIdEntity[u'list'] is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
  elif fileIdEntity[u'teamdriveadminquery']:
    fileIdEntity[u'list'] = doTeamDriveSearch(drive, user, i, count, fileIdEntity[u'teamdriveadminquery'], useDomainAdminAccess)
    if fileIdEntity[u'list'] is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
  elif fileIdEntity[u'teamdrivefilequery']:
    if not fileIdEntity[u'teamdrive'].get(u'teamDriveId'):
      fileIdEntity[u'teamdrive'][u'corpora'] = u'allTeamDrives,user'
    fileIdEntity[u'list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity[u'teamdrivefilequery'], orderBy=orderBy, teamDriveOnly=True, **fileIdEntity[u'teamdrive'])
    if fileIdEntity[u'list'] is None or not fileIdEntity[u'list']:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
    fileIdEntity[u'teamdrive'].pop(u'teamDriveId', None)
    fileIdEntity[u'teamdrive'].pop(u'corpora', None)
  elif fileIdEntity[u'root']:
    try:
      rootFolderId = callGAPI(drive.files(), u'get',
                              throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                              fileId=u'root', fields=u'id')[u'id']
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return (user, None, 0)
    for j in fileIdEntity[u'root']:
      fileIdEntity[u'list'][j] = rootFolderId
  l = len(fileIdEntity[u'list'])
  if l == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if entityType:
    entityPerformActionNumItems([Ent.USER, user], l, entityType, i, count)
  return (user, drive, l)

def _getDriveFileParentInfo(user, i, count, body, parameters, drive):
  body.pop(u'parents', None)
  if parameters[DFA_PARENTID]:
    body.setdefault(u'parents', [])
    try:
      result = callGAPI(drive.files(), u'get',
                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND],
                        fileId=parameters[DFA_PARENTID], fields=u'id,mimeType')
      if result[u'mimeType'] != MIMETYPE_GA_FOLDER:
        entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                        u'parentid: {0}, {1}'.format(parameters[DFA_PARENTID], Msg.NOT_AN_ENTITY.format((Ent.Singular(Ent.DRIVE_FOLDER)))), i, count)
        return False
      body[u'parents'].append(result[u'id'])
    except GAPI.fileNotFound as e:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                      u'parentid: {0}, {1}'.format(parameters[DFA_PARENTID], str(e)), i, count)
      return False
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return False
  if parameters[DFA_PARENTQUERY]:
    parents = doDriveSearch(drive, user, i, count, query=parameters[DFA_PARENTQUERY], parentQuery=True)
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return False
    body.setdefault(u'parents', [])
    for parent in parents:
      body[u'parents'].append(parent)
  if parameters[DFA_TEAMDRIVE_PARENTID]:
    try:
      if not parameters[DFA_TEAMDRIVE_PARENTQUERY]:
        body.setdefault(u'parents', [])
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND],
                          fileId=parameters[DFA_TEAMDRIVE_PARENTID], fields=u'id,mimeType,teamDriveId', supportsTeamDrives=True)
        if result[u'mimeType'] != MIMETYPE_GA_FOLDER:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                          u'teamdriveparentid: {0}, {1}'.format(parameters[DFA_TEAMDRIVE_PARENTID], Msg.NOT_AN_ENTITY.format((Ent.Singular(Ent.DRIVE_FOLDER)))), i, count)
          return False
        if not result.get(u'teamDriveId'):
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                          u'teamdriveparentid: {0}, {1}'.format(parameters[DFA_TEAMDRIVE_PARENTID], Msg.NOT_AN_ENTITY.format((Ent.Singular(Ent.TEAMDRIVE_FOLDER)))), i, count)
          return False
        body[u'parents'].append(result[u'id'])
        parameters[DFA_SEARCHARGS] = {u'teamDriveId': result[u'teamDriveId'], u'corpora': u'teamDrive',
                                      u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
      else:
        result = callGAPI(drive.teamdrives(), u'get',
                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND],
                          teamDriveId=parameters[DFA_TEAMDRIVE_PARENTID], fields=u'id')
        parameters[DFA_KWARGS][u'corpora'] = u'teamDrive'
        parameters[DFA_KWARGS][u'teamDriveId'] = result[u'id']
        parameters[DFA_SEARCHARGS] = {u'teamDriveId': result[u'id'], u'corpora': u'teamDrive',
                                      u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
    except (GAPI.fileNotFound, GAPI.teamDriveNotFound) as e:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                      u'temadriveparentid: {0}, {1}'.format(parameters[DFA_TEAMDRIVE_PARENTID], str(e)), i, count)
      return False
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return False
  if parameters[DFA_TEAMDRIVE_PARENT]:
    tempIdEntity = {u'teamdrivename': parameters[DFA_TEAMDRIVE_PARENT], u'teamdrive': {}}
    if not _convertTeamDriveNameToId(drive, user, i, count, tempIdEntity):
      return False
    if not parameters[DFA_TEAMDRIVE_PARENTQUERY]:
      body.setdefault(u'parents', [])
      body[u'parents'].append(tempIdEntity[u'teamdrive'][u'teamDriveId'])
    else:
      parameters[DFA_KWARGS][u'corpora'] = u'teamDrive'
      parameters[DFA_KWARGS][u'teamDriveId'] = tempIdEntity[u'teamdrive'][u'teamDriveId']
    parameters[DFA_SEARCHARGS] = {u'teamDriveId': tempIdEntity[u'teamdrive'][u'teamDriveId'], u'corpora': u'teamDrive',
                                  u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
  if parameters[DFA_TEAMDRIVE_PARENTQUERY]:
    parents = doDriveSearch(drive, user, i, count, query=parameters[DFA_TEAMDRIVE_PARENTQUERY], parentQuery=True, teamDriveOnly=True, **parameters[DFA_KWARGS])
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return False
    body.setdefault(u'parents', [])
    for parent in parents:
      body[u'parents'].append(parent)
  if u'parents' not in body or not body[u'parents']:
    body[u'parents'] = [u'root',]
  return True

def _getDriveFileAddRemoveParentInfo(user, i, count, parameters, drive):
  addParents = parameters[DFA_ADD_PARENT_IDS][:]
  for query in parameters[DFA_ADD_PARENT_NAMES]:
    parents = doDriveSearch(drive, user, i, count, query=query, parentQuery=True)
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (False, None, None)
    addParents.extend(parents)
  removeParents = parameters[DFA_REMOVE_PARENT_IDS][:]
  for query in parameters[DFA_REMOVE_PARENT_NAMES]:
    parents = doDriveSearch(drive, user, i, count, query=query, parentQuery=True)
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (False, None, None)
    removeParents.extend(parents)
  return (True, u','.join(addParents), u','.join(removeParents))

def _validateUserGetTeamDriveFileIDs(user, i, count, fileIdEntity, drive=None, entityType=None):
  if fileIdEntity[u'dict']:
    cleanFileIDsList(fileIdEntity, fileIdEntity[u'dict'][user])
  if not drive:
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      return (user, None, 0)
  else:
    user = convertUIDtoEmailAddress(user)
  if fileIdEntity.get(u'teamdrivename') and not _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity):
    return (user, None, 0)
  if fileIdEntity[u'teamdrivefilequery']:
    fileIdEntity[u'list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity[u'teamdrivefilequery'], teamDriveOnly=True, **fileIdEntity[u'teamdrive'])
    if fileIdEntity[u'list'] is None or not fileIdEntity[u'list']:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
    fileIdEntity[u'teamdrive'].pop(u'teamDriveId', None)
    fileIdEntity[u'teamdrive'].pop(u'corpora', None)
  l = len(fileIdEntity[u'list'])
  if l == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if entityType:
    entityPerformActionNumItems([Ent.USER, user], l, entityType, i, count)
  return (user, drive, l)

def _validateUserTeamDrive(user, i, count, fileIdEntity, useDomainAdminAccess=False):
  user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
  if not drive:
    return (user, None)
  if fileIdEntity.get(u'teamdrivename'):
    if not _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity, useDomainAdminAccess=useDomainAdminAccess):
      return (user, None)
    fileIdEntity[u'teamdrive'][u'corpora'] = u'teamDrive'
  return (user, drive)

DRIVEFILE_LABEL_CHOICE_MAP = {
  u'restrict': u'viewersCanCopyContent',
  u'restricted': u'viewersCanCopyContent',
  u'star': u'starred',
  u'starred': u'starred',
  u'trash': u'trashed',
  u'trashed': u'trashed',
  u'view': u'viewedByMe',
  u'viewed': u'viewedByMe',
  u'viewedbyme': u'viewedByMe',
  }

MIMETYPE_CHOICE_MAP = {
  u'gdoc': MIMETYPE_GA_DOCUMENT,
  u'gdocument': MIMETYPE_GA_DOCUMENT,
  u'gdrawing': MIMETYPE_GA_DRAWING,
  u'gfolder': MIMETYPE_GA_FOLDER,
  u'gdirectory': MIMETYPE_GA_FOLDER,
  u'gform': MIMETYPE_GA_FORM,
  u'gfusion': MIMETYPE_GA_FUSIONTABLE,
  u'gmap': MIMETYPE_GA_MAP,
  u'gpresentation': MIMETYPE_GA_PRESENTATION,
  u'gscript': MIMETYPE_GA_SCRIPT,
  u'gsite': MIMETYPE_GA_SITE,
  u'gsheet': MIMETYPE_GA_SPREADSHEET,
  u'gspreadsheet': MIMETYPE_GA_SPREADSHEET,
  }

MIMETYPE_TYPES = [u'application', u'audio', u'font', u'image', u'message', u'model', u'multipart', u'text', u'video',]

def validateMimeType(mimeType):
  if mimeType in MIMETYPE_CHOICE_MAP:
    return MIMETYPE_CHOICE_MAP[mimeType]
  if mimeType.startswith(APPLICATION_VND_GOOGLE_APPS):
    return mimeType
  if mimeType.find(u'/') > 0:
    mediaType, subType = mimeType.split(u'/', 1)
    if mediaType in MIMETYPE_TYPES and subType:
      return mimeType
  invalidChoiceExit(list(MIMETYPE_CHOICE_MAP)+[u'({0})/mediatype'.format(formatChoiceList(MIMETYPE_TYPES))], True)

def getMimeType():
  return validateMimeType(getString(Cmd.OB_MIMETYPE).lower())

def initMimeTypeCheck():
  return {u'mimeTypes': set(), u'reverse': False}

def getMimeTypeCheck(mimeTypeCheck):
  mimeTypeCheck[u'reverse'] = checkArgumentPresent(u'not')
  for mimeType in getString(Cmd.OB_MIMETYPE_LIST).lower().replace(u',', u' ').split():
    mimeTypeCheck[u'mimeTypes'].add(validateMimeType(mimeType))

def checkMimeType(mimeTypeCheck, fileEntry):
  if not mimeTypeCheck[u'mimeTypes']:
    return True
  if not mimeTypeCheck[u'reverse']:
    return fileEntry[u'mimeType'] in mimeTypeCheck[u'mimeTypes']
  return fileEntry[u'mimeType'] not in mimeTypeCheck[u'mimeTypes']

def initializeDriveFileAttributes():
  return {DFA_LOCALFILEPATH: None, DFA_LOCALFILENAME: None, DFA_LOCALMIMETYPE: None,
          DFA_OCRLANGUAGE: None,
          DFA_PARENTID: None, DFA_PARENTQUERY: None,
          DFA_ADD_PARENT_IDS: [], DFA_ADD_PARENT_NAMES: [],
          DFA_REMOVE_PARENT_IDS: [], DFA_REMOVE_PARENT_NAMES: [],
          DFA_TEAMDRIVE_PARENT: None, DFA_TEAMDRIVE_PARENTID: None, DFA_TEAMDRIVE_PARENTQUERY: None, DFA_KWARGS: {}, DFA_SEARCHARGS: {},
          DFA_IGNORE_DEFAULT_VISIBILITY: False, DFA_KEEP_REVISION_FOREVER: False, DFA_USE_CONTENT_AS_INDEXABLE_TEXT: False}

DRIVEFILE_PROPERTY_VISIBILITY_CHOICE_MAP = {
  u'private': u'appProperties',
  u'public': u'properties'
  }

def getDriveFileProperty(visibility=None):
  key = getString(Cmd.OB_PROPERTY_KEY)
  value = getString(Cmd.OB_PROPERTY_VALUE, minLen=0) or None
  if visibility is None:
    if peekArgumentPresent(DRIVEFILE_PROPERTY_VISIBILITY_CHOICE_MAP):
      visibility = getChoice(DRIVEFILE_PROPERTY_VISIBILITY_CHOICE_MAP, mapChoice=True)
    else:
      visibility = u'properties'
  return {u'key': key, u'value': value, u'visibility': visibility}

def getDriveFileParentAttribute(myarg, parameters):
  if myarg == u'parentid':
    parameters[DFA_PARENTID] = getString(Cmd.OB_DRIVE_FOLDER_ID)
  elif myarg == u'parentname':
    parameters[DFA_PARENTQUERY] = VX_MY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName())
  elif myarg in [u'anyownerparentname', u'sharedparentname']:
    parameters[DFA_PARENTQUERY] = VX_ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName())
  elif myarg == u'teamdriveparent':
    parameters[DFA_TEAMDRIVE_PARENT] = getString(Cmd.OB_TEAMDRIVE_NAME)
  elif myarg == u'teamdriveparentid':
    parameters[DFA_TEAMDRIVE_PARENTID] = getString(Cmd.OB_DRIVE_FOLDER_ID)
  elif myarg == u'teamdriveparentname':
    parameters[DFA_TEAMDRIVE_PARENTQUERY] = VX_ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName())
    parameters[DFA_KWARGS][u'corpora'] = u'user,allTeamDrives'
    parameters[DFA_KWARGS][u'includeTeamDriveItems'] = True
    parameters[DFA_KWARGS][u'supportsTeamDrives'] = True
  else:
    return False
  return True

def getDriveFileAddRemoveParentAttribute(myarg, parameters):
  if myarg in [u'addparent', u'addparents']:
    parameters[DFA_ADD_PARENT_IDS].extend(getString(Cmd.OB_DRIVE_FOLDER_ID_LIST).replace(u',', u' ').split())
  elif myarg in [u'removeparent', u'removeparents']:
    parameters[DFA_REMOVE_PARENT_IDS].extend(getString(Cmd.OB_DRIVE_FOLDER_ID_LIST).replace(u',', u' ').split())
  elif myarg == u'addparentname':
    parameters[DFA_ADD_PARENT_NAMES].append(VX_MY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg == u'removeparentname':
    parameters[DFA_REMOVE_PARENT_NAMES].append(VX_MY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg in [u'addanyownerparentname', u'addsharedparentname']:
    parameters[DFA_ADD_PARENT_NAMES].append(VX_ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg in [u'removeanyownerparentname', u'removesharedparentname']:
    parameters[DFA_REMOVE_PARENT_NAMES].append(VX_ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  else:
    return False
  return True

def getDriveFileAttribute(myarg, body, parameters, assignLocalName):
  if myarg == u'localfile':
    parameters[DFA_LOCALFILEPATH] = getString(Cmd.OB_FILE_NAME)
    try:
      f = open(os.path.expanduser(parameters[DFA_LOCALFILEPATH]), u'rb')
      f.close()
    except IOError as e:
      Cmd.Backup()
      usageErrorExit(u'{0}: {1}'.format(parameters[DFA_LOCALFILEPATH], str(e)))
    parameters[DFA_LOCALFILENAME] = os.path.basename(parameters[DFA_LOCALFILEPATH])
    if assignLocalName:
      body.setdefault(VX_FILENAME, parameters[DFA_LOCALFILENAME])
    body[u'mimeType'] = mimetypes.guess_type(parameters[DFA_LOCALFILEPATH])[0]
    if body[u'mimeType'] is None:
      body[u'mimeType'] = u'application/octet-stream'
    parameters[DFA_LOCALMIMETYPE] = body[u'mimeType']
  elif myarg in [u'convert', u'ocr']:
    deprecatedArgument(myarg)
  elif myarg == u'ocrlanguage':
    parameters[DFA_OCRLANGUAGE] = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
  elif myarg in DRIVEFILE_LABEL_CHOICE_MAP:
    myarg = DRIVEFILE_LABEL_CHOICE_MAP[myarg]
    if myarg != u'viewersCanCopyContent':
      body[myarg] = getBoolean()
    else:
      body[myarg] = not getBoolean()
  elif myarg in [u'lastviewedbyme', u'lastviewedbyuser', u'lastviewedbymedate', u'lastviewedbymetime']:
    body[VX_VIEWED_BY_ME_TIME] = getTimeOrDeltaFromNow()
  elif myarg == u'description':
    body[u'description'] = getStringWithCRsNLs()
  elif myarg == u'mimetype':
    body[u'mimeType'] = getMimeType()
  elif getDriveFileParentAttribute(myarg, parameters):
    pass
  elif myarg == u'writerscanshare':
    body[u'writersCanShare'] = getBoolean()
  elif myarg == u'writerscantshare':
    body[u'writersCanShare'] = not getBoolean()
  elif myarg == u'viewerscancopycontent':
    body[u'viewersCanCopyContent'] = getBoolean()
  elif myarg == u'foldercolorrgb':
    body[u'folderColorRgb'] = getColor()
  elif myarg == u'ignoredefaultvisibility':
    parameters[DFA_IGNORE_DEFAULT_VISIBILITY] = getBoolean()
  elif myarg in [u'keeprevisionforever', u'pinned']:
    parameters[DFA_KEEP_REVISION_FOREVER] = getBoolean()
  elif myarg == u'usecontentasindexabletext':
    parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT] = getBoolean()
  elif myarg == u'indexabletext':
    body.setdefault(u'contentHints', {})
    body[u'contentHints'][u'indexableText'] = getString(Cmd.OB_STRING)
  elif myarg == u'property':
    driveprop = getDriveFileProperty()
    body.setdefault(driveprop[u'visibility'], [])
    body[driveprop[u'visibility']].append({driveprop[u'key']: driveprop[u'value']})
  elif myarg == u'privateproperty':
    driveprop = getDriveFileProperty(u'appProperties')
    body.setdefault(driveprop[u'visibility'], [])
    body[driveprop[u'visibility']].append({driveprop[u'key']: driveprop[u'value']})
  elif myarg == u'publicproperty':
    driveprop = getDriveFileProperty(u'properties')
    body.setdefault(driveprop[u'visibility'], [])
    body[driveprop[u'visibility']].append({driveprop[u'key']: driveprop[u'value']})
  else:
    unknownArgumentExit()

PRINT_DRIVE_ACTIVITY_TITLES = [u'user.name', u'user.permissionId', u'target.id', u'target.name', u'target.mimeType']

# gam <UserTypeEntity> print|show driveactivity [todrive [<ToDriveAttributes>]] [fileid <DriveFileID>] [folderid <DriveFolderID>]
def printDriveActivity(users):
  drive_ancestorId = u'root'
  drive_fileId = None
  todrive = {}
  titles, csvRows = initializeTitlesCSVfile(PRINT_DRIVE_ACTIVITY_TITLES)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'fileid':
      drive_fileId = getString(Cmd.OB_DRIVE_FILE_ID)
      drive_ancestorId = None
    elif myarg == u'folderid':
      drive_ancestorId = getString(Cmd.OB_DRIVE_FOLDER_ID)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, activity = buildGAPIServiceObject(API.APPSACTIVITY, user, i, count)
    if not activity:
      continue
    try:
      printGettingAllEntityItemsForWhom(Ent.ACTIVITY, user, i, count)
      feed = callGAPIpages(activity.activities(), u'list', u'activities',
                           page_message=getPageMessageForWhom(noNL=True),
                           throw_reasons=GAPI.ACTIVITY_THROW_REASONS,
                           source=u'drive.google.com', userId=u'me',
                           drive_ancestorId=drive_ancestorId, groupingStrategy=u'none',
                           drive_fileId=drive_fileId, pageSize=GC.Values[GC.ACTIVITY_MAX_RESULTS])
      while feed:
        event = feed.popleft()[u'combinedEvent']
        event[u'eventTime'] = formatLocalTimestamp(event[u'eventTimeMillis'])
        addRowTitlesToCSVfile(flattenJSON(event), csvRows, titles)
    except GAPI.serviceNotAvailable:
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  writeCSVfile(csvRows, titles, u'Drive Activity', todrive, PRINT_DRIVE_ACTIVITY_TITLES)

DRIVESETTINGS_FIELDS_CHOICE_MAP = {
  u'appinstalled': u'appInstalled',
  u'exportformats': u'exportFormats',
  u'foldercolorpalette': u'folderColorPalette',
  u'importformats': u'importFormats',
  u'largestchangeid': u'largestChangeId',
  u'limit': u'limit',
  u'maximportsizes': u'maxImportSizes',
  u'maxuploadsize': u'maxUploadSize',
  u'name': u'name',
  u'permissionid': u'permissionId',
  u'rootfolderid': u'rootFolderId',
  u'teamdrivethemes': u'teamDriveThemes',
  u'usage': u'usage',
  u'usageindrive': u'usageInDrive',
  u'usageindrivetrash': u'usageInDriveTrash',
  }

DRIVESETTINGS_SCALAR_FIELDS = [
  u'name',
  u'appInstalled',
  u'largestChangeId',
  u'limit',
  u'maxUploadSize',
  u'permissionId',
  u'rootFolderId',
  u'usage',
  u'usageInDrive',
  u'usageInDriveTrash',
  ]

def _showTeamDriveThemeSettings(themes):
  Ind.Increment()
  for theme in themes:
    printKeyValueList([u'id', theme[u'id']])
    Ind.Increment()
    printKeyValueList([u'backgroundImageLink', theme[u'backgroundImageLink']])
    printKeyValueList([u'colorRgb', theme[u'colorRgb']])
    Ind.Decrement()
  Ind.Decrement()

def _printShowDriveSettings(users, csvFormat):

  def _showFormats(title):
    if title in fieldsList and title in feed:
      printKeyValueList([title, None])
      Ind.Increment()
      for item, value in sorted(iteritems(feed[title])):
        printKeyValueList([item, delimiter.join(value)])
      Ind.Decrement()

  def _showSetting(title):
    if title in fieldsList and title in feed:
      if not isinstance(feed[title], list):
        printKeyValueList([title, feed[title]])
      else:
        printKeyValueList([title, delimiter.join(feed[title])])

  def _addFormats(row, title):
    if title in fieldsList and title in feed:
      jcount = len(feed[title])
      row[title] = jcount
      j = 0
      for item, value in sorted(iteritems(feed[title])):
        row[u'{0}.{1:02d}.{2}'.format(title, j, item)] = delimiter.join(value)
        j += 1

  def _addSetting(row, title):
    if title in fieldsList and title in feed:
      if not isinstance(feed[title], list):
        row[title] = feed[title]
      else:
        row[title] = delimiter.join(feed[title])

  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  fieldsList = []
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'allfields':
      for field in DRIVESETTINGS_FIELDS_CHOICE_MAP:
        fieldsList.append(DRIVESETTINGS_FIELDS_CHOICE_MAP[field])
    elif getFieldsList(myarg, DRIVESETTINGS_FIELDS_CHOICE_MAP, fieldsList):
      pass
    else:
      unknownArgumentExit()
  if not fieldsList:
    fieldsList = DRIVESETTINGS_SCALAR_FIELDS[:]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    if csvFormat:
      printGettingEntityItemForWhom(Ent.DRIVE_SETTINGS, user, i, count)
    try:
      feed = callGAPI(drive.about(), u'get',
                      throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fields=u'*')
      feed[u'name'] = feed[u'user'][u'displayName']
      feed[u'maxUploadSize'] = formatFileSize(int(feed[u'maxUploadSize']))
      feed[u'permissionId'] = feed[u'user'][u'permissionId']
      feed[u'storageQuota'].setdefault(u'limit', 0)
      feed[u'limit'] = [u'UNLIMITED', u'LIMITED'][feed[u'storageQuota'].get(u'limit', 0) > 0]
      for setting in [u'usage', u'usageInDrive', u'usageInDriveTrash']:
        feed[setting] = formatFileSize(int(feed[u'storageQuota'].get(setting, 0)))
      if u'rootFolderId' in fieldsList:
        feed[u'rootFolderId'] = callGAPI(drive.files(), u'get',
                                         throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                         fileId=u'root', fields=u'id')[u'id']
      if u'largestChangeId' in fieldsList:
        feed[u'largestChangeId'] = callGAPI(drive.changes(), u'getStartPageToken',
                                            throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                            fields=u'startPageToken')[u'startPageToken']
      if not csvFormat:
        entityPerformActionNumItems([Ent.USER, user], 1, Ent.DRIVE_SETTINGS, i, count)
        Ind.Increment()
        for setting in DRIVESETTINGS_SCALAR_FIELDS:
          _showSetting(setting)
        _showSetting(u'folderColorPalette')
        _showFormats(u'exportFormats')
        _showFormats(u'importFormats')
        if u'maxImportSizes' in fieldsList and u'maxImportSizes' in fieldsList:
          printKeyValueList([u'maxImportSizes', None])
          Ind.Increment()
          for setting, value in iteritems(feed[u'maxImportSizes']):
            printKeyValueList([setting, formatFileSize(int(value))])
          Ind.Decrement()
        if u'teamDriveThemes' in fieldsList and u'teamDriveThemes' in feed:
          printKeyValueList([u'teamDriveThemes', None])
          _showTeamDriveThemeSettings(feed[u'teamDriveThemes'])
        Ind.Decrement()
      else:
        row = {u'email': user}
        for setting in DRIVESETTINGS_SCALAR_FIELDS:
          _addSetting(row, setting)
        _addSetting(row, u'folderColorPalette')
        _addFormats(row, u'exportFormats')
        _addFormats(row, u'importFormats')
        if u'maxImportSizes' in fieldsList and u'maxImportSizes' in fieldsList:
          jcount = len(feed[u'maxImportSizes'])
          row[u'maxImportSizes'] = jcount
          j = 0
          for setting, value in iteritems(feed[u'maxImportSizes']):
            row[u'maxImportSizes.{0}.{1}'.format(j, setting)] = formatFileSize(int(value))
            j += 1
        if u'teamDriveThemes' in fieldsList and u'teamDriveThemes' in feed:
          jcount = len(feed[u'teamDriveThemes'])
          row[u'teamDriveThemes'] = jcount
          j = 0
          for setting in feed[u'teamDriveThemes']:
            row[u'teamDriveThemes.{0:02d}.id'.format(j)] = setting[u'id']
            row[u'teamDriveThemes.{0:02d}.backgroundImageLink'.format(j)] = setting[u'backgroundImageLink']
            row[u'teamDriveThemes.{0:02d}.colorRgb'.format(j)] = setting[u'colorRgb']
            j += 1
        addRowTitlesToCSVfile(row, csvRows, titles)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'User Drive Settings', todrive, [u'email',]+DRIVESETTINGS_SCALAR_FIELDS)

# gam <UserTypeEntity> print drivesettings [todrive [<ToDriveAttributes>]] [allfields|<DriveSettingsFieldName>*|(fields <DriveSettingsFieldNameList>)] [delimiter <Character>]
def printDriveSettings(users):
  _printShowDriveSettings(users, True)

# gam <UserTypeEntity> show drivesettings [allfields|<DriveSettingsFieldName>*|(fields <DriveSettingsFieldNameList>)] [delimiter <Character>]
def showDriveSettings(users):
  _printShowDriveSettings(users, False)

# gam <UserTypeEntity> show teamdrivethemes
def _showTeamDriveThemes(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    try:
      themes = callGAPIitems(drive.about(), u'get', u'teamDriveThemes',
                             throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                             fields=u'teamDriveThemes')
      jcount = len(themes)
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.TEAMDRIVE_THEME, i, count)
      _showTeamDriveThemeSettings(themes)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

# gam <UserTypeEntity> show teamdrivethemes
def showTeamDriveThemes(users):
  _showTeamDriveThemes(users)

# gam show teamdrivethemes
def doShowTeamDriveThemes():
  _showTeamDriveThemes([_getValueFromOAuth(u'email')])

def initFilePathInfo():
  return {u'ids': {}, u'allPaths': {}, u'localPaths': None}

def getFilePaths(drive, fileTree, initialResult, filePathInfo):
  def _followParent(paths, parentId):
    result = None
    paths.setdefault(parentId, {})
    if fileTree:
      parentEntry = fileTree.get(parentId)
      if parentEntry:
        if parentEntry[u'info'][VX_FILENAME] == parentEntry[u'info'][u'id']:
          try:
            result = callGAPI(drive.files(), u'get',
                              throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                              fileId=parentId, fields=VX_FILENAME_PARENTS_MIMETYPE, supportsTeamDrives=True)
            parentEntry[u'info'][VX_FILENAME] = result[VX_FILENAME]
            parentEntry[u'info'][u'parents'] = result.get(u'parents', [])
          except (GAPI.fileNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
            pass
        filePathInfo[u'ids'][parentId] = parentEntry[u'info'][VX_FILENAME]
        parents = parentEntry[u'info'].get(u'parents', [])
      else:
        return
    else:
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=parentId, fields=VX_FILENAME_PARENTS_MIMETYPE_TEAMDRIVEID, supportsTeamDrives=True)
        filePathInfo[u'ids'][parentId] = result[VX_FILENAME]
        parents = result.get(u'parents', [])
      except (GAPI.fileNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
        return
    if parents:
      for lparentId in parents:
        if lparentId not in filePathInfo[u'allPaths']:
          _followParent(paths[parentId], lparentId)
          filePathInfo[u'allPaths'][lparentId] = paths[parentId][lparentId]
        else:
          paths[parentId][lparentId] = filePathInfo[u'allPaths'][lparentId]
    else:
      if result and (result[u'mimeType'] == MIMETYPE_GA_FOLDER) and (result[VX_FILENAME] == TEAM_DRIVE) and result.get(u'teamDriveId'):
        filePathInfo[u'ids'][parentId] = _getTeamDriveNameFromId(drive, result[u'teamDriveId'])

  def _makeFilePaths(localPaths, fplist, filePaths, name):
    for k, v in iteritems(localPaths):
      fplist.append(filePathInfo[u'ids'].get(k, u''))
      if not v:
        fp = fplist[:]
        fp.reverse()
        fp.append(name)
        filePaths.append(os.path.join(*fp))
      else:
        _makeFilePaths(v, fplist, filePaths, name)
      fplist.pop()
    return

  filePaths = []
  parents = initialResult.get(u'parents', [])
  if parents:
    filePathInfo[u'localPaths'] = {}
    for parentId in parents:
      if parentId not in filePathInfo[u'allPaths']:
        _followParent(filePathInfo[u'allPaths'], parentId)
      filePathInfo[u'localPaths'][parentId] = filePathInfo[u'allPaths'][parentId]
    fplist = []
    _makeFilePaths(filePathInfo[u'localPaths'], fplist, filePaths, initialResult[VX_FILENAME])
  return (_getEntityMimeType(initialResult), filePaths)

DRIVEFILE_ORDERBY_CHOICE_MAP = {
  u'createddate': VX_CREATED_TIME,
  u'createdtime': VX_CREATED_TIME,
  u'folder': u'folder',
  u'lastviewedbyme': VX_VIEWED_BY_ME_TIME,
  u'lastviewedbymedate': VX_VIEWED_BY_ME_TIME,
  u'lastviewedbymetime': VX_VIEWED_BY_ME_TIME,
  u'lastviewedbyuser': VX_VIEWED_BY_ME_TIME,
  u'modifiedbyme': VX_MODIFIED_BY_ME_TIME,
  u'modifiedbymedate': VX_MODIFIED_BY_ME_TIME,
  u'modifiedbymetime': VX_MODIFIED_BY_ME_TIME,
  u'modifiedbyuser': VX_MODIFIED_BY_ME_TIME,
  u'modifieddate': VX_MODIFIED_TIME,
  u'modifiedtime': VX_MODIFIED_TIME,
  u'name': VX_FILENAME,
  u'quotabytesused': u'quotaBytesUsed',
  u'quotaused': u'quotaBytesUsed',
  u'recency': u'recency',
  u'sharedwithmedate': VX_SHARED_WITH_ME_TIME,
  u'sharedwithmetime': VX_SHARED_WITH_ME_TIME,
  u'starred': u'starred',
  u'title': VX_FILENAME,
  u'viewedbymedate': VX_VIEWED_BY_ME_TIME,
  u'viewedbymetime': VX_VIEWED_BY_ME_TIME,
  }

def getDrivefileOrderBy(orderByList):
  fieldName = getChoice(DRIVEFILE_ORDERBY_CHOICE_MAP, mapChoice=True)
  if getChoice(SORTORDER_CHOICE_MAP, defaultChoice=None, mapChoice=True) != u'DESCENDING':
    orderByList.append(fieldName)
  else:
    orderByList.append(u'{0} desc'.format(fieldName))

def _mapDrive3TitlesToDrive2(titles, drive3TitlesMap):
  for i, title in enumerate(titles):
    if title in drive3TitlesMap:
      titles[i] = drive3TitlesMap[title]

def _mapDriveUser(field):
  if u'me' in field:
    field[u'isAuthenticatedUser'] = field.pop(u'me')
  if u'photoLink' in field:
    field[u'picture'] = {u'url': field.pop(u'photoLink')}

def _mapDrivePermissionNames(permission):
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    if u'displayName' in permission:
      permission[u'name'] = permission.pop(u'displayName')
    if VX_EXPIRATION_TIME in permission:
      permission[u'expirationDate'] = formatLocalTime(permission.pop(VX_EXPIRATION_TIME))
    if u'allowFileDiscovery' in permission:
      permission[u'withLink'] = not permission.pop(u'allowFileDiscovery')
  emailAddress = permission.get(u'emailAddress')
  if emailAddress:
    _, permission[u'domain'] = splitEmailAddress(emailAddress)

def _initParentsSubFields():
  return {u'id': False, u'isRoot': False, u'rootFolderId': None}

def _setAllParentsSubFields(parentsSubFields):
  parentsSubFields[u'id'] = parentsSubFields[u'isRoot'] = True

def _mapDriveParents(f_file, parentsSubFields):
  if u'parents' in f_file:
    parents = f_file[u'parents'][:]
    f_file[u'parents'] = []
    for parentId in parents:
      parent = {}
      if parentsSubFields[u'id']:
        parent[u'id'] = parentId
      if parentsSubFields[u'isRoot']:
        parent[u'isRoot'] = parentId == parentsSubFields[u'rootFolderId']
      f_file[u'parents'].append(parent)

def _mapDriveProperties(f_file):
  appProperties = f_file.pop(u'appProperties', [])
  properties = f_file.pop(u'properties', [])
  if appProperties:
    f_file.setdefault(u'properties', [])
    for key, value in sorted(iteritems(appProperties)):
      f_file[u'properties'].append({u'key': key, u'value': value, u'visibility': u'PRIVATE'})
  if properties:
    f_file.setdefault(u'properties', [])
    for key, value in sorted(iteritems(properties)):
      f_file[u'properties'].append({u'key': key, u'value': value, u'visibility': u'PUBLIC'})

def _mapDriveFieldNames(f_file, user, parentsSubFields, mapToLabels):
  if mapToLabels:
    for attrib in API.DRIVE3_TO_DRIVE2_LABELS_MAP:
      if attrib in f_file:
        f_file.setdefault(u'labels', {})
        if attrib != u'viewersCanCopyContent':
          f_file[u'labels'][API.DRIVE3_TO_DRIVE2_LABELS_MAP[attrib]] = f_file.pop(attrib)
        else:
          f_file[u'labels'][API.DRIVE3_TO_DRIVE2_LABELS_MAP[attrib]] = not f_file.pop(attrib)
  for attrib in API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP:
    if attrib in f_file:
      if attrib != u'viewersCanCopyContent':
        f_file[API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP[attrib]] = f_file.pop(attrib)
      else:
        f_file[API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP[attrib]] = not f_file.pop(attrib)
  capabilities = f_file.get(u'capabilities')
  if capabilities:
    for attrib in API.DRIVE3_TO_DRIVE2_CAPABILITIES_FIELDS_MAP:
      if attrib in capabilities:
        f_file[API.DRIVE3_TO_DRIVE2_CAPABILITIES_FIELDS_MAP[attrib]] = capabilities[attrib]
    for attrib in API.DRIVE3_TO_DRIVE2_CAPABILITIES_NAMES_MAP:
      if attrib in capabilities:
        capabilities[API.DRIVE3_TO_DRIVE2_CAPABILITIES_NAMES_MAP[attrib]] = capabilities.pop(attrib)
  if u'spaces' in f_file:
    f_file[u'appDataContents'] = u'appDataFolder' in f_file[u'spaces']
  if u'lastModifyingUser' in f_file:
    if u'displayName' in f_file[u'lastModifyingUser']:
      f_file[u'lastModifyingUserName'] = f_file[u'lastModifyingUser'][u'displayName']
    _mapDriveUser(f_file[u'lastModifyingUser'])
  if u'owners' in f_file:
    for owner in f_file[u'owners']:
      _mapDriveUser(owner)
      if u'displayName' in owner:
        f_file.setdefault('ownerNames', [])
        f_file['ownerNames'].append(owner[u'displayName'])
  _mapDriveUser(f_file.get(u'sharingUser', {}))
  _mapDriveParents(f_file, parentsSubFields)
  _mapDriveProperties(f_file)
  for permission in f_file.get(u'permissions', []):
    if (permission.get(u'type') == u'user') and (permission.get(u'emailAddress', u'').lower() == user) and (u'role' in permission):
      f_file[u'userPermission'] = {u'id': u'me', u'role': permission[u'role'], u'type': permission[u'type']}
    _mapDrivePermissionNames(permission)

def _mapDriveRevisionNames(revision):
  for attrib in API.DRIVE3_TO_DRIVE2_REVISIONS_FIELDS_MAP:
    if attrib in revision:
      revision[API.DRIVE3_TO_DRIVE2_REVISIONS_FIELDS_MAP[attrib]] = revision.pop(attrib)
  if u'lastModifyingUser' in revision:
    if u'displayName' in revision[u'lastModifyingUser']:
      revision[u'lastModifyingUserName'] = revision[u'lastModifyingUser'][u'displayName']
    _mapDriveUser(revision[u'lastModifyingUser'])

DRIVEFILE_FIELDS_CHOICE_MAP = {
  u'alternatelink': VX_WEB_VIEW_LINK,
  u'appdatacontents': u'spaces',
  u'appproperties': u'appProperties',
  u'cancomment': u'capabilities.canComment',
  u'canreadrevisions': u'capabilities.canReadRevisions',
  u'capabilities': u'capabilities',
  u'contenthints': u'contentHints',
  u'copyable': u'capabilities.canCopy',
  u'createddate': VX_CREATED_TIME,
  u'createdtime': VX_CREATED_TIME,
  u'description': u'description',
  u'editable': u'capabilities.canEdit',
  u'explicitlytrashed': u'explicitlyTrashed',
  u'fileextension': u'fileExtension',
  u'filesize': VX_SIZE,
  u'foldercolorrgb': u'folderColorRgb',
  u'fullfileextension': u'fullFileExtension',
  u'hasaugmentedpermissions': u'hasAugmentedPermissions',
  u'hasthumbnail': u'hasThumbnail',
  u'headrevisionid': u'headRevisionId',
  u'iconlink': u'iconLink',
  u'id': u'id',
  u'imagemediametadata': u'imageMediaMetadata',
  u'isappauthorized': u'isAppAuthorized',
  u'lastmodifyinguser': u'lastModifyingUser',
  u'lastmodifyingusername': u'lastModifyingUser.displayName',
  u'lastviewedbyme': VX_VIEWED_BY_ME_TIME,
  u'lastviewedbymedate': VX_VIEWED_BY_ME_TIME,
  u'lastviewedbymetime': VX_VIEWED_BY_ME_TIME,
  u'lastviewedbyuser': VX_VIEWED_BY_ME_TIME,
  u'md5': u'md5Checksum',
  u'md5checksum': u'md5Checksum',
  u'md5sum': u'md5Checksum',
  u'mime': u'mimeType',
  u'mimetype': u'mimeType',
  u'modifiedbyme': VX_MODIFIED_BY_ME_TIME,
  u'modifiedbymedate': VX_MODIFIED_BY_ME_TIME,
  u'modifiedbymetime': VX_MODIFIED_BY_ME_TIME,
  u'modifiedbyuser': VX_MODIFIED_BY_ME_TIME,
  u'modifieddate': VX_MODIFIED_TIME,
  u'modifiedtime': VX_MODIFIED_TIME,
  u'name': VX_FILENAME,
  u'originalfilename': u'originalFilename',
  u'ownedbyme': u'ownedByMe',
  u'ownernames': u'owners.displayName',
  u'owners': u'owners',
  u'parents': u'parents',
  u'permissions': u'permissions',
  u'permissionids': u'permissionIds',
  u'properties': u'properties',
  u'quotabytesused': u'quotaBytesUsed',
  u'quotaused': u'quotaBytesUsed',
  u'shareable': u'capabilities.canShare',
  u'shared': u'shared',
  u'sharedwithmedate': VX_SHARED_WITH_ME_TIME,
  u'sharedwithmetime': VX_SHARED_WITH_ME_TIME,
  u'sharinguser': u'sharingUser',
  u'size': VX_SIZE,
  u'spaces': u'spaces',
  u'teamdriveid': u'teamDriveId',
  u'thumbnaillink': u'thumbnailLink',
  u'thumbnailversion': u'thumbnailVersion',
  u'title': VX_FILENAME,
  u'trasheddate': u'trashedTime',
  u'trashedtime': u'trashedTime',
  u'trashinguser': u'trashingUser',
  u'userpermission': [u'ownedByMe,capabilities.canEdit,capabilities.canComment'],
  u'version': u'version',
  u'videomediametadata': u'videoMediaMetadata',
  u'viewedbyme': u'viewedByMe',
  u'viewedbymedate': VX_VIEWED_BY_ME_TIME,
  u'viewedbymetime': VX_VIEWED_BY_ME_TIME,
  u'viewerscancopycontent': u'viewersCanCopyContent',
  u'webcontentlink': u'webContentLink',
  u'webviewlink': VX_WEB_VIEW_LINK,
  u'writerscanshare': u'writersCanShare',
  }

OWNERS_SUBFIELDS_CHOICE_MAP = {
  u'displayname': u'displayName',
  u'emailaddress': u'emailAddress',
  u'isauthenticateduser': u'me',
  u'me': u'me',
  u'permissionid': u'permissionId',
  u'photolink': u'photoLink',
  u'picture': u'photoLink',
  }

PARENTS_SUBFIELDS_CHOICE_MAP = {
  u'id': u'id',
  u'isroot': u'isRoot',
  }

PERMISSIONS_SUBFIELDS_CHOICE_MAP = {
  u'id': u'id',
  u'name': u'displayName',
  u'displayname': u'displayName',
  u'emailaddress': u'emailAddress',
  u'domain': u'domain',
  u'role': u'role',
  u'additionalroles': u'role',
  u'type': u'type',
  u'allowfilediscovery': u'allowFileDiscovery',
  u'withlink': u'allowFileDiscovery',
  u'photolink': u'photoLink',
  u'expirationdate': u'expirationTime',
  u'expirationtime': u'expirationTime',
  u'teamdrivepermissiondetails': u'teamDrivePermissionDetails',
  u'deleted': u'deleted',
  }

SHARINGUSER_SUBFIELDS_CHOICE_MAP = {
  u'name': u'displayName',
  u'displayname': u'displayName',
  u'photolink': u'photoLink',
  u'picture': u'photoLink',
  u'isauthenticateduser': u'me',
  u'me': u'me',
  u'permissionid': u'permissionId',
  u'emailaddress': u'emailAddress',
  }

SUBFIELDS_CHOICE_MAP = {
  u'lastmodifyinguser': SHARINGUSER_SUBFIELDS_CHOICE_MAP,
  u'owners': OWNERS_SUBFIELDS_CHOICE_MAP,
  u'parents': PARENTS_SUBFIELDS_CHOICE_MAP,
  u'permissions': PERMISSIONS_SUBFIELDS_CHOICE_MAP,
  u'sharinguser': SHARINGUSER_SUBFIELDS_CHOICE_MAP,
  u'trashinguser': SHARINGUSER_SUBFIELDS_CHOICE_MAP,
}

VX_FILEINFO_FIELDS_TITLES = [VX_FILENAME, u'mimeType']
VX_FILEPATH_FIELDS_TITLES = [VX_FILENAME, u'id', u'mimeType', u'parents']

def _getDriveTimeObjects():
  timeObjects = [VX_CREATED_TIME, VX_VIEWED_BY_ME_TIME, VX_MODIFIED_BY_ME_TIME, VX_MODIFIED_TIME, VX_SHARED_WITH_ME_TIME]
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDrive3TitlesToDrive2(timeObjects, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
  return set(timeObjects)

def _getDriveFieldSubField(field, fieldsList, titles, parentsSubFields):
  field, subField = field.split(u'.', 1)
  if field in SUBFIELDS_CHOICE_MAP:
    if titles is not None:
      addTitlesToCSVfile(DRIVEFILE_FIELDS_CHOICE_MAP[field], titles)
    if field == u'parents':
      fieldsList.append(DRIVEFILE_FIELDS_CHOICE_MAP[field])
      parentsSubFields[SUBFIELDS_CHOICE_MAP[field][subField]] = True
    elif subField in SUBFIELDS_CHOICE_MAP[field]:
      fieldsList.append(u'{0}.{1}'.format(DRIVEFILE_FIELDS_CHOICE_MAP[field], SUBFIELDS_CHOICE_MAP[field][subField]))
    else:
      invalidChoiceExit(list(SUBFIELDS_CHOICE_MAP[field]), True)
  else:
    invalidChoiceExit(list(SUBFIELDS_CHOICE_MAP), True)

def _setSkipObjects(skipObjects, skipTitles, fieldsList):
  for field in skipTitles:
    if field != u'parents':
      if field not in fieldsList:
        skipObjects.add(field)
      fieldsList.append(field)
    else:
      for xfield in fieldsList:
        if xfield.startswith(u'parents'):
          break
      else:
        skipObjects.add(field)
      fieldsList.append(u'parents')

def _setGetPermissionsForTeamDrives(fieldsList):
  getPermissionsForTeamDrives = False
  permissionsFieldsList = []
  permissionsFields = None
  for field in fieldsList:
    if field.startswith(u'permissions'):
      getPermissionsForTeamDrives = True
      if field.find(u'.') != -1:
        field, subField = field.split(u'.', 1)
        permissionsFieldsList.append(subField)
  if getPermissionsForTeamDrives:
    permissionsFields = VX_NPT_PERMISSIONS_FIELDLIST.format(u','.join(set(permissionsFieldsList)).replace(u'.', u'/')) if permissionsFieldsList else VX_NPT_PERMISSIONS
  return (getPermissionsForTeamDrives, permissionsFields)

# gam <UserTypeEntity> show fileinfo <DriveFileEntity> [filepath] [allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def showFileInfo(users):
  def _setSelectionFields():
    _setSkipObjects(skipObjects, VX_FILEINFO_FIELDS_TITLES, fieldsList)
    if filepath:
      _setSkipObjects(skipObjects, VX_FILEPATH_FIELDS_TITLES, fieldsList)
    if getPermissionsForTeamDrives:
      if u'teamDriveId' not in fieldsList:
        skipObjects.add(u'teamDriveId')
        fieldsList.append(u'teamDriveId')

  filepath = showNoParents = False
  fieldsList = []
  orderByList = []
  skipObjects = set()
  fileIdEntity = getDriveFileEntity()
  parentsSubFields = _initParentsSubFields()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'filepath':
      filepath = True
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'allfields':
      fieldsList = []
    elif myarg in DRIVEFILE_LABEL_CHOICE_MAP:
      addFieldToFieldsList(myarg, DRIVEFILE_LABEL_CHOICE_MAP, fieldsList)
    elif myarg in DRIVEFILE_FIELDS_CHOICE_MAP:
      addFieldToFieldsList(myarg, DRIVEFILE_FIELDS_CHOICE_MAP, fieldsList)
      if myarg == u'parents':
        _setAllParentsSubFields(parentsSubFields)
    elif myarg == u'fields':
      for field in _getFieldsList():
        if field in DRIVEFILE_LABEL_CHOICE_MAP:
          addFieldToFieldsList(field, DRIVEFILE_LABEL_CHOICE_MAP, fieldsList)
        elif field.find(u'.') == -1:
          if field in DRIVEFILE_FIELDS_CHOICE_MAP:
            addFieldToFieldsList(field, DRIVEFILE_FIELDS_CHOICE_MAP, fieldsList)
            if field == u'parents':
              _setAllParentsSubFields(parentsSubFields)
          else:
            invalidChoiceExit(list(DRIVEFILE_FIELDS_CHOICE_MAP)+list(DRIVEFILE_LABEL_CHOICE_MAP), True)
        else:
          _getDriveFieldSubField(field, fieldsList, None, parentsSubFields)
    elif myarg.find(u'.') != -1:
      _getDriveFieldSubField(myarg, fieldsList, None, parentsSubFields)
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  getPermissionsForTeamDrives = False
  if fieldsList:
    getPermissionsForTeamDrives, permissionsFields = _setGetPermissionsForTeamDrives(fieldsList)
    _setSelectionFields()
    fields = u','.join(set(fieldsList)).replace(u'.', u'/')
    showNoParents = u'parents' in fieldsList
  else:
    fields = u'*'
    _setAllParentsSubFields(parentsSubFields)
    skipObjects = skipObjects.union(DEFAULT_SKIP_OBJECTS)
    showNoParents = True
  timeObjects = _getDriveTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER, orderBy=orderBy)
    if jcount == 0:
      continue
    if parentsSubFields[u'isRoot']:
      parentsSubFields[u'rootFolderId'] = callGAPI(drive.files(), u'get',
                                                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                                   fileId=u'root', fields=u'id')[u'id']
    if filepath:
      filePathInfo = initFilePathInfo()
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields=fields, supportsTeamDrives=True)
        if (result[u'mimeType'] == MIMETYPE_GA_FOLDER) and (result[VX_FILENAME] == TEAM_DRIVE) and result.get(u'teamDriveId'):
          result[VX_FILENAME] = _getTeamDriveNameFromId(drive, result[u'teamDriveId'])
        if showNoParents:
          result.setdefault(u'parents', [])
        if getPermissionsForTeamDrives and result.get(u'teamDriveId') and u'permissions' not in result:
          try:
            result[u'permissions'] = callGAPIpages(drive.permissions(), u'list', VX_PAGES_PERMISSIONS,
                                                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                                   fileId=fileId, fields=permissionsFields, supportsTeamDrives=True)
          except GAPI.insufficientFilePermissions as e:
            if fields != u'*':
              entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
              continue
        printEntity([_getEntityMimeType(result), u'{0} ({1})'.format(result[VX_FILENAME], fileId)], j, jcount)
        Ind.Increment()
        if filepath:
          _, paths = getFilePaths(drive, None, result, filePathInfo)
          kcount = len(paths)
          printKeyValueList([u'paths', kcount])
          Ind.Increment()
          for path in paths:
            printKeyValueList([u'path', path])
          Ind.Decrement()
        if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
          _mapDriveFieldNames(result, user, parentsSubFields, True)
        else:
          _mapDriveParents(result, parentsSubFields)
          _mapDriveProperties(result)
        showJSON(None, result, skipObjects, timeObjects, {u'owners': u'displayName', u'parents': u'id', u'permissions': [u'name', u'displayName'][GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]})
        Ind.Decrement()
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

def getRevisionsEntity():
  revisionsEntity = {u'list': [], u'dict': None, u'count': None, u'time': None, u'range': None}
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      revisionsEntity[u'dict'] = entityList
    else:
      revisionsEntity[u'list'] = entityList
  else:
    myarg = getString(Cmd.OB_DRIVE_FILE_REVISION_ID, checkBlank=True)
    mycmd = myarg.lower()
    if mycmd == u'id':
      revisionsEntity[u'list'] = getStringReturnInList(Cmd.OB_DRIVE_FILE_REVISION_ID)
    elif mycmd[:3] == u'id:':
      revisionsEntity[u'list'] = [myarg[3:]]
    elif mycmd == u'ids':
      revisionsEntity[u'list'] = getString(Cmd.OB_DRIVE_FILE_REVISION_ID).replace(u',', u' ').split()
    elif mycmd[:4] == u'ids:':
      revisionsEntity[u'list'] = myarg[4:].replace(u',', u' ').split()
    elif mycmd in [u'first', u'last', u'allexceptfirst', u'allexceptlast']:
      revisionsEntity[u'count'] = (mycmd, getInteger(minVal=1))
    elif mycmd in [u'before', u'after']:
      dateTime, _, _ = getTimeOrDeltaFromNow(True)
      revisionsEntity[u'time'] = (mycmd, dateTime)
    elif mycmd == u'range':
      startDateTime, _, startTime = getTimeOrDeltaFromNow(True)
      endDateTime, _, endTime = getTimeOrDeltaFromNow(True)
      if endDateTime < startDateTime:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_TIME_RANGE.format(u'end', endTime, u'start', startTime))
      revisionsEntity[u'range'] = (mycmd, startDateTime, endDateTime)
    else:
      revisionsEntity[u'list'] = [myarg,]
  return revisionsEntity

def _selectRevisionIds(drive, fileId, origUser, user, i, count, j, jcount, revisionsEntity):
  if revisionsEntity[u'list']:
    return revisionsEntity[u'list']
  if revisionsEntity[u'dict']:
    if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
      return revisionsEntity[u'dict'][fileId]
    else:
      return revisionsEntity[u'dict'][origUser][fileId]
  revisionIds = []
  try:
    results = callGAPIpages(drive.revisions(), u'list', VX_PAGES_REVISIONS,
                            throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.REVISIONS_NOT_SUPPORTED],
                            fileId=fileId, fields=VX_NPT_REVISIONS_ID_MODIFIEDTIME, pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    numRevisions = len(results)
    if numRevisions > 0:
      if revisionsEntity[u'count']:
        countType = revisionsEntity[u'count'][0]
        count = revisionsEntity[u'count'][1]
        revisions = [revision[u'id'] for revision in results]
        if countType == u'first':
          if count >= numRevisions:
            revisionIds = revisions[:-1]
          else:
            revisionIds = revisions[:count]
        elif countType == u'last':
          if count >= numRevisions:
            revisionIds = revisions[1:]
          else:
            revisionIds = revisions[-count:]
        elif countType == u'allexceptfirst':
          if count >= numRevisions:
            revisionIds = []
          else:
            revisionIds = revisions[count:]
        else: # allexceptlast
          if count >= numRevisions:
            revisionIds = []
          else:
            revisionIds = revisions[:-count]
      elif revisionsEntity[u'time']:
        dateTime = revisionsEntity[u'time'][1]
        count = 0
        if revisionsEntity[u'time'][0] == u'before':
          for revision in results:
            modifiedDateTime, _ = iso8601.parse_date(revision[VX_MODIFIED_TIME])
            if modifiedDateTime >= dateTime:
              break
            revisionIds.append(revision[u'id'])
            count += 1
          if count >= numRevisions:
            del revisionIds[-1]
        else: # after
          for revision in results:
            modifiedDateTime, _ = iso8601.parse_date(revision[VX_MODIFIED_TIME])
            if modifiedDateTime >= dateTime:
              revisionIds.append(revision[u'id'])
              count += 1
          if count >= numRevisions:
            del revisionIds[0]
      else: # range
        startDateTime = revisionsEntity[u'range'][1]
        endDateTime = revisionsEntity[u'range'][2]
        count = 0
        for revision in results:
          modifiedDateTime, _ = iso8601.parse_date(revision[VX_MODIFIED_TIME])
          if modifiedDateTime >= startDateTime:
            if modifiedDateTime >= endDateTime:
              break
            revisionIds.append(revision[u'id'])
            count += 1
        if count >= numRevisions:
          del revisionIds[0]
  except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
          GAPI.badRequest, GAPI.revisionsNotSupported) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return revisionIds

# gam <UserTypeEntity> delete filerevisions <DriveFileEntity> select <DriveFileRevisionIdEntity> [previewdelete]
#	[showtitles] [doit] [max_to_delete <Number>]
def deleteFileRevisions(users):
  fileIdEntity = getDriveFileEntity()
  revisionsEntity = None
  previewDelete = showTitles = doIt = False
  maxToProcess = 1
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'select':
      revisionsEntity = getRevisionsEntity()
    elif myarg == u'previewdelete':
      previewDelete = True
    elif myarg == u'showtitles':
      showTitles = True
    elif myarg == u'doit':
      doIt = True
    elif myarg in [u'maxtodelete', u'maxtoprocess']:
      maxToProcess = getInteger(minVal=0)
    else:
      unknownArgumentExit()
  if not revisionsEntity:
    missingArgumentExit(u'select <DriveFileRevisionIdEntity>')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if jcount == 0:
      continue
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      fileName = fileId
      entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
      if showTitles:
        fileName, entityType = _getDriveFileNameFromId(drive, fileId)
      revisionIds = _selectRevisionIds(drive, fileId, origUser, user, i, count, j, jcount, revisionsEntity)
      kcount = len(revisionIds)
      if kcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.USER, user, entityType, fileName], Ent.DRIVE_FILE_REVISION, kcount,
                                                   Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(Ent.DRIVE_FILE_REVISION)), j, jcount)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not previewDelete:
        if maxToProcess and kcount > maxToProcess:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user, entityType, fileName], Ent.DRIVE_FILE_REVISION, kcount,
                                                     Msg.COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(kcount, Act.ToPerform(), maxToProcess), j, jcount)
          continue
        if not doIt:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user, entityType, fileName], Ent.DRIVE_FILE_REVISION, kcount,
                                                     Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
          continue
        entityPerformActionNumItems([Ent.USER, user, entityType, fileName], kcount, Ent.DRIVE_FILE_REVISION, j, jcount)
      else:
        entityPerformActionNumItemsModifier([Ent.USER, user, entityType, fileName], kcount, Ent.DRIVE_FILE_REVISION, Msg.PREVIEW_ONLY, j, jcount)
      Ind.Increment()
      k = 0
      for revisionId in revisionIds:
        k += 1
        if not previewDelete:
          try:
            callGAPI(drive.revisions(), u'delete',
                     throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.REVISION_NOT_FOUND, GAPI.REVISION_DELETION_NOT_SUPPORTED,
                                                                    GAPI.CANNOT_DELETE_ONLY_REVISION, GAPI.REVISIONS_NOT_SUPPORTED],
                     fileId=fileId, revisionId=revisionId)
            entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.DRIVE_FILE_REVISION, revisionId], k, kcount)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                  GAPI.badRequest, GAPI.revisionDeletionNotSupported, GAPI.cannotDeleteOnlyRevision, GAPI.revisionsNotSupported) as e:
            entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
          except GAPI.revisionNotFound:
            entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.DRIVE_FILE_REVISION, revisionId], k, kcount)
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
            break
        else:
          entityActionNotPerformedWarning([Ent.USER, user, entityType, fileName, Ent.DRIVE_FILE_REVISION, revisionId], Msg.PREVIEW_ONLY, k, kcount)
      Ind.Decrement()

def _selectRevisionResults(results, fileId, origUser, revisionsEntity, previewDelete):
  numRevisions = len(results)
  if numRevisions == 0:
    return results
  if revisionsEntity[u'count']:
    countType = revisionsEntity[u'count'][0]
    count = revisionsEntity[u'count'][1]
    if countType == u'first':
      if count >= numRevisions:
        if previewDelete:
          results.pop()
      else:
        for _ in range(numRevisions-count):
          results.pop()
    elif countType == u'last':
      if count >= numRevisions:
        if previewDelete:
          results.popleft()
      else:
        for _ in range(numRevisions-count):
          results.popleft()
    elif countType == u'allexceptfirst':
      if count >= numRevisions:
        results.clear()
      else:
        for _ in range(count):
          results.popleft()
    else: # allexceptlast
      if count >= numRevisions:
        results.clear()
      else:
        for _ in range(count):
          results.pop()
    return results
  elif revisionsEntity[u'time']:
    dateTime = revisionsEntity[u'time'][1]
    count = 0
    if revisionsEntity[u'time'][0] == u'before':
      for revision in results:
        modifiedDateTime, _ = iso8601.parse_date(revision[VX_MODIFIED_TIME])
        if modifiedDateTime >= dateTime:
          break
        count += 1
      if count >= numRevisions:
        if previewDelete:
          results.pop()
      else:
        for _ in range(numRevisions-count):
          results.pop()
    else: # after
      for revision in results:
        modifiedDateTime, _ = iso8601.parse_date(revision[VX_MODIFIED_TIME])
        if modifiedDateTime >= dateTime:
          break
        count += 1
      if count == 0:
        if previewDelete:
          results.popleft()
      elif count >= numRevisions:
        results.clear()
      else:
        for _ in range(count):
          results.popleft()
    return results
  elif revisionsEntity[u'range']:
    startDateTime = revisionsEntity[u'range'][1]
    endDateTime = revisionsEntity[u'range'][2]
    count = 0
    selectedResults = collections.deque()
    while results:
      revision = results.popleft()
      modifiedDateTime, _ = iso8601.parse_date(revision[VX_MODIFIED_TIME])
      if modifiedDateTime >= startDateTime:
        if modifiedDateTime >= endDateTime:
          break
        selectedResults.append(revision)
        count += 1
    if count >= numRevisions:
      if previewDelete:
        selectedResults.popleft()
    else:
      results.clear()
    return selectedResults
  else:
    selectedResults = collections.deque()
    if revisionsEntity[u'dict']:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        revisionIds = revisionsEntity[u'dict'][fileId]
      else:
        revisionIds = revisionsEntity[u'dict'][origUser][fileId]
    else:
      revisionIds = revisionsEntity[u'list']
    while results:
      revision = results.popleft()
      if revision[u'id'] in revisionIds:
        selectedResults.append(revision)
    return selectedResults

FILEREVISIONS_FIELDS_CHOICE_MAP = {
  u'filesize': VX_SIZE,
  u'id': u'id',
  u'keepforever': u'keepForever',
  u'lastmodifyinguser': u'lastModifyingUser',
  u'lastmodifyingusername': u'lastModifyingUser.displayName',
  u'md5checksum': u'md5Checksum',
  u'mimetype': u'mimeType',
  u'modifieddate': VX_MODIFIED_TIME,
  u'modifiedtime': VX_MODIFIED_TIME,
  u'originalfilename': u'originalFilename',
  u'pinned': u'keepForever',
  u'published': u'published',
  u'publishauto': u'publishAuto',
  u'publishedoutsidedomain': u'publishedOutsideDomain',
  u'size': VX_SIZE,
  }

def _getFileRevisionsTimeObjects():
  timeObjects = [VX_MODIFIED_TIME]
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDrive3TitlesToDrive2(timeObjects, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
  return set(timeObjects)

def _showRevision(revision, timeObjects, i=0, count=0):
  printEntity([Ent.DRIVE_FILE_REVISION, revision[u'id']], i, count)
  Ind.Increment()
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDriveRevisionNames(revision)
  showJSON(None, revision, [u'id',], timeObjects)
  Ind.Decrement()

def _printShowFileRevisions(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'Owner', u'id'])
  fieldsList = []
  fileIdEntity = getDriveFileEntity()
  revisionsEntity = None
  oneItemPerRow = previewDelete = showTitles = False
  orderByList = []
  fileNameTitle = [V3_FILENAME, V2_FILENAME][not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'select':
      revisionsEntity = getRevisionsEntity()
    elif csvFormat and myarg == u'oneitemperrow':
      oneItemPerRow = True
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'previewdelete':
      previewDelete = True
    elif myarg == u'showtitles':
      showTitles = True
      if csvFormat:
        addTitlesToCSVfile(fileNameTitle, titles)
    elif getFieldsList(myarg, FILEREVISIONS_FIELDS_CHOICE_MAP, fieldsList, u'id'):
      pass
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  if fieldsList:
    fields = VX_NPT_REVISIONS_FIELDLIST.format(u','.join(set(fieldsList)).replace(u'.', u'/'))
  else:
    fields = u'*'
  timeObjects = _getFileRevisionsTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=[Ent.DRIVE_FILE_OR_FOLDER, None][csvFormat], orderBy=orderBy)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId, not csvFormat)
        results = callGAPIpages(drive.revisions(), u'list', VX_PAGES_REVISIONS,
                                throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.REVISIONS_NOT_SUPPORTED],
                                fileId=fileId, fields=fields, pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
        if revisionsEntity:
          results = _selectRevisionResults(results, fileId, origUser, revisionsEntity, previewDelete)
        if not csvFormat:
          kcount = len(results)
          entityPerformActionNumItems([entityType, fileName], kcount, Ent.DRIVE_FILE_REVISION, j, jcount)
          Ind.Increment()
          k = 0
          for revision in results:
            k += 1
            _showRevision(revision, timeObjects, k, kcount)
          Ind.Decrement()
        elif results:
          if oneItemPerRow:
            for revision in results:
              row = {u'Owner': user, u'id': fileId}
              if showTitles:
                row[fileNameTitle] = fileName
              if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
                _mapDriveRevisionNames(revision)
              addRowTitlesToCSVfile(flattenJSON({u'revision': revision}, flattened=row, timeObjects=timeObjects), csvRows, titles)
          else:
            if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
              for revision in results:
                _mapDriveRevisionNames(revision)
            if showTitles:
              addRowTitlesToCSVfile(flattenJSON({u'revisions': results}, flattened={u'Owner': user, u'id': fileId, fileNameTitle: fileName}, timeObjects=timeObjects), csvRows, titles)
            else:
              addRowTitlesToCSVfile(flattenJSON({u'revisions': results}, flattened={u'Owner': user, u'id': fileId}, timeObjects=timeObjects), csvRows, titles)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.revisionsNotSupported) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvFormat:
    if oneItemPerRow:
      writeCSVfile(csvRows, titles, u'Drive File Revisions', todrive, [u'Owner', u'id', fileNameTitle, u'revision.id'])
    else:
      writeCSVfile(csvRows, titles, u'Drive File Revisions', todrive, [u'Owner', u'id', fileNameTitle])

# gam <UserTypeEntity> print filerevisions <DriveFileEntity> [todrive [<ToDriveAttributes>]] [oneitemperrow] [select <DriveFileRevisionIDEntity>] [previewdelete]
#	[showtitles] [<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def printFileRevisions(users):
  _printShowFileRevisions(users, True)

# gam <UserTypeEntity> show filerevisions <DriveFileEntity> [select <DriveFileRevisionIDEntity>] [previewdelete]
#	[showtitles] [<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def showFileRevisions(users):
  _printShowFileRevisions(users, False)

def _stripMeInOwners(query):
  if not query:
    return query
  query = query.replace(ME_IN_OWNERS_AND, u'')
  query = query.replace(AND_ME_IN_OWNERS, u'')
  return query.replace(ME_IN_OWNERS, u'').strip() or None

def _stripNotMeInOwners(query):
  if not query:
    return query
  query = query.replace(NOT_ME_IN_OWNERS_AND, u'')
  query = query.replace(AND_NOT_ME_IN_OWNERS, u'')
  return query.replace(NOT_ME_IN_OWNERS, u'').strip() or None

def _updateAnyOwnerQuery(query):
  query = _stripNotMeInOwners(query)
  return _stripMeInOwners(query)

def _getShowOwnedBy(query):
  showOwnedBy = getChoice(SHOW_OWNED_BY_CHOICE_MAP, mapChoice=True)
  if showOwnedBy is None:
    query = _updateAnyOwnerQuery(query)
  elif not showOwnedBy:
    query = _stripMeInOwners(query)
    if query:
      if query.find(NOT_ME_IN_OWNERS) == -1:
        query = NOT_ME_IN_OWNERS_AND+query
    else:
      query = NOT_ME_IN_OWNERS
  else:
    query = _stripNotMeInOwners(query)
    if query:
      if query.find(ME_IN_OWNERS) == -1:
        query = ME_IN_OWNERS_AND+query
    else:
      query = ME_IN_OWNERS
  return (showOwnedBy, query)

OWNED_BY_ME_FIELDS_TITLES = [u'ownedByMe',]

def initFileTree(drive, teamdrive, getTeamDriveNames):
  fileTree = {u'Orphans': {u'info': {u'id': u'Orphans', VX_FILENAME: u'Orphans', u'mimeType': MIMETYPE_GA_FOLDER, u'ownedByMe': True}, u'children': []}}
  try:
    if not teamdrive:
      f_file = callGAPI(drive.files(), u'get',
                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                        fileId=u'root', fields=u','.join(VX_FILEPATH_FIELDS_TITLES+OWNED_BY_ME_FIELDS_TITLES))
      fileTree[f_file[u'id']] = {u'info': f_file, u'children': []}
    elif u'teamDriveId' in teamdrive:
      f_file = callGAPI(drive.files(), u'get',
                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                        fileId=teamdrive[u'teamDriveId'], supportsTeamDrives=True, fields=u','.join(VX_FILEPATH_FIELDS_TITLES+OWNED_BY_ME_FIELDS_TITLES))
      fileTree[f_file[u'id']] = {u'info': f_file, u'children': []}
      fileTree[f_file[u'id']][u'info'][VX_FILENAME] = u'TeamDrive({0})'.format(callGAPI(drive.teamdrives(), u'get',
                                                                                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND],
                                                                                        teamDriveId=teamdrive[u'teamDriveId'], fields=u'name')[u'name'])
    if getTeamDriveNames:
      tdrives = callGAPIpages(drive.teamdrives(), u'list', u'teamDrives',
                              throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                              fields=u'nextPageToken,teamDrives(id,name)', pageSize=100)
      for tdrive in tdrives:
        if tdrive[u'id'] not in fileTree:
          fileTree[tdrive[u'id']] = {u'info': {u'id': tdrive[u'id'], VX_FILENAME: u'TeamDrive({0})'.format(tdrive[u'name']), u'mimeType': MIMETYPE_GA_FOLDER}, u'children': []}
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.notFound, GAPI.teamDriveNotFound):
    pass
  return fileTree

def extendFileTree(fileTree, feed):
  for f_file in feed:
    if u'parents' not in f_file:
      f_file[u'parents'] = []
    fileId = f_file[u'id']
    if fileId not in fileTree:
      fileTree[fileId] = {u'info': f_file, u'children': []}
    else:
      fileTree[fileId][u'info'] = f_file
    parents = f_file[u'parents']
    if not parents:
      parents = [u'Orphans',]
    for parentId in parents:
      if parentId not in fileTree:
        fileTree[parentId] = {u'info': {u'id': parentId, VX_FILENAME: parentId, u'mimeType': MIMETYPE_GA_FOLDER}, u'children': []}
      fileTree[parentId][u'children'].append(fileId)

def buildFileTree(feed, drive, teamdrive=None, getTeamDriveNames=False):
  fileTree = initFileTree(drive, teamdrive, getTeamDriveNames)
  extendFileTree(fileTree, feed)
  return fileTree

def addFilePathsToRow(drive, fileTree, fileEntryInfo, filePathInfo, row, titles):
  _, paths = getFilePaths(drive, fileTree, fileEntryInfo, filePathInfo)
  kcount = len(paths)
  row[u'paths'] = kcount
  k = 0
  for path in sorted(paths):
    key = u'path.{0}'.format(k)
    if key not in titles[u'set']:
      addTitleToCSVfile(key, titles)
    row[key] = path
    k += 1

SHOW_OWNED_BY_CHOICE_MAP = {u'any': None, u'me': True, u'others': False}
FILELIST_FIELDS_TITLES = [u'id', u'mimeType', u'parents']

# gam <UserTypeEntity> print|show filelist [todrive [<ToDriveAttributes>]] [corpora <CorporaAttribute>] [anyowner|(showownedby any|me|others)]
#	[query <QueryDriveFile>] [fullquery <QueryDriveFile>] [<DriveFileQueryShortcut>]
#	[select <DriveFileEntityListTree>] [selectsubquery <QueryDriveFile>] [showmimetype [not] <MimeTypeList>] [depth <Number>] [showparent]
#	[filepath] [buildtree] [allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveFileOrderByFieldName> [ascending|descending])* [delimiter <Character>] [quotechar <Character>]
def printFileList(users):
  def _setSelectionFields():
    if fileIdEntity:
      _setSkipObjects(skipObjects, FILELIST_FIELDS_TITLES, fieldsList)
    if filepath:
      _setSkipObjects(skipObjects, VX_FILEPATH_FIELDS_TITLES, fieldsList)
    if showOwnedBy is not None:
      _setSkipObjects(skipObjects, OWNED_BY_ME_FIELDS_TITLES, fieldsList)
    if mimeTypeCheck[u'mimeTypes']:
      if u'mimeType' not in fieldsList:
        skipObjects.add(u'mimeType')
        fieldsList.append(u'mimeType')
    if onlyTeamDrives or getPermissionsForTeamDrives:
      if u'teamDriveId' not in fieldsList:
        skipObjects.add(u'teamDriveId')
        fieldsList.append(u'teamDriveId')

  def _printFileInfo(drive, f_file):
    if showOwnedBy is not None and f_file.get(u'ownedByMe', showOwnedBy) != showOwnedBy:
      return
    if not checkMimeType(mimeTypeCheck, f_file):
      return
    if onlyTeamDrives and not f_file.get(u'teamDriveId'):
      return
    if getPermissionsForTeamDrives and f_file.get(u'teamDriveId') and u'permissions' not in f_file:
      try:
        f_file[u'permissions'] = callGAPIpages(drive.permissions(), u'list', VX_PAGES_PERMISSIONS,
                                               throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                               fileId=f_file[u'id'], fields=permissionsFields, supportsTeamDrives=True)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.internalError,
              GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
        pass
    row = {u'Owner': user}
    fileInfo = f_file.copy()
    if filepath:
      addFilePathsToRow(drive, fileTree, fileInfo, filePathInfo, row, titles)
    if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
      _mapDriveFieldNames(fileInfo, user, parentsSubFields, False)
    else:
      _mapDriveParents(fileInfo, parentsSubFields)
      _mapDriveProperties(fileInfo)
      for permission in fileInfo.get(u'permissions', []):
        _mapDrivePermissionNames(permission)
    for attrib in fileInfo:
      if attrib in skipObjects:
        pass
      elif not isinstance(fileInfo[attrib], dict):
        if isinstance(fileInfo[attrib], (list, collections.deque)):
          if fileInfo[attrib]:
            if attrib not in titles[u'set']:
              addTitleToCSVfile(attrib, titles)
            if isinstance(fileInfo[attrib][0], non_compound_types):
              row[attrib] = delimiter.join(fileInfo[attrib])
            else:
              row[attrib] = len(fileInfo[attrib])
              for j, l_attrib in enumerate(fileInfo[attrib]):
                for list_attrib in l_attrib:
                  if list_attrib not in set([u'kind', u'etag', u'selfLink']):
                    x_attrib = u'{0}.{1}.{2}'.format(attrib, j, list_attrib)
                    row[x_attrib] = l_attrib[list_attrib]
                    if x_attrib not in titles[u'set']:
                      addTitleToCSVfile(x_attrib, titles)
        elif isinstance(fileInfo[attrib], non_compound_types):
          if attrib not in timeObjects:
            if isinstance(fileInfo[attrib], string_types) and (fileInfo[attrib].find(u'\n') >= 0 or fileInfo[attrib].find(u'\r') >= 0):
              if GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]:
                row[attrib] = escapeCRsNLs(fileInfo[attrib])
              else:
                row[attrib] = fileInfo[attrib]
            else:
              row[attrib] = fileInfo[attrib]
          else:
            row[attrib] = formatLocalTime(fileInfo[attrib])
          if attrib not in titles[u'set']:
            addTitleToCSVfile(attrib, titles)
        else:
          writeStderr(u'{0}: {1}, Attribute: {2}, Unknown type: {3}\n'.format(Ent.Singular(Ent.DRIVE_FILE_ID), fileInfo[u'id'], attrib, type(fileInfo[attrib])))
      else:
        for dict_attrib in fileInfo[attrib]:
          if dict_attrib not in DEFAULT_SKIP_OBJECTS:
            x_attrib = u'{0}.{1}'.format(attrib, dict_attrib)
            row[x_attrib] = fileInfo[attrib][dict_attrib]
            if x_attrib not in titles[u'set']:
              addTitleToCSVfile(x_attrib, titles)
    csvRows.append(row)

  def _printChildDriveFolderContents(drive, fileEntry, user, i, count, depth):
    parentFileEntry = fileTree.get(fileEntry[u'id'])
    if parentFileEntry and u'children' in parentFileEntry:
      for childFileId in parentFileEntry[u'children']:
        childEntry = fileTree.get(childFileId)
        if childEntry:
          if childFileId not in filesPrinted:
            filesPrinted.add(childFileId)
            _printFileInfo(drive, childEntry[u'info'].copy())
          if childEntry[u'info'][u'mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
            _printChildDriveFolderContents(drive, childEntry[u'info'], user, i, count, depth+1)
      return
    q = WITH_PARENTS.format(fileEntry[u'id'])
    if selectSubQuery:
      q += ' and '+selectSubQuery
    try:
      children = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID],
                               q=q, orderBy=orderBy, fields=pagesfields,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], includeTeamDriveItems=True, supportsTeamDrives=True)
    except (GAPI.invalidQuery, GAPI.invalid):
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(selectSubQuery), i, count)
      return
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      childFileId = childEntryInfo[u'id']
      if filepath:
        fileTree.setdefault(childFileId, {u'info': childEntryInfo})
      if childFileId not in filesPrinted:
        filesPrinted.add(childFileId)
        _printFileInfo(drive, childEntryInfo.copy())
      if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
        _printChildDriveFolderContents(drive, childEntryInfo, user, i, count, depth+1)

  todrive = {}
  titles, csvRows = initializeTitlesCSVfile([u'Owner',])
  allfields = buildTree = filepath = getTeamDriveNames = onlyTeamDrives = showParent = False
  maxdepth = -1
  fieldsList = []
  orderByList = []
  skipObjects = set()
  query = ME_IN_OWNERS
  selectSubQuery = u''
  fileIdEntity = {}
  parentsSubFields = _initParentsSubFields()
  showOwnedBy = fileTree = None
  mimeTypeCheck = initMimeTypeCheck()
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  kwargs = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'filepath':
      filepath = True
    elif myarg == u'buildtree':
      buildTree = True
    elif myarg == u'showparent':
      showParent = getBoolean()
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'query':
      if query:
        query += u' and '+getString(Cmd.OB_QUERY)
      else:
        query = getString(Cmd.OB_QUERY)
    elif myarg == u'fullquery':
      query = getString(Cmd.OB_QUERY, minLen=0)
      if not query:
        query = None
    elif myarg in QUERY_SHORTCUTS_MAP:
      query = _updateAnyOwnerQuery(query)
      if query:
        query += u' and '+QUERY_SHORTCUTS_MAP[myarg]
      else:
        query = QUERY_SHORTCUTS_MAP[myarg]
    elif myarg == u'select':
      fileIdEntity = getDriveFileEntity(orphansOK=True, queryShortcutsOK=False)
      query = None
    elif myarg == u'selectsubquery':
      selectSubQuery = getString(Cmd.OB_QUERY, minLen=0)
    elif myarg == u'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == u'allfields':
      fieldsList = []
      allfields = True
    elif myarg in DRIVEFILE_LABEL_CHOICE_MAP:
      addFieldToCSVfile(myarg, DRIVEFILE_LABEL_CHOICE_MAP, fieldsList, titles)
    elif myarg in DRIVEFILE_FIELDS_CHOICE_MAP:
      addFieldToCSVfile(myarg, DRIVEFILE_FIELDS_CHOICE_MAP, fieldsList, titles)
      if myarg == u'parents':
        _setAllParentsSubFields(parentsSubFields)
    elif myarg == u'fields':
      for field in _getFieldsList():
        if field in DRIVEFILE_LABEL_CHOICE_MAP:
          addFieldToCSVfile(field, DRIVEFILE_LABEL_CHOICE_MAP, fieldsList, titles)
        elif field.find(u'.') == -1:
          if field in DRIVEFILE_FIELDS_CHOICE_MAP:
            addFieldToCSVfile(field, DRIVEFILE_FIELDS_CHOICE_MAP, fieldsList, titles)
            if field == u'parents':
              _setAllParentsSubFields(parentsSubFields)
          else:
            invalidChoiceExit(list(DRIVEFILE_FIELDS_CHOICE_MAP)+list(DRIVEFILE_LABEL_CHOICE_MAP), True)
        else:
          _getDriveFieldSubField(field, fieldsList, titles, parentsSubFields)
    elif myarg.find(u'.') != -1:
      _getDriveFieldSubField(myarg, fieldsList, titles, parentsSubFields)
    elif myarg == u'anyowner':
      query = _updateAnyOwnerQuery(query)
    elif myarg == u'showownedby':
      showOwnedBy, query = _getShowOwnedBy(query)
    elif myarg == u'showmimetype':
      getMimeTypeCheck(mimeTypeCheck)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif myarg == u'corpora':
      onlyTeamDrives = _getCorpora(kwargs)
      getTeamDriveNames = True
      query = _updateAnyOwnerQuery(query)
    else:
      unknownArgumentExit()
  noSelect = (not fileIdEntity
              or (not fileIdEntity[u'dict']
                  and not fileIdEntity[u'query']
                  and not fileIdEntity[u'teamdrivefilequery']
                  and not fileIdEntity[u'list']))
  if noSelect:
    buildTree = True
    if maxdepth != -1:
      if not fileIdEntity:
        fileIdEntity = initDriveFileEntity()
      if not fileIdEntity[u'teamdrive']:
        cleanFileIDsList(fileIdEntity, [u'root',])
      noSelect = False
  getPermissionsForTeamDrives = False
  if fieldsList:
    getPermissionsForTeamDrives, permissionsFields = _setGetPermissionsForTeamDrives(fieldsList)
    _setSelectionFields()
    fields = u','.join(set(fieldsList)).replace(u'.', u'/')
    pagesfields = VX_NPT_FILES_FIELDLIST.format(fields)
  elif not allfields:
    for field in [u'name', u'webviewlink']:
      addFieldToCSVfile(field, DRIVEFILE_FIELDS_CHOICE_MAP, fieldsList, titles)
    _setSelectionFields()
    fields = u','.join(set(fieldsList)).replace(u'.', u'/')
    pagesfields = VX_NPT_FILES_FIELDLIST.format(fields)
  else:
    fields = pagesfields = u'*'
    _setAllParentsSubFields(parentsSubFields)
    skipObjects = skipObjects.union(DEFAULT_SKIP_OBJECTS)
  orderBy = u','.join(orderByList) if orderByList else None
  if filepath:
    addTitlesToCSVfile(u'paths', titles)
  timeObjects = _getDriveTimeObjects()
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    fileNameTitle = V2_FILENAME
    _mapDrive3TitlesToDrive2(titles[u'list'], API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
    _mapDrive3TitlesToDrive2(titles[u'list'], API.DRIVE3_TO_DRIVE2_CAPABILITIES_TITLES_MAP)
    titles[u'set'] = set(titles[u'list'])
  else:
    fileNameTitle = V3_FILENAME
  removeTitlesFromCSVfile([u'capabilities',], titles)
  query = _mapDrive2QueryToDrive3(query)
  incrementalPrint = (buildTree and (not filepath) and noSelect)
  if buildTree:
    if not fileIdEntity.get(u'teamdrive'):
      btkwargs = kwargs
    else:
      query = _updateAnyOwnerQuery(query)
      btkwargs = fileIdEntity[u'teamdrive']
      getTeamDriveNames = True
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    if parentsSubFields[u'isRoot']:
      parentsSubFields[u'rootFolderId'] = callGAPI(drive.files(), u'get',
                                                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                                   fileId=u'root', fields=u'id')[u'id']
    if filepath:
      filePathInfo = initFilePathInfo()
    filesPrinted = set()
    if incrementalPrint:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
      page_message = getPageMessageForWhom()
      pageToken = None
      totalItems = 0
      queryError = False
      while True:
        try:
          feed = callGAPI(drive.files(), u'list',
                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                          pageToken=pageToken,
                          q=query, orderBy=orderBy, fields=pagesfields,
                          pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **btkwargs)
          if feed:
            pageToken = feed.get(u'nextPageToken')
            if VX_PAGES_FILES in feed:
              totalItems += len(feed[VX_PAGES_FILES])
              show_message = page_message.replace(TOTAL_ITEMS_MARKER, str(totalItems))
              writeStderr(show_message.format(Ent.Choose(Ent.DRIVE_FILE_OR_FOLDER, totalItems)))
              for f_file in feed[VX_PAGES_FILES]:
                _printFileInfo(drive, f_file)
            del feed
          else:
            pageToken = None
          if not pageToken:
            break
        except (GAPI.invalidQuery, GAPI.invalid):
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(query), i, count)
          queryError = True
          break
        except GAPI.fileNotFound:
          printGotEntityItemsForWhom(0)
          break
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), i, count)
          break
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      if queryError:
        break
      continue
    fileTree = {}
    if buildTree:
      try:
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
        feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                             page_message=getPageMessageForWhom(),
                             throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                             q=query, orderBy=orderBy, fields=pagesfields,
                             pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **btkwargs)
        if filepath:
          fileTree = buildFileTree(feed, drive, getTeamDriveNames=getTeamDriveNames)
      except (GAPI.invalidQuery, GAPI.invalid):
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(query), i, count)
        break
      except GAPI.fileNotFound:
        printGotEntityItemsForWhom(0)
        continue
      except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), i, count)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
    if noSelect:
      if filepath:
        for f_file in feed:
          _printFileInfo(drive, f_file)
      else:
        while feed:
          _printFileInfo(drive, feed.popleft())
    else:
      user, drive, jcount = _validateUserGetFileIDs(origUser, i, count, fileIdEntity, drive=drive)
      if jcount == 0:
        continue
      j = 0
      for fileId in fileIdEntity[u'list']:
        j += 1
        try:
          fileEntry = fileTree.get(fileId)
          if fileEntry:
            fileEntryInfo = fileEntry[u'info']
          else:
            fileEntryInfo = callGAPI(drive.files(), u'get',
                                     throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                     fileId=fileId, fields=fields, supportsTeamDrives=True)
            if filepath:
              fileTree[fileId] = {u'info': fileEntryInfo}
          if showParent or fileEntryInfo[u'mimeType'] != MIMETYPE_GA_FOLDER:
            if fileId not in filesPrinted:
              filesPrinted.add(fileId)
              _printFileInfo(drive, fileEntryInfo.copy())
          if fileEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
            _printChildDriveFolderContents(drive, fileEntryInfo, user, i, count, 0)
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
  writeCSVfile(csvRows, titles,
               u'{0} {1} Drive Files'.format(Cmd.Argument(GM.Globals[GM.ENTITY_CL_START]),
                                             Cmd.Argument(GM.Globals[GM.ENTITY_CL_START]+1)),
               todrive, [u'Owner', u'id', fileNameTitle], quotechar, filepath)

def _printShowFilePaths(users, csvFormat):
  if csvFormat:
    fileNameTitle = [V3_FILENAME, V2_FILENAME][not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'Owner', u'id', fileNameTitle])
  fileIdEntity = getDriveFileEntity()
  oneItemPerRow = False
  orderByList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif csvFormat and myarg == u'oneitemperrow':
      oneItemPerRow = True
      addTitlesToCSVfile(u'path', titles)
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=[Ent.DRIVE_FILE_OR_FOLDER, None][csvFormat], orderBy=orderBy)
    if jcount == 0:
      continue
    filePathInfo = initFilePathInfo()
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields=VX_FILENAME_PARENTS_MIMETYPE, supportsTeamDrives=True)
        entityType, paths = getFilePaths(drive, None, result, filePathInfo)
        if not csvFormat:
          kcount = len(paths)
          entityPerformActionNumItems([entityType, u'{0} ({1})'.format(result[VX_FILENAME], fileId)], kcount, Ent.DRIVE_PATH, j, jcount)
          Ind.Increment()
          k = 0
          for path in paths:
            k += 1
            printEntity([Ent.DRIVE_PATH, path], k, kcount)
          Ind.Decrement()
        else:
          if oneItemPerRow:
            if paths:
              for path in paths:
                csvRows.append({u'Owner': user, u'id': fileId, fileNameTitle: result[VX_FILENAME], u'path': path})
            else:
              csvRows.append({u'Owner': user, u'id': fileId, fileNameTitle: result[VX_FILENAME]})
          else:
            addRowTitlesToCSVfile(flattenJSON({u'paths': paths}, flattened={u'Owner': user, u'id': fileId, fileNameTitle: result[VX_FILENAME]}), csvRows, titles)
      except GAPI.fileNotFound:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], Msg.DOES_NOT_EXIST, j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Drive File Paths', todrive, [u'Owner', u'id', fileNameTitle, u'paths'] if not oneItemPerRow else None)

# gam <UserTypeEntity> print filepaths <DriveFileEntity> [todrive [<ToDriveAttributes>]] [oneitemperrow] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def printFilePaths(users):
  _printShowFilePaths(users, True)

# gam <UserTypeEntity> show filepaths <DriveFileEntity> (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def showFilePaths(users):
  _printShowFilePaths(users, False)

def _printShowFileCounts(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'Total'])
  fieldsList = [u'mimeType',]
  onlyTeamDrives = False
  query = ME_IN_OWNERS
  mimeTypeCheck = initMimeTypeCheck()
  fileIdEntity = initDriveFileEntity()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'showmimetype':
      getMimeTypeCheck(mimeTypeCheck)
      if query:
        query += u' and ('
      if not mimeTypeCheck[u'reverse']:
        for mimeType in mimeTypeCheck[u'mimeTypes']:
          query += u"mimeType = '{0}' or ".format(mimeType)
        query = query[:-4]
      else:
        for mimeType in mimeTypeCheck[u'mimeTypes']:
          query += u"mimeType != '{0}' and ".format(mimeType)
        query = query[:-5]
      query += u')'
    elif myarg == u'query':
      if query:
        query += u' and '+getString(Cmd.OB_QUERY)
      else:
        query = getString(Cmd.OB_QUERY)
    elif myarg == u'fullquery':
      query = getString(Cmd.OB_QUERY, minLen=0)
      if not query:
        query = None
    elif myarg in QUERY_SHORTCUTS_MAP:
      query = _updateAnyOwnerQuery(query)
      if query:
        query += u' and '+QUERY_SHORTCUTS_MAP[myarg]
      else:
        query = QUERY_SHORTCUTS_MAP[myarg]
    elif myarg == u'anyowner':
      query = _updateAnyOwnerQuery(query)
    elif myarg == u'showownedby':
      _, query = _getShowOwnedBy(query)
    elif myarg == u'corpora':
      onlyTeamDrives = _getCorpora(fileIdEntity[u'teamdrive'])
      if onlyTeamDrives:
        fieldsList.append(u'teamDriveId')
    elif myarg == u'select':
      fileIdEntity = getTeamDriveEntity()
    else:
      unknownArgumentExit()
  if fileIdEntity.get(u'teamdrive'):
    query = _updateAnyOwnerQuery(query)
  query = _mapDrive2QueryToDrive3(query)
  pagesfields = VX_NPT_FILES_FIELDLIST.format(u','.join(fieldsList))
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    total = 0
    mimeTypeCounts = {}
    Ind.Increment()
    try:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
      feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                           page_message=getPageMessageForWhom(),
                           throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.TEAMDRIVE_NOT_FOUND, GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                           q=query, fields=pagesfields,
                           pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **fileIdEntity[u'teamdrive'])
      for f_file in feed:
        if not onlyTeamDrives or f_file.get(u'teamDriveId'):
          total += 1
          mimeTypeCounts.setdefault(f_file[u'mimeType'], 0)
          mimeTypeCounts[f_file[u'mimeType']] += 1
      if not csvFormat:
        printEntityKVList([Ent.USER, user], [Ent.Choose(Ent.DRIVE_FILE_OR_FOLDER, total), total], i, count)
        Ind.Increment()
        for mimeType, mimeTypeCount in sorted(iteritems(mimeTypeCounts)):
          printKeyValueList([mimeType, mimeTypeCount])
        Ind.Decrement()
      else:
        row = {u'User': user, u'Total': total}
        row.update(mimeTypeCounts)
        addRowTitlesToCSVfile(row, csvRows, titles)
    except (GAPI.teamDriveNotFound, GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), i, count)
    except (GAPI.invalidQuery, GAPI.invalid):
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, None], invalidQuery(query), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Drive File Counts', todrive, [u'User', u'Total'])

# gam <UserTypeEntity> print filecounts [todrive [<ToDriveAttributes>]] [corpora <CorporaAttribute>] [anyowner|(showownedby any|me|others)]
#	[query <QueryDriveFile>] [fullquery <QueryDriveFile>] [<DriveFileQueryShortcut>] [showmimetype [not] <MimeTypeList>]
#	[select <TeamDriveEntity>]
def printFileCounts(users):
  _printShowFileCounts(users, True)

# gam <UserTypeEntity> show filecounts [corpora <CorporaAttribute>] [anyowner|(showownedby any|me|others)]
#	[query <QueryDriveFile>] [fullquery <QueryDriveFile>] [<DriveFileQueryShortcut>] [showmimetype [not] <MimeTypeList>]
#	[select <TeamDriveEntity>]
def showFileCounts(users):
  _printShowFileCounts(users, False)

FILETREE_FIELDS_CHOICE_MAP = {
  u'id': u'id',
  u'mime': u'mimeType',
  u'mimetype': u'mimeType',
  u'owners': u'owners',
  u'parents': u'parents',
  }

FILETREE_FIELDS_PRINT_ORDER = [u'id', u'parents', u'owners', u'mimeType']

# gam <UserTypeEntity> show filetree [anyowner|(showownedby any|me|others)]
#	[select <DriveFileEntityListTree>] [selectsubquery <QueryDriveFile>] [showmimetype [not] <MimeTypeList>] [depth <Number>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [fields <FileTreeFieldNameList>] [delimiter <Character>]
def showFileTree(users):
  def _simpleFileIdEntityList(fileIdEntityList):
    for fileId in fileIdEntityList:
      if fileId not in [u'root', u'Orphans']:
        return False
    return True

  def _showFileInfo(fileEntry, j=0, jcount=0):
    fileInfoList = []
    for field in FILETREE_FIELDS_PRINT_ORDER:
      if showFields[field]:
        if field == u'parents':
          parents = fileEntry.get(field, [])
          fileInfoList.extend([field, u'{0} [{1}]'.format(len(parents), delimiter.join(parents))])
        elif field == u'owners':
          owners = [owner[u'emailAddress'] for owner in fileEntry.get(field, [])]
          if owners:
            fileInfoList.extend([field, delimiter.join(owners)])
        else:
          fileInfoList.extend([field, fileEntry[field]])
    if fileInfoList:
      printKeyValueListWithCount([fileEntry[VX_FILENAME], formatKeyValueList(u'(', fileInfoList, u')')], j, jcount)
    else:
      printKeyValueList([fileEntry[VX_FILENAME]])

  def _showDriveFolderContents(fileEntry, depth):
    for childId in fileEntry[u'children']:
      childEntry = fileTree.get(childId)
      if childEntry:
        if checkMimeType(mimeTypeCheck, childEntry[u'info']):
          _showFileInfo(childEntry[u'info'])
        if childEntry[u'info'][u'mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
          Ind.Increment()
          _showDriveFolderContents(childEntry, depth+1)
          Ind.Decrement()

  def _showChildDriveFolderContents(drive, fileEntry, user, i, count, depth):
    q = WITH_PARENTS.format(fileEntry[u'id'])
    if selectSubQuery:
      q += ' and '+selectSubQuery
    try:
      children = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID],
                               q=q, orderBy=orderBy, fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNERS,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], supportsTeamDrives=True, includeTeamDriveItems=True)
    except (GAPI.invalidQuery, GAPI.invalid):
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(selectSubQuery), i, count)
      return
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      if checkMimeType(mimeTypeCheck, childEntryInfo):
        _showFileInfo(childEntryInfo)
      if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
        Ind.Increment()
        _showChildDriveFolderContents(drive, childEntryInfo, user, i, count, depth+1)
        Ind.Decrement()

  maxdepth = -1
  query = ME_IN_OWNERS
  fileIdEntity = initDriveFileEntity()
  selectSubQuery = u''
  showOwnedBy = fileTree = None
  showFields = {}
  for field in FILETREE_FIELDS_CHOICE_MAP:
    showFields[FILETREE_FIELDS_CHOICE_MAP[field]] = False
  buildTree = getTeamDriveNames = False
  mimeTypeCheck = initMimeTypeCheck()
  orderByList = []
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'select':
      fileIdEntity = getDriveFileEntity(orphansOK=True, queryShortcutsOK=False)
    elif myarg == u'selectsubquery':
      selectSubQuery = getString(Cmd.OB_QUERY, minLen=0)
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == u'anyowner':
      query = None
    elif myarg == u'showownedby':
      showOwnedBy = getChoice(SHOW_OWNED_BY_CHOICE_MAP, mapChoice=True)
      if showOwnedBy is None:
        query = None
      elif not showOwnedBy:
        query = NOT_ME_IN_OWNERS
      else:
        query = ME_IN_OWNERS
    elif myarg == u'showmimetype':
      getMimeTypeCheck(mimeTypeCheck)
    elif myarg == u'fields':
      for field in _getFieldsList():
        if field in FILETREE_FIELDS_CHOICE_MAP:
          showFields[FILETREE_FIELDS_CHOICE_MAP[field]] = True
        else:
          invalidChoiceExit(FILETREE_FIELDS_CHOICE_MAP, True)
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  buildTree = (not fileIdEntity[u'dict']
               and not fileIdEntity[u'query']
               and not fileIdEntity[u'teamdrivefilequery']
               and _simpleFileIdEntityList(fileIdEntity[u'list']))
  if buildTree:
    if not fileIdEntity.get(u'teamdrive'):
      btkwargs = {u'q': query}
      defaultSelection = not fileIdEntity[u'list']
    else:
      btkwargs = fileIdEntity[u'teamdrive']
      defaultSelection = False
      getTeamDriveNames = True
  orderBy = u','.join(orderByList) if orderByList else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    if buildTree:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
      page_message = getPageMessageForWhom()
      pageToken = None
      totalItems = 0
      fileTree = initFileTree(drive, fileIdEntity.get(u'teamdrive'), getTeamDriveNames)
      userError = False
      while True:
        try:
          feed = callGAPI(drive.files(), u'list',
                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                          pageToken=pageToken,
                          orderBy=orderBy, fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNERS,
                          pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **btkwargs)
          if feed:
            pageToken = feed.get(u'nextPageToken')
            if VX_PAGES_FILES in feed:
              totalItems += len(feed[VX_PAGES_FILES])
              show_message = page_message.replace(TOTAL_ITEMS_MARKER, str(totalItems))
              writeStderr(show_message.format(Ent.Choose(Ent.DRIVE_FILE_OR_FOLDER, totalItems)))
              extendFileTree(fileTree, feed[VX_PAGES_FILES])
            del feed
          else:
            pageToken = None
          if not pageToken:
            break
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), i, count)
          userError = True
          break
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          userError = True
          break
      if userError:
        continue
      if defaultSelection:
        if u'Orphans' in fileTree and fileTree[u'Orphans'][u'children']:
          cleanFileIDsList(fileIdEntity, [u'root', u'Orphans'])
        else:
          cleanFileIDsList(fileIdEntity, [u'root',])
    else:
      fileTree = {}
    user, drive, jcount = _validateUserGetFileIDs(origUser, i, count, fileIdEntity, drive=drive, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    j = 0
    Ind.Increment()
    for fileId in fileIdEntity[u'list']:
      j += 1
      if buildTree:
        fileEntry = fileTree.get(fileId)
        if not fileEntry:
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        fileEntryInfo = fileEntry[u'info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), u'get',
                                   throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId, fields=VX_ID_FILENAME_PARENTS_MIMETYPE, supportsTeamDrives=True)
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      _showFileInfo(fileEntryInfo, j, jcount)
      Ind.Increment()
      if buildTree:
        _showDriveFolderContents(fileEntry, 0)
      else:
        _showChildDriveFolderContents(drive, fileEntryInfo, user, i, count, 0)
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> create|add drivefile [drivefilename <DriveFileName>] [<DriveFileCreateAttributes>] [csv [todrive [<ToDriveAttributes>]]]
def createDriveFile(users):
  csvFormat = False
  todrive = {}
  media_body = None
  fileIdEntity = initDriveFileEntity()
  body = {}
  parameters = initializeDriveFileAttributes()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'drivefilename':
      body[VX_FILENAME] = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg == u'csv':
      csvFormat = True
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      getDriveFileAttribute(myarg, body, parameters, True)
  if csvFormat:
    fileNameTitle = [V3_FILENAME, V2_FILENAME][not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]
    titles, csvRows = initializeTitlesCSVfile([u'User', fileNameTitle, u'id'])
  body.setdefault(VX_FILENAME, u'Untitled')
  Act.Set(Act.CREATE)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, _ = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if not drive:
      continue
    if not _getDriveFileParentInfo(user, i, count, body, parameters, drive):
      continue
    if parameters[DFA_LOCALFILEPATH]:
      try:
        media_body = googleapiclient.http.MediaFileUpload(parameters[DFA_LOCALFILEPATH], mimetype=parameters[DFA_LOCALMIMETYPE], resumable=True)
      except IOError as e:
        systemErrorExit(FILE_ERROR_RC, e)
    try:
      result = callGAPI(drive.files(), u'create',
                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INVALID],
                        ocrLanguage=parameters[DFA_OCRLANGUAGE],
                        ignoreDefaultVisibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                        keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                        useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                        media_body=media_body, body=body, fields=VX_ID_FILENAME_MIMETYPE, supportsTeamDrives=True)
      if not csvFormat:
        titleInfo = u'{0}({1})'.format(result[VX_FILENAME], result[u'id'])
        if parameters[DFA_LOCALFILENAME]:
          entityModifierNewValueActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, titleInfo], Act.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], i, count)
        else:
          entityActionPerformed([Ent.USER, user, _getEntityMimeType(result), titleInfo], i, count)
      else:
        csvRows.append({u'User': user, fileNameTitle: result[VX_FILENAME], u'id': result[u'id']})
    except (GAPI.forbidden, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, body[VX_FILENAME]], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Files', todrive)

# gam <UserTypeEntity> update drivefile <DriveFileEntity> [copy] [retainname | (newfilename <DriveFileName>)] [<DriveFileUpdateAttributes>]
def updateDriveFile(users):
  fileIdEntity = getDriveFileEntity()
  body = {}
  parameters = initializeDriveFileAttributes()
  media_body = None
  assignLocalName = True
  operation = u'update'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'copy':
      operation = u'copy'
      Act.Set(Act.COPY)
    elif myarg == u'retainname':
      assignLocalName = False
    elif myarg == u'newfilename':
      body[VX_FILENAME] = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg in [u'modifieddate', u'modifiedtime']:
      body[VX_MODIFIED_TIME] = getTimeOrDeltaFromNow()
    elif getDriveFileAddRemoveParentAttribute(myarg, parameters):
      pass
    else:
      getDriveFileAttribute(myarg, body, parameters, assignLocalName)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if operation == u'update':
      if parameters[DFA_LOCALFILEPATH]:
        try:
          media_body = googleapiclient.http.MediaFileUpload(parameters[DFA_LOCALFILEPATH], mimetype=parameters[DFA_LOCALMIMETYPE], resumable=True)
        except IOError as e:
          systemErrorExit(FILE_ERROR_RC, e)
      status, addParents, removeParents = _getDriveFileAddRemoveParentInfo(user, i, count, parameters, drive)
      if not status:
        continue
      Ind.Increment()
      j = 0
      for fileId in fileIdEntity[u'list']:
        j += 1
        try:
          if media_body:
            result = callGAPI(drive.files(), u'update',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST+GAPI.TEAMDRIVES_PARENT_LIMIT, GAPI.TEAMDRIVES_FOLDER_MOVE_IN_NOT_SUPPORTED],
                              fileId=fileId, ocrLanguage=parameters[DFA_OCRLANGUAGE],
                              keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                              useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                              addParents=addParents, removeParents=removeParents,
                              media_body=media_body, body=body, fields=VX_ID_FILENAME_MIMETYPE,
                              supportsTeamDrives=True)
            entityModifierNewValueActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]], Act.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], j, jcount)
          else:
            result = callGAPI(drive.files(), u'update',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST+GAPI.TEAMDRIVES_PARENT_LIMIT, GAPI.TEAMDRIVES_FOLDER_MOVE_IN_NOT_SUPPORTED],
                              fileId=fileId, ocrLanguage=parameters[DFA_OCRLANGUAGE],
                              keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                              useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                              addParents=addParents, removeParents=removeParents,
                              body=body, fields=VX_ID_FILENAME_MIMETYPE,
                              supportsTeamDrives=True)
            entityActionPerformed([Ent.USER, user, _getEntityMimeType(result), result[VX_FILENAME]], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
                GAPI.unknownError, GAPI.invalid, GAPI.badRequest,
                GAPI.teamDrivesParentLimit, GAPI.teamDrivesFolderMoveInNotSupported) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()
    else:
      Ind.Increment()
      j = 0
      for fileId in fileIdEntity[u'list']:
        j += 1
        try:
          result = callGAPI(drive.files(), u'copy',
                            throw_reasons=GAPI.DRIVE_COPY_THROW_REASONS+[GAPI.BAD_REQUEST],
                            fileId=fileId,
                            ignoreDefaultVisibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                            keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                            body=body, fields=VX_ID_FILENAME, supportsTeamDrives=True)
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, fileId],
                                                             Act.MODIFIER_TO, result[VX_FILENAME], [Ent.DRIVE_FILE_ID, result[u'id']], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
                GAPI.unknownError, GAPI.invalid, GAPI.cannotCopyFile, GAPI.badRequest) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, fileId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()

STAT_FOLDER_TOTAL = 0
STAT_FOLDER_COPIED_MOVED = 1
STAT_FOLDER_MERGED = 2
STAT_FOLDER_DUPLICATE = 3
STAT_FOLDER_FAILED = 4
STAT_FOLDER_NOT_WRITABLE = 5
STAT_FOLDER_PERMISSIONS_FAILED = 6
STAT_FILE_TOTAL = 7
STAT_FILE_COPIED_MOVED = 8
STAT_FILE_DUPLICATE = 9
STAT_FILE_FAILED = 10
STAT_FILE_NOT_COPYABLE_MOVABLE = 11
STAT_FILE_PERMISSIONS_FAILED = 12
STAT_LENGTH = 13

FOLDER_SUBTOTAL_STATS = [STAT_FOLDER_COPIED_MOVED, STAT_FOLDER_DUPLICATE, STAT_FOLDER_MERGED, STAT_FOLDER_FAILED, STAT_FOLDER_NOT_WRITABLE]
FILE_SUBTOTAL_STATS = [STAT_FILE_COPIED_MOVED, STAT_FILE_DUPLICATE, STAT_FILE_FAILED, STAT_FILE_NOT_COPYABLE_MOVABLE]

def _initStatistics():
  return [0] * STAT_LENGTH

def _incrStatistic(statistics, stat):
  statistics[stat] += 1
  if stat in FOLDER_SUBTOTAL_STATS:
    statistics[STAT_FOLDER_TOTAL] += 1
  elif stat in FILE_SUBTOTAL_STATS:
    statistics[STAT_FILE_TOTAL] += 1

def _printStatistics(user, statistics, i, count, copy):
  if statistics[STAT_FOLDER_TOTAL]:
    if copy:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FOLDER),
                         Msg.STATISTICS_COPY_FOLDER.format(statistics[STAT_FOLDER_TOTAL],
                                                           statistics[STAT_FOLDER_COPIED_MOVED],
                                                           statistics[STAT_FOLDER_DUPLICATE],
                                                           statistics[STAT_FOLDER_MERGED],
                                                           statistics[STAT_FOLDER_FAILED],
                                                           statistics[STAT_FOLDER_NOT_WRITABLE],
                                                           statistics[STAT_FOLDER_PERMISSIONS_FAILED])],
                        i, count)
    else:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FOLDER),
                         Msg.STATISTICS_MOVE_FOLDER.format(statistics[STAT_FOLDER_TOTAL],
                                                           statistics[STAT_FOLDER_COPIED_MOVED],
                                                           statistics[STAT_FOLDER_DUPLICATE],
                                                           statistics[STAT_FOLDER_MERGED],
                                                           statistics[STAT_FOLDER_FAILED],
                                                           statistics[STAT_FOLDER_NOT_WRITABLE])],
                        i, count)
  if statistics[STAT_FILE_TOTAL]:
    if copy:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FILE),
                         Msg.STATISTICS_COPY_FILE.format(statistics[STAT_FILE_TOTAL],
                                                         statistics[STAT_FILE_COPIED_MOVED],
                                                         statistics[STAT_FILE_DUPLICATE],
                                                         statistics[STAT_FILE_FAILED],
                                                         statistics[STAT_FILE_NOT_COPYABLE_MOVABLE],
                                                         statistics[STAT_FILE_PERMISSIONS_FAILED])],
                        i, count)
    else:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FILE),
                         Msg.STATISTICS_MOVE_FILE.format(statistics[STAT_FILE_TOTAL],
                                                         statistics[STAT_FILE_COPIED_MOVED],
                                                         statistics[STAT_FILE_DUPLICATE],
                                                         statistics[STAT_FILE_FAILED],
                                                         statistics[STAT_FILE_NOT_COPYABLE_MOVABLE])],
                        i, count)

DUPLICATE_FILE_OVERWRITE_OLDER = 0
DUPLICATE_FILE_OVERWRITE_ALL = 1
DUPLICATE_FILE_DUPLICATE_NAME = 2
DUPLICATE_FILE_UNIQUE_NAME = 3
DUPLICATE_FILE_SKIP = 4
DUPLICATE_FOLDER_MERGE = 0
DUPLICATE_FOLDER_DUPLICATE_NAME = 1
DUPLICATE_FOLDER_UNIQUE_NAME = 2
DUPLICATE_FOLDER_SKIP = 3
COPY_NO_PARENTS = 0
COPY_NONPATH_PARENTS = 1
COPY_ALL_PARENTS = 2

DEFAULT_COPY_OPTIONS = {
  u'retainSourceFolders': False,
  u'duplicateFiles': DUPLICATE_FILE_OVERWRITE_OLDER,
  u'duplicateFolders': DUPLICATE_FOLDER_MERGE,
  u'copyTopFileParents': COPY_NO_PARENTS,
  u'copySubFileParents': COPY_NONPATH_PARENTS,
  u'copyTopFolderParents': COPY_NO_PARENTS,
  u'copySubFolderParents': COPY_NONPATH_PARENTS,
  u'copyFilePermissions': False,
  u'copyTopFolderPermissions': True,
  u'copySubFolderPermissions': True,
  }
CLEAR_COPY_MOVE_PARENT_OPTIONS = {
  u'copyTopFileParents': COPY_NO_PARENTS,
  u'copySubFileParents': COPY_NO_PARENTS,
  u'copyTopFolderParents': COPY_NO_PARENTS,
  u'copySubFolderParents': COPY_NO_PARENTS,
  }
CLEAR_COPY_MOVE_FOLDER_PERMISSION_OPTIONS = {
  u'copyTopFolderPermissions': False,
  u'copySubFolderPermissions': False,
  }

def _targetFilenameExists(destFilename, mimeType, targetChildren):
  destFilenameLower = destFilename.lower()
  for target in targetChildren:
    if destFilenameLower == target[VX_FILENAME].lower() and mimeType == target[u'mimeType']:
      return True
  return False

UNIQUE_PREFIX_PATTERN = re.compile(r'^(.+)\(\d+\)$')

def _getFilenamePrefix(destFilename):
  if destFilename.find(u'.') != -1:
    (base, _) = destFilename.rsplit('.', 1)
  else:
    base = destFilename
  mg = UNIQUE_PREFIX_PATTERN.match(base)
  if mg:
    return mg.group(1)
  return base

def _getUniqueFilename(destFilename, mimeType, targetChildren):
  if not _targetFilenameExists(destFilename, mimeType, targetChildren):
    return destFilename
  if destFilename.find(u'.') != -1:
    (base, ext) = destFilename.rsplit('.', 1)
    mg = UNIQUE_PREFIX_PATTERN.match(base)
    if mg:
      base = mg.group(1)
    pattern = re.compile(r'^{0}\((\d+)\)\.{1}$'.format(base, ext), flags=re.IGNORECASE)
  else:
    base = destFilename
    ext = None
    mg = UNIQUE_PREFIX_PATTERN.match(base)
    if mg:
      base = mg.group(1)
    pattern = re.compile(r'^{0}\((\d+)\)$'.format(base), flags=re.IGNORECASE)
  n = 0
  for target in targetChildren:
    mg = pattern.match(target[VX_FILENAME])
    if mg:
      v = int(mg.group(1))
      if v > n:
        n = v
  if ext is not None:
    return u'{0}({1}).{2}'.format(base, n+1, ext)
  else:
    return u'{0}({1})'.format(base, n+1)

def _copyPermissions(drive, user, i, count, j, jcount, entityType, fileId, fileTitle, newFileId, newFileTitle, statistics, stat, destTeamDriveId):
  try:
    try:
      permissions = callGAPIpages(drive.permissions(), u'list', VX_PAGES_PERMISSIONS,
                                  throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                  fileId=fileId, fields=VX_NPT_PERMISSIONS_FIELDLIST.format(u'allowFileDiscovery,domain,emailAddress,expirationTime,id,role,type'),
                                  supportsTeamDrives=True)
    except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
      entityActionFailedWarning([Ent.USER, user, entityType, fileTitle], str(e), j, jcount)
      _incrStatistic(statistics, stat)
      return
    for permission in permissions:
      if (permission[u'role'] not in [u'owner', u'organizer']) and not (destTeamDriveId and permission[u'id'] == u'anyone'):
        permission.pop(u'id')
        try:
          callGAPI(drive.permissions(), u'create',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST,
                                                                  GAPI.OWNER_ON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                  GAPI.ORGANIZER_ON_NON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                  GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                   fileId=newFileId, sendNotificationEmail=False, emailMessage=None,
                   body=permission, fields=u'', supportsTeamDrives=True)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                GAPI.ownerOnTeamDriveItemNotSupported, GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
          entityActionFailedWarning([Ent.USER, user, entityType, newFileTitle], str(e), j, jcount)
        except GAPI.invalidSharingRequest as e:
          entityActionFailedWarning([Ent.USER, user, entityType, newFileTitle], Ent.TypeNameMessage(Ent.PERMISSION_ID, permission[u'id'], str(e)), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    _incrStatistic(statistics, stat)

def _cloneFolder(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren, atTop,
                 copyMoveOptions, statistics, destTeamDriveId):
  folderId = source.pop(u'id')
  folderTitle = source[VX_FILENAME]
  if copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
    newFolderTitleLower = newFolderTitle.lower()
    for target in targetChildren:
      if not target.get(u'processed', False) and newFolderTitleLower == target[VX_FILENAME].lower() and source[u'mimeType'] == target[u'mimeType']:
        target[u'processed'] = True
        if target[u'capabilities'][u'canAddChildren']:
          newFolderId = target[u'id']
          action = Act.Get()
          Act.Set(Act.MERGE)
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                             Act.MODIFIER_WITH, newFolderTitle,
                                                             [Ent.DRIVE_FOLDER_ID, newFolderId], j, jcount)
          Act.Set(action)
          _incrStatistic(statistics, STAT_FOLDER_MERGED)
          if copyMoveOptions[[u'copySubFolderPermissions', u'copyTopFolderPermissions'][atTop]]:
            _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FOLDER, folderId, folderTitle, newFolderId, newFolderTitle,
                             statistics, STAT_FOLDER_PERMISSIONS_FAILED, destTeamDriveId)
          return (newFolderId, True)
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], Msg.NOT_WRITABLE, j, jcount)
        _incrStatistic(statistics, STAT_FOLDER_NOT_WRITABLE)
        return (None, False)
  body = source.copy()
  body.pop(u'capabilities')
  body[VX_FILENAME] = newFolderTitle
  try:
    if destTeamDriveId:
      body.pop(u'viewersCanCopyContent', None)
      body.pop(u'writersCanShare', None)
    newFolderId = callGAPI(drive.files(), u'create',
                           throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INTERNAL_ERROR],
                           body=body, fields=u'id', supportsTeamDrives=True)[u'id']
    entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                       Act.MODIFIER_TO, newFolderTitle,
                                                       [Ent.DRIVE_FOLDER_ID, newFolderId], j, jcount)
    _incrStatistic(statistics, STAT_FOLDER_COPIED_MOVED)
    if copyMoveOptions[[u'copySubFolderPermissions', u'copyTopFolderPermissions'][atTop]]:
      _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FOLDER, folderId, folderTitle, newFolderId, newFolderTitle,
                       statistics, STAT_FOLDER_PERMISSIONS_FAILED, destTeamDriveId)
    return (newFolderId, False)
  except (GAPI.forbidden, GAPI.internalError) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], str(e), j, jcount)
    _incrStatistic(statistics, STAT_FOLDER_FAILED)
    return (None, False)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    _incrStatistic(statistics, STAT_FOLDER_FAILED)
    return (None, False)

def _identicalSourceTarget(fileId, targetChildren):
  for target in targetChildren:
    if fileId == target[u'id']:
      return True
  return False

def _checkForDuplicateTargetFile(drive, user, k, kcount, child, destFilename, targetChildren, copyMoveOptions, statistics):
  destFilenameLower = destFilename.lower()
  for target in targetChildren:
    if not target.get(u'processed', False) and destFilenameLower == target[VX_FILENAME].lower() and child[u'mimeType'] == target[u'mimeType']:
      target[u'processed'] = True
      if copyMoveOptions[u'duplicateFiles'] in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER]:
        if (copyMoveOptions[u'duplicateFiles'] == DUPLICATE_FILE_OVERWRITE_OLDER) and (child[VX_MODIFIED_TIME] <= target[VX_MODIFIED_TIME]):
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child[VX_FILENAME], Ent.DRIVE_FILE, target[VX_FILENAME]], Msg.DUPLICATE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_DUPLICATE)
          return True
        if not target[u'capabilities'][u'canDelete']:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child[VX_FILENAME], Ent.DRIVE_FILE, target[VX_FILENAME]], Msg.NOT_DELETABLE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_FAILED)
          return True
        try:
          callGAPI(drive.files(), u'delete',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                   fileId=target[u'id'])
          child[VX_FILENAME] = destFilename
          return False
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.fileNeverWritable) as e:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child[VX_FILENAME], Ent.DRIVE_FILE, target[VX_FILENAME]], u'{0}: {1}'.format(Msg.NOT_DELETABLE, str(e)), k, kcount)
          _incrStatistic(statistics, STAT_FILE_FAILED)
        return True
      elif copyMoveOptions[u'duplicateFiles'] == DUPLICATE_FILE_DUPLICATE_NAME:
        child[VX_FILENAME] = destFilename
        return False
      elif copyMoveOptions[u'duplicateFiles'] == DUPLICATE_FILE_UNIQUE_NAME:
        child[VX_FILENAME] = _getUniqueFilename(destFilename, child[u'mimeType'], targetChildren)
        return False
      else: #copyMoveOptions[u'duplicateFiles'] == DUPLICATE_FILE_SKIP
        entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child[VX_FILENAME], Ent.DRIVE_FILE, target[VX_FILENAME]], Msg.DUPLICATE, k, kcount)
        _incrStatistic(statistics, STAT_FILE_DUPLICATE)
        return True
  child[VX_FILENAME] = destFilename
  return False

DUPLICATE_FILE_CHOICES = {
  u'overwriteall': DUPLICATE_FILE_OVERWRITE_ALL,
  u'overwriteolder': DUPLICATE_FILE_OVERWRITE_OLDER,
  u'duplicatename': DUPLICATE_FILE_DUPLICATE_NAME,
  u'uniquename': DUPLICATE_FILE_UNIQUE_NAME,
  u'skip': DUPLICATE_FILE_SKIP,
  }
DUPLICATE_FOLDER_CHOICES = {
  u'merge': DUPLICATE_FOLDER_MERGE,
  u'duplicatename': DUPLICATE_FOLDER_DUPLICATE_NAME,
  u'uniquename': DUPLICATE_FOLDER_UNIQUE_NAME,
  u'skip': DUPLICATE_FOLDER_SKIP,
  }
COPY_TOP_PARENTS_CHOICES = {u'all': COPY_ALL_PARENTS, u'none': COPY_NO_PARENTS}
COPY_SUB_PARENTS_CHOICES = {u'all': COPY_ALL_PARENTS, u'none': COPY_NO_PARENTS, u'nonpath': COPY_NONPATH_PARENTS}

# gam <UserTypeEntity> copy drivefile <DriveFileEntity> [newfilename <DriveFileName>] [recursive [depth <Number>]] [summary [<Boolean>]]
#	<DriveFileCopyAttributes>*
#	[duplicatefiles overwriteolder|overwriteall|duplicatename|uniquename|skip]
#	[duplicatefolders merge|duplicatename|uniquename|skip]
#	[copytopfileparents none|all] [copytopfolderparents all|none]
#	[copysubfileparents nonpath|none|all] [copysubfolderparents nonpath|none|all]
#	[copyfilepermissions <Boolean>]
#	[copytopfolderpermissions <Boolean>] [copysubfolderpermissions <Boolean>]
def copyDriveFile(users):
  def _recursiveFolderCopy(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren, depth, atTop):
    folderId = source[u'id']
    sourceChildren = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                   q=WITH_PARENTS.format(folderId), fields=VX_NPT_FILES_ID_FILENAME_PARENTS_COPY_FIELDS,
                                   orderBy=VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME,
                                   pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **sourceSearchArgs)
    newFolderId, existingTargetFolder = _cloneFolder(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren, atTop,
                                                     copyMoveOptions, statistics, destTeamDriveId)
    if newFolderId is None:
      return
    copiedFiles[newFolderId] = 1
    kcount = len(sourceChildren)
    if kcount > 0:
      if existingTargetFolder:
        subTargetChildren = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                          q=VX_ANY_NON_TRASHED_WITH_PARENTS.format(newFolderId),
                                          orderBy=VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME,
                                          fields=VX_NPT_FILES_ID_FILENAME_CAPABILITIES_MIMETYPE_MODIFIEDTIME, **parameters[DFA_SEARCHARGS])
      else:
        subTargetChildren = collections.deque()
      Ind.Increment()
      k = 0
      for child in sourceChildren:
        k += 1
        childId = child[u'id']
        childTitle = child[VX_FILENAME]
        if copiedFiles.get(childId):
          continue
        if childId == newFolderId:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(child), childTitle], Msg.NOT_COPYABLE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
          continue
        childParents = child.pop(u'parents', [])
        child[u'parents'] = [newFolderId]
        if child[u'mimeType'] == MIMETYPE_GA_FOLDER:
          if maxdepth == -1 or depth < maxdepth:
            if copyMoveOptions[u'copySubFolderParents'] != COPY_NO_PARENTS:
              for parentId in childParents:
                if parentId != folderId or copyMoveOptions[u'copySubFolderParents'] == COPY_ALL_PARENTS:
                  child[u'parents'].append(parentId)
            _recursiveFolderCopy(drive, user, i, count, k, kcount, child, childTitle, subTargetChildren, depth+1, False)
        else:
          if not child.pop(u'capabilities')[u'canCopy']:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, childTitle], Msg.NOT_COPYABLE, k, kcount)
            _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
            continue
          if existingTargetFolder and _checkForDuplicateTargetFile(drive, user, k, kcount, child, child[VX_FILENAME], subTargetChildren, copyMoveOptions, statistics):
            continue
          if copyMoveOptions[u'copySubFileParents'] != COPY_NO_PARENTS:
            for parentId in childParents:
              if parentId != folderId or copyMoveOptions[u'copySubFileParents'] == COPY_ALL_PARENTS:
                child[u'parents'].append(parentId)
          child.pop(u'id')
          if destTeamDriveId:
            child.pop(u'viewersCanCopyContent', None)
            child.pop(u'writersCanShare', None)
          try:
            result = callGAPI(drive.files(), u'copy',
                              throw_reasons=GAPI.DRIVE_COPY_THROW_REASONS,
                              fileId=childId, body=child, fields=VX_ID_FILENAME, supportsTeamDrives=True)
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, childTitle],
                                                               Act.MODIFIER_TO, result[VX_FILENAME], [Ent.DRIVE_FILE_ID, result[u'id']], k, kcount)
            _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
            copiedFiles[result[u'id']] = 1
            if copyMoveOptions[u'copyFilePermissions']:
              _copyPermissions(drive, user, i, count, k, kcount, Ent.DRIVE_FILE, childId, childTitle, result[u'id'], result[VX_FILENAME],
                               statistics, STAT_FILE_PERMISSIONS_FAILED, destTeamDriveId)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                  GAPI.cannotCopyFile, GAPI.responsePreparationFailure, GAPI.rateLimitExceeded, GAPI.userRateLimitExceeded) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, childTitle], str(e), k, kcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
      Ind.Decrement()

  fileIdEntity = getDriveFileEntity()
  copyBody = {}
  parentBody = {}
  parameters = initializeDriveFileAttributes()
  copyParameters = initializeDriveFileAttributes()
  copyMoveOptions = DEFAULT_COPY_OPTIONS.copy()
  maxdepth = -1
  newFilename = None
  newParentsSpecified = recursive = summary = False
  copiedFiles = {}
  statistics = _initStatistics()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'newfilename':
      newFilename = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg == u'recursive':
      recursive = getBoolean()
    elif myarg == u'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == u'summary':
      summary = getBoolean()
    elif myarg == u'duplicatefiles':
      copyMoveOptions[u'duplicateFiles'] = getChoice(DUPLICATE_FILE_CHOICES, mapChoice=True)
    elif myarg == u'duplicatefolders':
      copyMoveOptions[u'duplicateFolders'] = getChoice(DUPLICATE_FOLDER_CHOICES, mapChoice=True)
    elif myarg == u'copytopfileparents':
      copyMoveOptions[u'copyTopFileParents'] = getChoice(COPY_TOP_PARENTS_CHOICES, mapChoice=True)
    elif myarg == u'copysubfileparents':
      copyMoveOptions[u'copySubFileParents'] = getChoice(COPY_SUB_PARENTS_CHOICES, mapChoice=True)
    elif myarg == u'copytopfolderparents':
      copyMoveOptions[u'copyTopFolderParents'] = getChoice(COPY_TOP_PARENTS_CHOICES, mapChoice=True)
    elif myarg == u'copysubfolderparents':
      copyMoveOptions[u'copySubFolderParents'] = getChoice(COPY_SUB_PARENTS_CHOICES, mapChoice=True)
    elif myarg == u'copyfilepermissions':
      copyMoveOptions[u'copyFilePermissions'] = getBoolean()
    elif myarg == u'copytopfolderpermissions':
      copyMoveOptions[u'copyTopFolderPermissions'] = getBoolean()
    elif myarg == u'copysubfolderpermissions':
      copyMoveOptions[u'copySubFolderPermissions'] = getBoolean()
    elif myarg == u'convert':
      deprecatedArgument(myarg)
    elif myarg == u'mimetype':
      copyBody[u'mimeType'] = getMimeType()
    elif myarg == u'ignoredefaultvisibility':
      copyParameters[DFA_IGNORE_DEFAULT_VISIBILITY] = getBoolean()
    elif myarg in [u'keeprevisionforever', u'pinned']:
      copyParameters[DFA_KEEP_REVISION_FOREVER] = getBoolean()
    elif getDriveFileParentAttribute(myarg, parameters):
      newParentsSpecified = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if not _getDriveFileParentInfo(user, i, count, parentBody, parameters, drive):
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        source = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields=VX_FILENAME_PARENTS_COPY_FILE_FIELDS, supportsTeamDrives=True)
        sourceTeamDriveId = source.get(u'teamDriveId')
        if sourceTeamDriveId:
          sourceSearchArgs = {u'teamDriveId': sourceTeamDriveId, u'corpora': u'teamDrive', u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
        else:
          sourceSearchArgs = {}
        sourceParents = source.pop(u'parents', None)
        if not sourceParents:
          sourceParents = [u'root',]
        sourceFilename = source[VX_FILENAME]
        if newParentsSpecified:
          newParents = parentBody[u'parents']
        else:
          newParents = sourceParents
        numNewParents = len(newParents)
        if numNewParents > 1:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(source), sourceFilename], Msg.MULTIPLE_PARENTS_SPECIFIED.format(numNewParents), i, count)
          _incrStatistic(statistics, STAT_FILE_FAILED)
          continue
        newParentId = newParents[0]
        source[u'parents'] = newParents
        if newFilename:
          destFilename = newFilename
        elif ((newParentsSpecified and newParentId not in sourceParents) or
              ((newParentId in sourceParents and
                (source[u'mimeType'] == MIMETYPE_GA_FOLDER and copyMoveOptions[u'duplicateFolders'] != DUPLICATE_FOLDER_MERGE) or
                (source[u'mimeType'] != MIMETYPE_GA_FOLDER and copyMoveOptions[u'duplicateFiles'] not in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER])))):
          destFilename = sourceFilename
        else:
          destFilename = u'Copy of {0}'.format(sourceFilename)
        targetChildren = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                       throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                       q=VX_ANY_NON_TRASHED_MIMETYPE_NAME_PREFIX_WITH_PARENTS.format(source[u'mimeType'], escapeDriveFileName(_getFilenamePrefix(destFilename)), newParentId),
                                       orderBy=VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME,
                                       fields=VX_NPT_FILES_ID_FILENAME_CAPABILITIES_MIMETYPE_MODIFIEDTIME, **parameters[DFA_SEARCHARGS])
        destTeamDriveId = callGAPI(drive.files(), u'get',
                                   throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=newParentId, fields=u'teamDriveId', supportsTeamDrives=True).get(u'teamDriveId')
        if sourceTeamDriveId or destTeamDriveId:
          copyMoveOptions.update(CLEAR_COPY_MOVE_PARENT_OPTIONS)
        if destTeamDriveId:
          copyMoveOptions.update(CLEAR_COPY_MOVE_FOLDER_PERMISSION_OPTIONS)
        if source[u'mimeType'] == MIMETYPE_GA_FOLDER:
          if copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
            if _identicalSourceTarget(fileId, targetChildren):
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, sourceFilename], Msg.NOT_COPYABLE_SAME_NAME_CURRENT_FOLDER_MERGE, i, count)
              _incrStatistic(statistics, STAT_FOLDER_FAILED)
              continue
          elif copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_UNIQUE_NAME:
            destFilename = _getUniqueFilename(destFilename, source[u'mimeType'], targetChildren)
          elif copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_SKIP:
            if _targetFilenameExists(destFilename, source[u'mimeType'], targetChildren):
              _incrStatistic(statistics, STAT_FOLDER_DUPLICATE)
              continue
          if copyMoveOptions[u'copyTopFolderParents'] == COPY_ALL_PARENTS:
            for parentId in sourceParents:
              if parentId not in newParents:
                source[u'parents'].append(parentId)
          if recursive:
            _recursiveFolderCopy(drive, user, i, count, j, jcount, source, destFilename, targetChildren, 0, True)
          else:
            _cloneFolder(drive, user, i, count, j, jcount, source, destFilename, targetChildren, True,
                         copyMoveOptions, statistics, destTeamDriveId)
        else:
          if not source.pop(u'capabilities')[u'canCopy']:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename], Msg.NOT_COPYABLE, j, jcount)
            _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
            continue
          if copyMoveOptions[u'duplicateFiles'] in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER] and _identicalSourceTarget(fileId, targetChildren):
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename], Msg.NOT_COPYABLE_SAME_NAME_CURRENT_FOLDER_OVERWRITE, i, count)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            continue
          if _checkForDuplicateTargetFile(drive, user, j, jcount, source, destFilename, targetChildren, copyMoveOptions, statistics):
            continue
          if copyMoveOptions[u'copyTopFileParents'] == COPY_ALL_PARENTS:
            for parentId in sourceParents:
              if parentId not in newParents:
                source[u'parents'].append(parentId)
          sourceId = source.pop(u'id')
          if destTeamDriveId:
            source.pop(u'viewersCanCopyContent', None)
            source.pop(u'writersCanShare', None)
          source.update(copyBody)
          result = callGAPI(drive.files(), u'copy',
                            throw_reasons=GAPI.DRIVE_COPY_THROW_REASONS+[GAPI.BAD_REQUEST],
                            ignoreDefaultVisibility=copyParameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                            keepRevisionForever=copyParameters[DFA_KEEP_REVISION_FOREVER],
                            fileId=fileId, body=source, fields=VX_ID_FILENAME, supportsTeamDrives=True)
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename],
                                                             Act.MODIFIER_TO, result[VX_FILENAME], [Ent.DRIVE_FILE_ID, result[u'id']], j, jcount)
          _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
          if copyMoveOptions[u'copyFilePermissions']:
            _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FILE, sourceId, sourceFilename, result[u'id'], result[VX_FILENAME],
                             statistics, STAT_FILE_PERMISSIONS_FAILED, destTeamDriveId)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
              GAPI.unknownError, GAPI.cannotCopyFile, GAPI.badRequest, GAPI.fileNeverWritable) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        _incrStatistic(statistics, STAT_FILE_FAILED)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        _incrStatistic(statistics, STAT_FILE_FAILED)
        break
    Ind.Decrement()
    if summary:
      _printStatistics(user, statistics, i, count, True)

# gam <UserTypeEntity> move drivefile <DriveFileEntity> [newfilename <DriveFileName>] [summary [<Boolean>]]
#	<DriveFileMoveAttributes>*
#	[duplicatefiles overwriteolder|overwriteall|duplicatename|uniquename|skip]
#	[duplicatefolders merge|duplicatename|uniquename|skip]
#	[retainsourcefolders]
def moveDriveFile(users):
  def _recursiveFolderMove(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren):
    folderId = source[u'id']
    sourceChildren = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                   q=WITH_PARENTS.format(folderId), fields=VX_NPT_FILES_ID_FILENAME_PARENTS_COPY_FIELDS,
                                   orderBy=VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME,
                                   pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **sourceSearchArgs)
    newFolderId, existingTargetFolder = _cloneFolder(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren, False,
                                                     copyMoveOptions, statistics, destTeamDriveId)
    if newFolderId is None:
      return
    movedFiles[newFolderId] = 1
    kcount = len(sourceChildren)
    if kcount > 0:
      if existingTargetFolder:
        subTargetChildren = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                          throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                          q=VX_ANY_NON_TRASHED_WITH_PARENTS.format(newFolderId),
                                          orderBy=VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME,
                                          fields=VX_NPT_FILES_ID_FILENAME_CAPABILITIES_MIMETYPE_MODIFIEDTIME, **parameters[DFA_SEARCHARGS])
      else:
        subTargetChildren = collections.deque()
      Ind.Increment()
      k = 0
      for child in sourceChildren:
        k += 1
        childId = child[u'id']
        childTitle = child[VX_FILENAME]
        if movedFiles.get(childId):
          continue
        if childId == newFolderId:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(child), childTitle], Msg.NOT_COPYABLE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
          continue
        if child[u'mimeType'] == MIMETYPE_GA_FOLDER:
          child.pop(u'parents', [])
          child[u'parents'] = [newFolderId]
          _recursiveFolderMove(drive, user, i, count, k, kcount, child, childTitle, subTargetChildren)
        else:
          if existingTargetFolder and _checkForDuplicateTargetFile(drive, user, k, kcount, child, childTitle, subTargetChildren, copyMoveOptions, statistics):
            copyMoveOptions[u'retainSourceFolders'] = True
            continue
          body = {VX_FILENAME: child[VX_FILENAME]}
          try:
            result = callGAPI(drive.files(), u'update',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_OWNER_NOT_MEMBER_OF_WRITER_DOMAIN],
                              fileId=childId, addParents=newFolderId, removeParents=folderId,
                              body=body, fields=VX_ID_FILENAME, supportsTeamDrives=True)
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, childTitle],
                                                               Act.MODIFIER_TO, result[VX_FILENAME], [Ent.DRIVE_FILE_ID, result[u'id']], k, kcount)
            _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.fileOwnerNotMemberOfWriterDomain) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, childTitle], str(e), k, kcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            copyMoveOptions[u'retainSourceFolders'] = True
      Ind.Decrement()
    Act.Set(Act.DELETE)
    if not copyMoveOptions[u'retainSourceFolders']:
      try:
        callGAPI(drive.files(), u'delete',
                 throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                 fileId=folderId, supportsTeamDrives=True)
        entityActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, source[VX_FILENAME], Ent.DRIVE_FOLDER_ID, folderId], i, count)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.fileNeverWritable) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER_ID, folderId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    else:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, source[VX_FILENAME], Ent.DRIVE_FOLDER_ID, folderId], i, count)
    Act.Set(Act.MOVE)
    return

  fileIdEntity = getDriveFileEntity()
  parentBody = {}
  parameters = initializeDriveFileAttributes()
  copyMoveOptions = DEFAULT_COPY_OPTIONS.copy()
  newFilename = None
  newParentsSpecified = summary = False
  movedFiles = {}
  statistics = _initStatistics()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'newfilename':
      newFilename = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg == u'summary':
      summary = getBoolean()
    elif myarg == u'retainsourcefolders':
      copyMoveOptions[u'retainSourceFolders'] = getBoolean()
    elif myarg == u'duplicatefiles':
      copyMoveOptions[u'duplicateFiles'] = getChoice(DUPLICATE_FILE_CHOICES, mapChoice=True)
    elif myarg == u'duplicatefolders':
      copyMoveOptions[u'duplicateFolders'] = getChoice(DUPLICATE_FOLDER_CHOICES, mapChoice=True)
    elif getDriveFileParentAttribute(myarg, parameters):
      newParentsSpecified = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if not _getDriveFileParentInfo(user, i, count, parentBody, parameters, drive):
      continue
    tdAddParents = None
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        source = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields=VX_FILENAME_PARENTS_COPY_FILE_FIELDS, supportsTeamDrives=True)
        sourceTeamDriveId = source.get(u'teamDriveId')
        if sourceTeamDriveId:
          sourceSearchArgs = {u'teamDriveId': sourceTeamDriveId, u'corpora': u'teamDrive', u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
        else:
          sourceSearchArgs = {}
        if not sourceTeamDriveId and source[u'mimeType'] == MIMETYPE_GA_FOLDER:
          if tdAddParents is None:
            tdAddParents = False
            for parentId in parentBody[u'parents']:
              try:
                result = callGAPI(drive.files(), u'get',
                                  throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                  fileId=parentId, fields=u'teamDriveId', supportsTeamDrives=True)
                if result.get(u'teamDriveId'):
                  tdAddParents = True
                  break
              except GAPI.fileNotFound as e:
                entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
                _incrStatistic(statistics, STAT_FILE_FAILED)
                break
              except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
                userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
                break
        sourceParents = source.pop(u'parents', None)
        if not sourceParents:
          sourceParents = [u'root',]
        sourceFilename = source[VX_FILENAME]
        if newParentsSpecified:
          newParents = parentBody[u'parents']
        else:
          newParents = sourceParents
          if sourceTeamDriveId and not parameters[DFA_SEARCHARGS]:
            parameters[DFA_SEARCHARGS] = {u'teamDriveId': sourceTeamDriveId, u'corpora': u'teamDrive',
                                          u'includeTeamDriveItems': True, u'supportsTeamDrives': True}
        numNewParents = len(newParents)
        if numNewParents > 1:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(source), sourceFilename], Msg.MULTIPLE_PARENTS_SPECIFIED.format(numNewParents), i, count)
          _incrStatistic(statistics, STAT_FILE_FAILED)
          continue
        newParentId = newParents[0]
        source[u'parents'] = newParents
        if newFilename:
          destFilename = newFilename
        else:
          destFilename = sourceFilename
        targetChildren = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                                       throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                       q=VX_ANY_NON_TRASHED_MIMETYPE_NAME_PREFIX_WITH_PARENTS.format(source[u'mimeType'], escapeDriveFileName(_getFilenamePrefix(destFilename)), newParentId),
                                       orderBy=VX_ORDERBY_FOLDER_DESC_NAME_MODIFIED_TIME,
                                       fields=VX_NPT_FILES_ID_FILENAME_CAPABILITIES_MIMETYPE_MODIFIEDTIME, **parameters[DFA_SEARCHARGS])
        destTeamDriveId = callGAPI(drive.files(), u'get',
                                   throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=newParentId, fields=u'teamDriveId', supportsTeamDrives=True).get(u'teamDriveId')
        if sourceTeamDriveId or destTeamDriveId:
          copyMoveOptions.update(CLEAR_COPY_MOVE_PARENT_OPTIONS)
        copyMoveOptions.update(CLEAR_COPY_MOVE_FOLDER_PERMISSION_OPTIONS)
        if source[u'mimeType'] == MIMETYPE_GA_FOLDER:
          if copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
            if _identicalSourceTarget(fileId, targetChildren):
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, sourceFilename], Msg.NOT_MOVABLE_SAME_NAME_CURRENT_FOLDER_MERGE, i, count)
              _incrStatistic(statistics, STAT_FOLDER_FAILED)
              continue
          elif copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_UNIQUE_NAME:
            destFilename = _getUniqueFilename(destFilename, source[u'mimeType'], targetChildren)
          elif copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_SKIP:
            if _targetFilenameExists(destFilename, source[u'mimeType'], targetChildren):
              _incrStatistic(statistics, STAT_FOLDER_DUPLICATE)
              continue
          if (tdAddParents or
              copyMoveOptions[u'retainSourceFolders'] or
              (copyMoveOptions[u'duplicateFolders'] == DUPLICATE_FOLDER_MERGE and _targetFilenameExists(destFilename, source[u'mimeType'], targetChildren))):
            _recursiveFolderMove(drive, user, i, count, j, jcount, source, destFilename, targetChildren)
            continue
          body = {VX_FILENAME: destFilename}
        else:
          if copyMoveOptions[u'duplicateFiles'] in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER] and _identicalSourceTarget(fileId, targetChildren):
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename], Msg.NOT_MOVABLE_SAME_NAME_CURRENT_FOLDER_OVERWRITE, i, count)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            continue
          if _checkForDuplicateTargetFile(drive, user, j, jcount, source, destFilename, targetChildren, copyMoveOptions, statistics):
            continue
          body = {VX_FILENAME: source[VX_FILENAME]}
        addParents = u','.join(newParents)
        removeParents = u','.join(sourceParents)
        result = callGAPI(drive.files(), u'update',
                          throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST],
                          fileId=fileId, addParents=addParents, removeParents=removeParents,
                          body=body, fields=VX_FILENAME, supportsTeamDrives=True)
        entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename],
                                                           Act.MODIFIER_TO, result[VX_FILENAME], [Ent.DRIVE_FOLDER_ID, addParents], j, jcount)
        _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
              GAPI.unknownError, GAPI.cannotCopyFile, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        _incrStatistic(statistics, STAT_FILE_FAILED)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        _incrStatistic(statistics, STAT_FILE_FAILED)
        break
    Ind.Decrement()
    if summary:
      _printStatistics(user, statistics, i, count, False)

DELETE_DRIVEFILE_CHOICE_MAP = {u'purge': u'delete', u'trash': u'trash', u'untrash': u'untrash',}
DELETE_DRIVEFILE_FUNCTION_TO_ACTION_MAP = {u'delete': Act.PURGE, u'trash': Act.TRASH, u'untrash': Act.UNTRASH,}

# gam <UserTypeEntity> delete drivefile <DriveFileEntity> [purge|trash|untrash]
def deleteDriveFile(users, function=None):
  fileIdEntity = getDriveFileEntity()
  if not function:
    function = getChoice(DELETE_DRIVEFILE_CHOICE_MAP, defaultChoice=u'trash', mapChoice=True)
  checkForExtraneousArguments()
  Act.Set(DELETE_DRIVEFILE_FUNCTION_TO_ACTION_MAP[function])
  if function != u'delete':
    trash_body = {u'trashed': function == u'trash'}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        if function != u'delete':
          result = callGAPI(drive.files(), u'update',
                            throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                            fileId=fileId, body=trash_body, fields=VX_FILENAME, supportsTeamDrives=True)
          if result and VX_FILENAME in result:
            fileName = result[VX_FILENAME]
          else:
            fileName = fileId
        else:
          callGAPI(drive.files(), function,
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                   fileId=fileId, supportsTeamDrives=True)
          fileName = fileId
        entityActionPerformed([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileName], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.fileNeverWritable) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> purge drivefile <DriveFileEntity>
def purgeDriveFile(users):
  deleteDriveFile(users, u'delete')

# gam <UserTypeEntity> trash drivefile <DriveFileEntity>
def trashDriveFile(users):
  deleteDriveFile(users, u'trash')

# gam <UserTypeEntity> untrash drivefile <DriveFileEntity>
def untrashDriveFile(users):
  deleteDriveFile(users, u'untrash')

NON_DOWNLOADABLE_MIMETYPES = [MIMETYPE_GA_FORM, MIMETYPE_GA_FUSIONTABLE, MIMETYPE_GA_MAP]

GOOGLEDOC_VALID_EXTENSIONS_MAP = {
  MIMETYPE_GA_DRAWING: [u'.jpeg', u'.jpg', u'.pdf', u'.png', u'.svg'],
  MIMETYPE_GA_DOCUMENT: [u'.docx', u'.html', u'.odt', u'.pdf', u'.rtf', u'.txt', u'.zip'],
  MIMETYPE_GA_PRESENTATION: [u'.pdf', u'.pptx', u'.odp', u'.txt'],
  MIMETYPE_GA_SPREADSHEET: [u'.csv', u'.ods', u'.pdf', u'.xlsx', u'.zip'],
  }

MICROSOFT_FORMATS_LIST = [{u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.document', u'ext': u'.docx'},
                          {u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.template', u'ext': u'.dotx'},
                          {u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.presentation', u'ext': u'.pptx'},
                          {u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.template', u'ext': u'.potx'},
                          {u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', u'ext': u'.xlsx'},
                          {u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.template', u'ext': u'.xltx'},
                          {u'mime': u'application/msword', u'ext': u'.doc'},
                          {u'mime': u'application/msword', u'ext': u'.dot'},
                          {u'mime': u'application/vnd.ms-powerpoint', u'ext': u'.ppt'},
                          {u'mime': u'application/vnd.ms-powerpoint', u'ext': u'.pot'},
                          {u'mime': u'application/vnd.ms-excel', u'ext': u'.xls'},
                          {u'mime': u'application/vnd.ms-excel', u'ext': u'.xlt'}]

DOCUMENT_FORMATS_MAP = {
  u'csv': [{u'mime': u'text/csv', u'ext': u'.csv'}],
  u'doc': [{u'mime': u'application/msword', u'ext': u'.doc'}],
  u'dot': [{u'mime': u'application/msword', u'ext': u'.dot'}],
  u'docx': [{u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.document', u'ext': u'.docx'}],
  u'dotx': [{u'mime': u'application/vnd.openxmlformats-officedocument.wordprocessingml.template', u'ext': u'.dotx'}],
  u'epub': [{u'mime': u'application/epub+zip', u'ext': u'.epub'}],
  u'html': [{u'mime': u'text/html', u'ext': u'.html'}],
  u'jpeg': [{u'mime': u'image/jpeg', u'ext': u'.jpeg'}],
  u'jpg': [{u'mime': u'image/jpeg', u'ext': u'.jpg'}],
  u'mht': [{u'mime': u'message/rfc822', u'ext': u'mht'}],
  u'odp': [{u'mime': u'application/vnd.oasis.opendocument.presentation', u'ext': u'.odp'}],
  u'ods': [{u'mime': u'application/x-vnd.oasis.opendocument.spreadsheet', u'ext': u'.ods'},
           {u'mime': u'application/vnd.oasis.opendocument.spreadsheet', u'ext': u'.ods'}],
  u'odt': [{u'mime': u'application/vnd.oasis.opendocument.text', u'ext': u'.odt'}],
  u'pdf': [{u'mime': u'application/pdf', u'ext': u'.pdf'}],
  u'png': [{u'mime': u'image/png', u'ext': u'.png'}],
  u'ppt': [{u'mime': u'application/vnd.ms-powerpoint', u'ext': u'.ppt'}],
  u'pot': [{u'mime': u'application/vnd.ms-powerpoint', u'ext': u'.pot'}],
  u'potx': [{u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.template', u'ext': u'.potx'}],
  u'pptx': [{u'mime': u'application/vnd.openxmlformats-officedocument.presentationml.presentation', u'ext': u'.pptx'}],
  u'rtf': [{u'mime': u'application/rtf', u'ext': u'.rtf'}],
  u'svg': [{u'mime': u'image/svg+xml', u'ext': u'.svg'}],
  u'tsv': [{u'mime': u'text/tab-separated-values', u'ext': u'.tsv'},
           {u'mime': u'text/tsv', u'ext': u'.tsv'}],
  u'txt': [{u'mime': u'text/plain', u'ext': u'.txt'}],
  u'xls': [{u'mime': u'application/vnd.ms-excel', u'ext': u'.xls'}],
  u'xlt': [{u'mime': u'application/vnd.ms-excel', u'ext': u'.xlt'}],
  u'xlsx': [{u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', u'ext': u'.xlsx'}],
  u'xltx': [{u'mime': u'application/vnd.openxmlformats-officedocument.spreadsheetml.template', u'ext': u'.xltx'}],
  u'zip': [{u'mime': u'application/zip', u'ext': u'.zip'}],
  u'ms': MICROSOFT_FORMATS_LIST,
  u'microsoft': MICROSOFT_FORMATS_LIST,
  u'micro$oft': MICROSOFT_FORMATS_LIST,
  u'openoffice': [{u'mime': u'application/vnd.oasis.opendocument.presentation', u'ext': u'.odp'},
                  {u'mime': u'application/x-vnd.oasis.opendocument.spreadsheet', u'ext': u'.ods'},
                  {u'mime': u'application/vnd.oasis.opendocument.spreadsheet', u'ext': u'.ods'},
                  {u'mime': u'application/vnd.oasis.opendocument.text', u'ext': u'.odt'}],
  }

# gam <UserTypeEntity> get drivefile <DriveFileEntity> [format <FileFormatList>] [targetfolder <FilePath>] [targetname <FileName>] [overwrite [<Boolean>]] [showprogress [<Boolean>]] [revision <Number>]
def getDriveFile(users):
  fileIdEntity = getDriveFileEntity()
  revisionId = None
  exportFormatName = u'openoffice'
  exportFormatChoices = [exportFormatName]
  exportFormats = DOCUMENT_FORMATS_MAP[exportFormatName]
  targetFolderPattern = GC.Values[GC.DRIVE_DIR]
  targetNamePattern = None
  overwrite = showProgress = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'format':
      exportFormatChoices = getString(Cmd.OB_FORMAT_LIST).replace(u',', u' ').lower().split()
      exportFormats = []
      for exportFormat in exportFormatChoices:
        if exportFormat in DOCUMENT_FORMATS_MAP:
          exportFormats.extend(DOCUMENT_FORMATS_MAP[exportFormat])
        else:
          invalidChoiceExit(DOCUMENT_FORMATS_MAP, True)
    elif myarg == u'targetfolder':
      targetFolderPattern = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
    elif myarg == u'targetname':
      targetNamePattern = getString(Cmd.OB_FILE_NAME)
    elif myarg == u'overwrite':
      overwrite = getBoolean()
    elif myarg == u'revision':
      revisionId = getInteger(minVal=1)
    elif myarg == u'nocache':
      pass
    elif myarg == u'showprogress':
      showProgress = getBoolean()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE)
    if jcount == 0:
      continue
    _, userName, _ = splitEmailAddressOrUID(user)
    targetFolder = _substituteForUser(targetFolderPattern, user, userName)
    if not os.path.isdir(targetFolder):
      os.makedirs(targetFolder)
    targetName = _substituteForUser(targetNamePattern, user, userName) if targetNamePattern else None
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      fileExtension = None
      try:
        result = callGAPI(drive.files(), u'get',
                          throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields=VX_DOWNLOAD_FIELDS)
        fileExtension = result.get(u'fileExtension')
        mimeType = result[u'mimeType']
        if mimeType == MIMETYPE_GA_FOLDER:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, result[VX_FILENAME]], Msg.CAN_NOT_BE_DOWNLOADED, j, jcount)
          continue
        if mimeType in NON_DOWNLOADABLE_MIMETYPES:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]], Msg.FORMAT_NOT_DOWNLOADABLE, j, jcount)
          continue
        validExtensions = GOOGLEDOC_VALID_EXTENSIONS_MAP.get(mimeType)
        if validExtensions:
          my_line = [u'Type', u'Google Doc']
          googleDoc = True
        else:
          if VX_SIZE in result:
            my_line = [u'Size', formatFileSize(int(result[VX_SIZE]))]
          else:
            my_line = [u'Size', u'Unknown']
          googleDoc = False
        fileDownloaded = fileDownloadFailed = False
        for exportFormat in exportFormats:
          extension = fileExtension or exportFormat[u'ext']
          if googleDoc and (extension not in validExtensions):
            continue
          safe_file_title = targetName or cleanFilename(result[VX_FILENAME])
          filename = os.path.join(targetFolder, safe_file_title)
          y = 0
          while True:
            if filename.lower()[-len(extension):] != extension.lower():
              filename += extension
            if overwrite or not os.path.isfile(filename):
              break
            y += 1
            filename = os.path.join(targetFolder, u'({0})-{1}'.format(y, safe_file_title))
          if googleDoc:
            request = drive.files().export_media(fileId=fileId, mimeType=exportFormat[u'mime'])
            if revisionId:
              request.uri = u'{0}&revision={1}'.format(request.uri, revisionId)
          else:
            request = drive.files().get_media(fileId=fileId)
          fh = None
          try:
            fh = open(filename, u'wb')
            downloader = googleapiclient.http.MediaIoBaseDownload(fh, request)
            done = False
            while not done:
              status, done = downloader.next_chunk()
              if showProgress:
                entityActionPerformedMessage([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]], u'{0:>7.2%}'.format(status.progress()), j, jcount)
            closeFile(fh)
            entityModifierNewValueKeyValueActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]], Act.MODIFIER_TO, filename, my_line[0], my_line[1], j, jcount)
            fileDownloaded = True
            break
          except (IOError, httplib2.HttpLib2Error) as e:
            entityModifierNewValueActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]], Act.MODIFIER_TO, filename, str(e), j, jcount)
            fileDownloadFailed = True
            break
          except googleapiclient.http.HttpError:
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]],
                                            Msg.FORMAT_NOT_AVAILABLE.format(extension[1:]), j, jcount)
          if fh:
            closeFile(fh)
            os.remove(filename)
        if not fileDownloaded and not fileDownloadFailed:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, result[VX_FILENAME]],
                                          Msg.FORMAT_NOT_AVAILABLE.format(u','.join(exportFormatChoices)), j, jcount)
      except GAPI.fileNotFound:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], Msg.DOES_NOT_EXIST, j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> collect orphans (orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[targetuserfoldername <DriveFileName>] [preview] [todrive [<ToDriveAttributes>]]
def collectOrphans(users):
  orderByList = []
  csvFormat = False
  todrive = {}
  targetUserFolderPattern = u'#user# orphaned files'
  query = ME_IN_OWNERS_AND+u'trashed = false'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'targetuserfoldername':
      targetUserFolderPattern = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg == u'preview':
      csvFormat = True
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile([u'Owner', u'type', u'id', VX_FILENAME])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    userName, _ = splitEmailAddress(user)
    try:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, Ent.TypeName(Ent.USER, user), i, count, query=query)
      feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                           page_message=getPageMessageForWhom(),
                           throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                           q=query, orderBy=orderBy, fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE,
                           pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      trgtUserFolderName = _substituteForUser(targetUserFolderPattern, user, userName)
      orphanDriveFiles = collections.deque()
      while feed:
        fileEntry = feed.popleft()
        if not fileEntry.get(u'parents'):
          orphanDriveFiles.append(fileEntry)
      jcount = len(orphanDriveFiles)
      entityPerformActionNumItemsModifier([Ent.USER, user], jcount, Ent.DRIVE_ORPHAN_FILE_OR_FOLDER,
                                          u'{0} {1}: {2}'.format(Act.MODIFIER_INTO, Ent.Singular(Ent.DRIVE_FOLDER), trgtUserFolderName), i, count)
      if jcount == 0:
        continue
      if not csvFormat:
        result = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               q=VX_MY_NON_TRASHED_FOLDER_NAME.format(escapeDriveFileName(trgtUserFolderName)),
                               fields=VX_NPT_FILES_ID)
        if len(result) > 0:
          trgtParentId = result[0][u'id']
        else:
          trgtParentId = callGAPI(drive.files(), u'create',
                                  throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                  body={VX_FILENAME: trgtUserFolderName, u'mimeType': MIMETYPE_GA_FOLDER}, fields=u'id')[u'id']
        newParent = u','.join([trgtParentId])
      setSysExitRC(ORPHANS_COLLECTED_RC)
      Ind.Increment()
      j = 0
      while orphanDriveFiles:
        fileEntry = orphanDriveFiles.popleft()
        j += 1
        fileId = fileEntry[u'id']
        fileName = fileEntry[VX_FILENAME]
        fileType = _getEntityMimeType(fileEntry)
        if csvFormat:
          csvRows.append({u'Owner': user, u'type': Ent.Singular(fileType), u'id': fileId, VX_FILENAME: fileName})
          continue
        try:
          callGAPI(drive.files(), u'update',
                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS, retry_reasons=[GAPI.FILE_NOT_FOUND],
                   fileId=fileId, addParents=newParent, fields=u'')
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, fileType, fileName], Act.MODIFIER_INTO, None, [Ent.DRIVE_FOLDER, trgtUserFolderName], j, jcount)
        except (GAPI.fileNotFound) as e:
          entityActionFailedWarning([Ent.USER, user, fileType, fileName], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Orphans to Collect', todrive)

TRANSFER_DRIVEFILE_ACL_ROLES_MAP = {
  u'commenter': u'commenter',
  u'editor': u'writer',
  u'organizer': u'organizer',
  u'reader': u'reader',
  u'writer': u'writer',
  u'current': u'current',
  u'none': u'none',
  u'source': u'source',
  }

# gam <UserTypeEntity> transfer drive <UserItem> [select <DriveFileEntity>]
#	[(targetfolderid <DriveFolderID>)|(targetfoldername <DriveFolderName>)] [targetuserfoldername <DriveFolderName>] [targetuserorphansfoldername <DriveFolderName>]
#	[keepuser | (retainrole reader|commenter|writer|editor|none)] [noretentionmessages]
#	[nonowner_retainrole reader|commenter|writer|editor|current|none] [nonowner_targetrole reader|commenter|writer|editor|current|none|source]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[preview] [todrive [<ToDriveAttributes>]]
def transferDrive(users):

  TARGET_PARENT_ID = 0
  TARGET_ORPHANS_PARENT_ID = 1

  def _buildTargetFile(folderName, folderParentId):
    try:
      result = callGAPIpages(targetDrive.files(), u'list', VX_PAGES_FILES,
                             throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                             orderBy=orderBy, q=VX_MY_NON_TRASHED_FOLDER_NAME_WITH_PARENTS.format(escapeDriveFileName(folderName), folderParentId),
                             fields=VX_NPT_FILES_ID)
      if len(result) > 0:
        return result[0][u'id']
      else:
        return callGAPI(targetDrive.files(), u'create',
                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                        body={u'parents': [folderParentId], VX_FILENAME: folderName, u'mimeType': MIMETYPE_GA_FOLDER}, fields=u'id')[u'id']
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(targetUser, str(e))
    return None

  def _buildTargetUserFolder():
    folderName = _substituteForUser(targetUserFolderPattern, sourceUser, sourceUserName)
    if not folderName:
      return targetFolderId
    return _buildTargetFile(folderName, targetFolderId)

  def _buildTargetUserOrphansFolder():
    folderName = _substituteForUser(targetUserOrphansFolderPattern, sourceUser, sourceUserName)
    if not folderName:
      return targetIds[TARGET_PARENT_ID]
    targetIds[TARGET_ORPHANS_PARENT_ID] = _buildTargetFile(folderName, targetIds[TARGET_PARENT_ID])
    if targetIds[TARGET_ORPHANS_PARENT_ID] is None:
      targetIds[TARGET_ORPHANS_PARENT_ID] = targetIds[TARGET_PARENT_ID]

  def _getMappedParentForRootParentOrOrphan(childEntryInfo):
    if not childEntryInfo[u'parents']:
      return targetIds[TARGET_ORPHANS_PARENT_ID]
    for parentId in childEntryInfo[u'parents']:
      if parentId == sourceRootId:
        return targetIds[TARGET_PARENT_ID]
    return None

  def _setSourceUpdateRole(permission):
    if permission[u'role'] == u'owner':
      return {u'role': u'writer'}
    return {u'role': permission[u'role']}

  def _transferFile(childEntry, i, count, j, jcount):
    childEntryInfo = childEntry[u'info']
    childFileId = childEntryInfo[u'id']
    childFileName = childEntryInfo[VX_FILENAME]
    childFileType = _getEntityMimeType(childEntryInfo)
    if childEntryInfo[u'ownedByMe']:
      childEntryInfo[u'sourcePermission'] = {u'role': u'owner'}
      for permission in childEntryInfo[u'permissions']:
        if targetPermissionId == permission[u'id']:
          childEntryInfo[u'targetPermission'] = _setSourceUpdateRole(permission)
          break
      else:
        childEntryInfo[u'targetPermission'] = {u'role': u'none'}
      childEntryInfo.pop(u'permissions', None)
      if csvFormat:
        csvRows.append({u'OldOwner': sourceUser, u'NewOwner': targetUser, u'type': Ent.Singular(childFileType), u'id': childFileId, VX_FILENAME: childFileName, u'role': u'owner'})
        return
      Act.Set(Act.TRANSFER_OWNERSHIP)
      addTargetParents = set()
      removeSourceParents = set()
      removeTargetParents = set()
      if childEntryInfo[u'parents']:
        for parentId in childEntryInfo[u'parents']:
          if parentId in parentIdMap:
            addTargetParents.add(parentIdMap[parentId])
            if parentId != sourceRootId:
              removeSourceParents.add(parentId)
            else:
              removeTargetParents.add(targetRootId)
      else:
        if targetIds[TARGET_ORPHANS_PARENT_ID] is None:
          _buildTargetUserOrphansFolder()
        addTargetParents.add(targetIds[TARGET_ORPHANS_PARENT_ID])
        removeTargetParents.add(targetRootId)
      try:
        callGAPI(sourceDrive.permissions(), u'create',
                 throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST],
                 fileId=childFileId, sendNotificationEmail=True, emailMessage=None, transferOwnership=True, body=targetOwnerPermissionsBody, fields=u'')
        if removeSourceParents:
          callGAPI(sourceDrive.files(), u'update',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS, retry_reasons=[GAPI.FILE_NOT_FOUND],
                   fileId=childFileId, removeParents=u','.join(removeSourceParents), fields=u'')
        if addTargetParents or removeTargetParents:
          callGAPI(targetDrive.files(), u'update',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS, retry_reasons=[GAPI.FILE_NOT_FOUND],
                   fileId=childFileId, addParents=u','.join(addTargetParents), removeParents=u','.join(removeTargetParents), fields=u'')
        entityModifierNewValueItemValueListActionPerformed([Ent.USER, sourceUser, childFileType, childFileName], Act.MODIFIER_TO, None, [Ent.USER, targetUser], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, sourceUser, childFileType, childFileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, sourceUser, childFileType, childFileName, Ent.PERMISSION_ID, sourcePermissionId], j, jcount)
      except GAPI.invalidSharingRequest as e:
        entityActionFailedWarning([Ent.USER, sourceUser, childFileType, childFileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, sourcePermissionId, str(e)), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
    else:
      Act.Set(Act.PROCESS)
      for permission in childEntryInfo[u'permissions']:
        if sourcePermissionId == permission[u'id']:
          childEntryInfo[u'sourcePermission'] = _setSourceUpdateRole(permission)
          break
      else:
        childEntryInfo[u'sourcePermission'] = nonOwnerRetainRoleBody
      for permission in childEntryInfo[u'permissions']:
        if targetPermissionId == permission[u'id']:
          childEntryInfo[u'targetPermission'] = _setSourceUpdateRole(permission)
          break
      else:
        childEntryInfo[u'targetPermission'] = {u'role': u'none'}
      childEntryInfo.pop(u'permissions', None)
      if csvFormat:
        csvRows.append({u'OldOwner': sourceUser, u'NewOwner': targetUser, u'type': Ent.Singular(childFileType),
                        u'id': childFileId, VX_FILENAME: childFileName, u'role': childEntryInfo[u'sourcePermission'][u'role']})
        return
      ownerUser = childEntryInfo[u'owners'][0][u'emailAddress']
      if ownerUser not in thirdPartyOwners:
        _, ownerDrive = buildGAPIServiceObject(API.DRIVE3, ownerUser, 0, 0)
        thirdPartyOwners[ownerUser] = ownerDrive
      else:
        ownerDrive = thirdPartyOwners[ownerUser]
      if not ownerDrive:
        return
      targetPreviousRole = childEntryInfo[u'targetPermission']
      if (childFileType == Ent.DRIVE_FOLDER) and (targetPreviousRole[u'role'] == u'none') and (ownerRetainRoleBody[u'role'] == u'none'):
        if targetIds[TARGET_ORPHANS_PARENT_ID] is None:
          _buildTargetUserOrphansFolder()
        parentIdMap[childFileId] = _buildTargetFile(childFileName, targetIds[TARGET_ORPHANS_PARENT_ID])
        entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName], j, jcount)
        return
      mappedParentId = _getMappedParentForRootParentOrOrphan(childEntryInfo)
      if mappedParentId is not None:
        if targetPreviousRole[u'role'] in [u'none', u'reader']:
          try:
            callGAPI(ownerDrive.permissions(), u'create',
                     throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST],
                     fileId=childFileId, sendNotificationEmail=False, body=targetWriterPermissionsBody, fields=u'')
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
            entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
            return
          except GAPI.invalidSharingRequest as e:
            entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, sourcePermissionId, str(e)), j, jcount)
            return
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(ownerUser, str(e), i, count)
            return
        try:
          callGAPI(targetDrive.files(), u'update',
                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS, retry_reasons=[GAPI.FILE_NOT_FOUND],
                   fileId=childFileId, addParents=mappedParentId, body={}, fields=u'')
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
          entityActionFailedWarning([Ent.USER, targetUser, childFileType, childFileName], str(e), j, jcount)
          return
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(targetUser, str(e), i, count)
          return
      entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName], j, jcount)

  def _manageRoleRetention(childEntry, i, count, j, jcount):
    def _setTargetInsertBody(permission):
      return {u'role': permission[u'role'], u'type': u'user', u'emailAddress': targetUser}

    def _checkForDiminishedTargetRole(currentPermission, newPermission):
      if currentPermission[u'role'] in [u'owner', u'organizer', u'writer']:
        return False
      if (currentPermission[u'role'] == u'commenter') and (newPermission[u'role'] == u'reader'):
        return False
      return True

    childEntryInfo = childEntry[u'info']
    childFileId = childEntryInfo[u'id']
    childFileName = childEntryInfo[VX_FILENAME]
    childFileType = _getEntityMimeType(childEntryInfo)
    if childEntryInfo[u'ownedByMe']:
      if ownerRetainRoleBody[u'role'] == u'current':
        sourceUpdateRole = childEntryInfo[u'sourcePermission']
      else:
        sourceUpdateRole = ownerRetainRoleBody
      try:
        if ownerRetainRoleBody[u'role'] != u'none':
          if sourceUpdateRole[u'role'] != u'writer':
            callGAPI(targetDrive.permissions(), u'update',
                     throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                     fileId=childFileId, permissionId=sourcePermissionId, body=sourceUpdateRole, fields=u'')
        else:
          callGAPI(targetDrive.permissions(), u'delete',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                   fileId=childFileId, permissionId=sourcePermissionId)
        if showRetentionMessages:
          entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName, Ent.ROLE, sourceUpdateRole[u'role']], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, sourceUser, childFileType, childFileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, sourceUser, childFileType, childFileName, Ent.PERMISSION_ID, sourcePermissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
    else:
      ownerUser = childEntryInfo[u'owners'][0][u'emailAddress']
      if ownerUser not in thirdPartyOwners:
        _, ownerDrive = buildGAPIServiceObject(API.DRIVE3, ownerUser, 0, 0)
        thirdPartyOwners[ownerUser] = ownerDrive
      else:
        ownerDrive = thirdPartyOwners[ownerUser]
      if not ownerDrive:
        return
      if nonOwnerRetainRoleBody[u'role'] == u'current':
        sourceUpdateRole = childEntryInfo[u'sourcePermission']
      else:
        sourceUpdateRole = nonOwnerRetainRoleBody
      if nonOwnerTargetRoleBody[u'role'] == u'current':
        targetInsertBody = {u'role': u'none'}
        resetTargetRole = False
      elif nonOwnerTargetRoleBody[u'role'] == u'source':
        targetInsertBody = _setTargetInsertBody(childEntryInfo[u'sourcePermission'])
        resetTargetRole = True
      else:
        targetInsertBody = _setTargetInsertBody(nonOwnerTargetRoleBody)
        resetTargetRole = True
      if resetTargetRole:
        resetTargetRole = _checkForDiminishedTargetRole(childEntryInfo[u'targetPermission'], targetInsertBody)
      mappedParentId = _getMappedParentForRootParentOrOrphan(childEntryInfo)
      if mappedParentId is not None:
        if targetInsertBody[u'role'] in [u'none', u'reader']:
          resetTargetRole = True
      try:
        if nonOwnerRetainRoleBody[u'role'] != u'none':
          if nonOwnerRetainRoleBody[u'role'] != u'current':
            callGAPI(ownerDrive.permissions(), u'update',
                     throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                     fileId=childFileId, permissionId=sourcePermissionId, body=sourceUpdateRole, fields=u'')
        else:
          try:
            callGAPI(ownerDrive.permissions(), u'delete',
                     throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                     fileId=childFileId, permissionId=sourcePermissionId)
          except GAPI.permissionNotFound:
            pass
        if showRetentionMessages:
          entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName, Ent.ROLE, sourceUpdateRole[u'role']], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, ownerUser, childFileType, childFileName, Ent.PERMISSION_ID, sourcePermissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(ownerUser, str(e), i, count)
      if resetTargetRole:
        try:
          if targetInsertBody[u'role'] != u'none':
            callGAPI(ownerDrive.permissions(), u'create',
                     throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST],
                     fileId=childFileId, sendNotificationEmail=False, body=targetInsertBody, fields=u'')
          else:
            try:
              callGAPI(ownerDrive.permissions(), u'delete',
                       throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                       fileId=childFileId, permissionId=targetPermissionId)
            except GAPI.permissionNotFound:
              pass
          if showRetentionMessages:
            entityActionPerformed([Ent.USER, targetUser, childFileType, childFileName, Ent.ROLE, targetInsertBody[u'role']], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
          entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
        except GAPI.invalidSharingRequest as e:
          entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, targetPermissionId, str(e)), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)

  def _getPermissionsForNonOwnedFilesFromTree(fileEntry, i, count):
    jcount = len(fileEntry[u'children'])
    if jcount == 0:
      return
    j = 0
    for childFileId in fileEntry[u'children']:
      j += 1
      childEntry = fileTree.get(childFileId)
      if not childEntry or childFileId in filesTransferred:
        continue
      if not childEntry[u'info'][u'ownedByMe']:
        ownerUser = childEntry[u'info'][u'owners'][0][u'emailAddress']
        if ownerUser not in thirdPartyOwners:
          _, ownerDrive = buildGAPIServiceObject(API.DRIVE3, ownerUser, 0, 0)
          thirdPartyOwners[ownerUser] = ownerDrive
        else:
          ownerDrive = thirdPartyOwners[ownerUser]
        if not ownerDrive:
          return
        try:
          result = callGAPI(ownerDrive.files(), u'get',
                            throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                            fileId=childFileId, fields=u'permissions(id,role)')
          childEntry[u'info'].update(result)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest):
          pass
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
          pass
      if childEntry[u'info'][u'mimeType'] == MIMETYPE_GA_FOLDER:
        Ind.Increment()
        _getPermissionsForNonOwnedFilesFromTree(childEntry, i, count)
        Ind.Decrement()

  def _transferDriveFilesFromTree(fileEntry, i, count):
    jcount = len(fileEntry[u'children'])
    if jcount == 0:
      return
    j = 0
    for childFileId in fileEntry[u'children']:
      j += 1
      childEntry = fileTree.get(childFileId)
      if not childEntry or childFileId in filesTransferred:
        continue
      filesTransferred.add(childFileId)
      _transferFile(childEntry, i, count, j, jcount)
      if childEntry[u'info'][u'mimeType'] == MIMETYPE_GA_FOLDER:
        Ind.Increment()
        _transferDriveFilesFromTree(childEntry, i, count)
        Ind.Decrement()

  def _manageRoleRetentionDriveFilesFromTree(fileEntry, i, count):
    jcount = len(fileEntry[u'children'])
    if jcount == 0:
      return
    j = 0
    for childFileId in fileEntry[u'children']:
      j += 1
      childEntry = fileTree.get(childFileId)
      if not childEntry or childFileId in filesTransferred:
        continue
      filesTransferred.add(childFileId)
      _manageRoleRetention(childEntry, i, count, j, jcount)
      if childEntry[u'info'][u'mimeType'] == MIMETYPE_GA_FOLDER:
        Ind.Increment()
        _manageRoleRetentionDriveFilesFromTree(childEntry, i, count)
        Ind.Decrement()

  def _identifyDriveFileAndChildren(fileEntry, i, count):
    fileId = fileEntry[u'id']
    if fileId not in fileTree:
      fileTree[fileId] = {u'info': fileEntry, u'children': []}
    if fileEntry[u'mimeType'] != MIMETYPE_GA_FOLDER:
      return
    try:
      children = callGAPIpages(sourceDrive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               orderBy=orderBy, q=WITH_PARENTS.format(fileId), fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS_PERMISSIONS,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
      return
    for childEntry in children:
      if not childEntry[u'trashed']:
        childId = childEntry[u'id']
        fileTree[fileId][u'children'].append(childId)
        if not childEntry[u'ownedByMe']:
          ownerUser = childEntry[u'owners'][0][u'emailAddress']
          if ownerUser not in thirdPartyOwners:
            _, ownerDrive = buildGAPIServiceObject(API.DRIVE3, ownerUser, 0, 0)
            thirdPartyOwners[ownerUser] = ownerDrive
          else:
            ownerDrive = thirdPartyOwners[ownerUser]
          if not ownerDrive:
            continue
          try:
            result = callGAPI(ownerDrive.files(), u'get',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                              fileId=childEntry[u'id'], fields=u'permissions(id,role)')
            childEntry.update(result)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
            continue
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            continue
        _identifyDriveFileAndChildren(childEntry, i, count)

  def _transferDriveFileAndChildren(fileEntry, i, count, j, jcount):
    fileId = fileEntry[u'info'][u'id']
    if fileId in filesTransferred:
      return
    if fileEntry[u'info'][VX_FILENAME] != u'My Drive':
      _transferFile(fileEntry, i, count, j, jcount)
      filesTransferred.add(fileId)
    kcount = len(fileEntry[u'children'])
    if kcount == 0:
      return
    k = 0
    for childFileId in fileEntry[u'children']:
      k += 1
      childEntry = fileTree.get(childFileId)
      if childEntry:
        Ind.Increment()
        _transferDriveFileAndChildren(childEntry, i, count, k, kcount)
        Ind.Decrement()

  def _manageRoleRetentionDriveFileAndChildren(fileEntry, i, count, j, jcount):
    fileId = fileEntry[u'info'][u'id']
    if fileId in filesTransferred:
      return
    if fileEntry[u'info'][VX_FILENAME] != u'My Drive':
      _manageRoleRetention(fileEntry, i, count, j, jcount)
      filesTransferred.add(fileId)
    kcount = len(fileEntry[u'children'])
    if kcount == 0:
      return
    k = 0
    for childFileId in fileEntry[u'children']:
      k += 1
      childEntry = fileTree.get(childFileId)
      if childEntry:
        Ind.Increment()
        _manageRoleRetentionDriveFileAndChildren(childEntry, i, count, k, kcount)
        Ind.Decrement()

  targetUser = getEmailAddress()
  buildTree = True
  csvFormat = False
  todrive = {}
  orderByList = []
  ownerRetainRoleBody = {u'role': u'none'}
  nonOwnerRetainRoleBody = {}
  nonOwnerTargetRoleBody = {u'role': u'source'}
  showRetentionMessages = True
  targetFolderId = targetFolderName = None
  targetUserFolderPattern = u'#user# old files'
  targetUserOrphansFolderPattern = u'#user# orphaned files'
  targetIds = [None, None]
  thirdPartyOwners = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'keepuser':
      ownerRetainRoleBody[u'role'] = u'writer'
    elif myarg == u'retainrole':
      ownerRetainRoleBody[u'role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if ownerRetainRoleBody[u'role'] in [u'source', u'current']:
        ownerRetainRoleBody[u'role'] = u'writer'
    elif myarg == u'nonownerretainrole':
      nonOwnerRetainRoleBody[u'role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if nonOwnerRetainRoleBody[u'role'] == u'source':
        nonOwnerRetainRoleBody[u'role'] = u'current'
    elif myarg == u'nonownertargetrole':
      nonOwnerTargetRoleBody[u'role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
    elif myarg == u'noretentionmessages':
      showRetentionMessages = False
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'targetfolderid':
      targetFolderIdLocation = Cmd.Location()
      targetFolderId = getString(Cmd.OB_DRIVE_FILE_ID, minLen=0)
    elif myarg == u'targetfoldername':
      targetFolderNameLocation = Cmd.Location()
      targetFolderName = getString(Cmd.OB_DRIVE_FILE_NAME, minLen=0)
    elif myarg == u'targetuserfoldername':
      targetUserFolderPattern = getString(Cmd.OB_DRIVE_FILE_NAME, minLen=0)
    elif myarg == u'targetuserorphansfoldername':
      targetUserOrphansFolderPattern = getString(Cmd.OB_DRIVE_FILE_NAME, minLen=0)
    elif myarg == u'preview':
      csvFormat = True
    elif myarg == u'select':
      fileIdEntity = getDriveFileEntity()
      buildTree = False
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  if not nonOwnerRetainRoleBody:
    nonOwnerRetainRoleBody = ownerRetainRoleBody
  orderBy = u','.join(orderByList) if orderByList else None
  targetUser, targetDrive = buildGAPIServiceObject(API.DRIVE3, targetUser, 0, 0)
  if not targetDrive:
    return
  try:
    result = callGAPI(targetDrive.about(), u'get',
                      throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fields=u'storageQuota,user(permissionId)')
    if result[u'storageQuota'].get(u'limit'):
      targetDriveFree = int(result[u'storageQuota'][u'limit'])-int(result[u'storageQuota'][u'usageInDrive'])
    else:
      targetDriveFree = None
    targetPermissionId = result[u'user'][u'permissionId']
    result = callGAPI(targetDrive.files(), u'get',
                      throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fileId=u'root', fields=VX_ID_FILENAME)
    targetRootId = result[u'id']
    if not targetFolderId and not targetFolderName:
      targetFolderId = targetRootId
      targetFolderName = result[VX_FILENAME]
    else:
      if targetFolderId:
        targetFolder = callGAPI(targetDrive.files(), u'get',
                                throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                fileId=targetFolderId, fields=VX_ID_FILENAME_MIMETYPE_OWNEDBYME)
        if targetFolder[u'mimeType'] != MIMETYPE_GA_FOLDER:
          Cmd.SetLocation(targetFolderIdLocation)
          usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                            [Ent.Singular(Ent.USER), targetUser,
                                             Ent.Singular(Ent.DRIVE_FOLDER_ID), targetFolderId,
                                             Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER))],
                                            u'\n'))
        if not targetFolder[u'ownedByMe']:
          Cmd.SetLocation(targetFolderIdLocation)
          usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                            [Ent.Singular(Ent.USER), targetUser,
                                             Ent.Singular(Ent.DRIVE_FOLDER_ID), targetFolderId,
                                             Msg.NOT_OWNED_BY.format(targetUser)],
                                            u'\n'))
        targetFolderName = targetFolder[VX_FILENAME]
      elif targetFolderName:
        result = callGAPIpages(targetDrive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               q=VX_MY_NON_TRASHED_FOLDER_NAME.format(escapeDriveFileName(targetFolderName)),
                               fields=VX_NPT_FILES_ID)
        if len(result) == 0:
          Cmd.SetLocation(targetFolderNameLocation)
          usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                            [Ent.Singular(Ent.USER), targetUser,
                                             Ent.Singular(Ent.DRIVE_FOLDER), targetFolderName,
                                             Msg.DOES_NOT_EXIST],
                                            u'\n'))
        targetFolderId = result[0][u'id']
  except GAPI.fileNotFound:
    Cmd.SetLocation(targetFolderIdLocation)
    usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                      [Ent.Singular(Ent.USER), targetUser,
                                       Ent.Singular(Ent.DRIVE_FOLDER_ID), targetFolderId,
                                       Msg.DOES_NOT_EXIST],
                                      u'\n'))
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(targetUser, str(e))
    return
  targetOwnerPermissionsBody = {u'role': u'owner', u'type': u'user', u'emailAddress': targetUser}
  targetWriterPermissionsBody = {u'role': u'writer', u'type': u'user', u'emailAddress': targetUser}
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile([u'OldOwner', u'NewOwner', u'type', u'id', VX_FILENAME, u'role'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if buildTree:
      sourceUser, sourceDrive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
      if not sourceDrive:
        continue
    else:
      sourceUser, sourceDrive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FOLDER)
      if jcount == 0:
        continue
    sourceUserName, _ = splitEmailAddress(sourceUser)
    try:
      result = callGAPI(sourceDrive.about(), u'get',
                        throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                        fields=u'storageQuota,user(permissionId)')
      sourceDriveSize = int(result[u'storageQuota'][u'usageInDrive'])
      sourcePermissionId = result[u'user'][u'permissionId']
      sourceRootId = callGAPI(sourceDrive.files(), u'get',
                              throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                              fileId=u'root', fields=u'id')[u'id']
      if (targetDriveFree is not None) and (targetDriveFree < sourceDriveSize):
        printWarningMessage(TARGET_DRIVE_SPACE_ERROR_RC,
                            u'{0} {1}'.format(Msg.NO_TRANSFER_LACK_OF_DISK_SPACE,
                                              formatKeyValueList(u'',
                                                                 [u'Source drive size', formatFileSize(sourceDriveSize),
                                                                  u'Target drive free', formatFileSize(targetDriveFree)],
                                                                 u'')))
        continue
      printKeyValueList([u'Source drive size', formatFileSize(sourceDriveSize),
                         u'Target drive free', formatFileSize(targetDriveFree) if targetDriveFree is not None else u'UNLIMITED'])
      if targetDriveFree is not None:
        targetDriveFree = targetDriveFree-sourceDriveSize # prep targetDriveFree for next user
      if not csvFormat:
        targetIds[TARGET_PARENT_ID] = _buildTargetUserFolder()
        if targetIds[TARGET_PARENT_ID] is None:
          return
      Ind.Increment()
      if buildTree:
        parentIdMap = {sourceRootId: targetIds[TARGET_PARENT_ID]}
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, Ent.TypeName(Ent.SOURCE_USER, user), i, count)
        sourceDriveFiles = callGAPIpages(sourceDrive.files(), u'list', VX_PAGES_FILES,
                                         page_message=getPageMessageForWhom(),
                                         throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                         orderBy=orderBy, q=NON_TRASHED,
                                         fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_OWNERS_PERMISSIONS,
                                         pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
        fileTree = buildFileTree(sourceDriveFiles, sourceDrive)
        filesTransferred = set()
        _getPermissionsForNonOwnedFilesFromTree(fileTree[sourceRootId], i, count)
        _getPermissionsForNonOwnedFilesFromTree(fileTree[u'Orphans'], i, count)
        filesTransferred = set()
        _transferDriveFilesFromTree(fileTree[sourceRootId], i, count)
        if fileTree[u'Orphans'][u'children']:
          if not csvFormat:
            _buildTargetUserOrphansFolder()
          _transferDriveFilesFromTree(fileTree[u'Orphans'], i, count)
        if not csvFormat:
          Act.Set(Act.RETAIN)
          filesTransferred = set()
          _manageRoleRetentionDriveFilesFromTree(fileTree[sourceRootId], i, count)
          if fileTree[u'Orphans'][u'children']:
            _manageRoleRetentionDriveFilesFromTree(fileTree[u'Orphans'], i, count)
      else:
        j = 0
        for fileId in fileIdEntity[u'list']:
          j += 1
          fileTree = {}
          parentIdMap = {sourceRootId: targetIds[TARGET_PARENT_ID]}
          try:
            fileEntry = callGAPI(sourceDrive.files(), u'get',
                                 throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                 fileId=fileId, fields=VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS_PERMISSIONS)
            entityType = _getEntityMimeType(fileEntry)
            entityPerformActionItemValue([Ent.USER, sourceUser], entityType, u'{0} ({1})'.format(fileEntry[VX_FILENAME], fileId), j, jcount)
            for parentId in fileEntry.get(u'parents', []):
              parentIdMap[parentId] = targetIds[TARGET_PARENT_ID]
            _identifyDriveFileAndChildren(fileEntry, i, count)
            filesTransferred = set()
            _transferDriveFileAndChildren(fileTree[fileEntry[u'id']], i, count, j, jcount)
            if not csvFormat:
              Act.Set(Act.RETAIN)
              filesTransferred = set()
              _manageRoleRetentionDriveFileAndChildren(fileTree[fileEntry[u'id']], i, count, j, jcount)
          except GAPI.fileNotFound:
            entityActionFailedWarning([Ent.USER, sourceUser, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
            break
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Files to Transfer', todrive)

def validateUserGetPermissionId(user, i=0, count=0):
  _, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
  if drive:
    try:
      return callGAPI(drive.about(), u'get',
                      throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fields=u'user(permissionId)')[u'user'][u'permissionId']
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return None

def getPermissionIdForEmail(email):
  _, drive = buildGAPIServiceObject(API.DRIVE, _getValueFromOAuth(u'email'), 0, 0)
  if drive:
    try:
      return callGAPI(drive.permissions(), u'getIdForEmail',
                      throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                      email=email, fields=u'id')[u'id']
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(email, str(e), 0, 0)
  return None

# gam <UserTypeEntity> transfer ownership <DriveFileEntity> <UserItem> [includetrashed]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[preview] [filepath] [buildtree] [todrive [<ToDriveAttributes>]]
def transferOwnership(users):
  def _identifyFilesToTransfer(fileEntry):
    for childFileId in fileEntry[u'children']:
      if childFileId in filesTransferred:
        continue
      filesTransferred.add(childFileId)
      childEntry = fileTree.get(childFileId)
      if childEntry:
        childEntryInfo = childEntry[u'info']
        if trashed or not childEntryInfo[u'trashed']:
          if childEntryInfo[u'ownedByMe']:
            filesToTransfer[childFileId] = {VX_FILENAME: childEntryInfo[VX_FILENAME], u'type': _getEntityMimeType(childEntryInfo)}
          if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
            _identifyFilesToTransfer(childEntry)

  def _identifyChildrenToTransfer(fileEntry, user, i, count):
    try:
      children = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               orderBy=orderBy, q=WITH_PARENTS.format(fileEntry[u'id']), fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      childFileId = childEntryInfo[u'id']
      if filepath:
        fileTree[childFileId] = {u'info': childEntryInfo}
      if childFileId in filesTransferred:
        continue
      filesTransferred.add(childFileId)
      if trashed or not childEntryInfo[u'trashed']:
        if childEntryInfo[u'ownedByMe']:
          filesToTransfer[childFileId] = {VX_FILENAME: childEntryInfo[VX_FILENAME], u'type': _getEntityMimeType(childEntryInfo)}
        if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
          _identifyChildrenToTransfer(childEntryInfo, user, i, count)

  fileIdEntity = getDriveFileEntity()
  body = {}
  newOwner = getEmailAddress()
  orderByList = []
  csvFormat = filepath = trashed = False
  todrive = {}
  fileTree = None
  buildTree = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'includetrashed':
      trashed = True
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'preview':
      csvFormat = True
    elif myarg == u'filepath':
      filepath = True
    elif myarg == u'buildtree':
      buildTree = True
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  Act.Set(Act.TRANSFER_OWNERSHIP)
  permissionId = validateUserGetPermissionId(newOwner)
  if not permissionId:
    return
  orderBy = u','.join(orderByList) if orderByList else None
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile([u'OldOwner', u'NewOwner', u'type', u'id', VX_FILENAME])
    if filepath:
      addTitlesToCSVfile(u'paths', titles)
  else:
    filepath = False
  body = {u'role': u'owner'}
  bodyAdd = {u'role': u'writer', u'type': u'user', u'emailAddress': newOwner}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FOLDER)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    filesTransferred = set()
    if buildTree:
      try:
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count)
        feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                             page_message=getPageMessageForWhom(),
                             throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                             orderBy=orderBy, fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED,
                             pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
      fileTree = buildFileTree(feed, drive)
    else:
      fileTree = {}
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      if buildTree:
        fileEntry = fileTree.get(fileId)
        if not fileEntry:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
        fileEntryInfo = fileEntry[u'info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), u'get',
                                   throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId, fields=VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED)
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
        if filepath:
          fileTree[fileId] = {u'info': fileEntryInfo}
      entityType = _getEntityMimeType(fileEntryInfo)
      entityPerformActionItemValue([Ent.USER, user], entityType, u'{0} ({1})'.format(fileEntryInfo[VX_FILENAME], fileId), j, jcount)
      if fileId in filesTransferred:
        continue
      filesTransferred.add(fileId)
      filesToTransfer = {}
      if trashed or not fileEntryInfo[u'trashed']:
        if fileEntryInfo[u'ownedByMe'] and fileEntryInfo[VX_FILENAME] != u'My Drive':
          filesToTransfer[fileId] = {VX_FILENAME: fileEntryInfo[VX_FILENAME], u'type': entityType}
        if fileEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
          if buildTree:
            _identifyFilesToTransfer(fileEntry)
          else:
            _identifyChildrenToTransfer(fileEntryInfo, user, i, count)
      if csvFormat:
        for xferFileId, fileInfo in iteritems(filesToTransfer):
          row = {u'OldOwner': user, u'NewOwner': newOwner, u'type': Ent.Singular(fileInfo[u'type']), u'id': xferFileId, VX_FILENAME: fileInfo[VX_FILENAME]}
          if filepath:
            addFilePathsToRow(drive, fileTree, fileTree[xferFileId][u'info'], filePathInfo, row, titles)
          csvRows.append(row)
        continue
      Ind.Increment()
      kcount = len(filesToTransfer)
      entityPerformActionNumItemsModifier([Ent.USER, user], kcount, Ent.DRIVE_FILE_OR_FOLDER, u'{0} {1}: {2}'.format(Act.MODIFIER_TO, Ent.Singular(Ent.USER), newOwner), i, count)
      Ind.Increment()
      k = 0
      for xferFileId in filesToTransfer:
        k += 1
        entityType = filesToTransfer[xferFileId][u'type']
        fileDesc = u'{0} ({1})'.format(filesToTransfer[xferFileId][VX_FILENAME], xferFileId)
        try:
          callGAPI(drive.permissions(), u'update',
                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND, GAPI.FORBIDDEN],
                   fileId=xferFileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_TO, None, [Ent.USER, newOwner], k, kcount)
        except GAPI.permissionNotFound:
          # this might happen if target user isn't explicitly in ACL (i.e. shared with anyone)
          try:
            callGAPI(drive.permissions(), u'create',
                     throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST, GAPI.FILE_NOT_FOUND, GAPI.FORBIDDEN],
                     fileId=xferFileId, sendNotificationEmail=False, body=bodyAdd, fields=u'')
            callGAPI(drive.permissions(), u'update',
                     throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND],
                     fileId=xferFileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_TO, None, [Ent.USER, newOwner], k, kcount)
          except GAPI.invalidSharingRequest as e:
            entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Ent.TypeNameMessage(Ent.PERMISSION_ID, permissionId, str(e)), k, kcount)
          except GAPI.permissionNotFound:
            entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileDesc, Ent.PERMISSION_ID, permissionId], k, kcount)
          except GAPI.fileNotFound:
            entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, k, kcount)
          except GAPI.forbidden as e:
            entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), k, kcount)
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, k, kcount)
        except GAPI.forbidden as e:
          entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), k, kcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Files to Transfer Ownership', todrive)

# gam <UserTypeEntity> claim ownership <DriveFileEntity> [includetrashed]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[skipids <DriveFileEntity>] [skipusers <UserTypeEntity>] [subdomains <DomainNameEntity>]
#	[restricted [<Boolean>]] [writerscanshare|writerscantshare [<Boolean>]] [keepuser | (retainrole reader|commenter|writer|editor|none)] [noretentionmessages]
#	[preview] [filepath] [buildtree] [todrive [<ToDriveAttributes>]]d
def claimOwnership(users):
  def _identifyFilesToClaim(fileEntry, skipids):
    for childFileId in fileEntry[u'children']:
      childEntry = fileTree.get(childFileId)
      if childEntry:
        childEntryInfo = childEntry[u'info']
        if childFileId not in skipids and (trashed or not childEntryInfo[u'trashed']):
          owner = childEntryInfo[u'owners'][0][u'emailAddress']
          if not childEntryInfo[u'ownedByMe'] and owner not in skipusers:
            oldOwnerPermissionIds[owner] = childEntryInfo[u'owners'][0][u'permissionId']
            filesToClaim.setdefault(owner, {})
            if childFileId not in filesToClaim[owner]:
              filesToClaim[owner][childFileId] = {VX_FILENAME: childEntryInfo[VX_FILENAME], u'type': _getEntityMimeType(childEntryInfo)}
          if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
            _identifyFilesToClaim(childEntry, skipids)

  def _identifyChildrenToClaim(fileEntry, skipIds, user, i, count):
    try:
      children = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               orderBy=orderBy, q=WITH_PARENTS.format(fileEntry[u'id']), fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      childFileId = childEntryInfo[u'id']
      if childFileId not in skipIds and (trashed or not childEntryInfo[u'trashed']):
        if filepath:
          fileTree[childFileId] = {u'info': childEntryInfo}
        owner = childEntryInfo[u'owners'][0][u'emailAddress']
        if not childEntryInfo[u'ownedByMe'] and owner not in skipusers:
          oldOwnerPermissionIds[owner] = childEntryInfo[u'owners'][0][u'permissionId']
          filesToClaim.setdefault(owner, {})
          if childFileId not in filesToClaim[owner]:
            filesToClaim[owner][childFileId] = {VX_FILENAME: childEntryInfo[VX_FILENAME], u'type': _getEntityMimeType(childEntryInfo)}
        if childEntryInfo[u'mimeType'] == MIMETYPE_GA_FOLDER:
          _identifyChildrenToClaim(childEntryInfo, skipIds, user, i, count)

  def _processRetainedRole(user, i, count, oldOwner, entityType, fileDesc, l, lcount):
    oldOwnerPermissionId = oldOwnerPermissionIds[oldOwner]
    Act.Set(Act.RETAIN)
    try:
      if sourceRetainRoleBody[u'role'] != u'none':
        if sourceRetainRoleBody[u'role'] != u'writer':
          callGAPI(sourceDrive.permissions(), u'update',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                   fileId=fileId, permissionId=oldOwnerPermissionId, body=sourceRetainRoleBody, fields=u'')
      else:
        callGAPI(sourceDrive.permissions(), u'delete',
                 throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                 fileId=fileId, permissionId=oldOwnerPermissionId)
      if showRetentionMessages:
        entityActionPerformed([Ent.USER, oldOwner, entityType, fileDesc, Ent.ROLE, sourceRetainRoleBody[u'role']], l, lcount)
    except GAPI.permissionNotFound:
      entityDoesNotHaveItemWarning([Ent.USER, oldOwner, entityType, fileDesc, Ent.PERMISSION_ID, oldOwnerPermissionId], l, lcount)
    except GAPI.badRequest as e:
      entityActionFailedWarning([Ent.USER, oldOwner, entityType, fileDesc], str(e), l, lcount)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    Act.Set(Act.CLAIM_OWNERSHIP)

  fileIdEntity = getDriveFileEntity()
  skipFileIdEntity = initDriveFileEntity()
  orderByList = []
  body = {}
  skipusers = []
  subdomains = []
  csvFormat = filepath = trashed = False
  todrive = {}
  sourceRetainRoleBody = {u'role': u'writer'}
  showRetentionMessages = True
  oldOwnerPermissionIds = {}
  fileTree = None
  buildTree = False
  bodyShare = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'keepuser':
      sourceRetainRoleBody[u'role'] = u'writer'
    elif myarg == u'retainrole':
      sourceRetainRoleBody[u'role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
    elif myarg == u'noretentionmessages':
      showRetentionMessages = False
    elif myarg == u'skipids':
      skipFileIdEntity = getDriveFileEntity()
    elif myarg == u'skipusers':
      _, skipusers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    elif myarg == u'subdomains':
      subdomains = getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY)
    elif myarg == u'includetrashed':
      trashed = True
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'restricted':
      bodyShare[u'viewersCanCopyContent'] = not getBoolean()
    elif myarg == u'writerscanshare':
      bodyShare[u'writersCanShare'] = getBoolean()
    elif myarg == u'writerscantshare':
      bodyShare[u'writersCanShare'] = not getBoolean()
    elif myarg == u'preview':
      csvFormat = True
    elif myarg == u'filepath':
      filepath = True
    elif myarg == u'buildtree':
      buildTree = True
    elif myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  Act.Set(Act.CLAIM_OWNERSHIP)
  orderBy = u','.join(orderByList) if orderByList else None
  if csvFormat:
    titles, csvRows = initializeTitlesCSVfile([u'NewOwner', u'OldOwner', u'type', u'id', VX_FILENAME])
    if filepath:
      addTitlesToCSVfile(u'paths', titles)
  else:
    filepath = False
  body = {u'role': u'owner'}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if not drive:
      continue
    permissionId = validateUserGetPermissionId(user, i, count)
    if not permissionId:
      continue
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.DRIVE_FILE_OR_FOLDER, i, count)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    bodyAdd = {u'role': u'writer', u'type': u'user', u'emailAddress': user}
    if skipFileIdEntity[u'query'] or skipFileIdEntity[u'root']:
      _validateUserGetFileIDs(origUser, i, count, skipFileIdEntity, drive=drive)
    if buildTree:
      try:
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count)
        feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                             page_message=getPageMessageForWhom(),
                             throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                             orderBy=orderBy, fields=VX_NPT_FILES_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS,
                             pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
      fileTree = buildFileTree(feed, drive)
    else:
      fileTree = {}
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      filesToClaim = {}
      if buildTree:
        fileEntry = fileTree.get(fileId)
        if not fileEntry:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        fileEntryInfo = fileEntry[u'info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), u'get',
                                   throw_reasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId, fields=VX_ID_FILENAME_PARENTS_MIMETYPE_OWNEDBYME_TRASHED_OWNERS)
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
        if filepath:
          fileTree[fileId] = {u'info': fileEntryInfo}
      entityType = _getEntityMimeType(fileEntryInfo)
      entityPerformActionItemValue([Ent.USER, user], entityType, u'{0} ({1})'.format(fileEntryInfo[VX_FILENAME], fileId), j, jcount)
      if fileId not in skipFileIdEntity[u'list'] and (trashed or not fileEntryInfo[u'trashed']):
        owner = fileEntryInfo[u'owners'][0][u'emailAddress']
        if not fileEntryInfo[u'ownedByMe'] and owner not in skipusers:
          oldOwnerPermissionIds[owner] = fileEntryInfo[u'owners'][0][u'permissionId']
          filesToClaim.setdefault(owner, {})
          if fileId not in filesToClaim[owner]:
            filesToClaim[owner][fileId] = {VX_FILENAME: fileEntryInfo[VX_FILENAME], u'type': entityType}
        if buildTree:
          _identifyFilesToClaim(fileEntry, skipFileIdEntity[u'list'])
        else:
          _identifyChildrenToClaim(fileEntryInfo, skipFileIdEntity[u'list'], user, i, count)
      if csvFormat:
        for oldOwner in filesToClaim:
          for claimFileId, fileInfo in iteritems(filesToClaim[oldOwner]):
            row = {u'NewOwner': user, u'OldOwner': oldOwner, u'type': Ent.Singular(fileInfo[u'type']), u'id': claimFileId, VX_FILENAME: fileInfo[VX_FILENAME]}
            if filepath:
              addFilePathsToRow(drive, fileTree, fileTree[claimFileId][u'info'], filePathInfo, row, titles)
            csvRows.append(row)
        continue
      Ind.Increment()
      kcount = len(filesToClaim)
      entityPerformActionNumItems([Ent.USER, user], kcount, Ent.USER, i, count)
      Ind.Increment()
      k = 0
      for oldOwner in filesToClaim:
        k += 1
        _, userDomain = splitEmailAddress(oldOwner)
        lcount = len(filesToClaim[oldOwner])
        if userDomain == GC.Values[GC.DOMAIN] or userDomain in subdomains:
          _, sourceDrive = buildGAPIServiceObject(API.DRIVE3, oldOwner, k, kcount)
          if not sourceDrive:
            continue
          entityPerformActionNumItemsModifier([Ent.USER, user], lcount, Ent.DRIVE_FILE_OR_FOLDER,
                                              u'{0} {1}: {2}'.format(Act.MODIFIER_FROM, Ent.Singular(Ent.USER), oldOwner), k, kcount)
          Ind.Increment()
          l = 0
          for fileId, fileInfo in iteritems(filesToClaim[oldOwner]):
            l += 1
            if bodyShare:
              callGAPI(sourceDrive.files(), u'update',
                       fileId=fileId, body=bodyShare, fields=u'')
            entityType = fileInfo[u'type']
            fileDesc = u'{0} ({1})'.format(fileInfo[VX_FILENAME], fileId)
            try:
              callGAPI(sourceDrive.permissions(), u'update',
                       throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND, GAPI.FORBIDDEN],
                       fileId=fileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
              entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_FROM, None, [Ent.USER, oldOwner], l, lcount)
              _processRetainedRole(user, i, count, oldOwner, entityType, fileDesc, l, lcount)
            except GAPI.permissionNotFound:
              # if claimer not in ACL (file might be visible for all with link)
              try:
                callGAPI(sourceDrive.permissions(), u'create',
                         throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST, GAPI.FILE_NOT_FOUND, GAPI.FORBIDDEN],
                         fileId=fileId, sendNotificationEmail=False, body=bodyAdd, fields=u'')
                callGAPI(sourceDrive.permissions(), u'update',
                         throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND],
                         fileId=fileId, permissionId=permissionId, transferOwnership=True, body=body, fields=u'')
                entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_FROM, None, [Ent.USER, oldOwner], l, lcount)
                _processRetainedRole(user, i, count, oldOwner, entityType, fileDesc, l, lcount)
              except GAPI.invalidSharingRequest as e:
                entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Ent.TypeNameMessage(Ent.PERMISSION_ID, permissionId, str(e)), l, lcount)
              except GAPI.permissionNotFound:
                entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileDesc, Ent.PERMISSION_ID, permissionId], l, lcount)
              except GAPI.fileNotFound:
                entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, l, lcount)
              except GAPI.forbidden as e:
                entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), l, lcount)
              except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
                userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
            except GAPI.fileNotFound:
              entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, l, lcount)
            except GAPI.forbidden as e:
              entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), l, lcount)
            except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
              userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
              break
          Ind.Decrement()
        else:
          entityPerformActionModifierNumItemsModifier([Ent.USER, user], u'Not Performed', kcount, Ent.DRIVE_FILE_OR_FOLDER,
                                                      u'{0} {1}: {2}'.format(Act.MODIFIER_FROM, Ent.Singular(Ent.USER), oldOwner), j, jcount)
          Ind.Increment()
          l = 0
          for fileId, fileInfo in iteritems(filesToClaim[oldOwner]):
            l += 1
            entityActionNotPerformedWarning([Ent.USER, user, fileInfo[u'type'], u'{0} ({1})'.format(fileInfo[VX_FILENAME], fileId)],
                                            Msg.USER_IN_OTHER_DOMAIN.format(Ent.Singular(Ent.USER), oldOwner), l, lcount)
          Ind.Decrement()
      Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Files to Claim Ownership', todrive)

# gam <UserTypeEntity> delete emptydrivefolders [<TeamDriveEntity>]
def deleteEmptyDriveFolders(users):
  Act.Set(Act.DELETE_EMPTY)
  if Cmd.ArgumentsRemaining():
    fileIdEntity = getTeamDriveEntity()
    query = ANY_FOLDERS
  else:
    fileIdEntity = {}
    query = MY_FOLDERS
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    try:
      printEntityKVList([Ent.USER, user],
                        [u'{0} {1}'.format(Act.ToPerform(), Ent.Plural(Ent.DRIVE_FILE_OR_FOLDER))],
                        i, count)
      Ind.Increment()
      deletedFolderIds = set()
      deleted_empty = True
      while deleted_empty:
        deleted_empty = False
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FOLDER, user, i, count)
        if not fileIdEntity.get(u'teamdrive'):
          feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               page_message=getPageMessageForWhom(),
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               q=query, fields=VX_NPT_FILES_ID_FILENAME_OWNEDBYME,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
        else:
          feed = callGAPIpages(drive.files(), u'list', VX_PAGES_FILES,
                               page_message=getPageMessageForWhom(),
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                               q=query, fields=VX_NPT_FILES_ID_FILENAME,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **fileIdEntity[u'teamdrive'])
        jcount = len(feed)
        j = 0
        for folder in feed:
          j += 1
          if folder[u'id'] in deletedFolderIds:
            pass
          elif folder.get(u'ownedByMe', True):
            if not fileIdEntity.get(u'teamdrive'):
              children = callGAPIitems(drive.files(), u'list', VX_PAGES_FILES,
                                       throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                                       q=WITH_PARENTS.format(folder[u'id']), fields=VX_FILES_ID_FILENAME,
                                       pageSize=1)
            else:
              children = callGAPIitems(drive.files(), u'list', VX_PAGES_FILES,
                                       throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                                       q=WITH_PARENTS.format(folder[u'id']), fields=VX_FILES_ID_FILENAME,
                                       pageSize=1, **fileIdEntity[u'teamdrive'])
            if len(children) == 0:
              try:
                callGAPI(drive.files(), u'delete',
                         throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                         fileId=folder[u'id'], supportsTeamDrives=True)
                entityActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folder[VX_FILENAME]], j, jcount)
                deletedFolderIds.add(folder[u'id'])
                deleted_empty = True
                if fileIdEntity.get(u'teamdrive'):
                  time.sleep(1)
              except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
                entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, folder[VX_FILENAME]], str(e), j, jcount)
            else:
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, folder[VX_FILENAME]],
                                              u'{0} - {1} ({2})'.format(Msg.CONTAINS_AT_LEAST_1_ITEM, children[0][VX_FILENAME], children[0][u'id']), j, jcount)
          else:
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, folder[VX_FILENAME]],
                                            Msg.NOT_OWNED_BY.format(user), j, jcount)
    except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity[u'teamdrive'][u'teamDriveId']], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    Ind.Decrement()

# gam <UserTypeEntity> empty drivetrash [<TeamDriveEntity>]
def emptyDriveTrash(users):
  if Cmd.ArgumentsRemaining():
    fileIdEntity = getTeamDriveEntity()
  else:
    fileIdEntity = {}
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  if not fileIdEntity:
    for user in users:
      i += 1
      user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
      if not drive:
        continue
      try:
        callGAPI(drive.files(), u'emptyTrash',
                 throw_reasons=GAPI.DRIVE_USER_THROW_REASONS)
        entityActionPerformed([Ent.USER, user, Ent.DRIVE_TRASH, None], i, count)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  else:
    Act.Set(Act.PURGE)
    fileIdEntity[u'teamdrivefilequery'] = u'trashed = true'
    for user in users:
      i += 1
      user, drive, jcount = _validateUserGetTeamDriveFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
      if jcount == 0:
        continue
      Ind.Increment()
      j = 0
      for fileId in fileIdEntity[u'list']:
        j += 1
        try:
          callGAPI(drive.files(), u'delete',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                   fileId=fileId, supportsTeamDrives=True)
          fileName = fileId
          entityActionPerformed([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileName], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()

def _getDriveFileACLPrintKeysTimeObjects():
  printKeys = [u'id', u'type', u'emailAddress', u'domain', u'role', u'teamDrivePermissionDetails', VX_EXPIRATION_TIME, u'photoLink', u'allowFileDiscovery', u'deleted']
  timeObjects = [VX_EXPIRATION_TIME]
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDrive3TitlesToDrive2(printKeys, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
    _mapDrive3TitlesToDrive2(timeObjects, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
  return (printKeys, set(timeObjects))

# DriveFileACL commands utilities
def _showDriveFilePermissionJSON(user, fileId, fileName, permission, timeObjects):
  _mapDrivePermissionNames(permission)
  flattened = {u'Owner': user, u'id': fileId, u'permission': permission}
  if fileId != fileName:
    flattened[VX_FILENAME] = fileName
  printLine(json.dumps(cleanJSON(flattened, u'', timeObjects=timeObjects), ensure_ascii=False, sort_keys=True))

def _showDriveFilePermission(permission, printKeys, timeObjects, i=0, count=0):
  if permission.get(u'displayName'):
    name = permission[u'displayName']
  elif u'id' in permission:
    if permission[u'id'] == u'anyone':
      name = u'Anyone'
    elif permission[u'id'] == u'anyoneWithLink':
      name = u'Anyone with Link'
    else:
      name = permission[u'id']
  _mapDrivePermissionNames(permission)
  printKeyValueListWithCount([name], i, count)
  Ind.Increment()
  for key in printKeys:
    value = permission.get(key)
    if value is None:
      continue
    if key == u'teamDrivePermissionDetails':
      printKeyValueList([key, u''])
      Ind.Increment()
      for detail in value:
        printKeyValueList([u'role', detail[u'role']])
        Ind.Increment()
        printKeyValueList([u'type', detail[u'teamDrivePermissionType']])
        if u'additionalRoles' in detail:
          printKeyValueList([u'additionalRoles', u','.join(detail[u'additionalRoles'])])
        printKeyValueList([u'inherited', detail[u'inherited']])
        if detail[u'inherited']:
          printKeyValueList([u'inheritedFrom', detail[u'inheritedFrom']])
        Ind.Decrement()
      Ind.Decrement()
    elif key not in timeObjects:
      printKeyValueList([key, value])
    else:
      printKeyValueList([key, formatLocalTime(value)])
  Ind.Decrement()

DRIVEFILE_ACL_ROLES_MAP = {
  u'commenter': u'commenter',
  u'editor': u'writer',
  u'organizer': u'organizer',
  u'owner': u'owner',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  }

DRIVEFILE_ACL_PERMISSION_TYPES = [u'anyone', u'domain', u'group', u'user',] # anyone must be first element

def _createDriveFileACL(users, useDomainAdminAccess):
  sendNotificationEmail = showTitles = _transferOwnership = False
  showDetails = True
  emailMessage = None
  fileIdEntity = getDriveFileEntity()
  body = {}
  body[u'type'] = getChoice(DRIVEFILE_ACL_PERMISSION_TYPES)
  if body[u'type'] != u'anyone':
    if body[u'type'] != u'domain':
      body[u'emailAddress'] = permissionId = getEmailAddress()
    else:
      body[u'domain'] = permissionId = getString(Cmd.OB_DOMAIN_NAME)
  else:
    permissionId = u'anyone'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'withlink':
      withLinkLocation = Cmd.Location()
      body[u'allowFileDiscovery'] = False
    elif myarg in [u'allowfilediscovery', u'discoverable']:
      withLinkLocation = Cmd.Location()
      body[u'allowFileDiscovery'] = getBoolean()
    elif myarg == u'role':
      roleLocation = Cmd.Location()
      body[u'role'] = getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if body[u'role'] == u'owner':
        sendNotificationEmail = True
        _transferOwnership = True
    elif myarg in [u'expiration', u'expires']:
      body[VX_EXPIRATION_TIME] = getTimeOrDeltaFromNow()
    elif myarg == u'sendemail':
      sendNotificationEmail = True
    elif myarg == u'emailmessage':
      sendNotificationEmail = True
      emailMessage = getString(Cmd.OB_STRING)
    elif myarg == u'showtitles':
      showTitles = True
    elif myarg == u'nodetails':
      showDetails = False
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if u'role' not in body:
    missingArgumentExit(u'role {0}'.format(formatChoiceList(DRIVEFILE_ACL_ROLES_MAP)))
  if body[u'role'] == u'owner' and body[u'type'] != u'user':
    Cmd.SetLocation(roleLocation)
    usageErrorExit(Msg.INVALID_OWNER_TYPE.format(body[u'role'], body[u'type']))
  if u'allowFileDiscovery' in body and body[u'type'] in [u'user', u'group']:
    Cmd.SetLocation(withLinkLocation-1)
    usageErrorExit(Msg.WITHLINK_INCOMPATIBILITY.format(body[u'type']))
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId)
        permission = callGAPI(drive.permissions(), u'create',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST,
                                                                             GAPI.TEAMDRIVE_NOT_FOUND,
                                                                             GAPI.CANNOT_SHARE_TEAMDRIVE_TOPFOLDER_WITH_ANYONEORDOMAINS,
                                                                             GAPI.OWNER_ON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                             GAPI.ORGANIZER_ON_NON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                             GAPI.TEAMDRIVES_FOLDER_SHARING_NOT_SUPPORTED],
                              useDomainAdminAccess=useDomainAdminAccess,
                              fileId=fileId, sendNotificationEmail=sendNotificationEmail, emailMessage=emailMessage,
                              transferOwnership=_transferOwnership, body=body, fields=u'*', supportsTeamDrives=True)
        entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
        if showDetails:
          _showDriveFilePermission(permission, printKeys, timeObjects)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.cannotShareTeamDriveTopFolderWithAnyoneOrDomains, GAPI.ownerOnTeamDriveItemNotSupported,
              GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.teamDrivesFolderSharingNotSupported) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.teamDriveNotFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except GAPI.invalidSharingRequest as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, permissionId, str(e)), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> create|add drivefileacl <DriveFileEntity> [adminaccess|asadmin] anyone|(user <UserItem>)|(group <GroupItem>)|(domain <DomainName>)
#	(role reader|commenter|writer|owner|editor|organizer) [withlink|(allowfilediscovery|discoverable [<Boolean>])] [expiration <Time>] [sendemail] [emailmessage <String>] [showtitles] [nodetails]
def createDriveFileACL(users):
  _createDriveFileACL(users, False)

# gam create|add drivefileacl <DriveFileEntity> anyone|(user <UserItem>)|(group <GroupItem>)|(domain <DomainName>)
#	(role reader|commenter|writer|owner|editor|organizer) [withlink|(allowfilediscovery|discoverable [<Boolean>])] [expiration <Time>] [sendemail] [emailmessage <String>] [showtitles] [nodetails]
def doCreateDriveFileACL():
  _createDriveFileACL([_getValueFromOAuth(u'email')], True)

def _updateDriveFileACLs(users, useDomainAdminAccess):
  fileIdEntity = getDriveFileEntity()
  body = {}
  isEmail, permissionId = getPermissionId()
  removeExpiration = showTitles = _transferOwnership = False
  showDetails = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'role':
      body[u'role'] = getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if body[u'role'] == u'owner':
        _transferOwnership = True
    elif myarg in [u'expiration', u'expires']:
      body[VX_EXPIRATION_TIME] = getTimeOrDeltaFromNow()
    elif myarg == u'removeexpiration':
      removeExpiration = getBoolean()
    elif myarg == u'showtitles':
      showTitles = True
    elif myarg == u'nodetails':
      showDetails = False
    elif myarg == u'transferownership':
      deprecatedArgument(myarg)
      getBoolean()
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if removeExpiration is None and u'role' not in body:
    missingArgumentExit(u'role {0}'.format(formatChoiceList(DRIVEFILE_ACL_ROLES_MAP)))
  if isEmail:
    permissionId = getPermissionIdForEmail(permissionId)
    if not permissionId:
      return
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId)
        permission = callGAPI(drive.permissions(), u'update',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.INVALID_OWNERSHIP_TRANSFER,
                                                                             GAPI.TEAMDRIVE_NOT_FOUND,
                                                                             GAPI.CANNOT_SHARE_TEAMDRIVE_TOPFOLDER_WITH_ANYONEORDOMAINS,
                                                                             GAPI.OWNER_ON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                             GAPI.ORGANIZER_ON_NON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                             GAPI.CANNOT_MODIFY_INHERITED_TEAMDRIVE_PERMISSION,
                                                                             GAPI.FIELD_NOT_WRITABLE, GAPI.PERMISSION_NOT_FOUND],
                              useDomainAdminAccess=useDomainAdminAccess,
                              fileId=fileId, permissionId=permissionId, removeExpiration=removeExpiration,
                              transferOwnership=_transferOwnership, body=body, fields=u'*', supportsTeamDrives=True)
        entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
        if showDetails:
          _showDriveFilePermission(permission, printKeys, timeObjects)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.invalidOwnershipTransfer,
              GAPI.cannotShareTeamDriveTopFolderWithAnyoneOrDomains, GAPI.ownerOnTeamDriveItemNotSupported, GAPI.organizerOnNonTeamDriveItemNotSupported,
              GAPI.cannotModifyInheritedTeamDrivePermission, GAPI.fieldNotWritable) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.teamDriveNotFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> update drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [adminaccess|asadmin]
#	(role reader|commenter|writer|owner|editor|organizer) [expiration <Time>] [removeexpiration [<Boolean>]] [showtitles] [nodetails]
def updateDriveFileACLs(users):
  _updateDriveFileACLs(users, False)

# gam update drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail>
#	(role reader|commenter|writer|owner|editor|organizer) [expiration <Time>] [removeexpiration [<Boolean>]] [showtitles] [nodetails]
def doUpdateDriveFileACLs():
  _updateDriveFileACLs([_getValueFromOAuth(u'email')], True)

def _createDriveFilePermissions(users, useDomainAdminAccess):

  def _makePermissionBody(permission):
    body = {}
    try:
      scope, role = permission.split(u';', 1)
      if scope == u'anyone' or scope == u'anyonewithlink':
        body[u'type'] = u'anyone'
        body[u'allowFileDiscovery'] = scope != u'anyonewithlink'
      else:
        body[u'type'], value = scope.split(u':', 1)
        if body[u'type'] == u'domainwithlink':
          body[u'allowFileDiscovery'] = False
          body[u'type'] = u'domain'
        if body[u'type'] not in DRIVEFILE_ACL_PERMISSION_TYPES[1:]:
          return None
        if body[u'type'] != u'domain':
          body[u'emailAddress'] = value
        else:
          body[u'domain'] = value
      body[u'role'] = DRIVEFILE_ACL_ROLES_MAP.get(role)
      if not body[u'role']:
        return None
      if expiration:
        body[VX_EXPIRATION_TIME] = expiration
      return body
    except ValueError:
      return None

  def _callbackCreatePermission(request_id, response, exception):
    ri = request_id.splitlines()
    if int(ri[RI_J]) == 1:
      entityPerformActionNumItems([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY]], int(ri[RI_JCOUNT]), Ent.PERMITTEE, int(ri[RI_I]), int(ri[RI_COUNT]))
      Ind.Increment()
    if exception is None:
      entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+[GAPI.SERVICE_LIMIT]:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
          Ind.Decrement()
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(drive.permissions(), u'create',
                 throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST,
                                                                GAPI.TEAMDRIVE_NOT_FOUND,
                                                                GAPI.CANNOT_SHARE_TEAMDRIVE_TOPFOLDER_WITH_ANYONEORDOMAINS,
                                                                GAPI.OWNER_ON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                GAPI.ORGANIZER_ON_NON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                GAPI.TEAMDRIVES_FOLDER_SHARING_NOT_SUPPORTED],
                 retry_reasons=[GAPI.SERVICE_LIMIT],
                 useDomainAdminAccess=useDomainAdminAccess,
                 fileId=ri[RI_ENTITY], sendNotificationEmail=sendNotificationEmail, emailMessage=emailMessage, body=_makePermissionBody(ri[RI_ITEM]), fields=u'')
        entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.invalidSharingRequest, GAPI.cannotShareTeamDriveTopFolderWithAnyoneOrDomains, GAPI.ownerOnTeamDriveItemNotSupported,
              GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.teamDrivesFolderSharingNotSupported,
              GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.teamDriveNotFound as e:
        entityActionFailedWarning([Ent.TEAMDRIVE, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))
    if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
      Ind.Decrement()

  sendNotificationEmail = False
  emailMessage = expiration = None
  fileIdEntity = getDriveFileEntity()
  permissions = getEntityList(Cmd.OB_DRIVE_FILE_PERMISSION_ENTITY)
  permissionsLists = permissions if isinstance(permissions, dict) else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'expiration', u'expires']:
      expiration = getTimeOrDeltaFromNow()
    elif myarg == u'sendemail':
      sendNotificationEmail = True
    elif myarg == u'emailmessage':
      sendNotificationEmail = True
      emailMessage = getString(Cmd.OB_STRING)
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    try:
      callGAPI(drive.about(), u'get',
               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
               fields=u'kind')
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      continue
    Ind.Increment()
    svcargs = dict([(u'fileId', None), (u'sendNotificationEmail', sendNotificationEmail), (u'emailMessage', emailMessage),
                    (u'useDomainAdminAccess', useDomainAdminAccess),
                    (u'body', None), (u'fields', u''), (u'supportsTeamDrives', True)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(drive.permissions(), u'create')
    dbatch = drive.new_batch_http_request(callback=_callbackCreatePermission)
    bcount = 0
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      if permissionsLists:
        if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
          permissions = permissionsLists[fileId]
        else:
          permissions = permissionsLists[origUser][fileId]
      kcount = len(permissions)
      if kcount == 0:
        continue
      k = 0
      for permission in permissions:
        k += 1
        svcparms = svcargs.copy()
        svcparms[u'fileId'] = fileId
        svcparms[u'body'] = _makePermissionBody(permission)
        if not svcparms[u'body']:
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, fileId, Ent.PERMITTEE, permission], Msg.INVALID, k, kcount)
          continue
        dbatch.add(method(**svcparms), request_id=batchRequestID(fileId, j, jcount, k, kcount, permission))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = drive.new_batch_http_request(callback=_callbackCreatePermission)
          bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

# gam <UserTypeEntity> create|add permissions <DriveFileEntity> <DriveFilePermissionsEntity> [adminaccess|asadmin] [expiration <Time>] [sendmail] [emailmessage <String>]
def createDriveFilePermissions(users):
  _createDriveFilePermissions(users, False)

# gam create|add permissions <DriveFileEntity> <DriveFilePermissionsEntity> [expiration <Time>] [sendmail] [emailmessage <String>]
def doCreatePermissions():
  _createDriveFilePermissions([_getValueFromOAuth(u'email')], True)

def _deleteDriveFileACLs(users, useDomainAdminAccess):
  fileIdEntity = getDriveFileEntity()
  isEmail, permissionId = getPermissionId()
  showTitles = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'showtitles':
      showTitles = getBoolean()
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if isEmail:
    permissionId = getPermissionIdForEmail(permissionId)
    if not permissionId:
      return
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId)
        callGAPI(drive.permissions(), u'delete',
                 throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.CANNOT_MODIFY_INHERITED_TEAMDRIVE_PERMISSION,
                                                                GAPI.TEAMDRIVE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND],
                 useDomainAdminAccess=useDomainAdminAccess,
                 fileId=fileId, permissionId=permissionId, supportsTeamDrives=True)
        entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.cannotModifyInheritedTeamDrivePermission) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.teamDriveNotFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [adminaccess|asadmin] [showtitles]
def deleteDriveFileACLs(users):
  _deleteDriveFileACLs(users, False)

# gam delete drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [showtitles]
def doDeleteDriveFileACLs():
  _deleteDriveFileACLs([_getValueFromOAuth(u'email')], True)

def _deletePermissions(users, useDomainAdminAccess):

  def _callbackDeletePermissionId(request_id, response, exception):
    ri = request_id.splitlines()
    if int(ri[RI_J]) == 1:
      entityPerformActionNumItems([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY]], int(ri[RI_JCOUNT]), Ent.PERMISSION_ID, int(ri[RI_I]), int(ri[RI_COUNT]))
      Ind.Increment()
    if exception is None:
      entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+[GAPI.SERVICE_LIMIT]:
        if reason == GAPI.PERMISSION_NOT_FOUND:
          entityDoesNotHaveItemWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
          Ind.Decrement()
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(drive.permissions(), u'delete',
                 throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.CANNOT_MODIFY_INHERITED_TEAMDRIVE_PERMISSION, GAPI.PERMISSION_NOT_FOUND],
                 retry_reasons=[GAPI.SERVICE_LIMIT],
                 fileId=ri[RI_ENTITY], permissionId=ri[RI_ITEM], useDomainAdminAccess=useDomainAdminAccess, supportsTeamDrives=True)
        entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.cannotModifyInheritedTeamDrivePermission, GAPI.permissionNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))
    if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
      Ind.Decrement()

  fileIdEntity = getDriveFileEntity()
  permissionIds = getEntityList(Cmd.OB_DRIVE_FILE_PERMISSION_ID_ENTITY)
  permissionIdsLists = permissionIds if isinstance(permissionIds, dict) else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    try:
      callGAPI(drive.about(), u'get',
               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
               fields=u'kind')
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      continue
    Ind.Increment()
    svcargs = dict([(u'fileId', None), (u'permissionId', None), (u'useDomainAdminAccess', useDomainAdminAccess), (u'supportsTeamDrives', True)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(drive.permissions(), u'delete')
    dbatch = drive.new_batch_http_request(callback=_callbackDeletePermissionId)
    bcount = 0
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      if permissionIdsLists:
        if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
          permissionIds = permissionIdsLists[fileId]
        else:
          permissionIds = permissionIdsLists[origUser][fileId]
      kcount = len(permissionIds)
      if kcount == 0:
        continue
      k = 0
      for permissionId in permissionIds:
        k += 1
        svcparms = svcargs.copy()
        svcparms[u'fileId'] = fileId
        svcparms[u'permissionId'] = permissionId
        dbatch.add(method(**svcparms), request_id=batchRequestID(fileId, j, jcount, k, kcount, permissionId))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = drive.new_batch_http_request(callback=_callbackDeletePermissionId)
          bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

# gam <UserTypeEntity> delete permissions <DriveFileEntity> <DriveFilePermissionIDEntity> [adminaccess|asadmin]
def deletePermissions(users):
  _deletePermissions(users, False)

# gam delete permissions <DriveFileEntity> <DriveFilePermissionIDEntity>
def doDeletePermissions():
  _deletePermissions([_getValueFromOAuth(u'email')], True)

def _infoDriveFileACLs(users, useDomainAdminAccess):
  fileIdEntity = getDriveFileEntity()
  isEmail, permissionId = getPermissionId()
  formatJSON = showTitles = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'showtitles':
      showTitles = getBoolean()
    elif myarg == u'formatjson':
      formatJSON = True
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if isEmail:
    permissionId = getPermissionIdForEmail(permissionId)
    if not permissionId:
      return
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=[Ent.DRIVE_FILE_OR_FOLDER_ACL, None][formatJSON],
                                                  useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId, not formatJSON)
        permission = callGAPI(drive.permissions(), u'get',
                              throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.PERMISSION_NOT_FOUND],
                              useDomainAdminAccess=useDomainAdminAccess,
                              fileId=fileId, permissionId=permissionId, fields=u'*', supportsTeamDrives=True)
        if not formatJSON:
          entityPerformActionNumItems([entityType, fileName], jcount, Ent.PERMITTEE)
          Ind.Increment()
          _showDriveFilePermission(permission, printKeys, timeObjects, j, jcount)
          Ind.Decrement()
        else:
          _showDriveFilePermissionJSON(user, fileId, fileName, permission, timeObjects)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> info drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [adminaccess|asadmin] [showtitles] [formatjson]
def infoDriveFileACLs(users):
  _infoDriveFileACLs(users, False)

# gam info drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [showtitles] [formatjson]
def doInfoDriveFileACLs():
  _infoDriveFileACLs([_getValueFromOAuth(u'email')], True)

def _printShowDriveFileACLs(users, csvFormat, useDomainAdminAccess):
  if csvFormat:
    todrive = {}
    sortTitles = [u'Owner', u'id']
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  fileIdEntity = getDriveFileEntity()
  formatJSON = oneItemPerRow = showTitles = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  orderByList = []
  fileNameTitle = [V3_FILENAME, V2_FILENAME][not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'oneitemperrow':
      oneItemPerRow = True
    elif myarg == u'orderby':
      getDrivefileOrderBy(orderByList)
    elif myarg == u'showtitles':
      showTitles = True
      if csvFormat:
        addTitlesToCSVfile(fileNameTitle, titles)
        sortTitles.append(fileNameTitle)
    elif myarg == u'formatjson':
      formatJSON = True
      if csvFormat:
        addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  orderBy = u','.join(orderByList) if orderByList else None
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=[Ent.DRIVE_FILE_OR_FOLDER, None][csvFormat or formatJSON], orderBy=orderBy,
                                                  useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity[u'list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId, not (csvFormat or formatJSON))
        results = callGAPIpages(drive.permissions(), u'list', VX_PAGES_PERMISSIONS,
                                throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND],
                                useDomainAdminAccess=useDomainAdminAccess,
                                fileId=fileId, fields=VX_NPT_PERMISSIONS, supportsTeamDrives=True)
        if not csvFormat:
          if not formatJSON:
            kcount = len(results)
            entityPerformActionNumItems([entityType, fileName], kcount, Ent.PERMITTEE, j, jcount)
            Ind.Increment()
            k = 0
            for permission in results:
              k += 1
              _showDriveFilePermission(permission, printKeys, timeObjects, k, kcount)
            Ind.Decrement()
          else:
            if oneItemPerRow:
              for permission in results:
                _showDriveFilePermissionJSON(user, fileId, fileName, permission, timeObjects)
            else:
              flattened = {u'Owner': user, u'id': fileId}
              if showTitles:
                flattened[fileNameTitle] = fileName
              for permission in results:
                _mapDrivePermissionNames(permission)
              flattened[u'permissions'] = results
              printLine(json.dumps(cleanJSON(flattened, u'', timeObjects=timeObjects), ensure_ascii=False, sort_keys=True))
        elif results:
          if oneItemPerRow:
            for permission in results:
              flattened = {u'Owner': user, u'id': fileId}
              if showTitles:
                flattened[fileNameTitle] = fileName
              _mapDrivePermissionNames(permission)
              if not formatJSON:
                addRowTitlesToCSVfile(flattenJSON({u'permission': permission}, flattened=flattened, timeObjects=timeObjects), csvRows, titles)
              else:
                flattened[u'JSON'] = json.dumps(cleanJSON({u'permission': permission}, u'', timeObjects=timeObjects), ensure_ascii=False, sort_keys=True)
                csvRows.append(flattened)
          else:
            flattened = {u'Owner': user, u'id': fileId}
            if showTitles:
              flattened[fileNameTitle] = fileName
            for permission in results:
              _mapDrivePermissionNames(permission)
            if not formatJSON:
              addRowTitlesToCSVfile(flattenJSON({u'permissions': results}, flattened=flattened, timeObjects=timeObjects), csvRows, titles)
            else:
              flattened[u'JSON'] = json.dumps(cleanJSON({u'permissions': results}, u'', timeObjects=timeObjects), ensure_ascii=False, sort_keys=True)
              csvRows.append(flattened)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.teamDriveNotFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Drive File ACLs', todrive, sortTitles, quotechar)

# gam <UserTypeEntity> print drivefileacl <DriveFileEntity> [todrive [<ToDriveAttributes>]] [oneitemperrow] [showtitles] [formatjson] [quotechar <Character>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [adminaccess|asadmin]
def printDriveFileACLs(users):
  _printShowDriveFileACLs(users, True, False)

# gam <UserTypeEntity> show drivefileacl <DriveFileEntity> [oneitemperrow] [showtitles] [formatjson]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [adminaccess|asadmin]
def showDriveFileACLs(users):
  _printShowDriveFileACLs(users, False, False)

# gam print drivefileacl <DriveFileEntity> [todrive [<ToDriveAttributes>]] [oneitemperrow] [showtitles] [formatjson] [quotechar <Character>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
def doPrintDriveFileACLs():
  _printShowDriveFileACLs([_getValueFromOAuth(u'email')], True, True)

# gam show drivefileacl <DriveFileEntity> [oneitemperrow] [showtitles] [formatjson]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
def doShowDriveFileACLs():
  _printShowDriveFileACLs([_getValueFromOAuth(u'email')], False, True)

def _doPrintShowOwnership(csvFormat):
  rep = buildGAPIObject(API.REPORTS)
  customerId = GC.Values[GC.CUSTOMER_ID]
  if customerId == GC.MY_CUSTOMER:
    customerId = None
  fileNameTitle = [V3_FILENAME, V2_FILENAME][not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]
  if csvFormat:
    todrive = {}
    sortTitles = [u'Owner', u'id', fileNameTitle, u'type', u'ownerIsTeamDrive', u'teamDriveId']
    titles, csvRows = initializeTitlesCSVfile(sortTitles)
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  showComplete = False
  entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
  myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  mycmd = myarg.lower().replace(u'_', u'').replace(u'-', u'')
  if mycmd == u'id':
    fileId = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  elif mycmd == u'drivefilename':
    entityType = Ent.DRIVE_FILE_OR_FOLDER
    fileId = getString(Cmd.OB_DRIVE_FILE_NAME, checkBlank=True)
  elif mycmd.find(u':') != -1:
    kw, fileId = myarg.split(u':', 1)
    kw = kw.lower().replace(u'_', u'').replace(u'-', u'')
    if fileId.isspace():
      Cmd.Backup()
      blankArgumentExit(Cmd.OB_DRIVE_FILE_ID)
    if kw == u'id':
      pass
    elif kw == u'drivefilename':
      entityType = Ent.DRIVE_FILE_OR_FOLDER
    else:
      Cmd.Backup()
      invalidArgumentExit(Cmd.OB_DRIVE_FILE_ID)
  else:
    fileId = myarg
  if not fileId:
    Cmd.Backup()
    invalidArgumentExit(Cmd.OB_DRIVE_FILE_ID)
  if entityType == Ent.DRIVE_FILE_OR_FOLDER_ID:
    filters = u'doc_id=={0}'.format(fileId)
  else:
    filters = u'doc_title=={0}'.format(fileId)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'formatjson':
      formatJSON = True
      if csvFormat:
        titles, csvRows = initializeTitlesCSVfile([u'JSON',])
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  foundIds = {}
  try:
    feed = callGAPIpages(rep.activities(), u'list', u'items',
                         throw_reasons=[GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.AUTH_ERROR],
                         applicationName=u'drive', userKey='all', customerId=customerId,
                         filters=filters, fields=u'nextPageToken,items(events(parameters))')
    while feed:
      activity = feed.popleft()
      events = activity.pop(u'events')
      for event in events:
        fileInfo = {}
        for item in event.get(u'parameters', []):
          if item[u'name'] == u'primary_event':
            if not item[u'boolValue']:
              break
          elif item[u'name'] == u'doc_id':
            if item[u'value'] in foundIds:
              break
            fileInfo[u'id'] = item[u'value']
          elif item[u'name'] == u'owner':
            fileInfo[u'Owner'] = item[u'value']
          elif item[u'name'] == u'doc_title':
            fileInfo[fileNameTitle] = item[u'value']
          elif item[u'name'] == u'doc_type':
            fileInfo[u'type'] = item[u'value']
          elif item[u'name'] == u'owner_is_team_drive':
            fileInfo[u'ownerIsTeamDrive'] = item[u'boolValue']
          elif item[u'name'] == u'team_drive_id':
            fileInfo[u'teamDriveId'] = item[u'value']
        else:
          if u'Owner' in fileInfo and u'id' in fileInfo:
            foundIds[fileInfo[u'id']] = True
            if not csvFormat:
              if not formatJSON:
                printEntityKVList([Ent.OWNER, fileInfo[u'Owner']],
                                  [u'id', fileInfo[u'id'], fileNameTitle, fileInfo.get(u'title', ''),
                                   u'type', fileInfo.get(u'type', ''), u'ownerIsTeamDrive', fileInfo.get(u'ownerIsTeamDrive', False), u'teamDriveId', fileInfo.get(u'teamDriveId', '')])
              else:
                printLine(json.dumps(cleanJSON(fileInfo, u''), ensure_ascii=False, sort_keys=True))
            else:
              if not formatJSON:
                addRowTitlesToCSVfile(flattenJSON(fileInfo), csvRows, titles)
              else:
                csvRows.append({u'JSON': json.dumps(cleanJSON(fileInfo, u''), ensure_ascii=False, sort_keys=True)})
            if entityType == Ent.DRIVE_FILE_OR_FOLDER_ID:
              showComplete = True
              break
        if showComplete:
          break
      if showComplete:
        break
    if not foundIds:
      entityActionFailedWarning([entityType, fileId], Msg.NOT_FOUND)
  except GAPI.badRequest:
    printErrorMessage(BAD_REQUEST_RC, Msg.BAD_REQUEST)
  except GAPI.invalid as e:
    systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
  except GAPI.authError:
    accessErrorExit(None)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Drive File Ownership', todrive, sortTitles, quotechar)

# gam print ownership <DriveFileID>|(drivefilename <DriveFileName>) [todrive [<ToDriveAttributes>]] [formatjson] [quotechar <Character>]
def doPrintOwnership():
  _doPrintShowOwnership(True)

# gam show ownership <DriveFileID>|(drivefilename <DriveFileName>) [formatjson]
def doShowOwnership():
  _doPrintShowOwnership(False)

def _getTeamDriveTheme(myarg, body):
  if myarg in [u'theme', u'themeid']:
    body.pop(u'backgroundImageFile', None)
    body.pop(u'colorRgb', None)
    body[u'themeId'] = getString(Cmd.OB_STRING, checkBlank=True)
  elif myarg == u'customtheme':
    body.pop(u'themeId', None)
    body[u'backgroundImageFile'] = {
      u'id': getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True),
      u'xCoordinate': getFloat(minVal=0.0, maxVal=1.0),
      u'yCoordinate': getFloat(minVal=0.0, maxVal=1.0),
      u'width': getFloat(minVal=0.0, maxVal=1.0)
      }
  elif myarg == u'color':
    body.pop(u'themeId', None)
    body[u'colorRgb'] = getColor()
  else:
    unknownArgumentExit()

# gam <UserTypeEntity> create|add teamdrive <Name> [(theme|themeid <String>) | ([customtheme <DriveFileID> <Float> <Float> <Float>] [color <ColorValue>])]
def createTeamDrive(users):
  requestId = text_type(uuid.uuid4())
  body = {u'name': getString(Cmd.OB_NAME, checkBlank=True)}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    _getTeamDriveTheme(myarg, body)
  updateBody = {}
  for field in [u'backgroundImageFile', u'colorRgb']:
    if field in body:
      updateBody[field] = body.pop(field)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    try:
      Act.Set(Act.CREATE)
      teamdrive = callGAPI(drive.teamdrives(), u'create',
                           throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.DUPLICATE, GAPI.BAD_REQUEST],
                           requestId=requestId, body=body, fields=u'id')
      teamDriveId = teamdrive[u'id']
      entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
      if updateBody:
        try:
          Act.Set(Act.UPDATE)
          callGAPI(drive.teamdrives(), u'update',
                   throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND, GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                   teamDriveId=teamDriveId, body=updateBody)
          entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
        except (GAPI.teamDriveNotFound, GAPI.notFound, GAPI.forbidden, GAPI.badRequest) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except GAPI.duplicate:
      entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], Msg.DUPLICATE, i, count)
    except (GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

# gam <UserTypeEntity> update teamdrive <TeamDriveEntity> [name <Name>] [(theme|themeid <String>) | ([customtheme <DriveFileID> <Float> <Float> <Float>] [color <ColorValue>])]
def updateTeamDrive(users):
  fileIdEntity = getTeamDriveEntity()
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[VX_FILENAME] = getString(Cmd.OB_NAME, checkBlank=True)
    else:
      _getTeamDriveTheme(myarg, body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity[u'teamdrive'][u'teamDriveId']
      callGAPI(drive.teamdrives(), u'update',
               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND, GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
               teamDriveId=teamDriveId, body=body)
      entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
    except (GAPI.teamDriveNotFound, GAPI.notFound, GAPI.forbidden, GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

# gam <UserTypeEntity> delete teamdrive <TeamDriveEntity>
def deleteTeamDrive(users):
  fileIdEntity = getTeamDriveEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity[u'teamdrive'][u'teamDriveId']
      callGAPI(drive.teamdrives(), u'delete',
               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND, GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.CANNOT_DELETE_RESOURCE_WITH_CHILDREN],
               teamDriveId=teamDriveId)
      entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
    except (GAPI.teamDriveNotFound, GAPI.notFound, GAPI.forbidden, GAPI.cannotDeleteResourceWithChildren) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

TEAMDRIVE_FIELDS_CHOICE_MAP = {
  u'backgroundimagefile': u'backgroundImageFile',
  u'backgroundimagelink': u'backgroundImageLink',
  u'capabilities': u'capabilities',
  u'colorrgb': u'colorRgb',
  u'createdtime': u'createdTime',
  u'id': u'id',
  u'name': u'name',
  u'themeid': u'themeId',
  }

TEAMDRIVE_CAPABILITIES_PRINT_ORDER = [
  u'canAddChildren',
  u'canChangeTeamDriveBackground',
  u'canComment',
  u'canCopy',
  u'canDeleteTeamDrive',
  u'canDownload',
  u'canEdit',
  u'canListChildren',
  u'canManageMembers',
  u'canReadRevisions',
  u'canRemoveChildren',
  u'canRename',
  u'canRenameTeamDrive',
  u'canShare',
  ]
TEAMDRIVE_TIME_OBJECTS = set([u'createdTime',])

def _showTeamDrive(user, teamdrive, j, jcount, formatJSON):
  if formatJSON:
    printLine(json.dumps(cleanJSON(teamdrive, u'', timeObjects=TEAMDRIVE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.USER, user, Ent.TEAMDRIVE, u'{0} ({1})'.format(teamdrive[u'name'], teamdrive[u'id'])], j, jcount)
  Ind.Increment()
  printEntity([Ent.TEAMDRIVE_ID, teamdrive[u'id']])
  printEntity([Ent.TEAMDRIVE_NAME, teamdrive[u'name']])
  if u'createdTime' in teamdrive:
    printKeyValueList([u'createdTime', formatLocalTime(teamdrive[u'createdTime'])])
  for setting in [u'backgroundImageLink', u'colorRgb', u'themeId']:
    if setting in teamdrive:
      printKeyValueList([setting, teamdrive[setting]])
  if u'capabilities' in teamdrive:
    printKeyValueList([u'capabilities', u''])
    Ind.Increment()
    for capability in TEAMDRIVE_CAPABILITIES_PRINT_ORDER:
      if capability in teamdrive[u'capabilities']:
        printKeyValueList([capability, teamdrive[u'capabilities'][capability]])
    Ind.Decrement()
  Ind.Decrement()

def _infoTeamDrive(users, useDomainAdminAccess):
  fileIdEntity = getTeamDriveEntity()
  fieldsList = []
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    elif myarg == u'formatjson':
      formatJSON = True
    elif getFieldsList(myarg, TEAMDRIVE_FIELDS_CHOICE_MAP, fieldsList, [u'id', u'name']):
      pass
    else:
      unknownArgumentExit()
  if fieldsList:
    fields = u','.join(set(fieldsList)).replace(u'.', u'/')
  else:
    fields = u'*'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity, useDomainAdminAccess=useDomainAdminAccess)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity[u'teamdrive'][u'teamDriveId']
      teamdrive = callGAPI(drive.teamdrives(), u'get',
                           throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TEAMDRIVE_NOT_FOUND],
                           useDomainAdminAccess=useDomainAdminAccess,
                           teamDriveId=teamDriveId, fields=fields)
      _showTeamDrive(user, teamdrive, i, count, formatJSON)
    except GAPI.teamDriveNotFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

# gam <UserTypeEntity> info teamdrive <TeamDriveEntity> [adminaccess|asadmin] [fields <TeamDriveFieldNameList>] [formatjson]
def infoTeamDrive(users):
  _infoTeamDrive(users, False)

# gam info teamdrive <TeamDriveEntity> [fields <TeamDriveFieldNameList>] [formatjson]
def doInfoTeamDrive():
  _infoTeamDrive([_getValueFromOAuth(u'email')], True)

TEAMDRIVE_ACL_ROLES_MAP = {
  u'commenter': u'commenter',
  u'editor': u'writer',
  u'organizer': u'organizer',
  u'owner': u'organizer',
  u'read': u'reader',
  u'reader': u'reader',
  u'writer': u'writer',
  }

TEAMDRIVE_ROLES_CAPABILITIES_MAP = {
  u'commenter': {u'canComment': True, u'canEdit': False},
  u'organizer': {u'canManageMembers': True},
  u'reader': {u'canCopy': True, u'canComment': False},
  u'writer': {u'canEdit': True, u'canManageMembers': False},
  }

def _printShowTeamDrives(users, csvFormat, useDomainAdminAccess):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'id', u'name'])
  roles = set()
  query = matchPattern = None
  showCapabilities = True
  fieldsList = []
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'teamdriveadminquery', u'query']:
      query = getString(Cmd.OB_QUERY, minLen=0) or None
    elif myarg == u'matchname':
      matchPattern = getREPattern(re.IGNORECASE)
    elif myarg == u'role':
      roles.add(getChoice(TEAMDRIVE_ACL_ROLES_MAP, mapChoice=True))
    elif myarg == u'checkgroups':
      pass
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    elif myarg == "formatjson":
      formatJSON = True
      if csvFormat:
        addTitlesToCSVfile(u'JSON', titles)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    elif getFieldsList(myarg, TEAMDRIVE_FIELDS_CHOICE_MAP, fieldsList, [u'id', u'name']):
      pass
    else:
      unknownArgumentExit()
  if fieldsList:
    if not useDomainAdminAccess and u'capabilities' not in fieldsList:
      addFieldToFieldsList(u'capabilities', TEAMDRIVE_FIELDS_CHOICE_MAP, fieldsList)
      showCapabilities = False
    fields = VX_NPT_TEAMDRIVES_FIELDLIST.format(u','.join(set(fieldsList)).replace(u'.', u'/'))
  else:
    fields = u'*'
  if csvFormat and not useDomainAdminAccess:
    addTitleToCSVfile(u'role', titles)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    try:
      if useDomainAdminAccess:
        printGettingAllAccountEntities(Ent.TEAMDRIVE, query)
      else:
        printGettingAllEntityItemsForWhom(Ent.TEAMDRIVE, user, i, count, query)
      feed = callGAPIpages(drive.teamdrives(), u'list', u'teamDrives',
                           throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.QUERY_REQUIRES_ADMIN_CREDENTIALS, GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                           page_message=getPageMessage(),
                           q=query, useDomainAdminAccess=useDomainAdminAccess,
                           fields=fields, pageSize=100)
    except (GAPI.invalidQuery, GAPI.invalid, GAPI.queryRequiresAdminCredentials, GAPI.noListTeamDrivesAdministratorPrivilege) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], str(e), i, count)
      continue
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      continue
    matchedFeed = collections.deque()
    if not useDomainAdminAccess:
      while feed:
        teamdrive = feed.popleft()
        if matchPattern is not None and matchPattern.match(teamdrive[u'name']) is None:
          continue
        for role, capabilities in iteritems(TEAMDRIVE_ROLES_CAPABILITIES_MAP):
          match = True
          for capability in capabilities:
            if capabilities[capability] != teamdrive[u'capabilities'][capability]:
              match = False
              break
          if match:
            break
        else:
          role = u'unknown'
        if not roles or role in roles:
          teamdrive[u'role'] = role
          matchedFeed.append(teamdrive)
    elif matchPattern is not None:
      while feed:
        teamdrive = feed.popleft()
        if matchPattern.match(teamdrive[u'name']) is not None:
          matchedFeed.append(teamdrive)
    else:
      matchedFeed = feed
    jcount = len(matchedFeed)
    if not csvFormat:
      if not formatJSON:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.TEAMDRIVE, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    else:
      if not csvFormat:
        Ind.Increment()
        j = 0
        for teamdrive in matchedFeed:
          j += 1
          if not showCapabilities:
            teamdrive.pop(u'capabilities', None)
          _showTeamDrive(user, teamdrive, j, jcount, formatJSON)
        Ind.Decrement()
      else:
        for teamdrive in matchedFeed:
          if not showCapabilities:
            teamdrive.pop(u'capabilities', None)
          if formatJSON:
            row = {u'User': user, u'id': teamdrive[u'id'], u'name': teamdrive[u'name']}
            if not useDomainAdminAccess:
              row[u'role'] = teamdrive[u'role']
            row[u'JSON'] = json.dumps(cleanJSON(teamdrive, u'', timeObjects=TEAMDRIVE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)
            csvRows.append(row)
          else:
            addRowTitlesToCSVfile(flattenJSON(teamdrive, flattened={u'User': user}, timeObjects=TEAMDRIVE_TIME_OBJECTS), csvRows, titles)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'TeamDrives', todrive, [u'User', u'id', u'name', u'role'], quotechar)

# gam <UserTypeEntity> print teamdrives [adminaccess|asadmin [teamdriveadminquery|query <QueryTeamDrive>]] [matchname <RegularExpression>] (role <TeamDriveACLRole>)* [todrive [<ToDriveAttributes>]]
#	[fields <TeamDriveFieldNameList>] [formatjson] [quotechar <Character>]
def printTeamDrives(users):
  _printShowTeamDrives(users, True, False)

# gam <UserTypeEntity> show teamdrives [adminaccess|asadmin [teamdriveadminquery|query <QueryTeamDrive>]] [matchname <RegularExpression>] (role <TeamDriveACLRole>)*
#	[fields <TeamDriveFieldNameList>] [formatjson] [quotechar <Character>]
def showTeamDrives(users):
  _printShowTeamDrives(users, False, False)

# gam print teamdrives [teamdriveadminquery|query <QueryTeamDrive>] [matchname <RegularExpression>] [todrive [<ToDriveAttributes>]]
#	[fields <TeamDriveFieldNameList>] [formatjson] [quotechar <Character>]
def doPrintTeamDrives():
  _printShowTeamDrives([_getValueFromOAuth(u'email')], True, True)

# gam show teamdrives [teamdriveadminquery|query <QueryTeamDrive>] [matchname <RegularExpression>]
#	[fields <TeamDriveFieldNameList>] [formatjson] [quotechar <Character>]
def doShowTeamDrives():
  _printShowTeamDrives([_getValueFromOAuth(u'email')], False, True)

def _printShowTeamDriveACLs(users, csvFormat, useDomainAdminAccess):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'id', u'name'])
  roles = set()
  checkGroups = oneItemPerRow = False
  query = matchPattern = permtype = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg in [u'teamdriveadminquery', u'query']:
      query = getString(Cmd.OB_QUERY, minLen=0) or None
    elif myarg == u'matchname':
      matchPattern = getREPattern(re.IGNORECASE)
    elif myarg in [u'user', u'group']:
      permtype = myarg
      emailAddress = getEmailAddress(noUid=True)
    elif myarg == u'role':
      roles.add(getChoice(TEAMDRIVE_ACL_ROLES_MAP, mapChoice=True))
    elif myarg == u'checkgroups':
      checkGroups = True
    elif csvFormat and myarg == u'oneitemperrow':
      oneItemPerRow = True
    elif myarg in [u'adminaccess', u'asadmin']:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  if checkGroups:
    cd = buildGAPIObject(API.DIRECTORY)
    groups = callGAPIpages(cd.groups(), u'list', u'groups',
                           userKey=emailAddress, fields=u'nextPageToken,groups(email)')
    groupsSet = set([group['email'] for group in groups])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    feed = None
    if permtype == u'user':
      _, userdrive = buildGAPIServiceObject(API.DRIVE3, emailAddress, 0, 0, False)
      if userdrive is not None:
        try:
          feed = callGAPIpages(userdrive.teamdrives(), u'list', u'teamDrives',
                               throw_reasons=GAPI.DRIVE_USER_THROW_REASONS,
                               fields=u'nextPageToken,teamDrives(id,name)', pageSize=100)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          pass
    if feed is None:
      try:
        if useDomainAdminAccess:
          printGettingAllAccountEntities(Ent.TEAMDRIVE, query)
        else:
          printGettingAllEntityItemsForWhom(Ent.TEAMDRIVE, user, i, count, query)
        feed = callGAPIpages(drive.teamdrives(), u'list', u'teamDrives',
                             throw_reasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.QUERY_REQUIRES_ADMIN_CREDENTIALS, GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                             page_message=getPageMessage(),
                             q=query, useDomainAdminAccess=useDomainAdminAccess,
                             fields=u'nextPageToken,teamDrives(id,name)', pageSize=100)
      except (GAPI.invalidQuery, GAPI.invalid, GAPI.queryRequiresAdminCredentials, GAPI.noListTeamDrivesAdministratorPrivilege) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], str(e), i, count)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
    matchFeed = collections.deque()
    jcount = len(feed)
    j = 0
    while feed:
      j += 1
      teamdrive = feed.popleft()
      printGettingAllEntityItemsForWhom(Ent.PERMISSION, teamdrive[u'name'], j, jcount)
      if matchPattern is not None and matchPattern.match(teamdrive[u'name']) is None:
        continue
      teamdrive[u'permissions'] = []
      try:
        results = callGAPIpages(drive.permissions(), u'list', VX_PAGES_PERMISSIONS,
                                throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                useDomainAdminAccess=useDomainAdminAccess,
                                fileId=teamdrive[u'id'], fields=VX_NPT_PERMISSIONS, supportsTeamDrives=True)
        for permission in results:
          if roles and permission[u'role'] not in roles:
            continue
          if permtype is None:
            teamdrive[u'permissions'].append(permission)
          elif permission[u'type'] == permtype and permission[u'emailAddress'] == emailAddress:
            teamdrive[u'permissions'].append(permission)
          elif checkGroups and permission[u'emailAddress'] in groupsSet:
            teamdrive[u'permissions'].append(permission)
        if teamdrive[u'permissions']:
          matchFeed.append(teamdrive)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
        pass
    jcount = len(matchFeed)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    if not csvFormat:
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.TEAMDRIVE, i, count)
      Ind.Increment()
      j = 0
      while matchFeed:
        j += 1
        teamdrive = matchFeed.popleft()
        kcount = len(teamdrive[u'permissions'])
        entityPerformActionNumItems([Ent.TEAMDRIVE, u'{0} ({1})'.format(teamdrive[u'name'], teamdrive[u'id'])], kcount, Ent.PERMITTEE, j, jcount)
        Ind.Increment()
        k = 0
        for permission in teamdrive[u'permissions']:
          k += 1
          _showDriveFilePermission(permission, printKeys, timeObjects, k, kcount)
        Ind.Decrement()
      Ind.Decrement()
    elif matchFeed:
      if oneItemPerRow:
        for teamdrive in matchFeed:
          for permission in teamdrive[u'permissions']:
            row = {u'User': user, u'id': teamdrive[u'id'], u'name': teamdrive[u'name']}
            _mapDrivePermissionNames(permission)
            addRowTitlesToCSVfile(flattenJSON({u'permission': permission}, flattened=row, timeObjects=timeObjects), csvRows, titles)
      else:
        for teamdrive in matchFeed:
          for permission in teamdrive[u'permissions']:
            _mapDrivePermissionNames(permission)
          addRowTitlesToCSVfile(flattenJSON({u'permissions': teamdrive[u'permissions']}, flattened={u'User': user, u'id': teamdrive[u'id'], u'name': teamdrive[u'name']}, timeObjects=timeObjects), csvRows, titles)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'TeamDrive ACLs', todrive, [u'User', u'id', u'name'])

# gam <UserTypeEntity> print teamdriveacls [adminaccess|asadmin [teamdriveadminquery|query <QueryTeamDrive>]] [matchname <RegularExpression>] [(user <UserItem>)|(group <GroupItem>) [checkgroups]] (role <TeamDriveACLRole>)* [oneitemperrow] [todrive [<ToDriveAttributes>]]
def printTeamDriveACLs(users):
  _printShowTeamDriveACLs(users, True, False)

# gam <UserTypeEntity> show teamdriveacls [adminaccess|asadmin [teamdriveadminquery|query <QueryTeamDrive>]] [matchname <RegularExpression>] [(user <UserItem>)|(group <GroupItem>) [checkgroups]] (role <TeamDriveACLRole>)* [oneitemperrow]
def showTeamDriveACLs(users):
  _printShowTeamDriveACLs(users, False, False)

# gam print teamdriveacls [teamdriveadminquery|query <QueryTeamDrive>] [matchname <RegularExpression>] [(user <UserItem>)|(group <GroupItem>) [checkgroups]] (role <TeamDriveACLRole>)* [oneitemperrow] [todrive [<ToDriveAttributes>]]
def doPrintTeamDriveACLs():
  _printShowTeamDriveACLs([_getValueFromOAuth(u'email')], True, True)

# gam show teamdriveacls [teamdriveadminquery|query <QueryTeamDrive>] [matchname <RegularExpression>] [(user <UserItem>)|(group <GroupItem>) [checkgroups]] (role <TeamDriveACLRole>)* [oneitemperrow]
def doShowTeamDriveACLs():
  _printShowTeamDriveACLs([_getValueFromOAuth(u'email')], False, True)

# gam <UserTypeEntity> delete alias|aliases
def deleteUsersAliases(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      user_aliases = callGAPI(cd.users(), u'get',
                              throw_reasons=GAPI.USER_GET_THROW_REASONS,
                              userKey=user, fields=u'id,primaryEmail,aliases')
      user_id = user_aliases[u'id']
      user_primary = user_aliases[u'primaryEmail']
      jcount = len(user_aliases[u'aliases']) if (u'aliases' in user_aliases) else 0
      entityPerformActionNumItems([Ent.USER, user_primary], jcount, Ent.ALIAS, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      Ind.Increment()
      j = 0
      for an_alias in user_aliases[u'aliases']:
        j += 1
        try:
          callGAPI(cd.users().aliases(), u'delete',
                   throw_reasons=[GAPI.RESOURCE_ID_NOT_FOUND],
                   userKey=user_id, alias=an_alias)
          entityActionPerformed([Ent.USER, user_primary, Ent.ALIAS, an_alias], j, jcount)
        except GAPI.resourceIdNotFound:
          entityActionFailedWarning([Ent.USER, user_primary, Ent.ALIAS, an_alias], Msg.DOES_NOT_EXIST, j, jcount)
      Ind.Decrement()
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> add group|groups [member|manager|owner] <GroupEntity>
def addUserToGroups(users):

  _ADD_USER_REASON_TO_MESSAGE_MAP = {GAPI.DUPLICATE: Msg.DUPLICATE,
                                     GAPI.MEMBER_NOT_FOUND: Msg.DOES_NOT_EXIST,
                                     GAPI.INVALID_MEMBER: Msg.INVALID_MEMBER}

  def _handleDuplicateAdd(group, i, count, role, member, j, jcount):
    try:
      result = callGAPI(cd.members(), u'get',
                        throw_reasons=[GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
                        groupKey=group, memberKey=member, fields=u'role')
      entityActionFailedWarning([Ent.GROUP, group, role, member], Msg.DUPLICATE_ALREADY_A_ROLE.format(Ent.Singular(result[u'role'])), j, jcount)
      return
    except (GAPI.memberNotFound, GAPI.resourceNotFound):
      pass
    printEntityKVList([Ent.GROUP, group, role, member], [Msg.MEMBERSHIP_IS_PENDING_WILL_DELETE_ADD_TO_ACCEPT], j, jcount)
    try:
      callGAPI(cd.members(), u'delete',
               throw_reasons=[GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               groupKey=group, memberKey=member)
    except (GAPI.memberNotFound, GAPI.resourceNotFound):
      entityActionFailedWarning([Ent.GROUP, group, role, member], Msg.DUPLICATE, j, jcount)
      return
    body = {u'role': role, u'email': member}
    try:
      callGAPI(cd.members(), u'insert',
               throw_reasons=[GAPI.DUPLICATE, GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND, GAPI.INVALID_MEMBER, GAPI.CYCLIC_MEMBERSHIPS_NOT_ALLOWED],
               groupKey=group, body=body, fields=u'')
      entityActionPerformed([Ent.GROUP, group, role, member], j, jcount)
    except (GAPI.duplicate, GAPI.memberNotFound, GAPI.resourceNotFound, GAPI.invalidMember, GAPI.cyclicMembershipsNotAllowed) as e:
      http_status, reason, message = checkGAPIError(e)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, group, i, count)
      else:
        errMsg = getHTTPError(_ADD_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, group, role, member], errMsg, j, jcount)

  def _callbackAddUserToGroups(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      elif reason == GAPI.DUPLICATE:
        _handleDuplicateAdd(ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]), ri[RI_ROLE], ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_ADD_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchAddUserToGroups(user, i, count, groupKeys, body):
    Act.Set(Act.ADD)
    role = body[u'role']
    jcount = len(groupKeys)
    entityPerformActionModifierNumItemsModifier([Ent.USER, user], Act.MODIFIER_TO, jcount, Ent.GROUP,
                                                u'{0} {1}'.format(Msg.AS, Ent.Singular(body[u'role'])), i, count)
    Ind.Increment()
    svcargs = dict([(u'groupKey', None), (u'body', body), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.members(), u'insert')
    dbatch = cd.new_batch_http_request(callback=_callbackAddUserToGroups)
    bcount = 0
    j = 0
    for group in groupKeys:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = normalizeEmailAddressOrUID(group)
      dbatch.add(method(**svcparms), request_id=batchRequestID(svcparms[u'groupKey'], 0, 0, j, jcount, user, role))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackAddUserToGroups)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  role = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
  groupKeys = getEntityList(Cmd.OB_GROUP_ENTITY)
  userGroupLists = groupKeys if isinstance(groupKeys, dict) else None
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if userGroupLists:
      groupKeys = userGroupLists[user]
    user = checkUserExists(cd, user, i, count)
    if user:
      _batchAddUserToGroups(user, i, count, groupKeys, {u'role': role, u'email': user})

# gam <UserTypeEntity> delete group|groups [<GroupEntity>]
def deleteUserFromGroups(users):

  _DELETE_USER_REASON_TO_MESSAGE_MAP = {GAPI.MEMBER_NOT_FOUND: u'{0} {1}'.format(Msg.NOT_A, Ent.Singular(Ent.MEMBER)),
                                        GAPI.INVALID_MEMBER: Msg.DOES_NOT_EXIST}

  def _callbackDeleteUserFromGroups(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_DELETE_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchDeleteUserFromGroups(user, i, count, groupKeys):
    Act.Set(Act.REMOVE)
    role = Ent.MEMBER
    jcount = len(groupKeys)
    entityPerformActionModifierNumItems([Ent.USER, user], Act.MODIFIER_FROM, jcount, Ent.GROUP, i, count)
    Ind.Increment()
    svcargs = dict([(u'groupKey', None), (u'memberKey', user), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.members(), u'delete')
    dbatch = cd.new_batch_http_request(callback=_callbackDeleteUserFromGroups)
    bcount = 0
    j = 0
    for group in groupKeys:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'groupKey'] = normalizeEmailAddressOrUID(group)
      dbatch.add(method(**svcparms), request_id=batchRequestID(svcparms[u'groupKey'], 0, 0, j, jcount, user, role))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackDeleteUserFromGroups)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  if Cmd.ArgumentsRemaining():
    groupKeys = getEntityList(Cmd.OB_GROUP_ENTITY)
    userGroupLists = groupKeys if isinstance(groupKeys, dict) else None
    checkForExtraneousArguments()
  else:
    groupKeys = None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if groupKeys is None:
      user = checkUserExists(cd, user, i, count)
      if user:
        result = callGAPIpages(cd.groups(), u'list', u'groups',
                               userKey=user, fields=u'nextPageToken,groups(email)')
        userGroupKeys = [item[u'email'] for item in result]
        _batchDeleteUserFromGroups(user, i, count, userGroupKeys)
    else:
      if userGroupLists:
        userGroupKeys = userGroupLists[user]
      else:
        userGroupKeys = groupKeys
      user = checkUserExists(cd, user, i, count)
      if user:
        _batchDeleteUserFromGroups(user, i, count, userGroupKeys)

# License command utilities
LICENSE_SKUID = u'skuId'
LICENSE_PRODUCTID = u'productId'
LICENSE_OLDSKUID = u'oldSkuId'

def getLicenseParameters(operation):
  lic = buildGAPIObject(API.LICENSING)
  parameters = {}
  parameters[LICENSE_PRODUCTID], parameters[LICENSE_SKUID] = getGoogleSKU()
  if checkArgumentPresent([u'product', u'productid']):
    parameters[LICENSE_PRODUCTID] = getGoogleProduct()
  if operation == u'patch':
    checkArgumentPresent(u'from')
    oldProductId, parameters[LICENSE_OLDSKUID] = getGoogleSKU()
    if parameters[LICENSE_PRODUCTID] != oldProductId:
      Cmd.Backup()
      usageErrorExit(Msg.SKU_PRODUCT_MISMATCH).format(oldProductId, parameters[LICENSE_PRODUCTID])
  checkForExtraneousArguments()
  return (lic, parameters)

# gam <UserTypeEntity> create|add license <SKUID>
def createLicense(users):
  lic, parameters = getLicenseParameters(u'insert')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), u'insert',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BACKEND_ERROR, GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_SKUID], body={u'userId': user}, fields=u'')
      entityActionPerformed([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], i, count)
    except (GAPI.conditionNotMet, GAPI.duplicate) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden, GAPI.backendError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> update license <SKUID> [from] <SKUID>
def updateLicense(users):
  lic, parameters = getLicenseParameters(u'patch')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), u'patch',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.NOT_FOUND, GAPI.BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_OLDSKUID], userId=user, body={u'skuId': parameters[LICENSE_SKUID]}, fields=u'')
      entityModifierNewValueActionPerformed([Ent.USER, user, Ent.LICENSE, SKU.skuIdToDisplayName(parameters[LICENSE_SKUID])],
                                            Act.MODIFIER_FROM, SKU.skuIdToDisplayName(parameters[LICENSE_OLDSKUID]), i, count)
    except GAPI.notFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_OLDSKUID])], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden, GAPI.backendError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete license <SKUID>
def deleteLicense(users):
  lic, parameters = getLicenseParameters(u'delete')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), u'delete',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.NOT_FOUND, GAPI.BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_SKUID], userId=user)
      entityActionPerformed([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], i, count)
    except GAPI.notFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden, GAPI.backendError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> update photo [<FileNamePattern>]
# gam <UserTypeEntity> update photo [drivedir|(sourcefolder <FilePath>)] [filename <FileNamePattern>]
#	#  #user# and #email" will be replaced with user email address #username# will be replaced by portion of email address in front of @
def updatePhoto(users):
  cd = buildGAPIObject(API.DIRECTORY)
  if Cmd.NumArgumentsRemaining() == 1 and not peekArgumentPresent([u'drivedir', u'sourcefolder', u'filename']):
    sourceFolder = None
    filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
  else:
    sourceFolder = os.getcwd()
    filenamePattern = u'#email#.jpg'
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'drivedir':
        sourceFolder = GC.Values[GC.DRIVE_DIR]
      elif myarg == u'sourcefolder':
        sourceFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
        if not os.path.isdir(sourceFolder):
          entityDoesNotExistExit(Ent.DIRECTORY, sourceFolder)
      elif myarg == u'filename':
        filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
      else:
        unknownArgumentExit()
  p = re.compile(u'^(ht|f)tps?://.*$')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, _ = splitEmailAddressOrUID(user)
    filename = _substituteForUser(filenamePattern, user, userName)
    if p.match(filename):
      try:
        status, image_data = getHttpObj().request(filename, u'GET')
        if status[u'status'] != u'200':
          entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], Msg.NOT_ALLOWED, i, count)
          continue
        if status[u'content-location'] != filename:
          entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], Msg.NOT_FOUND, i, count)
          continue
      except (httplib2.HttpLib2Error, httplib2.ServerNotFoundError,
              google.auth.exceptions.TransportError, httplib2.CertificateValidationUnsupportedInPython31) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
        continue
    else:
      if sourceFolder is not None:
        filename = os.path.join(sourceFolder, filename)
      try:
        with open(os.path.expanduser(filename), u'rb') as f:
          image_data = f.read()
      except (OSError, IOError) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
        continue
    body = {u'photoData': base64.urlsafe_b64encode(image_data)}
    try:
      callGAPI(cd.users().photos(), u'update',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID_INPUT],
               userKey=user, body=body, fields=u'')
      entityActionPerformed([Ent.USER, user, Ent.PHOTO, filename], i, count)
    except GAPI.invalidInput as e:
      entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete photo
def deletePhoto(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.users().photos(), u'delete',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.PHOTO_NOT_FOUND],
               userKey=user)
      entityActionPerformed([Ent.USER, user, Ent.PHOTO, u''], i, count)
    except GAPI.photoNotFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, u''], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> get photo [drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>] [noshow]
def getPhoto(users):
  cd = buildGAPIObject(API.DIRECTORY)
  targetFolder = os.getcwd()
  filenamePattern = u'#email#.jpg'
  showPhotoData = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'drivedir':
      targetFolder = GC.Values[GC.DRIVE_DIR]
    elif myarg == u'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    elif myarg == u'filename':
      filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
    elif myarg == u'noshow':
      showPhotoData = False
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    _, userName, _ = splitEmailAddressOrUID(user)
    filename = os.path.join(targetFolder, _substituteForUser(filenamePattern, user, userName))
    try:
      entityPerformActionNumItems([Ent.USER, user], 1, Ent.PHOTO, i, count)
      photo = callGAPI(cd.users().photos(), u'get',
                       throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.PHOTO_NOT_FOUND],
                       userKey=user)
      photo_data = str(photo[u'photoData'])
      if showPhotoData:
        writeStdout(photo_data+'\n')
      status, e = writeFileReturnError(filename, base64.urlsafe_b64decode(photo_data))
      if status:
        entityActionPerformed([Ent.USER, user, Ent.PHOTO, filename], i, count)
      else:
        entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
    except GAPI.photoNotFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, None], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

PROFILE_SHARING_CHOICE_MAP = {
  u'share': True,
  u'shared': True,
  u'unshare': False,
  u'unshared': False,
  }

def _setShowProfile(users, function, **kwargs):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      result = callGAPI(cd.users(), function,
                        throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN],
                        userKey=user, fields=u'includeInGlobalAddressList', **kwargs)
      printEntity([Ent.USER, user, Ent.PROFILE_SHARING_ENABLED, result.get(u'includeInGlobalAddressList', u'Unknown')], i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> profile share|shared|unshare|unshared
def setProfile(users):
  body = {u'includeInGlobalAddressList': getChoice(PROFILE_SHARING_CHOICE_MAP, mapChoice=True)}
  _setShowProfile(users, u'update', body=body)

# gam <UserTypeEntity> show profile
def showProfile(users):
  _setShowProfile(users, u'get')

# gam <UserTypeEntity> create sheet json <SpreadsheetJSONCreateRequest> [formatjson]
#	[parentid <DriveFolderID>] | [parentname <DriveFolderName>] | [anyownerparentname <DriveFolderName>]
#	[teamdriveparentid <DriveFolderID>] [teamdriveparent <TeamDriveName>] [teamdriveparentname <DriveFolderName>]
def createSheet(users):
  parameters = initializeDriveFileAttributes()
  parentBody = {}
  changeParents = False
  addParents = u''
  removeParents = u'root'
  body = {}
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'json':
      spreadsheetJSON = getString(Cmd.OB_SPREADSHEET_JSON_CREATEREQUEST)
      try:
        body = json.loads(spreadsheetJSON)
      except (ValueError, IndexError, KeyError, SyntaxError) as e:
        Cmd.Backup()
        usageErrorExit(u'{0}: {1}'.format(str(e), spreadsheetJSON))
    elif myarg == "formatjson":
      formatJSON = True
    elif getDriveFileParentAttribute(myarg, parameters):
      changeParents = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet = buildGAPIServiceObject(API.SHEETS, user, i, count)
    if not sheet:
      continue
    if changeParents:
      user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
      if not drive:
        continue
      if not _getDriveFileParentInfo(user, i, count, parentBody, parameters, drive):
        continue
      addParents = u','.join(parentBody[u'parents'])
    try:
      result = callGAPI(sheet.spreadsheets(), u'create',
                        throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                        body=body)
      spreadsheetId = result[u'spreadsheetId']
      if not formatJSON:
        entityActionPerformed([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], i, count)
      parentId = u'root'
      parentMsg = u'Success'
      if changeParents:
        try:
          callGAPI(drive.files(), u'update',
                   throw_reasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                   fileId=result[u'spreadsheetId'], addParents=addParents, removeParents=removeParents, fields=u'', supportsTeamDrives=True)
          parentId = addParents
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions) as e:
          parentMsg = u'{0}{1}: {2}'.format(ERROR_PREFIX, addParents, str(e))
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          parentMsg = u'{0}{1}: {2}'.format(ERROR_PREFIX, addParents, str(e))
      if formatJSON:
        printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "parentId": "{2}", "parentAssignment": "{3}", "JSON": {4}}}'.format(user, spreadsheetId, parentId, parentMsg, json.dumps(result, ensure_ascii=False, sort_keys=False)))
        continue
      Ind.Increment()
      for field in [u'spreadsheetId', u'spreadsheetUrl']:
        printKeyValueList([field, result[field]])
      printKeyValueList([u'parentId', parentId])
      printKeyValueList([u'parentAssignment', parentMsg])
      for field in [u'properties', u'sheets', u'namedRanges', u'developerMetadata']:
        if field in result:
          showJSON(field, result[field])
      Ind.Decrement()
    except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, u''], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

def _validateUserGetSpreadsheetIDs(user, i, count, fileIdEntity, showEntityType):
  user, _, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.SPREADSHEET if showEntityType else None)
  if jcount == 0:
    return (user, None, 0)
  user, sheet = buildGAPIServiceObject(API.SHEETS, user, i, count)
  if not sheet:
    return (user, None, 0)
  return (user, sheet, jcount)

# gam <UserTypeEntity> update sheet <DriveFileEntity> json <SpreadsheetJSONUpdateRequest> [formatjson]
def updateSheets(users):
  spreadsheetIdEntity = getDriveFileEntity()
  body = {}
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'json':
      spreadsheetJSON = getString(Cmd.OB_SPREADSHEET_JSON_UPDATEREQUEST)
      try:
        body = json.loads(spreadsheetJSON)
      except (ValueError, IndexError, KeyError, SyntaxError) as e:
        Cmd.Backup()
        usageErrorExit(u'{0}: {1}'.format(str(e), spreadsheetJSON))
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(sheet.spreadsheets(), u'batchUpdate',
                          throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, body=body)
        if formatJSON:
          printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "JSON": {2}}}'.format(user, spreadsheetId, json.dumps(result, ensure_ascii=False, sort_keys=False)))
          continue
        entityActionPerformed([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], j, jcount)
        Ind.Increment()
        for field in [u'replies', u'updatedSpreadsheet']:
          if field in result:
            showJSON(field, result[field])
        Ind.Decrement()
      except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> info sheet <DriveFileEntity> (range <String>)* [includegriddata [<Boolean>]] [formatjson]
def infoSheets(users):
  spreadsheetIdEntity = getDriveFileEntity()
  ranges = []
  includeGridData = False
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'range':
      ranges.append(getString(Cmd.OB_SPREADSHEET_RANGE))
    elif myarg == u'includegriddata':
      includeGridData = getBoolean()
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity[u'list']:
      j += 1
      try:
        result = callGAPI(sheet.spreadsheets(), u'get',
                          throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, ranges=ranges, includeGridData=includeGridData)
        if formatJSON:
          printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "JSON": {2}}}'.format(user, spreadsheetId, json.dumps(result, ensure_ascii=False, sort_keys=False)))
          continue
        printEntity([Ent.SPREADSHEET, spreadsheetId], j, jcount)
        Ind.Increment()
        printKeyValueList([u'spreadsheetUrl', result[u'spreadsheetUrl']])
        for field in [u'properties', u'sheets', u'namedRanges', u'developerMetadata']:
          if field in result:
            showJSON(field, result[field])
        Ind.Decrement()
      except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

SHEET_VALUE_INPUT_OPTIONS_MAP = {
  u'raw': u'RAW',
  u'userentered': u'USER_ENTERED',
  }
SHEET_DIMENSIONS_MAP = {
  u'rows': u'ROWS',
  u'columns': u'COLUMNS',
  }
SHEET_VALUE_RENDER_OPTIONS_MAP = {
  u'formula': u'FORMULA',
  u'formattedvalue': u'FORMATTED_VALUE',
  u'unformattedvalue': u'UNFORMATTED_VALUE',
  }
SHEET_DATETIME_RENDER_OPTIONS_MAP = {
  u'serialnumber': u'SERIAL_NUMBER',
  u'formattedstring': u'FORMATTED_STRING',
  }
SHEET_INSERT_DATA_OPTIONS_MAP = {
  u'overwrite': u'OVERWRITE',
  u'insertrows': u'INSERT_ROWS',
  }

def _getSpreadsheetRangesValues(append):
  spreadsheetRangesValues = []
  kwargs = {
    u'valueInputOption': u'USER_ENTERED',
    u'includeValuesInResponse': False,
    u'responseValueRenderOption': u'FORMATTED_VALUE',
    u'responseDateTimeRenderOption': u'FORMATTED_STRING',
    }
  if append:
    kwargs[u'insertDataOption'] = u'INSERT_ROWS'
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'json':
      if append and spreadsheetRangesValues:
        usageErrorExit(Msg.ONLY_ONE_JSON_RANGE_ALLOWED)
      spreadsheetJSON = getString(Cmd.OB_SPREADSHEET_JSON_RANGEVALUESLIST)
      try:
        spreadsheetRangeValue = json.loads(spreadsheetJSON)
        if isinstance(spreadsheetRangeValue, list):
          spreadsheetRangesValues.extend(spreadsheetRangeValue)
        else:
          spreadsheetRangesValues.append(spreadsheetRangeValue)
        if append and len(spreadsheetRangesValues) > 1:
          Cmd.Backup()
          usageErrorExit(Msg.ONLY_ONE_JSON_RANGE_ALLOWED)
      except (ValueError, IndexError, KeyError, SyntaxError) as e:
        Cmd.Backup()
        usageErrorExit(u'{0}: {1}'.format(str(e), spreadsheetJSON))
    elif myarg in SHEET_VALUE_INPUT_OPTIONS_MAP:
      kwargs[u'valueInputOption'] = SHEET_VALUE_INPUT_OPTIONS_MAP[myarg]
    elif myarg == u'includevaluesinresponse':
      kwargs[u'includeValuesInResponse'] = getBoolean()
    elif myarg in SHEET_VALUE_RENDER_OPTIONS_MAP:
      kwargs[u'responseValueRenderOption'] = SHEET_VALUE_RENDER_OPTIONS_MAP[myarg]
    elif myarg in SHEET_DATETIME_RENDER_OPTIONS_MAP:
      kwargs[u'responseDateTimeRenderOption'] = SHEET_DATETIME_RENDER_OPTIONS_MAP[myarg]
    elif append and myarg in SHEET_INSERT_DATA_OPTIONS_MAP:
      kwargs[u'insertDataOption'] = SHEET_INSERT_DATA_OPTIONS_MAP[myarg]
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  return (kwargs, spreadsheetRangesValues, formatJSON)

def _showValueRange(valueRange):
  Ind.Increment()
  printKeyValueList([u'majorDimension', valueRange[u'majorDimension']])
  printKeyValueList([u'range', valueRange[u'range']])
  printKeyValueList([u'value', u'{{"values": {0}}}'.format(json.dumps(valueRange.get(u'values', []), ensure_ascii=False, sort_keys=False))])
  Ind.Decrement()

def _showUpdateValuesResponse(result, k, kcount):
  printKeyValueListWithCount([u'updatedRange', result[u'updatedRange']], k, kcount)
  Ind.Increment()
  for field in [u'updatedRows', u'updatedColumns', u'updatedCells']:
    printKeyValueList([field, result[field]])
  if u'updatedData' in result:
    printKeyValueList([u'updatedData', u''])
    _showValueRange(result[u'updatedData'])
  Ind.Decrement()

# gam <UserTypeEntity> append sheetrange <DriveFileEntity> json <SpreadsheetJSONRangeValuesList> [overwrite|insertrows]
#	[raw|userentered] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[includevaluesinresponse [<Boolean>]] [formatjson]
def appendSheetRanges(users):
  spreadsheetIdEntity = getDriveFileEntity()
  kwargs, spreadsheetRangesValues, formatJSON = _getSpreadsheetRangesValues(True)
  kcount = len(spreadsheetRangesValues)
  body = spreadsheetRangesValues[0] if kcount > 0 else {}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity[u'list']:
      j += 1
      if not formatJSON:
        entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
      Ind.Increment()
      k = 1
      try:
        result = callGAPI(sheet.spreadsheets().values(), u'append',
                          throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, range=body[u'range'], body=body, **kwargs)
        if formatJSON:
          printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "JSON": {2}}}'.format(user, spreadsheetId, json.dumps(result, ensure_ascii=False, sort_keys=False)))
          continue
        for field in [u'tableRange',]:
          printKeyValueList([field, result[field]])
        _showUpdateValuesResponse(result[u'updates'], k, kcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> update sheetrange <DriveFileEntity> (json <SpreadsheetJSONRangeValuesList>)+
#	[raw|userentered] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[includevaluesinresponse [<Boolean>]] [formatjson]
def updateSheetRanges(users):
  spreadsheetIdEntity = getDriveFileEntity()
  body, spreadsheetRangesValues, formatJSON = _getSpreadsheetRangesValues(False)
  body[u'data'] = spreadsheetRangesValues
  kcount = len(spreadsheetRangesValues)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity[u'list']:
      j += 1
      if not formatJSON:
        entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
      Ind.Increment()
      try:
        result = callGAPI(sheet.spreadsheets().values(), u'batchUpdate',
                          throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, body=body)
        if formatJSON:
          printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "JSON": {2}}}'.format(user, spreadsheetId, json.dumps(result, ensure_ascii=False, sort_keys=False)))
          continue
        for field in [u'totalUpdatedRows', u'totalUpdatedColumns', u'totalUpdatedCells', u'totalUpdatedSheets']:
          printKeyValueList([field, result[field]])
        k = 0
        for response in result.get(u'responses', []):
          k += 1
          _showUpdateValuesResponse(response, k, kcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> clear sheetrange <DriveFileEntity> (range <SpreadsheetRange>)* [formatjson]
def clearSheetRanges(users):
  spreadsheetIdEntity = getDriveFileEntity()
  body = {u'ranges': []}
  formatJSON = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'range':
      body[u'ranges'].append(getString(Cmd.OB_SPREADSHEET_RANGE))
    elif myarg == "formatjson":
      formatJSON = True
    else:
      unknownArgumentExit()
  kcount = len(body[u'ranges'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity[u'list']:
      j += 1
      if not formatJSON:
        entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
      Ind.Increment()
      try:
        result = callGAPIitems(sheet.spreadsheets().values(), u'batchClear', u'clearedRanges',
                               throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                               spreadsheetId=spreadsheetId, body=body)
        if formatJSON:
          printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "JSON": {2}}}'.format(user, spreadsheetId, json.dumps({u'clearedRanges': result}, ensure_ascii=False, sort_keys=False)))
          continue
        k = 0
        for clearedRange in result:
          k += 1
          printKeyValueListWithCount([u'range', clearedRange], k, kcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      Ind.Decrement()
    Ind.Decrement()

PRINT_SHEETS_TITLES = [u'User', u'spreadsheetId', u'range', u'majorDimension', u'values']
PRINT_SHEETS_JSON_TITLES = [u'User', u'spreadsheetId', u'JSON']

def _printShowSheetRanges(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(PRINT_SHEETS_TITLES)
  spreadsheetIdEntity = getDriveFileEntity()
  spreadsheetRanges = []
  kwargs = {
    u'majorDimension': u'ROWS',
    u'valueRenderOption': u'FORMATTED_VALUE',
    u'dateTimeRenderOption': u'FORMATTED_STRING',
    }
  formatJSON = False
  quotechar = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'range':
      spreadsheetRanges.append(getString(Cmd.OB_SPREADSHEET_RANGE))
    elif myarg in SHEET_DIMENSIONS_MAP:
      kwargs[u'majorDimension'] = SHEET_DIMENSIONS_MAP[myarg]
    elif myarg in SHEET_VALUE_RENDER_OPTIONS_MAP:
      kwargs[u'valueRenderOption'] = SHEET_VALUE_RENDER_OPTIONS_MAP[myarg]
    elif myarg in SHEET_DATETIME_RENDER_OPTIONS_MAP:
      kwargs[u'dateTimeRenderOption'] = SHEET_DATETIME_RENDER_OPTIONS_MAP[myarg]
    elif myarg == "formatjson":
      formatJSON = True
      if csvFormat:
        titles, csvRows = initializeTitlesCSVfile(PRINT_SHEETS_JSON_TITLES)
    elif myarg == u'quotechar':
      quotechar = getCharacter()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not csvFormat and not formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity[u'list']:
      j += 1
      try:
        result = callGAPIitems(sheet.spreadsheets().values(), u'batchGet', u'valueRanges',
                               throw_reasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                               spreadsheetId=spreadsheetId, ranges=spreadsheetRanges, **kwargs)
        kcount = len(result)
        if not csvFormat:
          if formatJSON:
            printLine(u'{{"User": "{0}", "spreadsheetId": "{1}", "JSON": {2}}}'.format(user, spreadsheetId, json.dumps(result, ensure_ascii=False, sort_keys=False)))
            continue
          entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
          Ind.Increment()
          k = 0
          for valueRange in result:
            k += 1
            printKeyValueListWithCount([u'range', valueRange[u'range']], k, kcount)
            _showValueRange(valueRange)
          Ind.Decrement()
        else:
          if result:
            if formatJSON:
              csvRows.append({u'User': user, u'spreadsheetId': spreadsheetId, u'JSON': json.dumps(result, ensure_ascii=False, sort_keys=False)})
            else:
              addRowTitlesToCSVfile(flattenJSON(result, flattened={u'User': user, u'spreadsheetId': spreadsheetId}), csvRows, titles)
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
            csvRows.append({u'User': user})
      except (GAPI.notFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvFormat:
    if formatJSON:
      writeCSVfile(csvRows, titles, u'Spreadsheet', todrive, PRINT_SHEETS_JSON_TITLES, quotechar)
    else:
      writeCSVfile(csvRows, titles, u'Spreadsheet', todrive, PRINT_SHEETS_TITLES, quotechar)

# gam <UserTypeEntity> print sheetrange <DriveFileEntity> (range <SpreadsheetRange>)*  [todrive [<ToDriveAttributes>]]
#	[rows|columns] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[formatjson]
def printSheetRanges(users):
  _printShowSheetRanges(users, True)

# gam <UserTypeEntity> show sheetrange <DriveFileEntity> (range <SpreadsheetRange>)*
#	[rows|columns] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[formatjson]
def showSheetRanges(users):
  _printShowSheetRanges(users, False)

# Token commands utilities
def commonClientIds(clientId):
  if clientId == u'gasmo':
    return u'1095133494869.apps.googleusercontent.com'
  return clientId

# gam <UserTypeEntity> delete token|tokens|3lo|oauth clientid <ClientID>
def deleteTokens(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkArgumentPresent(u'clientid', required=True)
  clientId = commonClientIds(getString(Cmd.OB_CLIENT_ID))
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.tokens(), u'get',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN, GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               userKey=user, clientId=clientId, fields=u'')
      callGAPI(cd.tokens(), u'delete',
               throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN, GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               userKey=user, clientId=clientId)
      entityActionPerformed([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], i, count)
    except (GAPI.notFound, GAPI.resourceNotFound) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], str(e), i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

def _printShowTokens(entityType, users, csvFormat):
  def _showToken(token, j, jcount):
    printKeyValueListWithCount([u'Client ID', token[u'clientId']], j, jcount)
    Ind.Increment()
    for item in sorted(token):
      if item not in [u'clientId', u'scopes']:
        printKeyValueList([item, token.get(item, u'')])
    item = u'scopes'
    printKeyValueList([item, None])
    Ind.Increment()
    for it in sorted(token.get(item, [])):
      printKeyValueList([it])
    Ind.Decrement()
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'user', u'clientId', u'displayText', u'anonymous', u'nativeApp', u'userKey', u'scopes'])
  clientId = None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'clientid':
      clientId = commonClientIds(getString(Cmd.OB_CLIENT_ID))
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif not entityType:
      Cmd.Backup()
      entityType, users = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    else:
      unknownArgumentExit()
  if not entityType:
    users = getUsersToModify(Cmd.ENTITY_ALL_USERS, None)
  fields = u','.join([u'clientId', u'displayText', u'anonymous', u'nativeApp', u'userKey', u'scopes'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      if csvFormat:
        printGettingEntityItemForWhom(Ent.ACCESS_TOKEN, user, i, count)
      if clientId:
        results = [callGAPI(cd.tokens(), u'get',
                            throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN, GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
                            userKey=user, clientId=clientId, fields=fields)]
      else:
        results = callGAPIitems(cd.tokens(), u'list', u'items',
                                throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
                                userKey=user, fields=u'items({0})'.format(fields))
      jcount = len(results)
      if not csvFormat:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.ACCESS_TOKEN, i, count)
        Ind.Increment()
        j = 0
        for token in results:
          j += 1
          _showToken(token, j, jcount)
        Ind.Decrement()
      else:
        if results:
          for token in results:
            row = {u'user': user, u'scopes': delimiter.join(token.get(u'scopes', []))}
            for item in token:
              if item != u'scopes':
                row[item] = token.get(item, u'')
            csvRows.append(row)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvRows.append({u'user': user})
    except (GAPI.notFound, GAPI.resourceNotFound) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], str(e), i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'OAuth Tokens', todrive)

# gam <UserTypeEntity> show tokens|token|3lo|oauth [clientid <ClientID>]
def showTokens(users):
  _printShowTokens(Cmd.ENTITY_USERS, users, False)

# gam <UserTypeEntity> print tokens|token [todrive [<ToDriveAttributes>]] [clientid <ClientID>] [delimiter <Character>]
def printTokens(users):
  _printShowTokens(Cmd.ENTITY_USERS, users, True)

# gam print tokens|token [todrive [<ToDriveAttributes>]] [clientid <ClientID>] [<UserTypeEntity>] [delimiter <Character>]
def doPrintTokens():
  _printShowTokens(None, None, True)

# gam <UserTypeEntity> deprovision|deprov
def deprovisionUser(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      printGettingEntityItemForWhom(Ent.APPLICATION_SPECIFIC_PASSWORD, user, i, count)
      asps = callGAPIitems(cd.asps(), u'list', u'items',
                           throw_reasons=[GAPI.USER_NOT_FOUND],
                           userKey=user, fields=u'items(codeId)')
      codeIds = [asp[u'codeId'] for asp in asps]
      jcount = len(codeIds)
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.APPLICATION_SPECIFIC_PASSWORD, i, count)
      if jcount > 0:
        Ind.Increment()
        j = 0
        for codeId in codeIds:
          j += 1
          try:
            callGAPI(cd.asps(), u'delete',
                     throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.FORBIDDEN],
                     userKey=user, codeId=codeId)
            entityActionPerformed([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], j, jcount)
          except (GAPI.invalid, GAPI.invalidParameter, GAPI.forbidden) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], str(e), j, jcount)
        Ind.Decrement()
#
      printGettingEntityItemForWhom(Ent.BACKUP_VERIFICATION_CODES, user, i, count)
      try:
        codes = callGAPIitems(cd.verificationCodes(), u'list', u'items',
                              throw_reasons=[GAPI.USER_NOT_FOUND],
                              userKey=user, fields=u'items(verificationCode)')
        jcount = len(codes)
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.BACKUP_VERIFICATION_CODES, i, count)
        if jcount > 0:
          callGAPI(cd.verificationCodes(), u'invalidate',
                   throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID],
                   userKey=user)
          entityActionPerformed([Ent.USER, user, Ent.BACKUP_VERIFICATION_CODES, None], i, count)
      except GAPI.invalid as e:
        entityActionFailedWarning([Ent.USER, user, Ent.BACKUP_VERIFICATION_CODES, None], str(e), i, count)
#
      printGettingEntityItemForWhom(Ent.ACCESS_TOKEN, user, i, count)
      tokens = callGAPIitems(cd.tokens(), u'list', u'items',
                             throw_reasons=[GAPI.USER_NOT_FOUND],
                             userKey=user, fields=u'items(clientId)')
      jcount = len(tokens)
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.ACCESS_TOKEN, i, count)
      if jcount > 0:
        Ind.Increment()
        j = 0
        for token in tokens:
          j += 1
          clientId = token[u'clientId']
          try:
            callGAPI(cd.tokens(), u'delete',
                     throw_reasons=[GAPI.USER_NOT_FOUND, GAPI.NOT_FOUND],
                     userKey=user, clientId=clientId)
            entityActionPerformed([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], j, jcount)
          except GAPI.notFound as e:
            entityActionFailedWarning([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], str(e), j, jcount)
        Ind.Decrement()
#
      entityActionPerformed([Ent.USER, user], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)

def _printShowGmailProfile(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if csvFormat:
      printGettingEntityItemForWhom(Ent.GMAIL_PROFILE, user, i, count)
    try:
      results = callGAPI(gmail.users(), u'getProfile',
                         throw_reasons=GAPI.GMAIL_THROW_REASONS,
                         userId=u'me')
      if not csvFormat:
        kvList = []
        for item in [u'historyId', u'messagesTotal', u'threadsTotal']:
          kvList += [item, results[item]]
        printEntityKVList([Ent.USER, user], kvList, i, count)
      else:
        addRowTitlesToCSVfile(results, csvRows, titles)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Gmail Profiles', todrive, [u'emailAddress',])

# gam <UserTypeEntity> print gmailprofile [todrive [<ToDriveAttributes>]]
def printGmailProfile(users):
  _printShowGmailProfile(users, True)

# gam <UserTypeEntity> show gmailprofile
def showGmailProfile(users):
  _printShowGmailProfile(users, False)

PROFILE_PROPERTY_PRINT_ORDER = [
  u'objectType',
  u'displayName',
  u'name',
  u'nickname',
  u'domain',
  u'birthday',
  u'ageRange',
  u'gender',
  u'relationshipStatus',
  u'placesLived',
  u'language',
  u'occupation',
  u'aboutMe',
  u'braggingRights',
  u'skills',
  u'tagline',
  u'circledByCount',
  u'plusOneCount',
  u'verified',
  u'emails',
  u'organizations',
  u'urls',
  u'cover',
  ]

PROFILE_ARRAY_PROPERTY_PRINT_ORDER = {
  u'ageRange': [u'min', u'max'],
  u'cover': [u'layout', u'coverPhoto', u'coverInfo'],
  u'coverInfo': [u'topImageOffset', u'leftImageOffset'],
  u'coverPhoto': [u'url', u'height', u'width'],
  u'emails': [u'type', u'value'],
  u'image': [u'url',],
  u'name': [u'formatted', u'honorificPrefix', u'givenName', u'middleName', u'familyName', u'honorificSuffix'],
  u'organizations': [u'type', u'name', u'title', u'department', u'location', u'description', u'startDate', u'endDate', u'primary'],
  u'placesLived': [u'value', u'primary'],
  u'urls': [u'label', u'type', u'value'],
  }

def _showGplusProfile(user, i, count, result):
  def _showProfileObject(object_name, object_value, object_order=None, level=0):
    if object_name is not None:
      printJSONKey(object_name)
    if isinstance(object_value, list):
      if object_name is not None:
        printBlankLine()
        Ind.Increment()
      for sub_value in object_value:
        if isinstance(sub_value, non_compound_types):
          printKeyValueList([sub_value])
        else:
          _showProfileObject(None, sub_value, object_order=PROFILE_ARRAY_PROPERTY_PRINT_ORDER[object_name], level=level+1)
      if object_name is not None:
        Ind.Decrement()
    elif isinstance(object_value, dict):
      indentAfterFirst = unindentAfterLast = False
      if object_name is not None:
        printBlankLine()
        Ind.Increment()
      elif level > 0:
        indentAfterFirst = unindentAfterLast = True
      for sub_object in object_order or PROFILE_ARRAY_PROPERTY_PRINT_ORDER[object_name]:
        value = object_value.get(sub_object)
        if value is not None:
          _showProfileObject(sub_object, value, level=level+1)
          if indentAfterFirst:
            Ind.Increment()
            indentAfterFirst = False
      if object_name is not None or unindentAfterLast:
        Ind.Decrement()
    else:
      if object_name in [u'aboutMe',]:
        printJSONValue(dehtml(object_value))
      else:
        printJSONValue(object_value)

  enabled = result[u'isPlusUser']
  printEntity([Ent.USER, user, Ent.GPLUS_PROFILE, result[u'id']], i, count)
  Ind.Increment()
  printKeyValueList([u'isPlusUser', enabled])
  for item in PROFILE_PROPERTY_PRINT_ORDER:
    value = result.get(item)
    if value is not None:
      _showProfileObject(item, value)
  Ind.Decrement()

def _printShowGplusProfile(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(None)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gplus = buildGAPIServiceObject(API.GPLUS, user, i, count)
    if not gplus:
      continue
    if csvFormat:
      printGettingEntityItemForWhom(Ent.GPLUS_PROFILE, user, i, count)
    try:
      result = callGAPI(gplus.people(), u'get',
                        throw_reasons=GAPI.GPLUS_THROW_REASONS, retry_reasons=[GAPI.UNKNOWN_ERROR],
                        userId=u'me')
      if not csvFormat:
        _showGplusProfile(user, i, count, result)
      else:
        addRowTitlesToCSVfile(flattenJSON(result, flattened={u'emailAddress': user}), csvRows, titles)
    except (GAPI.serviceNotAvailable, GAPI.unknownError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Gplus Profiles', todrive, [u'emailAddress', u'id', u'displayName', u'domain'])

# gam <UserTypeEntity> print gplusprofile [todrive [<ToDriveAttributes>]]
def printGplusProfile(users):
  _printShowGplusProfile(users, True)

# gam <UserTypeEntity> show gplusprofile
def showGplusProfile(users):
  _printShowGplusProfile(users, False)

def _getUserGmailLabels(gmail, user, i, count, **kwargs):
  try:
    labels = callGAPI(gmail.users().labels(), u'list',
                      throw_reasons=GAPI.GMAIL_THROW_REASONS,
                      userId=u'me', **kwargs)
    if not labels:
      labels = {u'labels': []}
    return labels
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return None

def _getLabelId(labels, labelName):
  for label in labels[u'labels']:
    if label[u'id'] == labelName or label[u'name'] == labelName:
      return label[u'id']
  return None

def _getLabelName(labels, labelId):
  for label in labels[u'labels']:
    if label[u'id'] == labelId:
      return label[u'name']
  return labelId

LABEL_LABEL_LIST_VISIBILITY_CHOICE_MAP = {
  u'hide': u'labelHide',
  u'show': u'labelShow',
  u'showifunread': u'labelShowIfUnread',
  }
LABEL_MESSAGE_LIST_VISIBILITY_CHOICES = [u'hide', u'show',]

def getLabelAttributes(myarg, body):
  if myarg == u'labellistvisibility':
    body[u'labelListVisibility'] = getChoice(LABEL_LABEL_LIST_VISIBILITY_CHOICE_MAP, mapChoice=True)
  elif myarg == u'messagelistvisibility':
    body[u'messageListVisibility'] = getChoice(LABEL_MESSAGE_LIST_VISIBILITY_CHOICES)
  elif myarg == u'backgroundcolor':
    body.setdefault(u'color', {})
    body[u'color']['backgroundColor'] = getLabelColor()
  elif myarg == u'textcolor':
    body.setdefault(u'color', {})
    body[u'color']['textColor'] = getLabelColor()
  else:
    unknownArgumentExit()

def checkLabelColor(body):
  if u'color' not in body:
    return
  if u'backgroundColor' in body[u'color']:
    if u'textColor' in body[u'color']:
      return
    missingArgumentExit(u'textcolor <LabelColorHex>')
  missingArgumentExit(u'backgroundcolor <LabelColorHex>')

# gam <UserTypeEntity> [create|add] label|labels <String> [messagelistvisibility hide|show] [labellistvisibility hide|show|showifunread] [buildpath [<Boolean>]]
#	[backgroundcolor <LabelColorHex>] [textcolor <LabelColorHex>]
def createLabel(users):
  label = getString(Cmd.OB_LABEL_NAME)
  body = {u'name': label}
  buildPath = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'buildpath':
      buildPath = getBoolean()
      label = label.strip(u'/')
    else:
      getLabelAttributes(myarg, body)
  checkLabelColor(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if not buildPath:
      entityPerformActionNumItems([Ent.USER, user], 1, Ent.LABEL, i, count)
      Ind.Increment()
      try:
        callGAPI(gmail.users().labels(), u'create',
                 throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.DUPLICATE],
                 userId=u'me', body=body, fields=u'')
        entityActionPerformed([Ent.USER, user, Ent.LABEL, label], i, count)
      except GAPI.duplicate:
        entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label], Msg.DUPLICATE, i, count)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
      Ind.Decrement()
    else:
      labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
      if not labels:
        continue
      labelParts = label.split(u'/')
      invalid = False
      for j, labelPart in enumerate(labelParts):
        labelParts[j] = labelPart.strip()
        if not labelParts[j]:
          entityPerformActionNumItems([Ent.USER, user], 1, Ent.LABEL, i, count)
          Ind.Increment()
          entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label], Msg.INVALID, i, count)
          Ind.Decrement()
          invalid = True
          break
      if invalid:
        continue
      labelSet = set([ulabel[u'name'] for ulabel in labels[u'labels'] if ulabel[u'type'] != LABEL_TYPE_SYSTEM])
      duplicate = True
      labelPath = u''
      j = 0
      for k, labelPart in enumerate(labelParts):
        if labelPath != u'':
          labelPath += u'/'
        labelPath += labelPart
        if labelPath not in labelSet:
          if duplicate:
            jcount = len(labelParts)-k
            entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
            Ind.Increment()
            duplicate = False
          j += 1
          body[u'name'] = labelPath
          try:
            callGAPI(gmail.users().labels(), u'create',
                     throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.DUPLICATE],
                     userId=u'me', body=body, fields=u'')
            entityActionPerformed([Ent.USER, user, Ent.LABEL, labelPath], j, jcount)
          except GAPI.duplicate:
            entityActionFailedWarning([Ent.USER, user, Ent.LABEL, labelPath], Msg.DUPLICATE, j, jcount)
            break
          except (GAPI.serviceNotAvailable, GAPI.badRequest):
            entityServiceNotApplicableWarning(Ent.USER, user, i, count)
            break
      if duplicate:
        entityPerformActionNumItems([Ent.USER, user], 1, Ent.LABEL, i, count)
        Ind.Increment()
        entityActionFailedWarning([Ent.USER, user, Ent.LABEL, labelPath], Msg.DUPLICATE, i, count)
      Ind.Decrement()

# gam <UserTypeEntity> update labelsettings <LabelName> [name <String>] [messagelistvisibility hide|show] [labellistvisibility hide|show|showifunread]
#	[backgroundcolor <LabelColorHex>] [textcolor <LabelColorHex>]
def updateLabelSettings(users):
  label_name = getString(Cmd.OB_LABEL_NAME)
  label_name_lower = label_name.lower()
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'name':
      body[u'name'] = getString(Cmd.OB_STRING)
    else:
      getLabelAttributes(myarg, body)
  checkLabelColor(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
    if not labels:
      continue
    try:
      for label in labels[u'labels']:
        if label[u'name'].lower() == label_name_lower:
          callGAPI(gmail.users().labels(), u'patch',
                   throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT],
                   userId=u'me', id=label[u'id'], body=body, fields=u'')
          entityActionPerformed([Ent.USER, user, Ent.LABEL, label_name], i, count)
          break
      else:
        entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label_name], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.notFound, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label_name], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
#
LABEL_TYPE_SYSTEM = u'system'
LABEL_TYPE_USER = u'user'

# gam <UserTypeEntity> update label|labels [search <RegularExpression>] [replace <LabelReplacement>] [merge]
#	search defaults to '^Inbox/(.*)$' which will find all labels in the Inbox
#	replace defaults to '%s'
def updateLabels(users):
  search = u'^Inbox/(.*)$'
  pattern = re.compile(search, re.IGNORECASE)
  replace = u'%s'
  merge = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'search':
      search = getString(Cmd.OB_RE_PATTERN)
      pattern = validateREPattern(search, re.IGNORECASE)
    elif myarg == u'replace':
      replaceLocation = Cmd.Location()
      replace = getString(Cmd.OB_LABEL_REPLACEMENT)
    elif myarg == u'merge':
      merge = True
    else:
      unknownArgumentExit()
# Validate that number of substitions in replace matches the number of groups in pattern
  useRegexSub = replace.find(u'%s') == -1
  if useRegexSub:
    patternGroups = pattern.groups
    replSubs = REPLACE_GROUP_PATTERN.findall(replace)
    for replSub in replSubs:
      if int(replSub) > patternGroups:
        Cmd.SetLocation(replaceLocation)
        usageErrorExit(Msg.MISMATCH_RE_SEARCH_REPLACE_SUBFIELDS.format(pattern.groups, search, int(replSub), replace))
  else:
    if pattern.groups != replace.count(u'%s'):
      Cmd.SetLocation(replaceLocation)
      usageErrorExit(Msg.MISMATCH_SEARCH_REPLACE_SUBFIELDS.format(pattern.groups, search, replace.count(u'%s'), replace))
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
    if not labels:
      continue
    try:
      labelMatches = 0
      for label in labels[u'labels']:
        if label[u'type'] == LABEL_TYPE_SYSTEM:
          continue
        match_result = pattern.search(convertUTF8(label[u'name']))
        if match_result is not None:
          labelMatches += 1
          newLabelName = pattern.sub(replace, convertUTF8(label[u'name'])) if useRegexSub else replace % match_result.groups()
          newLabelNameLower = newLabelName.lower()
          try:
            Act.Set(Act.RENAME)
            callGAPI(gmail.users().labels(), u'patch',
                     throw_reasons=[GAPI.ABORTED, GAPI.DUPLICATE],
                     userId=u'me', id=label[u'id'], body={u'name': newLabelName}, fields=u'')
            entityModifierNewValueActionPerformed([Ent.USER, user, Ent.LABEL, label[u'name']], Act.MODIFIER_TO, newLabelName, i, count)
          except (GAPI.aborted, GAPI.duplicate):
            if merge:
              Act.Set(Act.MERGE)
              entityPerformActionModifierNewValue([Ent.USER, user, Ent.LABEL, label[u'name']], Act.MODIFIER_WITH, newLabelName, i, count)
              messagesToRelabel = callGAPIpages(gmail.users().messages(), u'list', u'messages',
                                                userId=u'me', q=u'label:"{0}"'.format(label[u'name']))
              Act.Set(Act.RELABEL)
              jcount = len(messagesToRelabel)
              Ind.Increment()
              if jcount > 0:
                for new_label in labels[u'labels']:
                  if new_label[u'name'].lower() == newLabelNameLower:
                    body = {u'addLabelIds': [new_label[u'id']]}
                    break
                j = 0
                for message in messagesToRelabel:
                  j += 1
                  callGAPI(gmail.users().messages(), u'modify',
                           userId=u'me', id=message[u'id'], body=body, fields=u'')
                  entityActionPerformed([Ent.USER, user, Ent.MESSAGE, message[u'id']], j, jcount)
              else:
                printEntityKVList([Ent.USER, user],
                                  [Msg.NO_MESSAGES_WITH_LABEL, label[u'name']],
                                  i, count)
              Ind.Decrement()
              callGAPI(gmail.users().labels(), u'delete',
                       userId=u'me', id=label[u'id'])
              Act.Set(Act.DELETE)
              entityActionPerformed([Ent.USER, user, Ent.LABEL, label[u'name']], i, count)
            else:
              entityActionNotPerformedWarning([Ent.USER, user, Ent.LABEL, newLabelName], Msg.ALREADY_EXISTS_USE_MERGE_ARGUMENT, i, count)
      if labels and (labelMatches == 0):
        printEntityKVList([Ent.USER, user],
                          [Msg.NO_LABELS_MATCH, search],
                          i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete label|labels <LabelName>|regex:<RegularExpression>
def deleteLabel(users):
  def _handleProcessGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], Ent.LABEL, labelIdToNameMap[ri[RI_ITEM]]], formatHTTPError(http_status, reason, message), int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _callbackDeleteLabel(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.USER, ri[RI_ENTITY], Ent.LABEL, labelIdToNameMap[ri[RI_ITEM]]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleProcessGmailError(exception, ri)

  label = getString(Cmd.OB_LABEL_NAME)
  if label[:6].lower() == u'regex:':
    labelPattern = validateREPattern(label[6:])
  else:
    labelPattern = None
  label_name_lower = label.lower()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      printGettingAllEntityItemsForWhom(Ent.LABEL, user, i, count)
      labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
      if not labels:
        continue
      del_labels = []
      if label == u'--ALL_LABELS--':
        count = len(labels[u'labels'])
        for del_label in labels[u'labels']:
          if del_label[u'type'] != LABEL_TYPE_SYSTEM:
            del_labels.append(del_label)
      elif labelPattern:
        for del_label in labels[u'labels']:
          if del_label[u'type'] != LABEL_TYPE_SYSTEM and labelPattern.match(del_label[u'name']):
            del_labels.append(del_label)
      else:
        for del_label in labels[u'labels']:
          if label_name_lower == del_label[u'name'].lower():
            del_labels.append(del_label)
            break
        else:
          entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label], Msg.DOES_NOT_EXIST, i, count)
          continue
      jcount = len(del_labels)
      labelIdToNameMap = {}
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
      Ind.Increment()
      svcargs = dict([(u'userId', u'me'), (u'id', None), (u'fields', u'')]+GM.Globals[GM.EXTRA_ARGS_LIST])
      method = getattr(gmail.users().labels(), u'delete')
      dbatch = gmail.new_batch_http_request(callback=_callbackDeleteLabel)
      bcount = 0
      j = 0
      for del_me in del_labels:
        j += 1
        svcparms = svcargs.copy()
        svcparms[u'id'] = del_me[u'id']
        labelIdToNameMap[del_me[u'id']] = del_me[u'name']
        dbatch.add(method(**svcparms), request_id=batchRequestID(user, i, count, j, jcount, del_me[u'id']))
        bcount += 1
        if bcount == 10:
          executeBatch(dbatch)
          dbatch = gmail.new_batch_http_request(callback=_callbackDeleteLabel)
          bcount = 0
      if bcount > 0:
        executeBatch(dbatch)
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

PRINT_LABELS_TITLES = [u'User', u'type', u'name', u'id']
SHOW_LABELS_DISPLAY_CHOICES = [u'allfields', u'basename', u'fullname']
LABEL_DISPLAY_FIELDS_LIST = [u'type', u'id', u'labelListVisibility', u'messageListVisibility', u'color']
LABEL_COUNTS_FIELDS_LIST = [u'messagesTotal', u'messagesUnread', u'threadsTotal', u'threadsUnread']
LABEL_COUNTS_FIELDS = u','.join(LABEL_COUNTS_FIELDS_LIST)

def printShowLabels(users, csvFormat):
  def _buildLabelTree(labels):
    def _checkChildLabel(label):
      if label.find(u'/') != -1:
        (parent, base) = label.rsplit(u'/', 1)
        if parent in labelTree:
          if label in labelTree:
            labelTree[label][u'info'][u'base'] = base
            labelTree[parent][u'children'].append(labelTree.pop(label))
          _checkChildLabel(parent)

    labelTree = {}
    for label in labels[u'labels']:
      if not onlyUser or (label[u'type'] != LABEL_TYPE_SYSTEM):
        label[u'base'] = label[u'name']
        labelTree[label[u'name']] = {u'info': label, u'children': []}
    labelList = sorted(list(labelTree), reverse=True)
    for label in labelList:
      _checkChildLabel(label)
    return labelTree

  def _printLabel(label):
    printKeyValueList([label[nameField]])
    if displayAllFields:
      Ind.Increment()
      for a_key in LABEL_DISPLAY_FIELDS_LIST:
        if a_key in label:
          if a_key != u'color':
            printKeyValueList([a_key, label[a_key]])
          else:
            printKeyValueList([u'backgroundColor', label[a_key][u'backgroundColor']])
            printKeyValueList([u'textColor', label[a_key][u'textColor']])
      if showCounts:
        counts = callGAPI(gmail.users().labels(), u'get',
                          throw_reasons=GAPI.GMAIL_THROW_REASONS,
                          userId=u'me', id=label[u'id'],
                          fields=LABEL_COUNTS_FIELDS)
        for a_key in LABEL_COUNTS_FIELDS_LIST:
          printKeyValueList([a_key, counts[a_key]])
      Ind.Decrement()

  def _printFlatLabel(label):
    _printLabel(label[u'info'])
    if label[u'children']:
      for child in sorted(label[u'children'], key=lambda k: k[u'info'][u'name']):
        _printFlatLabel(child)

  def _printNestedLabel(label):
    _printLabel(label[u'info'])
    if label[u'children']:
      Ind.Increment()
      if displayAllFields:
        printKeyValueList([u'nested', len(label[u'children'])])
        Ind.Increment()
        for child in sorted(label[u'children'], key=lambda k: k[u'info'][u'name']):
          _printNestedLabel(child)
        Ind.Decrement()
      else:
        for child in sorted(label[u'children'], key=lambda k: k[u'info'][u'name']):
          _printNestedLabel(child)
      Ind.Decrement()

  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile(PRINT_LABELS_TITLES)
  onlyUser = showCounts = showNested = False
  displayAllFields = True
  nameField = u'name'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'onlyuser':
      onlyUser = getBoolean()
    elif myarg == u'showcounts':
      showCounts = getBoolean()
    elif not csvFormat and myarg == u'nested':
      showNested = getBoolean()
    elif not csvFormat and myarg == u'display':
      fields = getChoice(SHOW_LABELS_DISPLAY_CHOICES)
      nameField = [u'base', u'name'][fields != u'basename']
      displayAllFields = fields == u'allfields'
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if csvFormat:
      printGettingEntityItemForWhom(Ent.LABEL, user, i, count)
    labels = _getUserGmailLabels(gmail, user, i, count)
    if not labels:
      continue
    try:
      jcount = len(labels[u'labels'])
      if (jcount > 0) and onlyUser:
        for label in labels[u'labels']:
          if label[u'type'] == LABEL_TYPE_SYSTEM:
            jcount -= 1
      if not csvFormat:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvFormat:
        labelTree = _buildLabelTree(labels)
        Ind.Increment()
        if not showNested:
          for label, _ in sorted(iteritems(labelTree), key=lambda k: (k[1][u'info'][u'type'], k[1][u'info'][u'name'])):
            _printFlatLabel(labelTree[label])
        else:
          for label, _ in sorted(iteritems(labelTree), key=lambda k: (k[1][u'info'][u'type'], k[1][u'info'][u'name'])):
            _printNestedLabel(labelTree[label])
        Ind.Decrement()
      else:
        for label in sorted(labels[u'labels'], key=lambda k: (k[u'type'], k[u'name'])):
          if not onlyUser or label[u'type'] != LABEL_TYPE_SYSTEM:
            if showCounts:
              counts = callGAPI(gmail.users().labels(), u'get',
                                throw_reasons=GAPI.GMAIL_THROW_REASONS,
                                userId=u'me', id=label[u'id'],
                                fields=LABEL_COUNTS_FIELDS)
              for a_key in LABEL_COUNTS_FIELDS_LIST:
                label[a_key] = counts[a_key]
            addRowTitlesToCSVfile(flattenJSON(label, flattened={u'User': user}), csvRows, titles)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Labels', todrive, PRINT_LABELS_TITLES)

# gam <UserTypeEntity> print labels|label [onlyuser [<Boolean>]] [showcounts [<Boolean>]] [todrive [<ToDriveAttributes>]]
def printLabels(users):
  printShowLabels(users, True)

# gam <UserTypeEntity> show labels|label [onlyuser [<Boolean>]] [showcounts [<Boolean>]] [nested [<Boolean>]] [display allfields|basename|fullname]
def showLabels(users):
  printShowLabels(users, False)

def _initLabelNameMap(userGmailLabels):
  baseLabelNameMap = {
    u'INBOX': u'INBOX', u'SPAM': u'SPAM', u'TRASH': u'TRASH',
    u'UNREAD': u'UNREAD', u'STARRED': u'STARRED', u'IMPORTANT': u'IMPORTANT',
    u'SENT': u'SENT', u'DRAFT': u'DRAFT',
    u'CATEGORY_PERSONAL': u'CATEGORY_PERSONAL',
    u'CATEGORY_SOCIAL': u'CATEGORY_SOCIAL',
    u'CATEGORY_PROMOTIONS': u'CATEGORY_PROMOTIONS',
    u'CATEGORY_UPDATES': u'CATEGORY_UPDATES',
    u'CATEGORY_FORUMS': u'CATEGORY_FORUMS',
    }

  labelNameMap = baseLabelNameMap.copy()
  for label in userGmailLabels[u'labels']:
    if label[u'type'] == u'system':
      labelNameMap[label[u'id']] = label[u'id']
    else:
      labelNameMap[label[u'name']] = label[u'id']
  return labelNameMap

def _convertLabelNamesToIds(gmail, bodyLabels, labelNameMap, addLabelIfMissing):
  labelIds = []
  for label in bodyLabels:
    if label.upper() in labelNameMap:
      label = label.upper()
    if label not in labelNameMap:
      results = callGAPI(gmail.users().labels(), u'create',
                         userId=u'me', body={u'labelListVisibility': u'labelShow', u'messageListVisibility': u'show', u'name': label}, fields=u'id')
      labelNameMap[label] = results[u'id']
    try:
      labelIds.append(labelNameMap[label])
    except KeyError:
      pass
    if addLabelIfMissing:
      if label.find(u'/') != -1:
        # make sure to create parent labels for proper nesting
        parent_label = label[:label.rfind(u'/')]
        while True:
          if not parent_label in labelNameMap:
            result = callGAPI(gmail.users().labels(), u'create',
                              userId=u'me', body={u'name': parent_label}, fields=u'id')
            labelNameMap[parent_label] = result[u'id']
          if parent_label.find(u'/') == -1:
            break
          parent_label = parent_label[:parent_label.rfind(u'/')]
  return labelIds

MESSAGES_MAX_TO_KEYWORDS = {
  Act.ARCHIVE: u'maxtoarchive',
  Act.DELETE: u'maxtodelete',
  Act.MODIFY: u'maxtomodify',
  Act.PRINT: u'maxtoprint',
  Act.SHOW: u'maxtoshow',
  Act.SPAM: u'maxtospam',
  Act.TRASH: u'maxtotrash',
  Act.UNTRASH: u'maxtountrash',
  }

def _initMessageThreadParameters(entityType, doIt, maxToProcess):
  listType = [u'threads', u'messages'][entityType == Ent.MESSAGE]
  return {u'currLabelOp': u'and', u'prevLabelOp': u'and', u'labelGroupOpen':  False, u'query': u'',
          u'entityType': entityType, u'messageEntity': None, u'doIt': doIt, u'quick': True,
          u'maxToProcess': maxToProcess, u'maxItems': 0,
          u'maxToKeywords': [MESSAGES_MAX_TO_KEYWORDS[Act.Get()], u'maxtoprocess'],
          u'listType': listType, u'fields': u'nextPageToken,{0}(id)'.format(listType)}

def _getMessageSelectParameters(myarg, parameters):
  if myarg == u'query':
    parameters[u'query'] += u' ({0})'.format(getString(Cmd.OB_QUERY))
  elif myarg == u'matchlabel':
    labelName = getString(Cmd.OB_LABEL_NAME).lower().replace(u' ', u'-').replace(u'/', u'-')
    if not parameters[u'labelGroupOpen']:
      parameters[u'query'] += u'('
      parameters[u'labelGroupOpen'] = True
    parameters[u'query'] += u' label:{0}'.format(labelName)
  elif myarg in [u'or', u'and']:
    parameters[u'prevLabelOp'] = parameters[u'currLabelOp']
    parameters[u'currLabelOp'] = myarg
    if parameters[u'labelGroupOpen'] and parameters[u'currLabelOp'] != parameters[u'prevLabelOp']:
      parameters[u'query'] += u')'
      parameters[u'labelGroupOpen'] = False
    if parameters[u'currLabelOp'] == u'or':
      parameters[u'query'] += u' OR '
  elif myarg == u'ids':
    parameters[u'messageEntity'] = getUserObjectEntity(Cmd.OB_MESSAGE_ID, parameters[u'entityType'])
  elif myarg == u'quick':
    parameters[u'quick'] = True
  elif myarg == u'notquick':
    parameters[u'quick'] = False
  elif myarg == u'doit':
    parameters[u'doIt'] = True
  elif myarg in parameters[u'maxToKeywords']:
    parameters[u'maxToProcess'] = getInteger(minVal=0)
  else:
    return False
  return True

def _finalizeMessageSelectParameters(parameters, queryOrIdsRequired):
  if parameters[u'query']:
    if parameters[u'labelGroupOpen']:
      parameters[u'query'] += u')'
  elif queryOrIdsRequired and parameters[u'messageEntity'] is None:
    missingArgumentExit(u'query|matchlabel|ids')
  else:
    parameters[u'query'] = None
  parameters[u'maxItems'] = [0, parameters[u'maxToProcess']][parameters[u'quick']]

# gam <UserTypeEntity> archive messages <GroupItem> (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_archive <Number>])|(ids <MessageIDEntity>)
def archiveMessages(users):
  gm = buildGAPIObject(API.GROUPSMIGRATION)
  entityType = Ent.MESSAGE
  parameters = _initMessageThreadParameters(entityType, True, 0)
  cd = buildGAPIObject(API.DIRECTORY)
  group = getEmailAddress()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getMessageSelectParameters(myarg, parameters):
      pass
    else:
      unknownArgumentExit()
  _finalizeMessageSelectParameters(parameters, False)
  try:
    group = callGAPI(cd.groups(), u'get',
                     throw_reasons=GAPI.GROUP_GET_THROW_REASONS,
                     groupKey=group, fields=u'email')[u'email']
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest) as e:
    entityDoesNotExistExit(Ent.GROUP, group)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, i, count, parameters[u'messageEntity'])
    if not gmail:
      continue
    service = gmail.users().messages()
    try:
      if parameters[u'messageEntity'] is None:
        printGettingAllEntityItemsForWhom(entityType, user, i, count)
        listResult = callGAPIpages(service, u'list', parameters[u'listType'],
                                   page_message=getPageMessage(), maxItems=parameters[u'maxItems'],
                                   throw_reasons=GAPI.GMAIL_THROW_REASONS,
                                   userId=u'me', q=parameters[u'query'], fields=parameters[u'fields'],
                                   maxResults=GC.Values[GC.MESSAGE_MAX_RESULTS])
        messageIds = [message[u'id'] for message in listResult]
      jcount = len(messageIds)
      if jcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if parameters[u'messageEntity'] is None:
        if parameters[u'maxToProcess'] and jcount > parameters[u'maxToProcess']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(jcount, Act.ToPerform(), parameters[u'maxToProcess']), i, count)
          continue
        if not parameters[u'doIt']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
          continue
      entityPerformActionNumItems([Ent.USER, user], jcount, entityType, i, count)
      Ind.Increment()
      j = 0
      for messageId in messageIds:
        j += 1
        try:
          message = callGAPI(service, u'get',
                             throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT],
                             userId=u'me', id=messageId, format=u'raw')
          stream = StringIOobject()
          stream.write(base64.urlsafe_b64decode(str(message[u'raw'])))
          try:
            callGAPI(gm.archive(), u'insert',
                     throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.BAD_REQUEST],
                     groupId=group, media_body=googleapiclient.http.MediaIoBaseUpload(stream, mimetype=u'message/rfc822', resumable=True))
            entityActionPerformed([Ent.USER, user, entityType, messageId], j, jcount)
          except GAPI.serviceNotAvailable:
            entityServiceNotApplicableWarning(Ent.USER, user, i, count)
            break
          except GAPI.badRequest as e:
            entityActionFailedWarning([Ent.USER, user, entityType, messageId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.badRequest):
          entityServiceNotApplicableWarning(Ent.USER, user, i, count)
          break
        except (GAPI.notFound, GAPI.invalidArgument) as e:
          entityActionFailedWarning([Ent.USER, user, entityType, messageId], str(e), j, jcount)
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _processMessagesThreads(users, entityType):
  def _batchDeleteModifyMessages(gmail, function, user, jcount, messageIds, body):
    mcount = 0
    bcount = min(jcount-mcount, GC.Values[GC.MESSAGE_BATCH_SIZE])
    while bcount > 0:
      body[u'ids'] = messageIds[mcount:mcount+bcount]
      try:
        callGAPI(gmail.users().messages(), function,
                 throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_MESSAGE_ID],
                 userId=u'me', body=body)
        for messageId in body[u'ids']:
          mcount += 1
          entityActionPerformed([Ent.USER, user, entityType, messageId], mcount, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        mcount += bcount
      except GAPI.invalidMessageId:
        entityActionFailedWarning([Ent.USER, user, entityType, Msg.BATCH], u'{0} ({1}-{2}/{3})'.format(Msg.INVALID_MESSAGE_ID, mcount+1, mcount+bcount, jcount))
        mcount += bcount
      bcount = min(jcount-mcount, GC.Values[GC.MESSAGE_BATCH_SIZE])

  _GMAIL_ERROR_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.INVALID_MESSAGE_ID: Msg.INVALID_MESSAGE_ID}
  def _handleProcessGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _callbackProcessMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleProcessGmailError(exception, ri)

  def _batchProcessMessagesThreads(service, function, user, jcount, messageIds, **kwargs):
    svcargs = dict([(u'userId', u'me'), (u'id', None), (u'fields', u'')]+list(kwargs.items())+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(service, function)
    dbatch = gmail.new_batch_http_request(callback=_callbackProcessMessage)
    bcount = 0
    j = 0
    for messageId in messageIds:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'id'] = messageId
      dbatch.add(method(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, svcparms[u'id']))
      bcount += 1
      if bcount == GC.Values[GC.EMAIL_BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = gmail.new_batch_http_request(callback=_callbackProcessMessage)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)

  parameters = _initMessageThreadParameters(entityType, False, 1)
  includeSpamTrash = False
  function = {Act.DELETE: u'delete', Act.MODIFY: u'modify', Act.SPAM: u'spam', Act.TRASH: u'trash', Act.UNTRASH: u'untrash'}[Act.Get()]
  labelNameMap = {}
  addLabelNames = []
  addLabelIds = []
  removeLabelNames = []
  removeLabelIds = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getMessageSelectParameters(myarg, parameters):
      pass
    elif (function == u'modify') and (myarg == u'addlabel'):
      addLabelNames.append(getString(Cmd.OB_LABEL_NAME))
    elif (function == u'modify') and (myarg == u'removelabel'):
      removeLabelNames.append(getString(Cmd.OB_LABEL_NAME))
    else:
      unknownArgumentExit()
  _finalizeMessageSelectParameters(parameters, True)
  includeSpamTrash = Act.Get() in [Act.DELETE, Act.MODIFY, Act.UNTRASH]
  if function == u'spam':
    function = u'modify'
    addLabelIds = [u'SPAM',]
    removeLabelIds = [u'INBOX',]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, i, count, parameters[u'messageEntity'])
    if not gmail:
      continue
    service = [gmail.users().threads(), gmail.users().messages()][entityType == Ent.MESSAGE]
    try:
      if addLabelNames or removeLabelNames:
        userGmailLabels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
        if not userGmailLabels:
          continue
        labelNameMap = _initLabelNameMap(userGmailLabels)
        addLabelIds = _convertLabelNamesToIds(gmail, addLabelNames, labelNameMap, True)
        removeLabelIds = _convertLabelNamesToIds(gmail, removeLabelNames, labelNameMap, False)
      if parameters[u'messageEntity'] is None:
        printGettingAllEntityItemsForWhom(Ent.MESSAGE, user, i, count)
        listResult = callGAPIpages(service, u'list', parameters[u'listType'],
                                   page_message=getPageMessage(), maxItems=parameters[u'maxItems'],
                                   throw_reasons=GAPI.GMAIL_THROW_REASONS,
                                   userId=u'me', q=parameters[u'query'], fields=parameters[u'fields'], includeSpamTrash=includeSpamTrash,
                                   maxResults=GC.Values[GC.MESSAGE_MAX_RESULTS])
        messageIds = [message[u'id'] for message in listResult]
      else:
        # Need to get authorization set up for batch
        callGAPI(gmail.users(), u'getProfile',
                 throw_reasons=GAPI.GMAIL_THROW_REASONS,
                 userId=u'me', fields=u'')
      jcount = len(messageIds)
      if jcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if parameters[u'messageEntity'] is None:
        if parameters[u'maxToProcess'] and jcount > parameters[u'maxToProcess']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(jcount, Act.ToPerform(), parameters[u'maxToProcess']), i, count)
          continue
        if not parameters[u'doIt']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
          continue
      entityPerformActionNumItems([Ent.USER, user], jcount, entityType, i, count)
      Ind.Increment()
      if function == u'delete' and entityType == Ent.MESSAGE:
        _batchDeleteModifyMessages(gmail, u'batchDelete', user, jcount, messageIds, {u'ids': []})
      elif function == u'modify' and entityType == Ent.MESSAGE:
        _batchDeleteModifyMessages(gmail, u'batchModify', user, jcount, messageIds, {u'ids': [], u'addLabelIds': addLabelIds, u'removeLabelIds': removeLabelIds})
      else:
        if addLabelIds or removeLabelIds:
          kwargs = {u'body': {u'addLabelIds': addLabelIds, u'removeLabelIds': removeLabelIds}}
        else:
          kwargs = {}
        _batchProcessMessagesThreads(service, function, user, jcount, messageIds, **kwargs)
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_delete <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> modify message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_modify <Number>])|(ids <MessageIDEntity>)
#	(addlabel <LabelName>)* (removelabel <LabelName>)*
# gam <UserTypeEntity> spam message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_spam <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> trash message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_trash <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> untrash message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_untrash <Number>])|(ids <MessageIDEntity>)
def processMessages(users):
  _processMessagesThreads(users, Ent.MESSAGE)

# gam <UserTypeEntity> delete thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_delete <Number>])|(ids <ThreadIDEntity>)
# gam <UserTypeEntity> modify thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_modify <Number>])|(ids <ThreadIDEntity>)
#	(addlabel <LabelName>)* (removelabel <LabelName>)*
# gam <UserTypeEntity> spam thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_spam <Number>])|(ids <ThreadIDEntity>)
# gam <UserTypeEntity> trash thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_trash <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> untrash thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_untrash <Number>])|(ids <ThreadIDEntity>)
def processThreads(users):
  _processMessagesThreads(users, Ent.THREAD)

SMTP_HEADERS_MAP = {
  u'accept-language': u'Accept-Language',
  u'alternate-recipient': u'Alternate-Recipient',
  u'autoforwarded': u'Autoforwarded',
  u'autosubmitted': u'Autosubmitted',
  u'bcc': u'Bcc',
  u'cc': u'Cc',
  u'comments': u'Comments',
  u'content-alternative': u'Content-Alternative',
  u'content-base': u'Content-Base',
  u'content-description': u'Content-Description',
  u'content-disposition': u'Content-Disposition',
  u'content-duration': u'Content-Duration',
  u'content-id': u'Content-ID',
  u'content-identifier': u'Content-Identifier',
  u'content-language': u'Content-Language',
  u'content-location': u'Content-Location',
  u'content-md5': u'Content-MD5',
  u'content-return': u'Content-Return',
  u'content-transfer-encoding': u'Content-Transfer-Encoding',
  u'content-type': u'Content-Type',
  u'content-features': u'Content-features',
  u'conversion': u'Conversion',
  u'conversion-with-loss': u'Conversion-With-Loss',
  u'dl-expansion-history': u'DL-Expansion-History',
  u'date': u'Date',
  u'deferred-delivery': u'Deferred-Delivery',
  u'delivered-to': u'Delivered-To',
  u'delivery-date': u'Delivery-Date',
  u'discarded-x400-ipms-extensions': u'Discarded-X400-IPMS-Extensions',
  u'discarded-x400-mts-extensions': u'Discarded-X400-MTS-Extensions',
  u'disclose-recipients': u'Disclose-Recipients',
  u'disposition-notification-options': u'Disposition-Notification-Options',
  u'disposition-notification-to': u'Disposition-Notification-To',
  u'encoding': u'Encoding',
  u'encrypted': u'Encrypted',
  u'expires': u'Expires',
  u'expiry-date': u'Expiry-Date',
  u'from': u'From',
  u'generate-delivery-report': u'Generate-Delivery-Report',
  u'importance': u'Importance',
  u'in-reply-to': u'In-Reply-To',
  u'incomplete-copy': u'Incomplete-Copy',
  u'keywords': u'Keywords',
  u'language': u'Language',
  u'latest-delivery-time': u'Latest-Delivery-Time',
  u'list-archive': u'List-Archive',
  u'list-help': u'List-Help',
  u'list-id': u'List-ID',
  u'list-owner': u'List-Owner',
  u'list-post': u'List-Post',
  u'list-subscribe': u'List-Subscribe',
  u'list-unsubscribe': u'List-Unsubscribe',
  u'mime-version': u'MIME-Version',
  u'message-context': u'Message-Context',
  u'message-id': u'Message-ID',
  u'message-type': u'Message-Type',
  u'obsoletes': u'Obsoletes',
  u'original-encoded-information-types': u'Original-Encoded-Information-Types',
  u'original-message-id': u'Original-Message-ID',
  u'originator-return-address': u'Originator-Return-Address',
  u'pics-label': u'PICS-Label',
  u'prevent-nondelivery-report': u'Prevent-NonDelivery-Report',
  u'priority': u'Priority',
  u'received': u'Received',
  u'references': u'References',
  u'reply-by': u'Reply-By',
  u'reply-to': u'Reply-To',
  u'resent-bcc': u'Resent-Bcc',
  u'resent-cc': u'Resent-Cc',
  u'resent-date': u'Resent-Date',
  u'resent-from': u'Resent-From',
  u'resent-message-id': u'Resent-Message-ID',
  u'resent-reply-to': u'Resent-Reply-To',
  u'resent-sender': u'Resent-Sender',
  u'resent-to': u'Resent-To',
  u'return-path': u'Return-Path',
  u'sender': u'Sender',
  u'sensitivity': u'Sensitivity',
  u'subject': u'Subject',
  u'supersedes': u'Supersedes',
  u'to': u'To',
  u'x400-content-identifier': u'X400-Content-Identifier',
  u'x400-content-return': u'X400-Content-Return',
  u'x400-content-type': u'X400-Content-Type',
  u'x400-mts-identifier': u'X400-MTS-Identifier',
  u'x400-originator': u'X400-Originator',
  u'x400-received': u'X400-Received',
  u'x400-recipients': u'X400-Recipients',
  u'x400-trace': u'X400-Trace',
  }

SMTP_ADDRESS_HEADERS = [
  u'Bcc',
  u'Cc',
  u'Delivered-To',
  u'From',
  u'Reply-To',
  u'Resent-Bcc',
  u'Resent-Cc',
  u'Resent-Reply-To',
  u'Resent-Sender',
  u'Resent-To',
  u'Sender',
  u'To',
  ]

SMTP_DATE_HEADERS = [
  u'date',
  u'delivery-date',
  u'expires',
  u'expiry-date',
  u'latest-delivery-time',
  u'reply-by',
  u'resent-date',
  ]

SMTP_NAME_ADDRESS_PATTERN = re.compile(r'^(.+?)\s*<(.+)>$')

def _importInsertMessage(users, importMsg):
  from email.charset import add_charset, QP
  from email.generator import Generator
  from email.header import Header
  from email.mime.text import MIMEText
  from email.mime.audio import MIMEAudio
  from email.mime.base import MIMEBase
  from email.mime.image import MIMEImage
  from email.mime.multipart import MIMEMultipart
  from email.utils import formatdate
  from tempfile import TemporaryFile

  def _appendToHeader(header, value):
    try:
      header.append(value)
    except UnicodeDecodeError:
      header.append(value, UTF8)

  labelNameMap = {}
  addLabelNames = []
  msgHTML = msgText = u''
  msgHeaders = {}
  tagReplacements = _initTagReplacements()
  attachments = []
  internalDateSource = u'receivedTime'
  deleted = neverMarkSpam = processForCalendar = substituteForUserInHeaders = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in SMTP_HEADERS_MAP:
      if myarg in SMTP_DATE_HEADERS:
        msgDate, _, _ = getTimeOrDeltaFromNow(True)
        msgHeaders[SMTP_HEADERS_MAP[myarg]] = formatdate(time.mktime(msgDate.timetuple()) + msgDate.microsecond/1E6, True)
        if myarg == u'date':
          internalDateSource = u'dateHeader'
      else:
        value = getString(Cmd.OB_STRING)
        if (value.find(u'#user#') >= 0) or (value.find(u'#email#') >= 0) or (value.find(u'#username#') >= 0):
          substituteForUserInHeaders = True
        msgHeaders[SMTP_HEADERS_MAP[myarg]] = value
    elif myarg == u'header':
      header = getString(Cmd.OB_STRING, minLen=1).lower()
      value = getString(Cmd.OB_STRING)
      if (value.find(u'#user#') >= 0) or (value.find(u'#email#') >= 0) or (value.find(u'#username#') >= 0):
        substituteForUserInHeaders = True
      msgHeaders[SMTP_HEADERS_MAP.get(header, header)] = value
    elif myarg == u'textmessage':
      msgText = getString(Cmd.OB_STRING)
    elif myarg == u'textfile':
      filename = getString(Cmd.OB_FILE_NAME)
      encoding = getCharSet()
      msgText = readFile(filename, encoding=encoding)
    elif myarg == u'htmlmessage':
      msgHTML = getString(Cmd.OB_STRING)
    elif myarg == u'htmlfile':
      filename = getString(Cmd.OB_FILE_NAME)
      encoding = getCharSet()
      msgHTML = readFile(filename, encoding=encoding)
    elif myarg == u'replace':
      _getTagReplacement(tagReplacements, False)
    elif myarg == u'addlabel':
      addLabelNames.append(getString(Cmd.OB_LABEL_NAME, minLen=1))
    elif myarg == u'attach':
      attachments.append(getString(Cmd.OB_FILE_NAME, minLen=1))
    elif myarg == u'deleted':
      deleted = getBoolean()
    elif importMsg and myarg == u'nevermarkspam':
      neverMarkSpam = getBoolean()
    elif importMsg and myarg == u'processforcalendar':
      processForCalendar = getBoolean()
    else:
      unknownArgumentExit()
  if not msgText and not msgHTML:
    missingArgumentExit(u'textmessage|textfile|htmlmessage|htmlfile')
  msgText = msgText.replace(u'\r', u'').replace(u'\\n', u'\n')
  msgHTML = msgHTML.replace(u'\r', u'').replace(u'\\n', u'<br/>')
  if not tagReplacements[u'tags']:
    tmpText = msgText
    tmpHTML = msgHTML
  if u'To' not in msgHeaders:
    msgHeaders[u'To'] = u'#user#'
    substituteForUserInHeaders = True
  if u'From' not in msgHeaders:
    msgHeaders[u'From'] = _getValueFromOAuth(u'email')
  kwargs = {u'internalDateSource': internalDateSource, u'deleted': deleted}
  if importMsg:
    function = u'import_'
    kwargs.update({u'neverMarkSpam': neverMarkSpam, u'processForCalendar': processForCalendar})
  else:
    function = u'insert'
  add_charset(UTF8, QP, QP, UTF8)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    userName, _ = splitEmailAddress(user)
    if tagReplacements[u'tags']:
      if tagReplacements[u'subs']:
        _getTagReplacementFieldValues(user, i, count, tagReplacements)
      tmpText = _processTagReplacements(tagReplacements, msgText)
      tmpHTML = _processTagReplacements(tagReplacements, msgHTML)
    if attachments:
      if tmpText and tmpHTML:
        message = MIMEMultipart(u'alternative')
        textpart = MIMEText(tmpText, u'plain', UTF8)
        message.attach(textpart)
        htmlpart = MIMEText(tmpHTML, u'html', UTF8)
        message.attach(htmlpart)
      elif tmpHTML:
        message = MIMEMultipart()
        htmlpart = MIMEText(tmpHTML, u'html', UTF8)
        message.attach(htmlpart)
      else:
        message = MIMEMultipart()
        textpart = MIMEText(tmpText, u'plain', UTF8)
        message.attach(textpart)
      for attachFilename in attachments:
        try:
          attachFd = openFile(attachFilename, u'rb')
          attachContentType, attachEncoding = mimetypes.guess_type(attachFilename)
          if attachContentType is None or attachEncoding is not None:
            attachContentType = u'application/octet-stream'
          main_type, sub_type = attachContentType.split('/', 1)
          if main_type == u'text':
            msg = MIMEText(attachFd.read(), _subtype=sub_type)
          elif main_type == u'image':
            msg = MIMEImage(attachFd.read(), _subtype=sub_type)
          elif main_type == u'audio':
            msg = MIMEAudio(attachFd.read(), _subtype=sub_type)
          else:
            msg = MIMEBase(main_type, sub_type)
            msg.set_payload(attachFd.read())
          attachFd.close()
          msg.add_header(u'Content-Disposition', u'attachment', filename=attachFilename)
          message.attach(msg)
        except IOError as e:
          usageErrorExit(u'{0}: {1}'.format(attachFilename, str(e)))
    else:
      if tmpText and tmpHTML:
        message = MIMEMultipart(u'alternative')
        textpart = MIMEText(tmpText, u'plain', UTF8)
        message.attach(textpart)
        htmlpart = MIMEText(tmpHTML, u'html', UTF8)
        message.attach(htmlpart)
      elif tmpHTML:
        message = MIMEText(tmpHTML, u'html', UTF8)
      else:
        message = MIMEText(tmpText, u'plain', UTF8)
    for header, value in iteritems(msgHeaders):
      if substituteForUserInHeaders:
        value = _substituteForUser(value, user, userName)
      message[header] = Header()
      if header in SMTP_ADDRESS_HEADERS:
        match = SMTP_NAME_ADDRESS_PATTERN.match(value.strip())
        if match:
          _appendToHeader(message[header], match.group(1))
          _appendToHeader(message[header], match.group(2))
        else:
          _appendToHeader(message[header], value)
      else:
        _appendToHeader(message[header], value)
    tmpFile = TemporaryFile(mode=u'w+', encoding=UTF8)
    g = Generator(tmpFile, False)
    g.flatten(message)
    tmpFile.seek(0)
    body = {u'raw': base64.urlsafe_b64encode(bytes(tmpFile.read(), UTF8)).decode()}
    tmpFile.close()
    try:
      if addLabelNames:
        userGmailLabels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name,type)')
        if not userGmailLabels:
          continue
        labelNameMap = _initLabelNameMap(userGmailLabels)
        body[u'labelIds'] = _convertLabelNamesToIds(gmail, addLabelNames, labelNameMap, True)
      else:
        body[u'labelIds'] = [u'INBOX',]
      result = callGAPI(gmail.users().messages(), function,
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me', body=body, **kwargs)
      entityActionPerformed([Ent.USER, user, Ent.MESSAGE, result[u'id']], i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> import message (<SMTPDateHeader> <Time>)* (<SMTPHeader> <String>)* (header <String> <String>)* (addlabel <LabelName>)*
#	(textmessage <String>)|(textfile <FileName> [charset <CharSet>]) (htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])
#	(replace <Tag> <String>)* (attach <FileName>)*
#	[deleted [<Boolean>]] [nevermarkspam [<Boolean>]] [processforcalendar [<Boolean>]]
def importMessage(users):
  _importInsertMessage(users, True)

# gam <UserTypeEntity> insert message (<SMTPDateHeader> <Time>)* (<SMTPHeader> <String>)* (header <String> <String>)* (addlabel <LabelName>)*
#	(textmessage <String>)|(textfile <FileName> [charset <CharSet>]) (htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])
#	(replace <Tag> <String>)* (attach <FileName>)*
#	[deleted [<Boolean>]]
def insertMessage(users):
  _importInsertMessage(users, False)

def _printShowMessagesThreads(users, entityType, csvFormat):

  _GMAIL_ERROR_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.INVALID_MESSAGE_ID: Msg.INVALID_MESSAGE_ID}
  def _handleShowGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    printKeyValueListWithCount([Ent.Singular(entityType), ri[RI_ITEM], errMsg], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    setSysExitRC(AC_FAILED_RC)

  def _handlePrintGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  HEADER_ENCODE_PATTERN = re.compile(r'=\?(.*?)\?Q\?(.*?)\?=')

  def _decodeHeader(header):
    from email.header import decode_header
    header = header.encode(UTF8, u'replace').decode(UTF8)
    while True:
      mg = HEADER_ENCODE_PATTERN.search(header)
      if not mg:
        return header
      header = header[:mg.start()]+decode_header(mg.group())[0][0].decode(mg.group(1)).encode(UTF8)+header[mg.end():]

  def _getBodyData(payload, getOrigMsg):
    data = headers = u''
    for part in payload.get(u'parts', []):
      if getOrigMsg:
        for name in headersToShow:
          for header in part[u'headers']:
            if name == header[u'name'].lower():
              if not headers:
                headers = u'---------- Original message ----------\n'
              headers += SMTP_HEADERS_MAP.get(name, header[u'name'])+u': '+_decodeHeader(header[u'value'])+u'\n'
        if headers:
          headers += u'Body:\n'
          data = Ind.INDENT_SPACES_PER_LEVEL
      if part[u'mimeType'] == u'text/plain':
        if u'data' in part[u'body']:
          data += base64.urlsafe_b64decode(str(part[u'body'][u'data']))+u'\n'
      elif part[u'mimeType'] == u'text/rfc822-headers':
        if u'data' in part[u'body']:
          data += _decodeHeader(base64.urlsafe_b64decode(str(part[u'body'][u'data']))+u'\n')
      else:
        data += _getBodyData(part, part[u'mimeType'] == u'message/rfc822')
    if getOrigMsg:
      data = data.replace(u'\n', u'\n{0}'.format(Ind.INDENT_SPACES_PER_LEVEL)).rstrip()
    return headers+data

  def _getMessageBody(payload):
    if payload[u'body'][u'size']:
      return base64.urlsafe_b64decode(str(payload[u'body'][u'data']))
    data = _getBodyData(payload, False)
    if data:
      return data
    return u'Body not available'

  ATTACHMENT_NAME_PATTERN = re.compile(r'^.*name="(.*?)".*$')

  def _showAttachments(messageId, payload, attachmentNamePattern):
    for part in payload.get(u'parts', []):
      if part[u'mimeType'] == u'text/plain':
        if u'attachmentId' in part[u'body']:
          for header in part[u'headers']:
            if header[u'name'] == u'Content-Type':
              mg = ATTACHMENT_NAME_PATTERN.match(header[u'value'])
              if mg:
                attachmentName = mg.group(1)
              if (not attachmentNamePattern) or attachmentNamePattern.match(attachmentName):
                try:
                  result = callGAPI(gmail.users().messages().attachments(), u'get',
                                    throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                                    messageId=messageId, id=part[u'body'][u'attachmentId'], userId=u'me')
                  if u'data' in result:
                    printKeyValueList([u'Attachment', attachmentName])
                    Ind.Increment()
                    printKeyValueList([Ind.MultiLineText(base64.urlsafe_b64decode(str(result[u'data']))+u'\n')])
                    Ind.Decrement()
                except (GAPI.serviceNotAvailable, GAPI.badRequest, GAPI.notFound):
                  pass
              break
      else:
        _showAttachments(messageId, part, attachmentNamePattern)

  def _showMessage(result, j, jcount):
    printEntity([Ent.MESSAGE, result[u'id']], j, jcount)
    Ind.Increment()
    if show_snippet:
      printKeyValueList([u'Snippet', dehtml(result[u'snippet']).replace(u'\n', u' ')])
    for name in headersToShow:
      for header in result[u'payload'][u'headers']:
        if name == header[u'name'].lower():
          printKeyValueList([SMTP_HEADERS_MAP.get(name, header[u'name']), _decodeHeader(header[u'value'])])
    if show_size:
      printKeyValueList([u'SizeEstimate', result[u'sizeEstimate']])
    if show_labels:
      messageLabels = []
      for labelId in result.get(u'labelIds', []):
        for label in labels[u'labels']:
          if label[u'id'] == labelId:
            messageLabels.append(label[u'name'])
            break
      printKeyValueList([u'Labels', u','.join(messageLabels)])
    if show_body:
      printKeyValueList([u'Body', None])
      Ind.Increment()
      printKeyValueList([Ind.MultiLineText(_getMessageBody(result[u'payload']))])
      Ind.Decrement()
    if show_attachments:
      _showAttachments(result[u'id'], result[u'payload'], attachmentNamePattern)
    Ind.Decrement()

  def _callbackShowMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is  None:
      _showMessage(response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleShowGmailError(exception, ri)

  def _printMessage(user, result):
    row = {u'User': user, u'threadId': result[u'threadId'], u'id': result[u'id']}
    if show_snippet:
      row[u'Snippet'] = dehtml(result[u'snippet']).replace(u'\n', u' ')
    for name in headersToShow:
      j = 0
      for header in result[u'payload'][u'headers']:
        if name == header[u'name'].lower():
          j += 1
          if j == 1:
            row[SMTP_HEADERS_MAP.get(name, header[u'name'])] = _decodeHeader(header[u'value'])
          else:
            row[u'{0} {1}'.format(SMTP_HEADERS_MAP.get(name, header[u'name']), j)] = _decodeHeader(header[u'value'])
    if show_size:
      row[u'SizeEstimate'] = result[u'sizeEstimate']
    if show_labels:
      messageLabels = []
      for labelId in result.get(u'labelIds', []):
        for label in labels[u'labels']:
          if label[u'id'] == labelId:
            messageLabels.append(label[u'name'])
            break
      row[u'Labels'] = delimiter.join(messageLabels)
    if show_body:
      if not convertCRNL:
        row[u'Body'] = _getMessageBody(result[u'payload'])
      else:
        row[u'Body'] = escapeCRsNLs(_getMessageBody(result[u'payload']))
    addRowTitlesToCSVfile(row, csvRows, titles)

  def _callbackPrintMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printMessage(ri[RI_ENTITY], response)
    else:
      _handlePrintGmailError(exception, ri)

  def _showThread(result, j, jcount):
    printEntity([Ent.THREAD, result[u'id']], j, jcount)
    Ind.Increment()
    if show_snippet and u'snippet' in result:
      printKeyValueList([u'Snippet', dehtml(result[u'snippet']).replace(u'\n', u' ')])
    try:
      result = callGAPI(service, u'get',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                        id=result[u'id'], userId=u'me', format=u'metadata')
      kcount = len(result[u'messages'])
      k = 0
      for message in result[u'messages']:
        k += 1
        _showMessage(message, k, kcount)
    except (GAPI.serviceNotAvailable, GAPI.badRequest, GAPI.notFound):
      pass
    Ind.Decrement()

  def _callbackShowThread(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _showThread(response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleShowGmailError(exception, ri)

  def _printThread(user, result):
    try:
      result = callGAPI(service, u'get',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                        id=result[u'id'], userId=u'me', format=u'metadata')
      for message in result[u'messages']:
        _printMessage(user, message)
    except (GAPI.serviceNotAvailable, GAPI.badRequest, GAPI.notFound):
      pass

  def _callbackPrintThread(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printThread(ri[RI_ENTITY], response)
    else:
      _handlePrintGmailError(exception, ri)

  def _batchPrintShowMessagesThreads(service, user, jcount, messageIds, callback):
    svcargs = dict([(u'userId', u'me'), (u'id', None), (u'format', [u'metadata', u'full'][show_body or show_attachments])]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(service, u'get')
    dbatch = gmail.new_batch_http_request(callback=callback)
    bcount = 0
    j = 0
    for messageId in messageIds:
      j += 1
      svcparms = svcargs.copy()
      svcparms[u'id'] = messageId
      dbatch.add(method(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, svcparms[u'id']))
      bcount += 1
      if parameters[u'maxToProcess'] and j == parameters[u'maxToProcess']:
        break
      if bcount == GC.Values[GC.EMAIL_BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = gmail.new_batch_http_request(callback=callback)
        bcount = 0
    if bcount > 0:
      executeBatch(dbatch)

  parameters = _initMessageThreadParameters(entityType, True, 0)
  includeSpamTrash = False
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  countsOnly = show_attachments = show_body = show_labels = show_size = show_snippet = False
  attachmentNamePattern = None
  headersToShow = [u'Date', u'Subject', u'From', u'Reply-To', u'To', u'Delivered-To', u'Content-Type', u'Message-ID']
  if csvFormat:
    todrive = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif _getMessageSelectParameters(myarg, parameters):
      pass
    elif myarg == u'headers':
      headersToShow = getString(Cmd.OB_STRING, minLen=0).replace(u',', u' ').split()
    elif myarg in [u'convertcrnl', u'converttextnl', u'convertbodynl']:
      convertCRNL = True
    elif myarg == u'showbody':
      show_body = True
    elif myarg == u'showlabels':
      show_labels = True
    elif myarg == u'showsize':
      show_size = True
    elif myarg == u'showsnippet':
      show_snippet = True
    elif myarg == u'showattachments':
      show_attachments = True
    elif myarg == u'attachmentnamepattern':
      attachmentNamePattern = getREPattern(re.IGNORECASE)
    elif myarg == u'includespamtrash':
      includeSpamTrash = True
    elif myarg == u'delimiter':
      delimiter = getCharacter()
    elif myarg == u'countsonly':
      countsOnly = True
    else:
      unknownArgumentExit()
  _finalizeMessageSelectParameters(parameters, False)
  if csvFormat:
    if countsOnly:
      headerTitles = [u'User', parameters[u'listType']]
    else:
      headerTitles = [u'User', u'threadId', u'id']
      for j, name in enumerate(headersToShow):
        headersToShow[j] = name.lower()
        headerTitles.append(SMTP_HEADERS_MAP.get(headersToShow[j], name))
    titles, csvRows = initializeTitlesCSVfile(headerTitles)
  else:
    for j, name in enumerate(headersToShow):
      headersToShow[j] = name.lower()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, i, count, parameters[u'messageEntity'])
    if not gmail:
      continue
    service = [gmail.users().threads(), gmail.users().messages()][entityType == Ent.MESSAGE]
    try:
      if show_labels:
        labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
        if not labels:
          continue
      if parameters[u'messageEntity'] is None:
        printGettingAllEntityItemsForWhom(entityType, user, i, count)
        listResult = callGAPIpages(service, u'list', parameters[u'listType'],
                                   page_message=getPageMessage(), maxItems=parameters[u'maxItems'],
                                   throw_reasons=GAPI.GMAIL_THROW_REASONS,
                                   userId=u'me', q=parameters[u'query'], fields=parameters[u'fields'], includeSpamTrash=includeSpamTrash,
                                   maxResults=GC.Values[GC.MESSAGE_MAX_RESULTS])
        messageIds = [message[u'id'] for message in listResult]
      else:
        # Need to get authorization set up for batch
        callGAPI(gmail.users(), u'getProfile',
                 throw_reasons=GAPI.GMAIL_THROW_REASONS,
                 userId=u'me', fields=u'')
      jcount = len(messageIds)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
      if countsOnly:
        if not csvFormat:
          printEntityKVList([Ent.USER, user], [parameters[u'listType'], jcount], i, count)
        else:
          csvRows.append({u'User': user, parameters[u'listType']: jcount})
        continue
      if jcount == 0:
        if not csvFormat:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(entityType)), i, count)
        continue
      if not csvFormat:
        if parameters[u'messageEntity'] is not None or parameters[u'maxToProcess'] == 0 or jcount <= parameters[u'maxToProcess']:
          entityPerformActionNumItems([Ent.USER, user], jcount, entityType, i, count)
        else:
          entityPerformActionNumItemsModifier([Ent.USER, user], parameters[u'maxToProcess'], entityType, u'of {0} Total {1}'.format(jcount, Ent.Plural(entityType)), i, count)
      if parameters[u'messageEntity'] is None and parameters[u'maxToProcess'] and (jcount > parameters[u'maxToProcess']):
        jcount = parameters[u'maxToProcess']
      if not csvFormat:
        Ind.Increment()
        _batchPrintShowMessagesThreads(service, user, jcount, messageIds, [_callbackShowThread, _callbackShowMessage][entityType == Ent.MESSAGE])
        Ind.Decrement()
      else:
        _batchPrintShowMessagesThreads(service, user, jcount, messageIds, [_callbackPrintThread, _callbackPrintMessage][entityType == Ent.MESSAGE])
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    if not countsOnly:
      removeTitlesFromCSVfile([u'Snippet', u'SizeEstimate', u'Labels', u'Body'], titles)
      if show_snippet:
        addTitleToCSVfile(u'Snippet', titles)
      if show_size:
        addTitleToCSVfile(u'SizeEstimate', titles)
      if show_labels:
        addTitleToCSVfile(u'Labels', titles)
      if show_body:
        addTitleToCSVfile(u'Body', titles)
    writeCSVfile(csvRows, titles, u'Messages', todrive)

# gam <UserTypeEntity> print message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_print <Number>] [includespamtrash])|(ids <MessageIDEntity>)
#	[countsonly] [headers <SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl] [delimiter <Character>] [todrive [<ToDriveAttributes>]]
def printMessages(users):
  _printShowMessagesThreads(users, Ent.MESSAGE, True)

# gam <UserTypeEntity> print thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_print <Number>] [includespamtrash])|(ids <ThreadIDEntity>)
#	[countsonly] [headers <SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl] [delimiter <Character>] [todrive [<ToDriveAttributes>]]
def printThreads(users):
  _printShowMessagesThreads(users, Ent.THREAD, True)

# gam <UserTypeEntity> show message|messages (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <MessageIDEntity>)
#	[countsonly] [headers <SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [showattachments [attachmentnamepattern <RegularExpression>]]
def showMessages(users):
  _printShowMessagesThreads(users, Ent.MESSAGE, False)

# gam <UserTypeEntity> show thread|threads (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <ThreadIDEntity>)
#	[countsonly] [headers <SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [showattachments [attachmentnamepattern <RegularExpression>]]
def showThreads(users):
  _printShowMessagesThreads(users, Ent.THREAD, False)

def _checkDelegator(cd, delegatorEmail, i, count, jcount):
  try:
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=delegatorEmail, fields=u'suspended,changePasswordAtNextLogin')
    if result[u'suspended']:
      entityNumEntitiesActionFailedWarning(Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, jcount, Ent.TypeMessage(Ent.DELEGATOR, Msg.IS_SUSPENDED_NO_DELEGATION), i, count)
      setSysExitRC(USER_SUSPENDED_ERROR_RC)
    elif result[u'changePasswordAtNextLogin']:
      entityNumEntitiesActionFailedWarning(Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, jcount, Ent.TypeMessage(Ent.DELEGATOR, Msg.IS_REQD_TO_CHG_PWD_NO_DELEGATION), i, count)
      setSysExitRC(USER_REQUIRED_TO_CHANGE_PASSWORD_ERROR_RC)
    else:
      return True
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError) as e:
    entityNumEntitiesActionFailedWarning(Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, jcount, Ent.TypeMessage(Ent.DELEGATOR, str(e)), i, count)
  return False

def _checkDelegate(cd, delegatorEmail, delegateEmail, j, jcount):
  try:
    result = callGAPI(cd.users(), u'get',
                      throw_reasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=delegateEmail, fields=u'suspended,changePasswordAtNextLogin')
    if result[u'suspended']:
      entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], Ent.TypeMessage(Ent.DELEGATE, Msg.IS_SUSPENDED_NO_DELEGATION), j, jcount)
      setSysExitRC(USER_SUSPENDED_ERROR_RC)
    elif result[u'changePasswordAtNextLogin']:
      entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], Ent.TypeMessage(Ent.DELEGATE, Msg.IS_REQD_TO_CHG_PWD_NO_DELEGATION), j, jcount)
      setSysExitRC(USER_REQUIRED_TO_CHANGE_PASSWORD_ERROR_RC)
    else:
      entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], Msg.GOOGLE_DELEGATION_ERROR, j, jcount)
      setSysExitRC(GOOGLE_API_ERROR_RC)
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError) as e:
    entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], Ent.TypeMessage(Ent.DELEGATE, str(e)), j, jcount)

def _checkDelegatorDelegate(cd, delegatorEmail, delegateEmail, i, count, j, jcount):
  if not _checkDelegator(cd, delegatorEmail, i, count, jcount):
    return False
  _checkDelegate(cd, delegatorEmail, delegateEmail, j, jcount)
  return True

HTTP_400_RESULT_PATTERN = re.compile(r'errorCode="(.*)".*invalidInput="(.*)".*reason="(.*)"')
HTTP_4XX_5XX_RESULT_PATTERN = re.compile(r'<TITLE>(.*)</TITLE>')

# gam <UserTypeEntity> delegate to <UserEntity>
def delegateTo(users, checkForTo=True):
  cd = buildGAPIObject(API.DIRECTORY)
  emailSettings = buildGAPIObject(API.EMAIL_SETTINGS)
  if checkForTo:
    checkArgumentPresent(u'to', required=True)
  delegateEntity = getUserObjectEntity(Cmd.OB_USER_ENTITY, Ent.DELEGATE)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    delegatorEmail, delegatorName, delegatorDomain, delegates, jcount = _validateDelegatorGetObjectList(user, i, count, delegateEntity)
    Ind.Increment()
    j = 0
    for delegate in delegates:
      j += 1
      delegateEmail = convertUIDtoEmailAddress(delegate, cd=cd)
      uri = u'https://apps-apis.google.com/a/feeds/emailsettings/2.0/{0}/{1}/delegation'.format(delegatorDomain, delegatorName)
      body = u'''<?xml version="1.0" encoding="utf-8"?>
  <atom:entry xmlns:atom="http://www.w3.org/2005/Atom" xmlns:apps="http://schemas.google.com/apps/2006">
  <apps:property name="address" value="{0}" />
  </atom:entry>'''.format(delegateEmail)
      headers = {u'GData-Version': u'2.0', u'Content-Type': u'application/atom+xml; charset=UTF-8'}
      retries = 10
      delegatorOK = True
      for n in range(1, retries+1):
        status, result = emailSettings._http.request(uri=uri, method=u'POST', body=body, headers=headers)
        httpStatus = int(status[u'status'])
        if httpStatus == 201: # Success
          entityActionPerformed([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], j, jcount)
          time.sleep(10) # on success, sleep 10 seconds before exiting or moving on to next user to prevent ghost delegates
          break
        if httpStatus == 400:
          tg = HTTP_400_RESULT_PATTERN.search(str(result))
          if tg is not None:
            errorCode = int(tg.group(1))
            invalidInput = tg.group(2)
            reason = tg.group(3)
            if errorCode == GDATA.DOES_NOT_EXIST:
              delegatorOK = _checkDelegatorDelegate(cd, delegatorEmail, delegateEmail, i, count, j, jcount)
            elif errorCode == GDATA.NAME_NOT_VALID:
              entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail],
                                        Ent.TypeMessage(Ent.DELEGATE, Msg.ENTITY_NAME_NOT_VALID), j, jcount)
            elif errorCode == GDATA.ENTITY_EXISTS:
              entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail],
                                        Ent.TypeMessage(Ent.DELEGATE, Msg.DUPLICATE), j, jcount)
            else:
              if not invalidInput:
                delegatorOK = False
                entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail],
                                          Ent.TypeMessage(Ent.DELEGATOR, u'errorCode: {0}, reason: {1}'.format(errorCode, reason)), i, count)
              else:
                entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail],
                                          Ent.TypeMessage(Ent.DELEGATE, u'errorCode: {0}, reason: {1}'.format(errorCode, reason)), j, jcount)
          else:
            delegatorOK = _checkDelegatorDelegate(cd, delegatorEmail, delegateEmail, i, count, j, jcount)
          break
        if httpStatus < 500:
          delegatorOK = _checkDelegatorDelegate(cd, delegatorEmail, delegateEmail, i, count, j, jcount)
          break
        tg = HTTP_4XX_5XX_RESULT_PATTERN.search(str(result))
        reason = tg.group(1) if tg is not None else u'Unknown Error'
        waitOnFailure(n, retries, httpStatus, reason)
      else: #retries exceeded
        delegatorOK = _checkDelegatorDelegate(cd, delegatorEmail, delegateEmail, i, count, j, jcount)
      if not delegatorOK:
        break
    Ind.Decrement()

# gam <UserTypeEntity> create|add delegate|delegates <UserEntity>
def createDelegate(users):
  delegateTo(users, checkForTo=False)

# gam <UserTypeEntity> delete delegate|delegates <UserEntity>
def deleteDelegate(users):

# Add domain to foo or convert uid:xxx to foo. Return foo@bar.com
  def addDomainToEmailAddressOrUID(emailAddressOrUID, addDomain):
    cg = UID_PATTERN.match(emailAddressOrUID)
    if cg:
      try:
        result = callGAPI(cd.users(), u'get',
                          throw_reasons=GAPI.USER_GET_THROW_REASONS,
                          userKey=cg.group(1), fields=u'primaryEmail')
        if u'primaryEmail' in result:
          return result[u'primaryEmail'].lower()
      except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
        pass
      return None
    atLoc = emailAddressOrUID.find(u'@')
    if atLoc == -1:
      return u'{0}@{1}'.format(emailAddressOrUID, addDomain)
    if atLoc == len(emailAddressOrUID)-1:
      return u'{0}{1}'.format(emailAddressOrUID, addDomain)
    return emailAddressOrUID

  cd = buildGAPIObject(API.DIRECTORY)
  emailSettings = buildGAPIObject(API.EMAIL_SETTINGS)
  delegateEntity = getUserObjectEntity(Cmd.OB_USER_ENTITY, Ent.DELEGATE)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    delegatorEmail, delegatorName, delegatorDomain, delegates, jcount = _validateDelegatorGetObjectList(user, i, count, delegateEntity)
    Ind.Increment()
    j = 0
    for delegate in delegates:
      j += 1
      delegateEmail = addDomainToEmailAddressOrUID(delegate, delegatorDomain)
      if not delegateEmail:
        entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegate], Msg.DOES_NOT_EXIST, j, jcount)
        continue
      try:
        callGAPI(emailSettings.delegates(), u'delete',
                 throw_reasons=[GAPI.NOT_FOUND, GAPI.SERVICE_NOT_AVAILABLE, GAPI.DOMAIN_NOT_FOUND, GAPI.INVALID_INPUT],
                 v=u'2.0', delegator=delegatorName, domainName=delegatorDomain, delegate=delegateEmail)
        entityActionPerformed([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], j, jcount)
      except (GAPI.notFound, GAPI.serviceNotAvailable, GAPI.domainNotFound):
        if not _checkDelegatorDelegate(cd, delegatorEmail, delegateEmail, i, count, j, jcount):
          break
      except GAPI.invalidInput as e:
        entityActionFailedWarning([Ent.DELEGATOR, delegatorEmail, Ent.DELEGATE, delegateEmail], str(e), j, jcount)
    Ind.Decrement()

DELEGATES_FIELD_TITLES_MAP = {
  u'user': [u'User', u'Delegator'],
  u'delegateName': [u'delegateName', u'Delegate'],
  u'delegateAddress': [u'delegateAddress', u'Delegate Email'],
  u'delegationStatus': [u'delegationStatus', u'Status'],
  }
DELEGATE_FIELD_PRINT_ORDER = [u'user', u'delegateName', u'delegateAddress', u'delegationStatus']

def _printShowDelegates(users, csvFormat):

  def getDelegateFields(delegate):
    delegateName = u''
    delegateAddress = u''
    delegationStatus = u''
    for item in delegate[u'apps$property']:
      if item[u'name'] == u'delegate':
        delegateName = item[u'value']
      elif item[u'name'] == u'address':
        delegateAddress = item[u'value']
      elif item[u'name'] == u'status':
        delegationStatus = item[u'value']
    return delegateName, delegateAddress, delegationStatus

  emailSettings = buildGAPIObject(API.EMAIL_SETTINGS)
  if csvFormat:
    todrive = {}
    titlesList = []
    titleIndex = [1, 0][GC.Values[GC.PRINT_NATIVE_NAMES]]
    fieldsTitles = {}
    for field in DELEGATE_FIELD_PRINT_ORDER:
      fieldsTitles[field] = DELEGATES_FIELD_TITLES_MAP[field][titleIndex]
      titlesList.append(fieldsTitles[field])
    titles, csvRows = initializeTitlesCSVfile(titlesList)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    delegatorEmail, delegatorName, delegatorDomain = splitEmailAddressOrUID(user)
    if csvFormat:
      printGettingAllEntityItemsForWhom(Ent.DELEGATE, delegatorEmail, i, count)
    try:
      result = callGAPI(emailSettings.delegates(), u'get',
                        throw_reasons=[GAPI.NOT_FOUND, GAPI.SERVICE_NOT_AVAILABLE, GAPI.DOMAIN_NOT_FOUND],
                        v=u'2.0', delegator=delegatorName, domainName=delegatorDomain)
      if result is not None and u'feed' in result and u'entry' in result[u'feed']:
        delegates = result[u'feed'][u'entry']
      else:
        delegates = []
      jcount = len(delegates)
      if not csvFormat:
        entityPerformActionNumItems([Ent.DELEGATOR, delegatorEmail], jcount, Ent.DELEGATE, i, count)
        Ind.Increment()
        j = 0
        for delegate in delegates:
          j += 1
          delegateName, delegateAddress, delegationStatus = getDelegateFields(delegate)
          printEntity([Ent.DELEGATE, delegateName], j, jcount)
          Ind.Increment()
          printKeyValueList([u'Delegate Email', delegateAddress])
          printKeyValueList([u'Status', delegationStatus])
          Ind.Decrement()
        Ind.Decrement()
      else:
        if delegates:
          for delegate in delegates:
            delegateName, delegateAddress, delegationStatus = getDelegateFields(delegate)
            csvRows.append({fieldsTitles[u'user']: delegatorEmail, fieldsTitles[u'delegateName']: delegateName,
                            fieldsTitles[u'delegateAddress']: delegateAddress, fieldsTitles[u'delegationStatus']: delegationStatus})
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvRows.append({fieldsTitles[u'user']: delegatorEmail})
    except (GAPI.notFound, GAPI.serviceNotAvailable, GAPI.domainNotFound):
      entityServiceNotApplicableWarning(Ent.DELEGATOR, delegatorEmail, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Delegates', todrive)

# gam <UserTypeEntity> print delegates|delegate [todrive [<ToDriveAttributes>]]
def printDelegates(users):
  _printShowDelegates(users, True)

# gam <UserTypeEntity> show delegates|delegate
def showDelegates(users):
  _printShowDelegates(users, False)

FILTER_ADD_LABEL_TO_ARGUMENT_MAP = {
  u'IMPORTANT': u'important',
  u'STARRED': u'star',
  u'TRASH': u'trash',
  }

FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP = {
  u'IMPORTANT': u'notimportant',
  u'INBOX': u'archive',
  u'SPAM': u'neverspam',
  u'UNREAD': u'markread',
  }

def _printFilter(user, userFilter, labels):
  row = {u'User': user, u'id': userFilter[u'id']}
  if u'criteria' in userFilter:
    for item in userFilter[u'criteria']:
      if item in [u'hasAttachment', u'excludeChats']:
        row[item] = item
      elif item == u'size':
        row[item] = u'size {0} {1}'.format(userFilter[u'criteria'][u'sizeComparison'], formatMaxMessageBytes(userFilter[u'criteria'][item]))
      elif item == u'sizeComparison':
        pass
      else:
        row[item] = u'{0} {1}'.format(item, userFilter[u'criteria'][item])
  else:
    row[u'error'] = u'NoCriteria'
  if u'action' in userFilter:
    for labelId in userFilter[u'action'].get(u'addLabelIds', []):
      if labelId in FILTER_ADD_LABEL_TO_ARGUMENT_MAP:
        row[FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]] = FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]
      else:
        row[u'label'] = u'label {0}'.format(_getLabelName(labels, labelId))
    for labelId in userFilter[u'action'].get(u'removeLabelIds', []):
      if labelId in FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP:
        row[FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]] = FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]
    if userFilter[u'action'].get(u'forward'):
      row[u'forward'] = u'forward {0}'.format(userFilter[u'action'][u'forward'])
  else:
    row[u'error'] = u'NoActions'
  return row

def _showFilter(userFilter, j, jcount, labels):
  printEntity([Ent.FILTER, userFilter[u'id']], j, jcount)
  Ind.Increment()
  printEntitiesCount(Ent.CRITERIA, None)
  Ind.Increment()
  if u'criteria' in userFilter:
    for item in sorted(userFilter[u'criteria']):
      if item in [u'hasAttachment', u'excludeChats']:
        printKeyValueList([item])
      elif item == u'size':
        printKeyValueList([u'{0} {1} {2}'.format(item, userFilter[u'criteria'][u'sizeComparison'], formatMaxMessageBytes(userFilter[u'criteria'][item]))])
      elif item == u'sizeComparison':
        pass
      else:
        printKeyValueList([u'{0} "{1}"'.format(item, userFilter[u'criteria'][item])])
  else:
    printKeyValueList([ERROR, Msg.NO_FILTER_CRITERIA.format(Ent.Singular(Ent.FILTER))])
  Ind.Decrement()
  printEntitiesCount(Ent.ACTION, None)
  Ind.Increment()
  if u'action' in userFilter:
    for labelId in sorted(userFilter[u'action'].get(u'addLabelIds', [])):
      if labelId in FILTER_ADD_LABEL_TO_ARGUMENT_MAP:
        printKeyValueList([FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]])
      else:
        printKeyValueList([u'label "{0}"'.format(_getLabelName(labels, labelId))])
    for labelId in sorted(userFilter[u'action'].get(u'removeLabelIds', [])):
      if labelId in FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP:
        printKeyValueList([FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]])
    Ind.Decrement()
    if userFilter[u'action'].get(u'forward'):
      printEntity([Ent.FORWARDING_ADDRESS, userFilter[u'action'][u'forward']])
  else:
    printKeyValueList([ERROR, Msg.NO_FILTER_ACTIONS.format(Ent.Singular(Ent.FILTER))])
    Ind.Decrement()
  Ind.Decrement()
#
FILTER_CRITERIA_CHOICE_MAP = {
  u'excludechats': u'excludeChats',
  u'from': u'from',
  u'hasattachment': u'hasAttachment',
  u'haswords': u'query',
  u'musthaveattachment': u'hasAttachment',
  u'negatedquery': u'negatedQuery',
  u'nowords': u'negatedQuery',
  u'query': u'query',
  u'size': u'size',
  u'subject': u'subject',
  u'to': u'to',
  }
FILTER_ADD_LABEL_ACTIONS = [u'important', u'star', u'trash']
FILTER_REMOVE_LABEL_ACTIONS = [u'markread', u'notimportant', u'archive', u'neverspam']
FILTER_ACTION_CHOICES = FILTER_ADD_LABEL_ACTIONS+FILTER_REMOVE_LABEL_ACTIONS+[u'forward', u'label',]
FILTER_ACTION_LABEL_MAP = {
  u'archive': u'INBOX',
  u'important': u'IMPORTANT',
  u'markread': u'UNREAD',
  u'neverspam': u'SPAM',
  u'notimportant': u'IMPORTANT',
  u'star': u'STARRED',
  u'trash': u'TRASH',
  }

# gam <UserTypeEntity> [create|add] filter <FilterCriteria>+ <FilterAction>+
def createFilter(users):
  body = {}
  addLabelName = None
  addLabelIds = []
  removeLabelIds = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in FILTER_CRITERIA_CHOICE_MAP:
      myarg = FILTER_CRITERIA_CHOICE_MAP[myarg]
      body.setdefault(u'criteria', {})
      if myarg in [u'from', u'to']:
        body[u'criteria'][myarg] = getEmailAddress(noUid=True)
      elif myarg in [u'subject', u'query', u'negatedQuery']:
        body[u'criteria'][myarg] = getString(Cmd.OB_STRING)
      elif myarg in [u'hasAttachment', u'excludeChats']:
        body[u'criteria'][myarg] = True
      elif myarg == u'size':
        body[u'criteria'][u'sizeComparison'] = getChoice([u'larger', u'smaller'])
        body[u'criteria'][myarg] = getMaxMessageBytes()
    elif myarg in FILTER_ACTION_CHOICES:
      body.setdefault(u'action', {})
      if myarg in FILTER_ADD_LABEL_ACTIONS:
        addLabelIds.append(myarg)
        if (myarg == u'important') and (u'notimportant' in removeLabelIds):
          removeLabelIds.remove(u'notimportant')
      elif myarg in FILTER_REMOVE_LABEL_ACTIONS:
        removeLabelIds.append(myarg)
        if (myarg == u'notimportant') and (u'important' in addLabelIds):
          addLabelIds.remove(u'important')
      elif myarg == u'forward':
        body[u'action'][u'forward'] = getEmailAddress(noUid=True)
      else: #elif myarg == u'label':
        addLabelName = getString(Cmd.OB_LABEL_NAME)
    else:
      unknownArgumentExit()
  if u'criteria' not in body:
    missingChoiceExit(FILTER_CRITERIA_CHOICE_MAP)
  if u'action' not in body:
    missingChoiceExit(FILTER_ACTION_CHOICES)
  if removeLabelIds:
    body[u'action'][u'removeLabelIds'] = [FILTER_ACTION_LABEL_MAP[action] for action in FILTER_REMOVE_LABEL_ACTIONS if action in removeLabelIds]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
    if not labels:
      continue
    try:
      if addLabelIds:
        body[u'action'][u'addLabelIds'] = [FILTER_ACTION_LABEL_MAP[action] for action in FILTER_ADD_LABEL_ACTIONS if action in addLabelIds]
      if addLabelName:
        if not addLabelIds:
          body[u'action'][u'addLabelIds'] = []
        addLabelId = _getLabelId(labels, addLabelName)
        if not addLabelId:
          result = callGAPI(gmail.users().labels(), u'create',
                            throw_reasons=GAPI.GMAIL_THROW_REASONS,
                            userId=u'me', body={u'name': addLabelName}, fields=u'id')
          addLabelId = result[u'id']
        body[u'action'][u'addLabelIds'].append(addLabelId)
      result = callGAPI(gmail.users().settings().filters(), u'create',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_ARGUMENT, GAPI.FAILED_PRECONDITION],
                        userId=u'me', body=body, fields=u'id')
      if result:
        entityActionPerformed([Ent.USER, user, Ent.FILTER, result[u'id']], i, count)
    except (GAPI.invalidArgument, GAPI.failedPrecondition) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.FILTER, u''], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete filter <FilterIDEntity>
def deleteFilters(users):
  filterIdEntity = getUserObjectEntity(Cmd.OB_FILTER_ID_ENTITY, Ent.FILTER)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, filterIds, jcount = _validateUserGetObjectList(user, i, count, filterIdEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for filterId in filterIds:
      j += 1
      try:
        callGAPI(gmail.users().settings().filters(), u'delete',
                 throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                 userId=u'me', id=filterId)
        entityActionPerformed([Ent.USER, user, Ent.FILTER, filterId], j, jcount)
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.FILTER, filterId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> info filters <FilterIDEntity>
def infoFilters(users):
  filterIdEntity = getUserObjectEntity(Cmd.OB_FILTER_ID_ENTITY, Ent.FILTER)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, filterIds, jcount = _validateUserGetObjectList(user, i, count, filterIdEntity)
    if jcount == 0:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
    if not labels:
      continue
    Ind.Increment()
    j = 0
    for filterId in filterIds:
      j += 1
      try:
        result = callGAPI(gmail.users().settings().filters(), u'get',
                          throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                          userId=u'me', id=filterId)
        printEntityKVList([Ent.USER, user],
                          [Ent.Singular(Ent.FILTER), result[u'id']],
                          i, count)
        Ind.Increment()
        _showFilter(result, j, jcount, labels)
        Ind.Decrement()
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.FILTER, filterId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

def _printShowFilters(users, csvFormat):
  labelIdsOnly = False
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'id'])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'labelidsonly':
      labelIdsOnly = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if not labelIdsOnly:
      labels = _getUserGmailLabels(gmail, user, i, count, fields=u'labels(id,name)')
      if not labels:
        continue
    else:
      labels = {u'labels': []}
    try:
      results = callGAPIitems(gmail.users().settings().filters(), u'list', u'filter',
                              throw_reasons=GAPI.GMAIL_THROW_REASONS,
                              userId=u'me')
      jcount = len(results)
      if not csvFormat:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.FILTER, i, count)
        Ind.Increment()
        j = 0
        for userFilter in results:
          j += 1
          _showFilter(userFilter, j, jcount, labels)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.FILTER, user, i, count)
        if results:
          for userFilter in results:
            addRowTitlesToCSVfile(_printFilter(user, userFilter, labels), csvRows, titles)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvRows.append({u'User': user})
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Filters', todrive, [u'User', u'id'])

# gam <UserTypeEntity> print filters [labelidsonly] [todrive [<ToDriveAttributes>]]
def printFilters(users):
  _printShowFilters(users, True)

# gam <UserTypeEntity> show filters [labelidsonly]
def showFilters(users):
  _printShowFilters(users, False)

EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP = {
  u'ARCHIVE': u'archive',
  u'DELETE': u'trash',
  u'KEEP': u'leaveInInBox',
  u'MARK_READ': u'markRead',
  u'archive': u'ARCHIVE',
  u'trash': u'DELETE',
  u'leaveInInbox': u'KEEP',
  u'markRead': u'MARK_READ',
  }

def _showForward(user, i, count, result):
  if u'enabled' in result:
    enabled = result[u'enabled']
    kvList = [Ent.Singular(Ent.FORWARD_ENABLED), enabled]
    if enabled:
      kvList += [Ent.Singular(Ent.FORWARDING_ADDRESS), result[u'emailAddress']]
      kvList += [Ent.Singular(Ent.ACTION), result[u'disposition']]
  else:
    enabled = result[u'enable'] == u'true'
    kvList = [Ent.Singular(Ent.FORWARD_ENABLED), enabled]
    if enabled:
      kvList += [Ent.Singular(Ent.FORWARDING_ADDRESS), result[u'forwardTo']]
      kvList += [Ent.Singular(Ent.ACTION), EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP[result[u'action']]]
  printEntityKVList([Ent.USER, user], kvList, i, count)

EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP = {
  u'archive': u'archive',
  u'delete': u'trash',
  u'keep': u'leaveInInbox',
  u'leaveininbox': u'leaveInInbox',
  u'markread': u'markRead',
  u'trash': u'trash',
  }

# gam <UserTypeEntity> forward <FalseValues>
# gam <UserTypeEntity> forward <TrueValues> keep|leaveininbox|archive|delete|trash|markread <EmailAddress>
def setForward(users):
  enable = getBoolean(None)
  body = {u'enabled': enable}
  if enable:
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP:
        body[u'disposition'] = EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP[myarg]
      elif myarg == u'confirm':
        deprecatedArgument(myarg)
      elif myarg.find(u'@') != -1:
        body[u'emailAddress'] = normalizeEmailAddressOrUID(Cmd.Previous())
      else:
        unknownArgumentExit()
    if not body.get(u'disposition'):
      missingChoiceExit(EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP)
    if not body.get(u'emailAddress'):
      missingArgumentExit(Cmd.OB_EMAIL_ADDRESS)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updateAutoForwarding',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.FAILED_PRECONDITION],
                        userId=u'me', body=body)
      _showForward(user, i, count, result)
    except GAPI.failedPrecondition as e:
      entityActionFailedWarning([Ent.USER, user, Ent.FORWARDING_ADDRESS, body[u'emailAddress']], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _printShowForward(users, csvFormat):
  def _printForward(user, result, showDisabled):
    if u'enabled' in result:
      enabled = result[u'enabled']
      if not enabled and not showDisabled:
        return
      row = {u'User': user, u'forwardEnabled': enabled}
      if enabled:
        row[u'forwardTo'] = result[u'emailAddress']
        row[u'disposition'] = result[u'disposition']
    else:
      enabled = result[u'enable'] == u'true'
      if not enabled and not showDisabled:
        return
      row = {u'User': user, u'forwardEnabled': enabled}
      if enabled:
        row[u'forwardTo'] = result[u'forwardTo']
        row[u'disposition'] = EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP[result[u'action']]
    csvRows.append(row)

  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'forwardEnabled', u'forwardTo', u'disposition'])
  showDisabled = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif csvFormat and myarg == u'enabledonly':
      showDisabled = False
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getAutoForwarding',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me')
      if not csvFormat:
        _showForward(user, i, count, result)
      else:
        printGettingEntityItemForWhom(Ent.FORWARD_ENABLED, user, i, count)
        _printForward(user, result, showDisabled)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Forward', todrive)

# gam <UserTypeEntity> print forward [enabledonly] [todrive [<ToDriveAttributes>]]
def printForward(users):
  _printShowForward(users, True)

# gam <UserTypeEntity> show forward
def showForward(users):
  _printShowForward(users, False)

# Process ForwardingAddresses functions
def _showForwardingAddress(j, jcount, result):
  printEntityKVList([Ent.FORWARDING_ADDRESS, result[u'forwardingEmail']], [u'Verification Status', result[u'verificationStatus']], j, jcount)

def _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, function, **kwargs):
  userDefined = True
  try:
    result = callGAPI(gmail.users().settings().forwardingAddresses(), function,
                      throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.ALREADY_EXISTS, GAPI.DUPLICATE],
                      userId=u'me', **kwargs)
    if function == u'get':
      _showForwardingAddress(j, count, result)
    else:
      entityActionPerformed([Ent.USER, user, Ent.FORWARDING_ADDRESS, emailAddress], j, jcount)
  except (GAPI.notFound, GAPI.alreadyExists, GAPI.duplicate) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.FORWARDING_ADDRESS, emailAddress], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    userDefined = False
  return userDefined

# gam <UserTypeEntity> create|add forwardingaddresses <EmailAddressEntity>
def createForwardingAddresses(users):
  emailAddressEntity = getUserObjectEntity(Cmd.OB_EMAIL_ADDRESS_ENTITY, Ent.FORWARDING_ADDRESS)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      body = {u'forwardingEmail': emailAddress}
      if not _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, u'create', body=body, fields=u''):
        break
    Ind.Decrement()

def _deleteInfoForwardingAddreses(users, function):
  emailAddressEntity = getUserObjectEntity(Cmd.OB_EMAIL_ADDRESS_ENTITY, Ent.FORWARDING_ADDRESS)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      if not _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, function, forwardingEmail=emailAddress):
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete forwardingaddresses <EmailAddressEntity>
def deleteForwardingAddresses(users):
  _deleteInfoForwardingAddreses(users, u'delete')

# gam <UserTypeEntity> info forwardingaddresses <EmailAddressEntity>
def infoForwardingAddresses(users):
  _deleteInfoForwardingAddreses(users, u'get')

def _printShowForwardingAddresses(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'forwardingEmail', u'verificationStatus'])
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      results = callGAPIitems(gmail.users().settings().forwardingAddresses(), u'list', u'forwardingAddresses',
                              throw_reasons=GAPI.GMAIL_THROW_REASONS,
                              userId=u'me')
      jcount = len(results)
      if not csvFormat:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.FORWARDING_ADDRESS, i, count)
        Ind.Increment()
        j = 0
        for forward in results:
          j += 1
          _showForwardingAddress(j, jcount, forward)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.FORWARDING_ADDRESS, user, i, count)
        if results:
          for forward in results:
            csvRows.append({u'User': user, u'forwardingEmail': forward[u'forwardingEmail'], u'verificationStatus': forward[u'verificationStatus']})
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvRows.append({u'User': user})
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Forwarding Addresses', todrive)

# gam <UserTypeEntity> print forwardingaddresses [todrive [<ToDriveAttributes>]]
def printForwardingAddresses(users):
  _printShowForwardingAddresses(users, True)

# gam <UserTypeEntity> show forwardingaddresses
def showForwardingAddresses(users):
  _printShowForwardingAddresses(users, False)

def _showImap(user, i, count, result):
  enabled = result[u'enabled']
  kvList = [Ent.Singular(Ent.IMAP_ENABLED), enabled]
  if enabled:
    for item in result:
      if item != u'enabled':
        kvList += [item, result[item]]
  printEntityKVList([Ent.USER, user], kvList, i, count)
#
EMAILSETTINGS_IMAP_EXPUNGE_BEHAVIOR_CHOICE_MAP = {
  u'archive': u'archive',
  u'deleteforever': u'deleteForever',
  u'trash': u'trash',
  }

EMAILSETTINGS_IMAP_MAX_FOLDER_SIZE_CHOICES = [u'0', u'1000', u'2000', u'5000', u'10000']

# gam <UserTypeEntity> imap|imap4 <Boolean> [noautoexpunge] [expungebehavior archive|deleteforever|trash] [maxfoldersize 0|1000|2000|5000|10000]
def setImap(users):
  enable = getBoolean(None)
  body = {u'enabled': enable, u'autoExpunge': True, u'expungeBehavior': u'archive', u'maxFolderSize': 0}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'noautoexpunge':
      body[u'autoExpunge'] = False
    elif myarg == u'expungebehavior':
      body[u'expungeBehavior'] = getChoice(EMAILSETTINGS_IMAP_EXPUNGE_BEHAVIOR_CHOICE_MAP, mapChoice=True)
    elif myarg == u'maxfoldersize':
      body[u'maxFolderSize'] = int(getChoice(EMAILSETTINGS_IMAP_MAX_FOLDER_SIZE_CHOICES))
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updateImap',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me', body=body)
      _showImap(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> show imap|imap4
def showImap(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getImap',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me')
      _showImap(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _showPop(user, i, count, result):
  enabled = result[u'accessWindow'] != u'disabled'
  kvList = [Ent.Singular(Ent.POP_ENABLED), enabled]
  if enabled:
    kvList += [u'For', result[u'accessWindow'], Ent.Singular(Ent.ACTION), result[u'disposition']]
  printEntityKVList([Ent.USER, user], kvList, i, count)
#
EMAILSETTINGS_POP_ENABLE_FOR_CHOICE_MAP = {
  u'allmail': u'allMail',
  u'fromnowon': u'fromNowOn',
  u'mailfromnowon': u'fromNowOn',
  u'newmail': u'fromNowOn',
  }

# gam <UserTypeEntity> pop|pop3 <Boolean> [for allmail|newmail|mailfromnowon|fromnowown] [action keep|leaveininbox|archive|delete|trash|markread]
def setPop(users):
  enable = getBoolean(None)
  body = {u'accessWindow': [u'disabled', u'allMail'][enable], u'disposition': u'leaveInInbox'}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'for':
      body[u'accessWindow'] = getChoice(EMAILSETTINGS_POP_ENABLE_FOR_CHOICE_MAP, mapChoice=True)
    elif myarg == u'action':
      body[u'disposition'] = getChoice(EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP, mapChoice=True)
    elif myarg == u'confirm':
      deprecatedArgument(myarg)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'updatePop',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me', body=body)
      _showPop(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> show pop|pop3
def showPop(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getPop',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me')
      _showPop(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _showSendAs(result, j, jcount, formatSig):
  if result[u'displayName']:
    printEntity([Ent.SENDAS_ADDRESS, u'{0} <{1}>'.format(result[u'displayName'], result[u'sendAsEmail'])], j, jcount)
  else:
    printEntity([Ent.SENDAS_ADDRESS, u'<{0}>'.format(result[u'sendAsEmail'])], j, jcount)
  Ind.Increment()
  if result.get(u'replyToAddress'):
    printKeyValueList([u'ReplyTo', result[u'replyToAddress']])
  printKeyValueList([u'IsPrimary', result.get(u'isPrimary', False)])
  printKeyValueList([u'Default', result.get(u'isDefault', False)])
  if not result.get(u'isPrimary', False):
    printKeyValueList([u'TreatAsAlias', result.get(u'treatAsAlias', False)])
    printKeyValueList([u'Verification Status', result.get(u'verificationStatus', u'unspecified')])
  if formatSig:
    printKeyValueList([u'Signature', None])
    Ind.Increment()
    signature = result.get(u'signature')
    if not signature:
      signature = u'None'
    printKeyValueList([Ind.MultiLineText(dehtml(signature))])
    Ind.Decrement()
  else:
    signature = result.get(u'signature')
    if not signature:
      signature = u'None'
    printKeyValueList([u'Signature', escapeCRsNLs(signature)])
  Ind.Decrement()

def _processSignature(tagReplacements, signature, html):
  if signature:
    signature = signature.replace(u'\r', u'').replace(u'\\n', u'<br/>')
    if tagReplacements[u'tags']:
      signature = _processTagReplacements(tagReplacements, signature)
    if not html:
      signature = signature.replace(u'\n', u'<br/>')
  return signature

# Process SendAs functions
def _processSendAs(user, i, count, entityType, emailAddress, j, jcount, gmail, function, formatSig, **kwargs):
  userDefined = True
  try:
    result = callGAPI(gmail.users().settings().sendAs(), function,
                      throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.ALREADY_EXISTS, GAPI.DUPLICATE, GAPI.CANNOT_DELETE_PRIMARY_SENDAS, GAPI.INVALID_ARGUMENT],
                      userId=u'me', **kwargs)
    if function == u'get':
      _showSendAs(result, j, jcount, formatSig)
    else:
      entityActionPerformed([Ent.USER, user, entityType, emailAddress], j, jcount)
  except (GAPI.notFound, GAPI.alreadyExists, GAPI.duplicate, GAPI.cannotDeletePrimarySendAs, GAPI.invalidArgument) as e:
    entityActionFailedWarning([Ent.USER, user, entityType, emailAddress], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    userDefined = False
  return userDefined

def getSendAsAttributes(myarg, body, tagReplacements):
  if myarg == u'replace':
    _getTagReplacement(tagReplacements, True)
  elif myarg == u'name':
    body[u'displayName'] = getString(Cmd.OB_NAME, minLen=0)
  elif myarg == u'replyto':
    body[u'replyToAddress'] = getEmailAddress(noUid=True, minLen=0)
  elif myarg == u'default':
    body[u'isDefault'] = True
  elif myarg == u'treatasalias':
    body[u'treatAsAlias'] = getBoolean()
  else:
    unknownArgumentExit()

def _createUpdateSendAs(users, addCmd):
  emailAddress = getEmailAddress(noUid=True)
  if addCmd:
    body = {u'sendAsEmail': emailAddress, u'displayName': getString(Cmd.OB_NAME)}
  else:
    body = {}
  signature = None
  tagReplacements = _initTagReplacements()
  html = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [u'signature', u'sig']:
      if checkArgumentPresent(u'file'):
        filename = getString(Cmd.OB_FILE_NAME)
        encoding = getCharSet()
        signature = readFile(filename, encoding=encoding)
      else:
        signature = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == u'html':
      html = getBoolean()
    else:
      getSendAsAttributes(myarg, body, tagReplacements)
  if signature is not None and not tagReplacements[u'subs']:
    body[u'signature'] = _processSignature(tagReplacements, signature, html)
  kwargs = {u'body': body, u'fields': u''}
  if not addCmd:
    kwargs[u'sendAsEmail'] = emailAddress
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if signature is not None and tagReplacements[u'subs']:
      _getTagReplacementFieldValues(user, i, count, tagReplacements)
      kwargs[u'body'][u'signature'] = _processSignature(tagReplacements, signature, html)
    _processSendAs(user, i, count, Ent.SENDAS_ADDRESS, emailAddress, i, count, gmail, [u'patch', u'create'][addCmd], False, **kwargs)

# gam <UserTypeEntity> [create|add] sendas <EmailAddress> <String> [signature|sig <String>|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)*]
#	[html [<Boolean>]] [replyto <EmailAddress>] [default] [treatasalias <Boolean>]
def createSendAs(users):
  _createUpdateSendAs(users, True)

# gam <UserTypeEntity> update sendas <EmailAddress> [name <String>] [signature|sig <String>|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)*]
#	[html [<Boolean>]] [replyto <EmailAddress>] [default] [treatasalias <Boolean>]
def updateSendAs(users):
  _createUpdateSendAs(users, False)

def _deleteInfoSendAs(users, function):
  emailAddressEntity = getUserObjectEntity(Cmd.OB_EMAIL_ADDRESS_ENTITY, Ent.SENDAS_ADDRESS)
  formatSig = False
  if function == u'get':
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'format':
        formatSig = True
      else:
        unknownArgumentExit()
  else:
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      if not _processSendAs(user, i, count, Ent.SENDAS_ADDRESS, emailAddress, j, jcount, gmail, function, formatSig, sendAsEmail=emailAddress):
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete sendas <EmailAddressEntity>
def deleteSendAs(users):
  _deleteInfoSendAs(users, u'delete')

# gam <UserTypeEntity> info sendas <EmailAddressEntity> [format]
def infoSendAs(users):
  _deleteInfoSendAs(users, u'get')

def _printShowSendAs(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'displayName', u'sendAsEmail', u'replyToAddress', u'isPrimary', u'isDefault', u'treatAsAlias', u'verificationStatus'])
  formatSig = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif not csvFormat and myarg == u'format':
      formatSig = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      results = callGAPIitems(gmail.users().settings().sendAs(), u'list', u'sendAs',
                              throw_reasons=GAPI.GMAIL_THROW_REASONS,
                              userId=u'me')
      jcount = len(results)
      if not csvFormat:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.SENDAS_ADDRESS, i, count)
        Ind.Increment()
        j = 0
        for sendas in results:
          j += 1
          _showSendAs(sendas, j, jcount, formatSig)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.SENDAS_ADDRESS, user, i, count)
        if results:
          for sendas in results:
            row = {u'User': user, u'isPrimary': False}
            for item in sendas:
              row[item] = sendas[item]
            addRowTitlesToCSVfile(row, csvRows, titles)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvRows.append({u'User': user})
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'SendAs', todrive)

# gam <UserTypeEntity> print sendas [todrive [<ToDriveAttributes>]]
def printSendAs(users):
  _printShowSendAs(users, True)

# gam <UserTypeEntity> show sendas [format]
def showSendAs(users):
  _printShowSendAs(users, False)

# gam <UserTypeEntity> create|add smime file <FileName> [password <Password>] [sendas|sendasemail <EmailAddress>] [default]
def createSmime(users):
  sendAsEmailBase = None
  setDefault = False
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'file':
      smimefile = getString(Cmd.OB_FILE_NAME)
      body[u'pkcs12'] = base64.urlsafe_b64encode(readFile(smimefile, mode=u'rb'))
    elif myarg == u'password':
      body[u'encryptedKeyPassword'] = getString(Cmd.OB_PASSWORD)
    elif myarg == u'default':
      setDefault = True
    elif myarg in [u'sendas', u'sendasemail']:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  if u'pkcs12' not in body:
    missingArgumentExit(u'file')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    try:
      result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'insert',
                        throw_reasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                        userId=u'me', sendAsEmail=sendAsEmail, body=body, fields=u'id,issuerCn')
      if setDefault:
        callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'setDefault',
                 throw_reasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                 userId=u'me', sendAsEmail=sendAsEmail, id=result[u'id'])
      entityModifierNewValueActionPerformed([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, result[u'id']],
                                            Act.MODIFIER_FROM, u'{0}: {1}'.format(Ent.Singular(Ent.ISSUER_CN), result[u'issuerCn']), i, count)
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _getSmimeIds(gmail, user, i, count, sendAsEmail, function):
  try:
    result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'list',
                      throw_reasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                      userId=u'me', sendAsEmail=sendAsEmail, fields=u'smimeInfo(id)')
    smimes = result.get(u'smimeInfo', [])
    jcount = len(smimes)
    if jcount == 0:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, None],
                                      Msg.NO_ENTITIES_FOUND.format(Ent.Plural(Ent.SMIME_ID)), i, count)
      setSysExitRC(NO_ENTITIES_FOUND)
    elif jcount > 1:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, None],
                                      Msg.PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Ent.Plural(Ent.SMIME_ID), function, u'id <S/MIMEID>'),
                                      i, count)
      Ind.Increment()
      j = 0
      for smime in smimes:
        j += 1
        printEntityKVList([Ent.SMIME_ID, smime[u'id'], Ent.ISSUER_CN, smime[u'issuerCn']], [u'Default', smime.get(u'isDefault', False)], j, jcount)
      Ind.Decrement()
    else:
      return smimes[0][u'id']
  except GAPI.forbidden as e:
    entityActionFailedWarning([Ent.USER, user], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  return None

# gam <UserTypeEntity> update smime [id <SmimeID>] [sendas|sendasemail <EmailAddress>] [default]
def updateSmime(users):
  smimeIdBase = None
  sendAsEmailBase = None
  setDefault = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'id':
      smimeIdBase = getString(Cmd.OB_SMIME_ID)
    elif myarg in [u'sendas', u'sendasemail']:
      sendAsEmailBase = getEmailAddress(noUid=True)
    elif myarg == u'default':
      setDefault = True
    else:
      unknownArgumentExit()
  if not setDefault:
    missingArgumentExit(u'default')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    if not smimeIdBase:
      smimeId = _getSmimeIds(gmail, user, i, count, sendAsEmail, u'update')
      if not smimeId:
        continue
    else:
      smimeId = smimeIdBase
    try:
      callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'setDefault',
               throw_reasons=GAPI.GMAIL_SMIME_THROW_REASONS,
               userId=u'me', sendAsEmail=sendAsEmail, id=smimeId)
      entityActionPerformed([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, smimeId], i, count)
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete smime [id <SmimeID>] [sendas|sendasemail <EmailAddress>]
def deleteSmime(users):
  smimeIdBase = None
  sendAsEmailBase = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'id':
      smimeIdBase = getString(Cmd.OB_SMIME_ID)
    elif myarg in [u'sendas', u'sendasemail']:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    if not smimeIdBase:
      smimeId = _getSmimeIds(gmail, user, i, count, sendAsEmail, u'delete')
      if not smimeId:
        continue
    else:
      smimeId = smimeIdBase
    try:
      callGAPI(gmail.users().settings().sendAs().smimeInfo(), u'delete',
               throw_reasons=GAPI.GMAIL_SMIME_THROW_REASONS,
               userId=u'me', sendAsEmail=sendAsEmail, id=smimeId)
      entityActionPerformed([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, smimeId], i, count)
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _printShowSmimes(users, csvFormat):
  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'id', u'isDefault', u'issuerCn', u'expiration', u'encryptedKeyPassword', u'pem'])
  primaryonly = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif myarg == u'primaryonly':
      primaryonly = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      if primaryonly:
        sendAsEmails = [user]
      else:
        results = callGAPIitems(gmail.users().settings().sendAs(), u'list', u'sendAs',
                                throw_reasons=GAPI.GMAIL_THROW_REASONS,
                                userId=u'me', fields=u'sendAs(sendAsEmail)')
        sendAsEmails = [sendAs[u'sendAsEmail'] for sendAs in results]
      jcount = len(sendAsEmails)
      if not csvFormat:
        entityPerformActionSubItemModifierNumItems([Ent.USER, user], Ent.SMIME_ID, Act.MODIFIER_FROM, jcount, Ent.SENDAS_ADDRESS, i, count)
      else:
        printGettingEntityItemForWhom(Ent.SENDAS_ADDRESS, user, i, count)
      if sendAsEmails:
        j = 0
        for sendAsEmail in sendAsEmails:
          j += 1
          smimes = callGAPIitems(gmail.users().settings().sendAs().smimeInfo(), u'list', u'smimeInfo',
                                 throw_reasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                                 userId=u'me', sendAsEmail=sendAsEmail)
          kcount = len(smimes)
          if not csvFormat:
            Ind.Increment()
            printEntity([Ent.SENDAS_ADDRESS, sendAsEmail], j, jcount)
            Ind.Increment()
            k = 0
            for smime in smimes:
              k += 1
              printEntity([Ent.SMIME_ID, smime[u'id']], k, kcount)
              Ind.Increment()
              printKeyValueList([u'Default', smime.get(u'isDefault', False)])
              printKeyValueList([u'Issuer CN', smime[u'issuerCn']])
              printKeyValueList([u'Expiration', formatLocalTimestamp(smime[u'expiration'])])
              printKeyValueList([u'Password', smime.get(u'encryptedKeyPassword', u'')])
              printKeyValueList([u'PEM', None])
              Ind.Increment()
              printKeyValueList([Ind.MultiLineText(smime[u'pem'])])
              Ind.Decrement()
              Ind.Decrement()
            Ind.Decrement()
            Ind.Decrement()
          elif smimes:
            for smime in smimes:
              smime[u'expiration'] = formatLocalTimestamp(smime[u'expiration'])
              addRowTitlesToCSVfile(flattenJSON(smime, flattened={u'User': user}), csvRows, titles)
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
            csvRows.append({u'User': user})
      elif csvFormat and GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
        csvRows.append({u'User': user})
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'S/MIME', todrive)

# gam <UserTypeEntity> print smimes [todrive [<ToDriveAttributes>]] [primaryonly]
def printSmimes(users):
  _printShowSmimes(users, True)

# gam <UserTypeEntity> show smimes [primaryonly]
def showSmimes(users):
  _printShowSmimes(users, False)

# gam <UserTypeEntity> signature|sig <String>|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)*
#	[html [<Boolean>]] [name <String>] [replyto <EmailAddress>] [default] [primary] [treatasalias <Boolean>]
def setSignature(users):
  tagReplacements = _initTagReplacements()
  if checkArgumentPresent(u'file'):
    filename = getString(Cmd.OB_FILE_NAME)
    encoding = getCharSet()
    signature = readFile(filename, encoding=encoding)
  else:
    signature = getString(Cmd.OB_STRING, minLen=0)
  body = {}
  html = primary = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'primary':
      primary = True
    elif myarg == u'html':
      html = getBoolean()
    else:
      getSendAsAttributes(myarg, body, tagReplacements)
  if not tagReplacements[u'subs']:
    body[u'signature'] = _processSignature(tagReplacements, signature, html)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if tagReplacements[u'subs']:
      _getTagReplacementFieldValues(user, i, count, tagReplacements)
      body[u'signature'] = _processSignature(tagReplacements, signature, html)
    if primary:
      try:
        result = callGAPI(gmail.users().settings().sendAs(), u'list',
                          throw_reasons=GAPI.GMAIL_THROW_REASONS,
                          userId=u'me')
        for sendas in result[u'sendAs']:
          if sendas.get(u'isPrimary', False):
            emailAddress = sendas[u'sendAsEmail']
            _processSendAs(user, i, count, Ent.SIGNATURE, emailAddress, i, count, gmail, u'patch', False, body=body, sendAsEmail=emailAddress, fields=u'')
            break
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    else:
      _processSendAs(user, i, count, Ent.SIGNATURE, user, i, count, gmail, u'patch', False, body=body, sendAsEmail=user, fields=u'')

# gam <UserTypeEntity> show signature|sig [format] [primary]
def showSignature(users):
  formatSig = primary = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == u'primary':
      primary = True
    elif myarg == u'format':
      formatSig = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if primary:
      try:
        result = callGAPI(gmail.users().settings().sendAs(), u'list',
                          throw_reasons=GAPI.GMAIL_THROW_REASONS,
                          userId=u'me')
        printEntity([Ent.USER, user, Ent.SIGNATURE, u''], i, count)
        Ind.Increment()
        for sendas in result[u'sendAs']:
          if sendas.get(u'isPrimary', False):
            _showSendAs(sendas, 0, 0, formatSig)
            break
        Ind.Decrement()
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    else:
      _processSendAs(user, i, count, Ent.SIGNATURE, user, i, count, gmail, u'get', formatSig, sendAsEmail=user)

VACATION_START_STARTED = u'Started'
VACATION_END_NOT_SPECIFIED = u'NotSpecified'

def _showVacation(user, i, count, result, formatReply):
  enabled = result[u'enableAutoReply']
  printEntity([Ent.USER, user, Ent.VACATION, None], i, count)
  Ind.Increment()
  printKeyValueList([u'Enabled', enabled])
  if enabled:
    printKeyValueList([u'Contacts Only', result[u'restrictToContacts']])
    printKeyValueList([u'Domain Only', result[u'restrictToDomain']])
    if u'startTime' in result:
      printKeyValueList([u'Start Date', formatLocalDatestamp(result[u'startTime'])])
    else:
      printKeyValueList([u'Start Date', VACATION_START_STARTED])
    if u'endTime' in result:
      printKeyValueList([u'End Date', formatLocalDatestamp(result[u'endTime'])])
    else:
      printKeyValueList([u'End Date', VACATION_END_NOT_SPECIFIED])
    printKeyValueList([u'Subject', result.get(u'responseSubject', u'None')])
    if formatReply:
      printKeyValueList([u'Message', None])
      Ind.Increment()
      if result.get(u'responseBodyPlainText'):
        printKeyValueList([Ind.MultiLineText(result[u'responseBodyPlainText'])])
      elif result.get(u'responseBodyHtml'):
        printKeyValueList([Ind.MultiLineText(dehtml(result[u'responseBodyHtml']))])
      else:
        printKeyValueList([u'None'])
      Ind.Decrement()
    else:
      if result.get(u'responseBodyPlainText'):
        printKeyValueList([u'Message', escapeCRsNLs(result[u'responseBodyPlainText'])])
      elif result.get(u'responseBodyHtml'):
        printKeyValueList([u'Message', result[u'responseBodyHtml']])
      else:
        printKeyValueList([u'Message', u'None'])
  Ind.Decrement()

# gam <UserTypeEntity> vacation <FalseValues>
# gam <UserTypeEntity> vacation <TrueValues> subject <String> (message <String>)|(file <FileName> [charset <CharSet>]) (replace <RegularExpression> <String>)*
#	[html [<Boolean>]] [contactsonly [<Boolean>]] [domainonly [<Boolean>]] [startdate <Date>|Started] [enddate <Date>|NotSpecified]
def setVacation(users):
  enable = getBoolean(None)
  body = {u'enableAutoReply': enable}
  if enable:
    responseBodyType = u'responseBodyPlainText'
    message = None
    tagReplacements = _initTagReplacements()
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == u'subject':
        body[u'responseSubject'] = getString(Cmd.OB_STRING, minLen=0)
      elif myarg == u'message':
        message = getString(Cmd.OB_STRING, minLen=0)
      elif myarg == u'file':
        filename = getString(Cmd.OB_FILE_NAME)
        encoding = getCharSet()
        message = readFile(filename, encoding=encoding)
      elif myarg == u'replace':
        _getTagReplacement(tagReplacements, True)
      elif myarg == u'html':
        if getBoolean():
          responseBodyType = u'responseBodyHtml'
      elif myarg == u'contactsonly':
        body[u'restrictToContacts'] = getBoolean()
      elif myarg == u'domainonly':
        body[u'restrictToDomain'] = getBoolean()
      elif myarg == u'startdate':
        body[u'startTime'] = getYYYYMMDD(returnTimeStamp=True, alternateValue=VACATION_START_STARTED)
        if body[u'startTime'] is None:
          del body[u'startTime']
      elif myarg == u'enddate':
        body[u'endTime'] = getYYYYMMDD(returnTimeStamp=True, alternateValue=VACATION_END_NOT_SPECIFIED)
        if body[u'endTime'] is None:
          del body[u'endTime']
      else:
        unknownArgumentExit()
    if message:
      if responseBodyType == u'responseBodyHtml':
        message = message.replace(u'\r', u'').replace(u'\\n', u'<br/>')
      else:
        message = message.replace(u'\r', u'').replace(u'\\n', u'\n')
      if tagReplacements[u'tags'] and not tagReplacements[u'subs']:
        message = _processTagReplacements(tagReplacements, message)
      body[responseBodyType] = message
    if not message and not body.get(u'responseSubject'):
      missingArgumentExit(u'message or subject')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if tagReplacements[u'subs']:
      _getTagReplacementFieldValues(user, i, count, tagReplacements)
      body[responseBodyType] = _processTagReplacements(tagReplacements, message)
    try:
      result = callGAPI(gmail.users().settings(), u'updateVacation',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_ARGUMENT],
                        userId=u'me', body=body)
      printEntity([Ent.USER, user, Ent.VACATION_ENABLED, result[u'enableAutoReply']], i, count)
    except GAPI.invalidArgument as e:
      entityActionFailedWarning([Ent.USER, user, Ent.VACATION_ENABLED, enable], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _printShowVacation(users, csvFormat):
  def _printVacation(user, result, showDisabled):
    enabled = result[u'enableAutoReply']
    if not enabled and not showDisabled:
      return
    row = {u'User': user, u'enabled': enabled}
    if enabled:
      row[u'contactsonly'] = result[u'restrictToContacts']
      row[u'domainonly'] = result[u'restrictToDomain']
      if u'startTime' in result:
        row[u'startdate'] = formatLocalDatestamp(result[u'startTime'])
      else:
        row[u'startdate'] = VACATION_START_STARTED
      if u'endTime' in result:
        row[u'enddate'] = formatLocalDatestamp(result[u'endTime'])
      else:
        row[u'enddate'] = VACATION_END_NOT_SPECIFIED
      row[u'subject'] = result.get(u'responseSubject', u'None')
      if result.get(u'responseBodyPlainText'):
        row[u'html'] = False
        row[u'message'] = escapeCRsNLs(result[u'responseBodyPlainText'])
      elif result.get(u'responseBodyHtml'):
        row[u'html'] = True
        row[u'message'] = result[u'responseBodyHtml']
      else:
        row[u'html'] = False
        row[u'message'] = u'None'
    csvRows.append(row)

  if csvFormat:
    todrive = {}
    titles, csvRows = initializeTitlesCSVfile([u'User', u'enabled', u'contactsonly', u'domainonly',
                                               u'startdate', u'enddate', u'subject', u'html', u'message'])
  showDisabled = True
  formatReply = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvFormat and myarg == u'todrive':
      todrive = getTodriveParameters()
    elif not csvFormat and myarg == u'format':
      formatReply = True
    elif csvFormat and myarg == u'enabledonly':
      showDisabled = False
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), u'getVacation',
                        throw_reasons=GAPI.GMAIL_THROW_REASONS,
                        userId=u'me')
      if not csvFormat:
        _showVacation(user, i, count, result, formatReply)
      else:
        printGettingEntityItemForWhom(Ent.VACATION, user, i, count)
        _printVacation(user, result, showDisabled)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvFormat:
    writeCSVfile(csvRows, titles, u'Vacation', todrive)

# gam <UserTypeEntity> print vacation [enabledonly] [todrive [<ToDriveAttributes>]]
def printVacation(users):
  _printShowVacation(users, True)

# gam <UserTypeEntity> show vacation [format]
def showVacation(users):
  _printShowVacation(users, False)

# Process Email Settings
def _processEmailSettings(users, function, entityType, entityValue, **kwargs):
  emailSettings = getEmailSettingsObject()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, emailSettings.domain = splitEmailAddressOrUID(user)
    try:
      result = callGData(emailSettings, function,
                         throw_errors=GDATA.EMAILSETTINGS_THROW_LIST,
                         username=userName, **kwargs)
      if result:
        printEntity([Ent.USER, user, entityType, result[entityValue]], i, count)
    except GDATA.doesNotExist:
      entityActionFailedWarning([Ent.USER, user], Msg.DOES_NOT_EXIST, i, count)
    except (GDATA.serviceNotApplicable, GDATA.invalidDomain):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    except (GDATA.badRequest, GDATA.internalServerError, GDATA.nameNotValid, GDATA.invalidValue) as e:
      entityBadRequestWarning([Ent.USER, user, Ent.EMAIL_SETTINGS, None], str(e), i, count)

# gam <UserTypeEntity> arrows <Boolean>
def setArrows(users):
  enable = getBoolean(None)
  _processEmailSettings(users, u'UpdateGeneral', Ent.ARROWS_ENABLED, u'arrows', arrows=enable)

# gam <UserTypeEntity> language <Language>
def setLanguage(users):
  language = getChoice(LANGUAGE_CODES_MAP, mapChoice=True)
  _processEmailSettings(users, u'UpdateLanguage', Ent.LANGUAGE, u'language', language=language)

# gam <UserTypeEntity> pagesize 25|50|100
def setPageSize(users):
  page_size = getChoice([u'25', u'50', u'100'])
  _processEmailSettings(users, u'UpdateGeneral', Ent.PAGE_SIZE, u'pageSize', page_size=page_size)

# gam <UserTypeEntity> shortcuts <Boolean>
def setShortCuts(users):
  enable = getBoolean(None)
  _processEmailSettings(users, u'UpdateGeneral', Ent.KEYBOARD_SHORTCUTS_ENABLED, u'shortcuts', shortcuts=enable)

# gam <UserTypeEntity> snippets <Boolean>
def setSnippets(users):
  enable = getBoolean(None)
  _processEmailSettings(users, u'UpdateGeneral', Ent.SNIPPETS_ENABLED, u'snippets', snippets=enable)

# gam <UserTypeEntity> utf|utf8|utf-8|unicode <Boolean>
def setUnicode(users):
  enable = getBoolean(None)
  _processEmailSettings(users, u'UpdateGeneral', Ent.UNICODE_ENCODING_ENABLED, u'unicode', unicode=enable)

# gam <UserTypeEntity> webclips <Boolean>
def setWebClips(users):
  enable = getBoolean(None)
  _processEmailSettings(users, u'UpdateWebClipSettings', Ent.WEBCLIPS_ENABLED, u'enable', enable=enable)

# Command line processing

CMD_ACTION = 0
CMD_FUNCTION = 1

# Main commands
BATCH_CSV_COMMANDS = {
  Cmd.BATCH_CMD: (Act.PERFORM, doBatch),
  Cmd.CSV_CMD: (Act.PERFORM, doCSV),
  Cmd.TBATCH_CMD: (Act.PERFORM, doThreadBatch),
  }
MAIN_COMMANDS = {
  u'help': (Act.PERFORM, doUsage),
  u'list': (Act.LIST, doListType),
  u'report': (Act.REPORT, doReport),
  u'sendemail': (Act.SENDEMAIL, doSendEmail),
  u'version': (Act.PERFORM, doVersion),
  u'whatis': (Act.INFO, doWhatIs),
  }

# Main commands with objects
MAIN_ADD_CREATE_FUNCTIONS = {
  Cmd.ARG_ADMIN:	doCreateAdmin,
  Cmd.ARG_ALIAS:	doCreateAliases,
  Cmd.ARG_BUILDING:	doCreateBuilding,
  Cmd.ARG_CONTACT:	doCreateDomainContact,
  Cmd.ARG_COURSE:	doCreateCourse,
  Cmd.ARG_DATATRANSFER:	doCreateDataTransfer,
  Cmd.ARG_DOMAIN:	doCreateDomain,
  Cmd.ARG_DOMAINALIAS:	doCreateDomainAlias,
  Cmd.ARG_DRIVEFILEACL:	doCreateDriveFileACL,
  Cmd.ARG_FEATURE:	doCreateFeature,
  Cmd.ARG_GROUP:	doCreateGroup,
  Cmd.ARG_GUARDIAN: 	doInviteGuardian,
  Cmd.ARG_ORG:		doCreateOrg,
  Cmd.ARG_PERMISSIONS:	doCreatePermissions,
  Cmd.ARG_PROJECT:	doCreateProject,
  Cmd.ARG_RESOLDCUSTOMER:	doCreateResoldCustomer,
  Cmd.ARG_RESOLDSUBSCRIPTION:	doCreateResoldSubscription,
  Cmd.ARG_RESOURCE:	doCreateResourceCalendar,
  Cmd.ARG_SCHEMA:	doCreateUserSchema,
  Cmd.ARG_SITE:		doCreateDomainSite,
  Cmd.ARG_SITEACL:	doProcessDomainSiteACLs,
  Cmd.ARG_USER:		doCreateUser,
  Cmd.ARG_VAULTHOLD:	doCreateVaultHold,
  Cmd.ARG_VAULTMATTER:	doCreateVaultMatter,
  Cmd.ARG_VERIFY:	doCreateSiteVerification,
  }

MAIN_COMMANDS_WITH_OBJECTS = {
  u'add': (Act.ADD, MAIN_ADD_CREATE_FUNCTIONS),
  u'cancel': (Act.CANCEL, {Cmd.ARG_GUARDIANINVITATION: doCancelGuardianInvitation}),
  u'close': (Act.CLOSE, {Cmd.ARG_VAULTMATTER: doCloseVaultMatter}),
  u'create': (Act.CREATE, MAIN_ADD_CREATE_FUNCTIONS),
  u'delete':
    (Act.DELETE,
     {Cmd.ARG_ADMIN:		doDeleteAdmin,
      Cmd.ARG_ALIAS:		doDeleteAliases,
      Cmd.ARG_BUILDING:		doDeleteBuilding,
      Cmd.ARG_CONTACT:		doDeleteDomainContacts,
      Cmd.ARG_CONTACTPHOTO:	doDeleteDomainContactPhoto,
      Cmd.ARG_COURSE:		doDeleteCourse,
      Cmd.ARG_COURSES:		doDeleteCourses,
      Cmd.ARG_DOMAIN:		doDeleteDomain,
      Cmd.ARG_DOMAINALIAS:	doDeleteDomainAlias,
      Cmd.ARG_DRIVEFILEACL:	doDeleteDriveFileACLs,
      Cmd.ARG_FEATURE:		doDeleteFeature,
      Cmd.ARG_GROUP:		doDeleteGroups,
      Cmd.ARG_GUARDIAN: 	doDeleteGuardian,
      Cmd.ARG_MOBILE:		doDeleteMobileDevices,
      Cmd.ARG_NOTIFICATION:	doDeleteNotification,
      Cmd.ARG_ORG:		doDeleteOrg,
      Cmd.ARG_ORGS:		doDeleteOrgs,
      Cmd.ARG_PERMISSIONS:	doDeletePermissions,
      Cmd.ARG_PRINTER:		doDeletePrinters,
      Cmd.ARG_PROJECT:		doDeleteProjects,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doDeleteResoldSubscription,
      Cmd.ARG_RESOURCE:		doDeleteResourceCalendar,
      Cmd.ARG_RESOURCES:	doDeleteResourceCalendars,
      Cmd.ARG_SCHEMA:		doDeleteUserSchemas,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_USER:		doDeleteUser,
      Cmd.ARG_USERS:		doDeleteUsers,
      Cmd.ARG_VAULTHOLD:	doDeleteVaultHold,
      Cmd.ARG_VAULTMATTER:	doDeleteVaultMatter,
     }
    ),
  u'get': (Act.DOWNLOAD, {Cmd.ARG_CONTACTPHOTO: doGetDomainContactPhoto, Cmd.ARG_DEVICEFILE: doGetCrOSDeviceFiles}),
  u'info':
    (Act.INFO,
     {Cmd.ARG_ALIAS:		doInfoAliases,
      Cmd.ARG_BUILDING:		doInfoBuilding,
      Cmd.ARG_CONTACT:		doInfoDomainContacts,
      Cmd.ARG_COURSE:		doInfoCourse,
      Cmd.ARG_COURSES:		doInfoCourses,
      Cmd.ARG_CROS:		doInfoCrOSDevices,
      Cmd.ARG_CUSTOMER:		doInfoCustomer,
      Cmd.ARG_DATATRANSFER:	doInfoDataTransfer,
      Cmd.ARG_DOMAIN:		doInfoDomain,
      Cmd.ARG_DOMAINALIAS:	doInfoDomainAlias,
      Cmd.ARG_DRIVEFILEACL:	doInfoDriveFileACLs,
      Cmd.ARG_INSTANCE:		doInfoInstance,
      Cmd.ARG_GAL:		doInfoGAL,
      Cmd.ARG_GROUP:		doInfoGroups,
      Cmd.ARG_MOBILE:		doInfoMobileDevices,
      Cmd.ARG_NOTIFICATION:	doInfoNotifications,
      Cmd.ARG_ORG:		doInfoOrg,
      Cmd.ARG_ORGS:		doInfoOrgs,
      Cmd.ARG_PRINTER:		doInfoPrinters,
      Cmd.ARG_RESOLDCUSTOMER:	doInfoResoldCustomer,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doInfoResoldSubscription,
      Cmd.ARG_RESOURCE:		doInfoResourceCalendar,
      Cmd.ARG_RESOURCES:	doInfoResourceCalendars,
      Cmd.ARG_SCHEMA:		doInfoUserSchemas,
      Cmd.ARG_SITE:		doInfoDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_TEAMDRIVE:	doInfoTeamDrive,
      Cmd.ARG_USER:		doInfoUser,
      Cmd.ARG_USERS:		doInfoUsers,
      Cmd.ARG_VAULTHOLD:	doInfoVaultHold,
      Cmd.ARG_VAULTMATTER:	doInfoVaultMatter,
      Cmd.ARG_VERIFY:		doInfoSiteVerification,
     }
    ),
  u'print':
    (Act.PRINT,
     {Cmd.ARG_ADMINROLES:	doPrintAdminRoles,
      Cmd.ARG_ADMIN:		doPrintAdmins,
      Cmd.ARG_ALIAS:		doPrintAliases,
      Cmd.ARG_BUILDING:		doPrintBuildings,
      Cmd.ARG_CONTACT:		doPrintDomainContacts,
      Cmd.ARG_COURSE:		doPrintCourses,
      Cmd.ARG_COURSES:		doPrintCourses,
      Cmd.ARG_COURSEANNOUNCEMENTS:	doPrintCourseAnnouncements,
      Cmd.ARG_COURSEPARTICIPANTS:	doPrintCourseParticipants,
      Cmd.ARG_COURSESUBMISSIONS:	doPrintCourseSubmissions,
      Cmd.ARG_COURSEWORK:	doPrintCourseWork,
      Cmd.ARG_CROS:		doPrintCrOSDevices,
      Cmd.ARG_CROSACTIVITY:	doPrintCrOSActivity,
      Cmd.ARG_DATATRANSFER:	doPrintDataTransfers,
      Cmd.ARG_DOMAIN:		doPrintDomains,
      Cmd.ARG_DOMAINALIAS:	doPrintDomainAliases,
      Cmd.ARG_DRIVEFILEACL:	doPrintDriveFileACLs,
      Cmd.ARG_FEATURE:		doPrintFeatures,
      Cmd.ARG_GAL:		doPrintGAL,
      Cmd.ARG_GROUPMEMBERS:	doPrintGroupMembers,
      Cmd.ARG_GROUP:		doPrintGroups,
      Cmd.ARG_GUARDIAN: 	doPrintGuardians,
      Cmd.ARG_LICENSE:		doPrintLicenses,
      Cmd.ARG_MOBILE:		doPrintMobileDevices,
      Cmd.ARG_ORG:		doPrintOrgs,
      Cmd.ARG_ORGS:		doPrintOrgs,
      Cmd.ARG_OWNERSHIP:	doPrintOwnership,
      Cmd.ARG_PRINTER:		doPrintPrinters,
      Cmd.ARG_PRINTJOBS:	doPrintPrintJobs,
      Cmd.ARG_PRIVILEGES:	doPrintPrivileges,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doPrintResoldSubscriptions,
      Cmd.ARG_RESOURCE:		doPrintResourceCalendars,
      Cmd.ARG_RESOURCES:	doPrintResourceCalendars,
      Cmd.ARG_SCHEMA:		doPrintUserSchemas,
      Cmd.ARG_SITE:		doPrintDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_SITEACTIVITY:	doPrintDomainSiteActivity,
      Cmd.ARG_TEAMDRIVE:	doPrintTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	doPrintTeamDriveACLs,
      Cmd.ARG_TOKEN:		doPrintTokens,
      Cmd.ARG_TRANSFERAPPS:	doShowTransferApps,
      Cmd.ARG_USER:		doPrintUsers,
      Cmd.ARG_USERS:		doPrintUsers,
      Cmd.ARG_VAULTHOLD:	doPrintVaultHolds,
      Cmd.ARG_VAULTMATTER:	doPrintVaultMatters,
     }
    ),
  u'reopen': (Act.REOPEN, {Cmd.ARG_VAULTMATTER: doReopenVaultMatter}),
  u'show':
    (Act.SHOW,
     {Cmd.ARG_ADMINROLES:	doShowAdminRoles,
      Cmd.ARG_ADMIN:		doShowAdmins,
      Cmd.ARG_BUILDING:		doShowBuildings,
      Cmd.ARG_CONTACT:		doShowDomainContacts,
      Cmd.ARG_DATATRANSFER:	doShowDataTransfers,
      Cmd.ARG_DRIVEFILEACL:	doShowDriveFileACLs,
      Cmd.ARG_FEATURE:		doShowFeatures,
      Cmd.ARG_GAL:		doShowGAL,
      Cmd.ARG_GROUPMEMBERS:	doShowGroupMembers,
      Cmd.ARG_GUARDIAN: 	doShowGuardians,
      Cmd.ARG_ORGTREE:		doShowOrgTree,
      Cmd.ARG_OWNERSHIP:	doShowOwnership,
      Cmd.ARG_PRIVILEGES:	doShowPrivileges,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doShowResoldSubscriptions,
      Cmd.ARG_RESOURCE:		doShowResourceCalendars,
      Cmd.ARG_RESOURCES:	doShowResourceCalendars,
      Cmd.ARG_SCHEMA:		doShowUserSchemas,
      Cmd.ARG_SITE:		doShowDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_TEAMDRIVE:	doShowTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	doShowTeamDriveACLs,
      Cmd.ARG_TEAMDRIVEINFO:	doInfoTeamDrive,
      Cmd.ARG_TEAMDRIVETHEMES:	doShowTeamDriveThemes,
      Cmd.ARG_TRANSFERAPPS:	doShowTransferApps,
      Cmd.ARG_VAULTHOLD:	doShowVaultHolds,
      Cmd.ARG_VAULTMATTER:	doShowVaultMatters,
     }
    ),
  u'suspend': (Act.SUSPEND, {Cmd.ARG_USER: doSuspendUser, Cmd.ARG_USERS: doSuspendUsers}),
  u'update':
    (Act.UPDATE,
     {Cmd.ARG_ALIAS:		doUpdateAliases,
      Cmd.ARG_BUILDING:		doUpdateBuilding,
      Cmd.ARG_CONTACT:		doUpdateDomainContacts,
      Cmd.ARG_CONTACTPHOTO:	doUpdateDomainContactPhoto,
      Cmd.ARG_COURSE:		doUpdateCourse,
      Cmd.ARG_COURSES:		doUpdateCourses,
      Cmd.ARG_CROS:		doUpdateCrOSDevices,
      Cmd.ARG_CUSTOMER:		doUpdateCustomer,
      Cmd.ARG_DOMAIN:		doUpdateDomain,
      Cmd.ARG_DRIVEFILEACL:	doUpdateDriveFileACLs,
      Cmd.ARG_FEATURE:		doUpdateFeature,
      Cmd.ARG_GROUP:		doUpdateGroups,
      Cmd.ARG_INSTANCE:		doUpdateInstance,
      Cmd.ARG_MOBILE:		doUpdateMobileDevices,
      Cmd.ARG_NOTIFICATION:	doUpdateNotification,
      Cmd.ARG_ORG:		doUpdateOrg,
      Cmd.ARG_ORGS:		doUpdateOrgs,
      Cmd.ARG_PRINTER:		doUpdatePrinters,
      Cmd.ARG_PROJECT:		doUpdateProject,
      Cmd.ARG_RESOLDCUSTOMER:	doUpdateResoldCustomer,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doUpdateResoldSubscription,
      Cmd.ARG_RESOURCE:		doUpdateResourceCalendar,
      Cmd.ARG_RESOURCES:	doUpdateResourceCalendars,
      Cmd.ARG_SCHEMA:		doUpdateUserSchemas,
      Cmd.ARG_SITE:		doUpdateDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_USER:		doUpdateUser,
      Cmd.ARG_USERS:		doUpdateUsers,
      Cmd.ARG_VAULTHOLD:	doUpdateVaultHold,
      Cmd.ARG_VAULTMATTER:	doUpdateVaultMatter,
      Cmd.ARG_VERIFY:		doUpdateSiteVerification,
     }
    ),
  u'undelete': (Act.UNDELETE, {Cmd.ARG_USER: doUndeleteUser, Cmd.ARG_USERS: doUndeleteUsers, Cmd.ARG_VAULTMATTER: doUndeleteVaultMatter}),
  u'unsuspend': (Act.UNSUSPEND, {Cmd.ARG_USER: doUnsuspendUser, Cmd.ARG_USERS: doUnsuspendUsers}),
  }

MAIN_COMMANDS_OBJ_ALIASES = {
  Cmd.ARG_ADMINS:	Cmd.ARG_ADMIN,
  Cmd.ARG_ALIASDOMAIN:	Cmd.ARG_DOMAINALIAS,
  Cmd.ARG_ALIASDOMAINS:	Cmd.ARG_DOMAINALIAS,
  Cmd.ARG_ALIASES:	Cmd.ARG_ALIAS,
  Cmd.ARG_APIPROJECT:	Cmd.ARG_PROJECT,
  Cmd.ARG_BUILDINGS:	Cmd.ARG_BUILDING,
  Cmd.ARG_CLASS:	Cmd.ARG_COURSE,
  Cmd.ARG_CLASSES:	Cmd.ARG_COURSES,
  Cmd.ARG_CLASSPARTICIPANTS:	Cmd.ARG_COURSEPARTICIPANTS,
  Cmd.ARG_CONTACTS:	Cmd.ARG_CONTACT,
  Cmd.ARG_CONTACTPHOTOS:	Cmd.ARG_CONTACTPHOTO,
  Cmd.ARG_DATATRANSFERS:	Cmd.ARG_DATATRANSFER,
  Cmd.ARG_DEVICEFILES:	Cmd.ARG_DEVICEFILE,
  Cmd.ARG_DOMAINS:	Cmd.ARG_DOMAIN,
  Cmd.ARG_DOMAINALIASES:	Cmd.ARG_DOMAINALIAS,
  Cmd.ARG_DRIVEFILEACLS:	Cmd.ARG_DRIVEFILEACL,
  Cmd.ARG_FEATURES:	Cmd.ARG_FEATURE,
  Cmd.ARG_GROUPS:	Cmd.ARG_GROUP,
  Cmd.ARG_GROUPSMEMBERS:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_GUARDIANINVITATIONS:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_GUARDIANINVITE:	Cmd.ARG_GUARDIAN,
  Cmd.ARG_GUARDIANS:	Cmd.ARG_GUARDIAN,
  Cmd.ARG_HOLDS:	Cmd.ARG_VAULTHOLD,
  Cmd.ARG_INVITEGUARDIAN:	Cmd.ARG_GUARDIAN,
  Cmd.ARG_LICENCE:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENCES:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENSES:	Cmd.ARG_LICENSE,
  Cmd.ARG_MATTER:	Cmd.ARG_VAULTMATTER,
  Cmd.ARG_MATTERS:	Cmd.ARG_VAULTMATTER,
  Cmd.ARG_MOBILES:	Cmd.ARG_MOBILE,
  Cmd.ARG_NICKNAME:	Cmd.ARG_ALIAS,
  Cmd.ARG_NICKNAMES:	Cmd.ARG_ALIAS,
  Cmd.ARG_NOTIFICATIONS:	Cmd.ARG_NOTIFICATION,
  Cmd.ARG_OU:		Cmd.ARG_ORG,
  Cmd.ARG_OUS:		Cmd.ARG_ORGS,
  Cmd.ARG_OUTREE:	Cmd.ARG_ORGTREE,
  Cmd.ARG_PARTICIPANTS:	Cmd.ARG_COURSEPARTICIPANTS,
  Cmd.ARG_PRINT:	Cmd.ARG_PRINTER,
  Cmd.ARG_PRINTERS:	Cmd.ARG_PRINTER,
  Cmd.ARG_PROJECTS:	Cmd.ARG_PROJECT,
  Cmd.ARG_RESELLERCUSTOMERS:	Cmd.ARG_RESOLDCUSTOMER,
  Cmd.ARG_RESELLERSUBSCRIPTIONS:	Cmd.ARG_RESOLDSUBSCRIPTION,
  Cmd.ARG_RESOLDCUSTOMERS:	Cmd.ARG_RESOLDCUSTOMER,
  Cmd.ARG_RESOLDSUBSCRIPTIONS:	Cmd.ARG_RESOLDSUBSCRIPTION,
  Cmd.ARG_ROLES:	Cmd.ARG_ADMINROLES,
  Cmd.ARG_SCHEMAS:	Cmd.ARG_SCHEMA,
  Cmd.ARG_SITEACLS:	Cmd.ARG_SITEACL,
  Cmd.ARG_SITES:	Cmd.ARG_SITE,
  Cmd.ARG_TEAMDRIVES:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_TOKENS:	Cmd.ARG_TOKEN,
  Cmd.ARG_TRANSFER:	Cmd.ARG_DATATRANSFER,
  Cmd.ARG_TRANSFERS:	Cmd.ARG_DATATRANSFER,
  Cmd.ARG_VAULTHOLDS:	Cmd.ARG_VAULTHOLD,
  Cmd.ARG_VAULTMATTERS:	Cmd.ARG_VAULTMATTER,
  Cmd.ARG_VERIFICATION:	Cmd.ARG_VERIFY,
  }

# Oauth command sub-commands
OAUTH2_SUBCOMMANDS = {
  u'create': (Act.CREATE, doOAuthRequest),
  u'delete': (Act.DELETE, doOAuthDelete),
  u'export': (Act.EXPORT, doOAuthExport),
  u'import': (Act.IMPORT, doOAuthImport),
  u'info': (Act.INFO, doOAuthInfo),
  }

# Oauth sub-command aliases
OAUTH2_SUBCOMMAND_ALIASES = {
  u'request':	u'create',
  u'revoke':	u'delete',
  u'verify':	u'info',
  }

def processOauthCommands():
  CL_subCommand = getChoice(OAUTH2_SUBCOMMANDS, choiceAliases=OAUTH2_SUBCOMMAND_ALIASES)
  Act.Set(OAUTH2_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  OAUTH2_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION]()

# Audit command sub-commands
AUDIT_SUBCOMMANDS = {
  u'uploadkey': (Act.UPLOAD, doUploadAuditKey),
  }

# Audit command sub-commands with objects
AUDIT_SUBCOMMANDS_WITH_OBJECTS = {
  u'export':
    {u'request': (Act.SUBMIT, doSubmitExportRequest),
     u'delete': (Act.DELETE, doDeleteExportRequest),
     u'download': (Act.DOWNLOAD, doDownloadExportRequest),
     u'status': (Act.LIST, doStatusExportRequests),
     u'watch': (Act.WATCH, doWatchExportRequest),
    },
  u'monitor':
    {u'create': (Act.CREATE, doCreateMonitor),
     u'delete': (Act.DELETE, doDeleteMonitor),
     u'list': (Act.LIST, doShowMonitors),
    },
  }

def processAuditCommands():
  CL_subCommand = getChoice(list(AUDIT_SUBCOMMANDS)+list(AUDIT_SUBCOMMANDS_WITH_OBJECTS))
  if CL_subCommand in AUDIT_SUBCOMMANDS:
    Act.Set(AUDIT_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    AUDIT_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION]()
  else:
    CL_objectName = getChoice(AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand])
    Act.Set(AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CL_objectName][CMD_ACTION])
    AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CL_objectName][CMD_FUNCTION]()

# Calendar command sub-commands
CALENDAR_SUBCOMMANDS = {
  u'showacl': (Act.SHOW, doCalendarsShowACLs),
  u'addevent': (Act.ADD, doCalendarsCreateEvent),
  u'deleteevent': (Act.DELETE, doCalendarsDeleteEvents),
  u'wipe': (Act.WIPE, doCalendarsWipeEvents),
  u'modify': (Act.MODIFY, doCalendarsModifySettings),
  }

CALENDAR_OLDACL_SUBCOMMANDS = {
  u'add': (Act.ADD, doCalendarsCreateACL),
  u'create': (Act.CREATE, doCalendarsCreateACL),
  u'delete': (Act.DELETE, doCalendarsDeleteACL),
  u'update': (Act.UPDATE, doCalendarsUpdateACL),
  }

# Calendar sub-command aliases
CALENDAR_OLDACL_SUBCOMMAND_ALIASES = {
  u'del':	u'delete',
  }

# Calendars command sub-commands with objects
CALENDARS_SUBCOMMANDS_WITH_OBJECTS = {
  u'add': (Act.ADD, {Cmd.ARG_CALENDARACL: doCalendarsCreateACLs, Cmd.ARG_EVENT: doCalendarsCreateEvent}),
  u'create': (Act.CREATE, {Cmd.ARG_CALENDARACL: doCalendarsCreateACLs, Cmd.ARG_EVENT: doCalendarsCreateEvent}),
  u'import': (Act.IMPORT, {Cmd.ARG_EVENT: doCalendarsImportEvent}),
  u'update': (Act.UPDATE, {Cmd.ARG_CALENDARACL: doCalendarsUpdateACLs, Cmd.ARG_EVENT: doCalendarsUpdateEvents}),
  u'delete': (Act.DELETE, {Cmd.ARG_CALENDARACL: doCalendarsDeleteACLs, Cmd.ARG_EVENT: doCalendarsDeleteEvents}),
  u'info': (Act.INFO, {Cmd.ARG_CALENDARACL: doCalendarsInfoACLs, Cmd.ARG_EVENT: doCalendarsInfoEvents}),
  u'move': (Act.MOVE, {Cmd.ARG_EVENT: doCalendarsMoveEvents}),
  u'print': (Act.PRINT, {Cmd.ARG_CALENDARACL: doCalendarsPrintACLs, Cmd.ARG_EVENT: doCalendarsPrintEvents}),
  u'show': (Act.SHOW, {Cmd.ARG_CALENDARACL: doCalendarsShowACLs, Cmd.ARG_EVENT: doCalendarsShowEvents}),
  u'wipe': (Act.WIPE, {Cmd.ARG_EVENT: doCalendarsWipeEvents}),
  }

CALENDARS_SUBCOMMANDS_OBJECT_ALIASES = {
  Cmd.ARG_ACL:		Cmd.ARG_CALENDARACL,
  Cmd.ARG_ACLS:		Cmd.ARG_CALENDARACL,
  Cmd.ARG_CALENDARACLS:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_EVENTS:	Cmd.ARG_EVENT,
  }

def processCalendarsCommands():
  cal = buildGAPIObject(API.CALENDAR)
  calendarList = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
  CL_subCommand = getChoice(CALENDAR_SUBCOMMANDS, defaultChoice=None)
  if CL_subCommand:
    Act.Set(CALENDAR_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    CALENDAR_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](cal, calendarList)
    return
  CL_subCommand = getChoice(CALENDAR_OLDACL_SUBCOMMANDS, choiceAliases=CALENDAR_OLDACL_SUBCOMMAND_ALIASES, defaultChoice=None)
  if CL_subCommand:
    Act.Set(CALENDAR_OLDACL_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    CL_objectName = getChoice([Cmd.ARG_CALENDARACL, Cmd.ARG_EVENT], choiceAliases=CALENDARS_SUBCOMMANDS_OBJECT_ALIASES, defaultChoice=None)
    if not CL_objectName:
      CALENDAR_OLDACL_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](cal, calendarList)
    else:
      CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](cal, calendarList)
    return
  CL_subCommand = getChoice(CALENDARS_SUBCOMMANDS_WITH_OBJECTS)
  Act.Set(CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_ACTION])
  CL_objectName = getChoice(CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION], choiceAliases=CALENDARS_SUBCOMMANDS_OBJECT_ALIASES)
  CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](cal, calendarList)

# Course command sub-commands
COURSE_SUBCOMMANDS = {
  u'add': (Act.ADD, doCourseAddParticipants),
  u'remove': (Act.REMOVE, doCourseRemoveParticipants),
  u'sync': (Act.SYNC, doCourseSyncParticipants),
  }

# Course sub-command aliases
COURSE_SUBCOMMAND_ALIASES = {
  u'create':	u'add',
  u'del':	u'remove',
  u'delete':	u'remove',
  }

def executeCourseCommands(courseIdList, getEntityListArg):
  CL_subCommand = getChoice(COURSE_SUBCOMMANDS, choiceAliases=COURSE_SUBCOMMAND_ALIASES)
  Act.Set(COURSE_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  COURSE_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](courseIdList, getEntityListArg)

def processCourseCommands():
  executeCourseCommands(getStringReturnInList(Cmd.OB_COURSE_ID), False)

def processCoursesCommands():
  executeCourseCommands(getEntityList(Cmd.OB_COURSE_ENTITY), True)

# Printer command sub-commands
PRINTER_SUBCOMMANDS = {
  u'add': (Act.ADD, doPrinterCreateACL),
  u'delete': (Act.DELETE, doPrinterDeleteACLs),
  u'printacls': (Act.PRINT, doPrinterPrintACLs),
  u'showacls': (Act.SHOW, doPrinterShowACLs),
  u'sync': (Act.SYNC, doPrinterSyncACLs),
  u'wipe': (Act.DELETE, doPrinterWipeACLs),
  }

# Printer sub-command aliases
PRINTER_SUBCOMMAND_ALIASES = {
  u'create':	u'add',
  u'del':	u'delete',
  u'printacl':	u'printacls',
  u'showacl':	u'showacls',
  u'remove':	u'delete',
  }

def processPrintersCommands():
  printerIdList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  if printerIdList[0] == u'register':
    Act.Set(Act.REGISTER)
    doPrinterRegister()
    return
  CL_subCommand = getChoice(PRINTER_SUBCOMMANDS, choiceAliases=PRINTER_SUBCOMMAND_ALIASES)
  Act.Set(PRINTER_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  PRINTER_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](printerIdList)

# Printjob command sub-commands
PRINTJOB_SUBCOMMANDS = {
  u'cancel': (Act.CANCEL, doPrintJobCancel),
  u'delete': (Act.DELETE, doPrintJobDelete),
  u'fetch': (Act.DOWNLOAD, doPrintJobFetch),
  u'resubmit': (Act.RESUBMIT, doPrintJobResubmit),
  u'submit': (Act.SUBMIT, doPrintJobSubmit),
  }

def processPrintjobsCommands():
  jobPrinterIdList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  CL_subCommand = getChoice(PRINTJOB_SUBCOMMANDS)
  Act.Set(PRINTJOB_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  PRINTJOB_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](jobPrinterIdList)

# Resource command sub-commands
RESOURCE_SUBCOMMANDS_WITH_OBJECTS = {
  u'add': (Act.ADD, {Cmd.ARG_CALENDARACL: doResourceCreateCalendarACLs}),
  u'create': (Act.CREATE, {Cmd.ARG_CALENDARACL: doResourceCreateCalendarACLs}),
  u'update': (Act.UPDATE, {Cmd.ARG_CALENDARACL: doResourceUpdateCalendarACLs}),
  u'delete': (Act.DELETE, {Cmd.ARG_CALENDARACL: doResourceDeleteCalendarACLs}),
  u'info': (Act.INFO, {Cmd.ARG_CALENDARACL: doResourceInfoCalendarACLs}),
  u'print': (Act.PRINT, {Cmd.ARG_CALENDARACL: doResourcePrintCalendarACLs}),
  u'show': (Act.SHOW, {Cmd.ARG_CALENDARACL: doResourceShowCalendarACLs}),
  }

# Resource sub-command aliases
RESOURCE_SUBCOMMAND_ALIASES = {
  u'del':	u'delete',
  }

RESOURCE_SUBCOMMANDS_OBJECT_ALIASES = {
  Cmd.ARG_ACL:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_ACLS:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_CALENDARACLS:	Cmd.ARG_CALENDARACL,
  }

def executeResourceCommands(resourceEntity):
  CL_subCommand = getChoice(RESOURCE_SUBCOMMANDS_WITH_OBJECTS, choiceAliases=RESOURCE_SUBCOMMAND_ALIASES)
  Act.Set(RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_ACTION])
  CL_objectName = getChoice(RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION], choiceAliases=RESOURCE_SUBCOMMANDS_OBJECT_ALIASES)
  RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](resourceEntity)

def processResourceCommands():
  executeResourceCommands(getStringReturnInList(Cmd.OB_RESOURCE_ID))

def processResourcesCommands():
  executeResourceCommands(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# Commands
COMMANDS_MAP = {
  u'oauth':	processOauthCommands,
  u'audit':	processAuditCommands,
  u'calendars':	processCalendarsCommands,
  u'course':	processCourseCommands,
  u'courses':	processCoursesCommands,
  u'printers':	processPrintersCommands,
  u'printjobs':	processPrintjobsCommands,
  u'resource':	processResourceCommands,
  u'resources':	processResourcesCommands,
  }

# Commands aliases
COMMANDS_ALIASES = {
  u'oauth2':	u'oauth',
  u'calendar':	u'calendars',
  u'printer':	u'printers',
  u'printjob':	u'printjobs',
  }

# <CrOSTypeEntity> commands
CROS_COMMANDS = {
  u'info': (Act.INFO, infoCrOSDevices),
  u'list': (Act.LIST, doListCrOS),
  u'print': (Act.PRINT, doPrintCrOSEntity),
  u'update': (Act.UPDATE, updateCrOSDevices),
  }

CROS_COMMANDS_WITH_OBJECTS = {
  u'get': (Act.DOWNLOAD, {Cmd.ARG_DEVICEFILE: getCrOSDeviceFiles}),
  }

CROS_COMMANDS_OBJ_ALIASES = {
  Cmd.ARG_DEVICEFILES:	Cmd.ARG_DEVICEFILE,
  }

# <UserTypeEntity> commands
USER_COMMANDS = {
  u'arrows': (Act.SET, setArrows),
  u'delegate': (Act.ADD, delegateTo),
  u'deprovision':(Act.DEPROVISION, deprovisionUser),
  u'filter': (Act.ADD, createFilter),
  u'forward': (Act.SET, setForward),
  u'imap': (Act.SET, setImap),
  u'label': (Act.ADD, createLabel),
  u'list': (Act.LIST, doListUser),
  u'language': (Act.SET, setLanguage),
  u'pagesize': (Act.SET, setPageSize),
  u'pop': (Act.SET, setPop),
  u'profile': (Act.SET, setProfile),
  u'sendas': (Act.ADD, createSendAs),
  u'shortcuts': (Act.SET, setShortCuts),
  u'signature': (Act.SET, setSignature),
  u'snippets': (Act.SET, setSnippets),
  u'unicode': (Act.SET, setUnicode),
  u'vacation': (Act.SET, setVacation),
  u'webclips': (Act.SET, setWebClips),
  }

# User commands with objects
#
USER_ADD_CREATE_FUNCTIONS = {
  Cmd.ARG_CALENDAR:	addCreateCalendars,
  Cmd.ARG_GROUP:	addUserToGroups,
  Cmd.ARG_CALENDARACL:	createCalendarACLs,
  Cmd.ARG_CLASSROOMOAUTH2:	createClassroomOauth2,
  Cmd.ARG_CONTACT:	createUserContact,
  Cmd.ARG_CONTACTGROUP:	createUserContactGroup,
  Cmd.ARG_DELEGATE:	createDelegate,
  Cmd.ARG_DRIVEFILE:	createDriveFile,
  Cmd.ARG_DRIVEFILEACL:	createDriveFileACL,
  Cmd.ARG_EVENT:	createCalendarEvent,
  Cmd.ARG_FILTER:	createFilter,
  Cmd.ARG_FORWARDINGADDRESS:	createForwardingAddresses,
  Cmd.ARG_LABEL:	createLabel,
  Cmd.ARG_LICENSE:	createLicense,
  Cmd.ARG_PERMISSIONS:	createDriveFilePermissions,
  Cmd.ARG_SENDAS:	createSendAs,
  Cmd.ARG_SHEET:	createSheet,
  Cmd.ARG_SITE:		createUserSite,
  Cmd.ARG_SITEACL:	processUserSiteACLs,
  Cmd.ARG_SMIME:	createSmime,
  Cmd.ARG_TEAMDRIVE:	createTeamDrive,
  }

USER_COMMANDS_WITH_OBJECTS = {
  u'add': (Act.ADD, USER_ADD_CREATE_FUNCTIONS),
  u'append': (Act.APPEND, {Cmd.ARG_SHEETRANGE: appendSheetRanges}),
  u'archive': (Act.ARCHIVE, {Cmd.ARG_MESSAGE: archiveMessages}),
  u'check': (Act.CHECK, {Cmd.ARG_SERVICEACCOUNT: checkServiceAccount}),
  u'claim': (Act.CLAIM, {Cmd.ARG_OWNERSHIP:  claimOwnership}),
  u'clear': (Act.CLEAR, {Cmd.ARG_SHEETRANGE: clearSheetRanges}),
  u'collect': (Act.COLLECT, {Cmd.ARG_ORPHANS: collectOrphans}),
  u'copy': (Act.COPY, {Cmd.ARG_DRIVEFILE: copyDriveFile}),
  u'create': (Act.CREATE, USER_ADD_CREATE_FUNCTIONS),
  u'delete':
    (Act.DELETE,
     {Cmd.ARG_ALIAS:		deleteUsersAliases,
      Cmd.ARG_ASP:		deleteASP,
      Cmd.ARG_BACKUPCODE:	deleteBackupCodes,
      Cmd.ARG_CALENDAR:		deleteCalendars,
      Cmd.ARG_CALENDARACL:	deleteCalendarACLs,
      Cmd.ARG_CLASSROOMOAUTH2:	deleteClassroomOauth2,
      Cmd.ARG_CONTACT:		deleteUserContacts,
      Cmd.ARG_CONTACTGROUP:	deleteUserContactGroups,
      Cmd.ARG_CONTACTPHOTO:	deleteUserContactPhoto,
      Cmd.ARG_DELEGATE:		deleteDelegate,
      Cmd.ARG_DRIVEFILE:	deleteDriveFile,
      Cmd.ARG_DRIVEFILEACL:	deleteDriveFileACLs,
      Cmd.ARG_EMPTYDRIVEFOLDERS:	deleteEmptyDriveFolders,
      Cmd.ARG_EVENT:		deleteCalendarEvents,
      Cmd.ARG_FILEREVISION:	deleteFileRevisions,
      Cmd.ARG_FILTER:		deleteFilters,
      Cmd.ARG_FORWARDINGADDRESS:	deleteForwardingAddresses,
      Cmd.ARG_GROUP:		deleteUserFromGroups,
      Cmd.ARG_LABEL:		deleteLabel,
      Cmd.ARG_LICENSE:		deleteLicense,
      Cmd.ARG_MESSAGE:		processMessages,
      Cmd.ARG_PERMISSIONS:	deletePermissions,
      Cmd.ARG_PHOTO:		deletePhoto,
      Cmd.ARG_SENDAS:		deleteSendAs,
      Cmd.ARG_SMIME:		deleteSmime,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_TEAMDRIVE:	deleteTeamDrive,
      Cmd.ARG_THREAD:		processThreads,
      Cmd.ARG_TOKEN:		deleteTokens,
      Cmd.ARG_USER:		deleteUsers,
     }
    ),
  u'empty': (Act.EMPTY, {Cmd.ARG_DRIVETRASH: emptyDriveTrash}),
  u'get': (Act.DOWNLOAD, {Cmd.ARG_CONTACTPHOTO: getUserContactPhoto, Cmd.ARG_DRIVEFILE: getDriveFile, Cmd.ARG_PHOTO: getPhoto}),
  u'import': (Act.IMPORT, {Cmd.ARG_EVENT: importCalendarEvent, Cmd.ARG_MESSAGE: importMessage}),
  u'info':
    (Act.INFO,
     {Cmd.ARG_CALENDAR:		infoCalendars,
      Cmd.ARG_CALENDARACL:	infoCalendarACLs,
      Cmd.ARG_CLASSROOMOAUTH2:	infoClassroomOauth2,
      Cmd.ARG_CONTACT:		infoUserContacts,
      Cmd.ARG_CONTACTGROUP:	infoUserContactGroups,
      Cmd.ARG_DRIVEFILEACL:	infoDriveFileACLs,
      Cmd.ARG_EVENT:		infoCalendarEvents,
      Cmd.ARG_FILTER:		infoFilters,
      Cmd.ARG_FORWARDINGADDRESS:	infoForwardingAddresses,
      Cmd.ARG_SENDAS:		infoSendAs,
      Cmd.ARG_SHEET:		infoSheets,
      Cmd.ARG_SITE:		infoUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_TEAMDRIVE:	infoTeamDrive,
      Cmd.ARG_USER:		infoUsers,
     }
    ),
  u'insert': (Act.INSERT, {Cmd.ARG_MESSAGE: insertMessage}),
  u'modify': (Act.MODIFY, {Cmd.ARG_CALENDAR: modifyCalendars, Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  u'move': (Act.MOVE, {Cmd.ARG_DRIVEFILE: moveDriveFile, Cmd.ARG_EVENT: moveCalendarEvents}),
  u'purge': (Act.PURGE, {Cmd.ARG_DRIVEFILE: purgeDriveFile}),
  u'print':
    (Act.PRINT,
     {Cmd.ARG_CALENDAR:		printCalendars,
      Cmd.ARG_CALENDARACL:	printCalendarACLs,
      Cmd.ARG_CALSETTINGS:	printCalSettings,
      Cmd.ARG_CONTACT:		printUserContacts,
      Cmd.ARG_CONTACTGROUP:	printUserContactGroups,
      Cmd.ARG_DELEGATE:		printDelegates,
      Cmd.ARG_DRIVEACTIVITY:	printDriveActivity,
      Cmd.ARG_DRIVEFILEACL:	printDriveFileACLs,
      Cmd.ARG_DRIVESETTINGS:	printDriveSettings,
      Cmd.ARG_EVENT:		printCalendarEvents,
      Cmd.ARG_FILECOUNT:	printFileCounts,
      Cmd.ARG_FILEINFO:		showFileInfo,
      Cmd.ARG_FILELIST:		printFileList,
      Cmd.ARG_FILEPATH:		printFilePaths,
      Cmd.ARG_FILEREVISION:	printFileRevisions,
      Cmd.ARG_FILTER:		printFilters,
      Cmd.ARG_FORWARD:		printForward,
      Cmd.ARG_FORWARDINGADDRESS:	printForwardingAddresses,
      Cmd.ARG_GMAILPROFILE:	printGmailProfile,
      Cmd.ARG_GPLUSPROFILE:	printGplusProfile,
      Cmd.ARG_LABEL:		printLabels,
      Cmd.ARG_MESSAGE:		printMessages,
      Cmd.ARG_SENDAS:		printSendAs,
      Cmd.ARG_SHEETRANGE:	printSheetRanges,
      Cmd.ARG_SIGNATURE:	printSendAs,
      Cmd.ARG_SMIME:		printSmimes,
      Cmd.ARG_SITE:		printUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_SITEACTIVITY:	printUserSiteActivity,
      Cmd.ARG_TEAMDRIVE:	printTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	printTeamDriveACLs,
      Cmd.ARG_THREAD:		printThreads,
      Cmd.ARG_TOKEN:		printTokens,
      Cmd.ARG_USER:		doPrintUserEntity,
      Cmd.ARG_VACATION:		printVacation,
     }
    ),
  u'remove': (Act.REMOVE, {Cmd.ARG_CALENDAR: removeCalendars}),
  u'show':
    (Act.SHOW,
     {Cmd.ARG_ASP:		showASPs,
      Cmd.ARG_BACKUPCODE:	showBackupCodes,
      Cmd.ARG_CALENDAR:		showCalendars,
      Cmd.ARG_CALENDARACL:	showCalendarACLs,
      Cmd.ARG_CALSETTINGS:	showCalSettings,
      Cmd.ARG_CONTACT:		showUserContacts,
      Cmd.ARG_CONTACTGROUP:	showUserContactGroups,
      Cmd.ARG_DELEGATE:		showDelegates,
      Cmd.ARG_DRIVEACTIVITY:	printDriveActivity,
      Cmd.ARG_DRIVEFILEACL:	showDriveFileACLs,
      Cmd.ARG_DRIVESETTINGS:	showDriveSettings,
      Cmd.ARG_EVENT:		showCalendarEvents,
      Cmd.ARG_FILECOUNT:	showFileCounts,
      Cmd.ARG_FILEINFO:		showFileInfo,
      Cmd.ARG_FILELIST:		printFileList,
      Cmd.ARG_FILEPATH:		showFilePaths,
      Cmd.ARG_FILEREVISION:	showFileRevisions,
      Cmd.ARG_FILETREE:		showFileTree,
      Cmd.ARG_FILTER:		showFilters,
      Cmd.ARG_FORWARD:		showForward,
      Cmd.ARG_FORWARDINGADDRESS:	showForwardingAddresses,
      Cmd.ARG_GMAILPROFILE:	showGmailProfile,
      Cmd.ARG_GPLUSPROFILE:	showGplusProfile,
      Cmd.ARG_IMAP:		showImap,
      Cmd.ARG_LABEL:		showLabels,
      Cmd.ARG_MESSAGE:		showMessages,
      Cmd.ARG_POP:		showPop,
      Cmd.ARG_PROFILE:		showProfile,
      Cmd.ARG_SENDAS:		showSendAs,
      Cmd.ARG_SHEETRANGE:	showSheetRanges,
      Cmd.ARG_SIGNATURE:	showSignature,
      Cmd.ARG_SITE:		showUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_SMIME:		showSmimes,
      Cmd.ARG_TEAMDRIVE:	showTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	showTeamDriveACLs,
      Cmd.ARG_TEAMDRIVEINFO:	infoTeamDrive,
      Cmd.ARG_TEAMDRIVETHEMES:	showTeamDriveThemes,
      Cmd.ARG_THREAD:		showThreads,
      Cmd.ARG_TOKEN:		showTokens,
      Cmd.ARG_VACATION:		showVacation,
     }
    ),
  u'spam': (Act.SPAM, {Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  u'suspend': (Act.SUSPEND, {Cmd.ARG_USER: suspendUsers}),
  u'transfer': (Act.TRANSFER, {Cmd.ARG_DRIVE: transferDrive, Cmd.ARG_CALENDAR: transferCalendars, Cmd.ARG_OWNERSHIP: transferOwnership}),
  u'trash': (Act.TRASH, {Cmd.ARG_DRIVEFILE: trashDriveFile, Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  u'untrash': (Act.UNTRASH, {Cmd.ARG_DRIVEFILE: untrashDriveFile, Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  u'undelete': (Act.UNDELETE, {Cmd.ARG_USER: undeleteUsers}),
  u'unsuspend': (Act.UNSUSPEND, {Cmd.ARG_USER: unsuspendUsers}),
  u'update':
    (Act.UPDATE,
     {Cmd.ARG_BACKUPCODE:	updateBackupCodes,
      Cmd.ARG_CALATTENDEES:	updateCalendarAttendees,
      Cmd.ARG_CALENDAR:		updateCalendars,
      Cmd.ARG_CALENDARACL:	updateCalendarACLs,
      Cmd.ARG_CONTACT:		updateUserContacts,
      Cmd.ARG_CONTACTGROUP:	updateUserContactGroup,
      Cmd.ARG_CONTACTPHOTO:	updateUserContactPhoto,
      Cmd.ARG_DRIVEFILE:	updateDriveFile,
      Cmd.ARG_DRIVEFILEACL:	updateDriveFileACLs,
      Cmd.ARG_EVENT:		updateCalendarEvents,
      Cmd.ARG_LABEL:		updateLabels,
      Cmd.ARG_LABELSETTINGS:	updateLabelSettings,
      Cmd.ARG_LICENSE:		updateLicense,
      Cmd.ARG_PHOTO:		updatePhoto,
      Cmd.ARG_SENDAS:		updateSendAs,
      Cmd.ARG_SHEET:		updateSheets,
      Cmd.ARG_SHEETRANGE:	updateSheetRanges,
      Cmd.ARG_SMIME:		updateSmime,
      Cmd.ARG_SITE:		updateUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_TEAMDRIVE:	updateTeamDrive,
      Cmd.ARG_USER:		updateUsers,
     }
    ),
  u'wipe': (Act.WIPE, {Cmd.ARG_EVENT: wipeCalendarEvents}),
  }

# User commands aliases
USER_COMMANDS_ALIASES = {
  u'del':	u'delete',
  u'delegates':	u'delegate',
  u'deprov':	u'deprovision',
  u'imap4':	u'imap',
  u'pop3':	u'pop',
  u'sig':	u'signature',
  u'utf':	u'unicode',
  u'utf-8':	u'unicode',
  u'utf8':	u'unicode',
  }

USER_COMMANDS_OBJ_ALIASES = {
  Cmd.ARG_3LO:		Cmd.ARG_TOKEN,
  Cmd.ARG_ALIASES:	Cmd.ARG_ALIAS,
  Cmd.ARG_APPLICATIONSPECIFICPASSWORDS:	Cmd.ARG_ASP,
  Cmd.ARG_ASPS:		Cmd.ARG_ASP,
  Cmd.ARG_BACKUPCODES:	Cmd.ARG_BACKUPCODE,
  Cmd.ARG_CALENDARS:	Cmd.ARG_CALENDAR,
  Cmd.ARG_CALENDARACLS:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_CONTACTS:	Cmd.ARG_CONTACT,
  Cmd.ARG_CONTACTGROUPS:	Cmd.ARG_CONTACTGROUP,
  Cmd.ARG_CONTACTPHOTOS:	Cmd.ARG_CONTACTPHOTO,
  Cmd.ARG_DELEGATES:	Cmd.ARG_DELEGATE,
  Cmd.ARG_DRIVEFILEACLS:	Cmd.ARG_DRIVEFILEACL,
  Cmd.ARG_EVENTS:	Cmd.ARG_EVENT,
  Cmd.ARG_FILECOUNTS:	Cmd.ARG_FILECOUNT,
  Cmd.ARG_FILEPATHS:	Cmd.ARG_FILEPATH,
  Cmd.ARG_FILEREVISIONS:	Cmd.ARG_FILEREVISION,
  Cmd.ARG_FILTERS:	Cmd.ARG_FILTER,
  Cmd.ARG_FORWARDINGADDRESSES:	Cmd.ARG_FORWARDINGADDRESS,
  Cmd.ARG_GROUPS:	Cmd.ARG_GROUP,
  Cmd.ARG_IMAP4:	Cmd.ARG_IMAP,
  Cmd.ARG_LABELS:	Cmd.ARG_LABEL,
  Cmd.ARG_LICENCE:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENCES:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENSES:	Cmd.ARG_LICENSE,
  Cmd.ARG_MESSAGES:	Cmd.ARG_MESSAGE,
  Cmd.ARG_OAUTH:	Cmd.ARG_TOKEN,
  Cmd.ARG_POP3:		Cmd.ARG_POP,
  Cmd.ARG_SECCALS:	Cmd.ARG_CALENDAR,
  Cmd.ARG_SHEETS:	Cmd.ARG_SHEET,
  Cmd.ARG_SHEETRANGES:	Cmd.ARG_SHEETRANGE,
  Cmd.ARG_SIG:		Cmd.ARG_SIGNATURE,
  Cmd.ARG_SITES:	Cmd.ARG_SITE,
  Cmd.ARG_SITEACLS:	Cmd.ARG_SITEACL,
  Cmd.ARG_SMIMES:	Cmd.ARG_SMIME,
  Cmd.ARG_TEAMDRIVES:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_THREADS:	Cmd.ARG_THREAD,
  Cmd.ARG_TOKENS:	Cmd.ARG_TOKEN,
  Cmd.ARG_USERS:	Cmd.ARG_USER,
  Cmd.ARG_VERIFICATIONCODES:	Cmd.ARG_BACKUPCODE,
  }

def adjustRedirectedSTDFilesIfNotMultiprocessing():
  def adjustRedirectedSTDFile(stdtype):
    rdFd = GM.Globals[stdtype].get(GM.REDIRECT_FD)
    rdMultiFd = GM.Globals[stdtype].get(GM.REDIRECT_MULTI_FD)
    if rdFd and rdMultiFd and rdFd != rdMultiFd:
      try:
        rdFd.write(rdMultiFd.getvalue())
        rdMultiFd.close()
        GM.Globals[stdtype][GM.REDIRECT_MULTI_FD] = rdFd
        if (stdtype == GM.STDOUT) and (GM.Globals.get(GM.SAVED_STDOUT) is not None):
          sys.stdout = rdFd
      except IOError as e:
        systemErrorExit(FILE_ERROR_RC, e)

  adjustRedirectedSTDFile(GM.STDOUT)
  if GM.Globals[GM.STDERR].get(GM.REDIRECT_NAME) != u'stdout':
    adjustRedirectedSTDFile(GM.STDERR)
  else:
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]

def closeSTDFilesIfNotMultiprocessing():
  def closeSTDFile(stdtype, stdfile):
    rdFd = GM.Globals[stdtype].get(GM.REDIRECT_FD)
    rdMultiFd = GM.Globals[stdtype].get(GM.REDIRECT_MULTI_FD)
    if rdFd and rdMultiFd and (rdFd == rdMultiFd) and (rdFd != stdfile):
      rdFd.close()

  closeSTDFile(GM.STDOUT, sys.stdout)
  if GM.Globals[GM.STDERR].get(GM.REDIRECT_NAME) != u'stdout':
    closeSTDFile(GM.STDERR, sys.stderr)

# Process GAM command
def ProcessGAMCommand(args, processGamCfg=True):
  setSysExitRC(0)
  Cmd.InitializeArguments(args)
  Ind.Reset()
  try:
    if checkArgumentPresent(Cmd.LOOP_CMD):
      if processGamCfg and (not SetGlobalVariables()):
        sys.exit(GM.Globals[GM.SYSEXITRC])
      doLoop()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    if processGamCfg and (not SetGlobalVariables()):
      sys.exit(GM.Globals[GM.SYSEXITRC])
    if checkArgumentPresent(Cmd.LOOP_CMD):
      doLoop()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    if not Cmd.ArgumentsRemaining():
      doUsage()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(BATCH_CSV_COMMANDS, defaultChoice=None)
    if CL_command:
      Act.Set(BATCH_CSV_COMMANDS[CL_command][CMD_ACTION])
      BATCH_CSV_COMMANDS[CL_command][CMD_FUNCTION]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(MAIN_COMMANDS, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Act.Set(MAIN_COMMANDS[CL_command][CMD_ACTION])
      MAIN_COMMANDS[CL_command][CMD_FUNCTION]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(MAIN_COMMANDS_WITH_OBJECTS, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Act.Set(MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
      CL_objectName = getChoice(MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=MAIN_COMMANDS_OBJ_ALIASES)
      MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(COMMANDS_MAP, choiceAliases=COMMANDS_ALIASES, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      COMMANDS_MAP[CL_command]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    GM.Globals[GM.ENTITY_CL_START] = Cmd.Location()
    entityType, entityList = getEntityToModify(crosAllowed=True, returnOnError=True, delayGet=True)
    if entityType is None:
      usageErrorExit(Msg.UNKNOWN_COMMAND_SELECTOR)
    if entityType == Cmd.ENTITY_USERS:
      CL_command = getChoice(list(USER_COMMANDS)+list(USER_COMMANDS_WITH_OBJECTS), choiceAliases=USER_COMMANDS_ALIASES)
      if (CL_command != u'list') and (GC.Values[GC.AUTO_BATCH_MIN] > 0):
        _, count, entityList = getEntityArgument(entityList)
        if count > GC.Values[GC.AUTO_BATCH_MIN]:
          doAutoBatch(Cmd.ENTITY_USER, entityList, CL_command)
          sys.exit(GM.Globals[GM.SYSEXITRC])
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      if CL_command in USER_COMMANDS:
        Act.Set(USER_COMMANDS[CL_command][CMD_ACTION])
        USER_COMMANDS[CL_command][CMD_FUNCTION](entityList)
      else:
        Act.Set(USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
        CL_objectName = getChoice(USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=USER_COMMANDS_OBJ_ALIASES,
                                  defaultChoice=[Cmd.ARG_USER, NO_DEFAULT][CL_command != u'print'])
        USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName](entityList)
    else:
      CL_command = getChoice(list(CROS_COMMANDS)+list(CROS_COMMANDS_WITH_OBJECTS))
      if (CL_command != u'list') and (GC.Values[GC.AUTO_BATCH_MIN] > 0):
        _, count, entityList = getEntityArgument(entityList)
        if count > GC.Values[GC.AUTO_BATCH_MIN]:
          doAutoBatch(Cmd.ENTITY_CROS, entityList, CL_command)
          sys.exit(GM.Globals[GM.SYSEXITRC])
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      if CL_command in CROS_COMMANDS:
        Act.Set(CROS_COMMANDS[CL_command][CMD_ACTION])
        CROS_COMMANDS[CL_command][CMD_FUNCTION](entityList)
      else:
        Act.Set(CROS_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
        CL_objectName = getChoice(CROS_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=CROS_COMMANDS_OBJ_ALIASES,
                                  defaultChoice=NO_DEFAULT)
        CROS_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName](entityList)
    sys.exit(GM.Globals[GM.SYSEXITRC])
  except KeyboardInterrupt:
    setSysExitRC(KEYBOARD_INTERRUPT_RC)
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except socket.error as e:
    printErrorMessage(SOCKET_ERROR_RC, str(e).decode(u'latin1'))
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except MemoryError:
    printErrorMessage(MEMORY_ERROR_RC, Msg.GAM_OUT_OF_MEMORY)
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except SystemExit as e:
    GM.Globals[GM.SYSEXITRC] = e.code
    try:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
    except SystemExit:
      pass
  except Exception:
    from traceback import print_exc
    print_exc(file=sys.stderr)
    setSysExitRC(UNKNOWN_ERROR_RC)
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  if processGamCfg:
    if GM.Globals.get(GM.SAVED_STDOUT) is not None:
      sys.stdout = GM.Globals[GM.SAVED_STDOUT]
    closeSTDFilesIfNotMultiprocessing()
  return GM.Globals[GM.SYSEXITRC]

# gam loop <FileName>|- [charset <String>] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>] (matchfield <FieldName> <RegularExpression>)* gam <GAM argument list>
def doLoop():
  filename = getString(Cmd.OB_FILE_NAME)
  if (filename == u'-') and (GC.Values[GC.DEBUG_LEVEL] > 0):
    Cmd.Backup()
    usageErrorExit(Msg.BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(Cmd.LOOP_CMD))
  f, csvFile = openCSVFileReader(filename)
  matchFields = getMatchFields(csvFile.fieldnames)
  checkArgumentPresent(Cmd.GAM_CMD, required=True)
  if not Cmd.ArgumentsRemaining():
    missingArgumentExit(Cmd.OB_GAM_ARGUMENT_LIST)
  choice = Cmd.Current().strip().lower()
  if choice == Cmd.LOOP_CMD:
    usageErrorExit(Msg.NESTED_LOOP_CMD_NOT_ALLOWED)
# gam loop ... gam redirect|select|config ... process gam.cfg on each iteration
# gam redirect|select|config ... loop ... gam redirect|select|config ... process gam.cfg on each iteration
# gam loop ... gam !redirect|select|config ... no further processing of gam.cfg
# gam redirect|select|config ... loop ... gam !redirect|select|config ... no further processing of gam.cfg
  processGamCfg = choice in Cmd.GAM_META_COMMANDS
  GAM_argv, subFields = getSubFields([Cmd.GAM_CMD,], csvFile.fieldnames)
  multi = GM.Globals[GM.CSVFILE][GM.REDIRECT_MULTIPROCESS]
  if multi:
    mpQueue, mpQueueHandler = initializeCSVFileQueueHandler()
  else:
    mpQueue = None
  GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = mpQueue
  for row in csvFile:
    if (not matchFields) or checkMatchFields(row, matchFields):
      ProcessGAMCommand(processSubFields(GAM_argv, row, subFields), processGamCfg=processGamCfg)
      if (GM.Globals[GM.SYSEXITRC] > 0) and (GM.Globals[GM.SYSEXITRC] <= HARD_ERROR_RC):
        break
  closeFile(f)
  if multi:
    terminateCSVFileQueueHandler(mpQueue, mpQueueHandler)

# Run from command line
if __name__ == "__main__":
  multiprocessing.freeze_support()
  initializeLogging()
  rc = ProcessGAMCommand(sys.argv)
  try:
    sys.stdout.flush()
  except (IOError, ValueError):
    pass
  sys.exit(rc)
